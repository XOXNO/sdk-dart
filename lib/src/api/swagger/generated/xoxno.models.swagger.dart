// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'xoxno.enums.swagger.dart' as enums;

part 'xoxno.models.swagger.g.dart';

@JsonSerializable(explicitToJson: true)
class ErrorResponseDto {
  const ErrorResponseDto({
    required this.statusCode,
    required this.message,
    required this.timestamp,
    required this.path,
  });

  factory ErrorResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ErrorResponseDtoFromJson(json);

  static const toJsonFactory = _$ErrorResponseDtoToJson;
  Map<String, dynamic> toJson() => _$ErrorResponseDtoToJson(this);

  @JsonKey(name: 'statusCode')
  final double statusCode;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'timestamp')
  final String timestamp;
  @JsonKey(name: 'path')
  final String path;
  static const fromJsonFactory = _$ErrorResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ErrorResponseDto &&
            (identical(other.statusCode, statusCode) ||
                const DeepCollectionEquality().equals(
                  other.statusCode,
                  statusCode,
                )) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(statusCode) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(path) ^
      runtimeType.hashCode;
}

extension $ErrorResponseDtoExtension on ErrorResponseDto {
  ErrorResponseDto copyWith({
    double? statusCode,
    String? message,
    String? timestamp,
    String? path,
  }) {
    return ErrorResponseDto(
      statusCode: statusCode ?? this.statusCode,
      message: message ?? this.message,
      timestamp: timestamp ?? this.timestamp,
      path: path ?? this.path,
    );
  }

  ErrorResponseDto copyWithWrapped({
    Wrapped<double>? statusCode,
    Wrapped<String>? message,
    Wrapped<String>? timestamp,
    Wrapped<String>? path,
  }) {
    return ErrorResponseDto(
      statusCode: (statusCode != null ? statusCode.value : this.statusCode),
      message: (message != null ? message.value : this.message),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      path: (path != null ? path.value : this.path),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveGuardianDto {
  const ActiveGuardianDto({
    required this.activationEpoch,
    required this.address,
    required this.serviceUID,
  });

  factory ActiveGuardianDto.fromJson(Map<String, dynamic> json) =>
      _$ActiveGuardianDtoFromJson(json);

  static const toJsonFactory = _$ActiveGuardianDtoToJson;
  Map<String, dynamic> toJson() => _$ActiveGuardianDtoToJson(this);

  @JsonKey(name: 'activationEpoch')
  final double activationEpoch;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'serviceUID')
  final String serviceUID;
  static const fromJsonFactory = _$ActiveGuardianDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActiveGuardianDto &&
            (identical(other.activationEpoch, activationEpoch) ||
                const DeepCollectionEquality().equals(
                  other.activationEpoch,
                  activationEpoch,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.serviceUID, serviceUID) ||
                const DeepCollectionEquality().equals(
                  other.serviceUID,
                  serviceUID,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(activationEpoch) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(serviceUID) ^
      runtimeType.hashCode;
}

extension $ActiveGuardianDtoExtension on ActiveGuardianDto {
  ActiveGuardianDto copyWith({
    double? activationEpoch,
    String? address,
    String? serviceUID,
  }) {
    return ActiveGuardianDto(
      activationEpoch: activationEpoch ?? this.activationEpoch,
      address: address ?? this.address,
      serviceUID: serviceUID ?? this.serviceUID,
    );
  }

  ActiveGuardianDto copyWithWrapped({
    Wrapped<double>? activationEpoch,
    Wrapped<String>? address,
    Wrapped<String>? serviceUID,
  }) {
    return ActiveGuardianDto(
      activationEpoch: (activationEpoch != null
          ? activationEpoch.value
          : this.activationEpoch),
      address: (address != null ? address.value : this.address),
      serviceUID: (serviceUID != null ? serviceUID.value : this.serviceUID),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserNetworkInfoDto {
  const UserNetworkInfoDto({
    required this.address,
    required this.nonce,
    required this.balanceShort,
    required this.username,
    this.isUpgradeable,
    this.isReadable,
    this.isGuarded,
    this.isPayable,
    this.isPayableBySmartContract,
    required this.balance,
    required this.shard,
    required this.guarded,
    this.activeGuardian,
    required this.usdValue,
  });

  factory UserNetworkInfoDto.fromJson(Map<String, dynamic> json) =>
      _$UserNetworkInfoDtoFromJson(json);

  static const toJsonFactory = _$UserNetworkInfoDtoToJson;
  Map<String, dynamic> toJson() => _$UserNetworkInfoDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'balanceShort')
  final double balanceShort;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'isUpgradeable')
  final bool? isUpgradeable;
  @JsonKey(name: 'isReadable')
  final bool? isReadable;
  @JsonKey(name: 'isGuarded')
  final bool? isGuarded;
  @JsonKey(name: 'isPayable')
  final bool? isPayable;
  @JsonKey(name: 'isPayableBySmartContract')
  final bool? isPayableBySmartContract;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'guarded')
  final bool guarded;
  @JsonKey(name: 'activeGuardian')
  final ActiveGuardianDto? activeGuardian;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  static const fromJsonFactory = _$UserNetworkInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserNetworkInfoDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.balanceShort, balanceShort) ||
                const DeepCollectionEquality().equals(
                  other.balanceShort,
                  balanceShort,
                )) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.isUpgradeable, isUpgradeable) ||
                const DeepCollectionEquality().equals(
                  other.isUpgradeable,
                  isUpgradeable,
                )) &&
            (identical(other.isReadable, isReadable) ||
                const DeepCollectionEquality().equals(
                  other.isReadable,
                  isReadable,
                )) &&
            (identical(other.isGuarded, isGuarded) ||
                const DeepCollectionEquality().equals(
                  other.isGuarded,
                  isGuarded,
                )) &&
            (identical(other.isPayable, isPayable) ||
                const DeepCollectionEquality().equals(
                  other.isPayable,
                  isPayable,
                )) &&
            (identical(
                  other.isPayableBySmartContract,
                  isPayableBySmartContract,
                ) ||
                const DeepCollectionEquality().equals(
                  other.isPayableBySmartContract,
                  isPayableBySmartContract,
                )) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.shard, shard) ||
                const DeepCollectionEquality().equals(other.shard, shard)) &&
            (identical(other.guarded, guarded) ||
                const DeepCollectionEquality().equals(
                  other.guarded,
                  guarded,
                )) &&
            (identical(other.activeGuardian, activeGuardian) ||
                const DeepCollectionEquality().equals(
                  other.activeGuardian,
                  activeGuardian,
                )) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(balanceShort) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(isUpgradeable) ^
      const DeepCollectionEquality().hash(isReadable) ^
      const DeepCollectionEquality().hash(isGuarded) ^
      const DeepCollectionEquality().hash(isPayable) ^
      const DeepCollectionEquality().hash(isPayableBySmartContract) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(shard) ^
      const DeepCollectionEquality().hash(guarded) ^
      const DeepCollectionEquality().hash(activeGuardian) ^
      const DeepCollectionEquality().hash(usdValue) ^
      runtimeType.hashCode;
}

extension $UserNetworkInfoDtoExtension on UserNetworkInfoDto {
  UserNetworkInfoDto copyWith({
    String? address,
    double? nonce,
    double? balanceShort,
    String? username,
    bool? isUpgradeable,
    bool? isReadable,
    bool? isGuarded,
    bool? isPayable,
    bool? isPayableBySmartContract,
    String? balance,
    double? shard,
    bool? guarded,
    ActiveGuardianDto? activeGuardian,
    double? usdValue,
  }) {
    return UserNetworkInfoDto(
      address: address ?? this.address,
      nonce: nonce ?? this.nonce,
      balanceShort: balanceShort ?? this.balanceShort,
      username: username ?? this.username,
      isUpgradeable: isUpgradeable ?? this.isUpgradeable,
      isReadable: isReadable ?? this.isReadable,
      isGuarded: isGuarded ?? this.isGuarded,
      isPayable: isPayable ?? this.isPayable,
      isPayableBySmartContract:
          isPayableBySmartContract ?? this.isPayableBySmartContract,
      balance: balance ?? this.balance,
      shard: shard ?? this.shard,
      guarded: guarded ?? this.guarded,
      activeGuardian: activeGuardian ?? this.activeGuardian,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  UserNetworkInfoDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? nonce,
    Wrapped<double>? balanceShort,
    Wrapped<String>? username,
    Wrapped<bool?>? isUpgradeable,
    Wrapped<bool?>? isReadable,
    Wrapped<bool?>? isGuarded,
    Wrapped<bool?>? isPayable,
    Wrapped<bool?>? isPayableBySmartContract,
    Wrapped<String>? balance,
    Wrapped<double>? shard,
    Wrapped<bool>? guarded,
    Wrapped<ActiveGuardianDto?>? activeGuardian,
    Wrapped<double>? usdValue,
  }) {
    return UserNetworkInfoDto(
      address: (address != null ? address.value : this.address),
      nonce: (nonce != null ? nonce.value : this.nonce),
      balanceShort: (balanceShort != null
          ? balanceShort.value
          : this.balanceShort),
      username: (username != null ? username.value : this.username),
      isUpgradeable: (isUpgradeable != null
          ? isUpgradeable.value
          : this.isUpgradeable),
      isReadable: (isReadable != null ? isReadable.value : this.isReadable),
      isGuarded: (isGuarded != null ? isGuarded.value : this.isGuarded),
      isPayable: (isPayable != null ? isPayable.value : this.isPayable),
      isPayableBySmartContract: (isPayableBySmartContract != null
          ? isPayableBySmartContract.value
          : this.isPayableBySmartContract),
      balance: (balance != null ? balance.value : this.balance),
      shard: (shard != null ? shard.value : this.shard),
      guarded: (guarded != null ? guarded.value : this.guarded),
      activeGuardian: (activeGuardian != null
          ? activeGuardian.value
          : this.activeGuardian),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WalletDto {
  const WalletDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory WalletDto.fromJson(Map<String, dynamic> json) =>
      _$WalletDtoFromJson(json);

  static const toJsonFactory = _$WalletDtoToJson;
  Map<String, dynamic> toJson() => _$WalletDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$WalletDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletDto &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.egldValue, egldValue) ||
                const DeepCollectionEquality().equals(
                  other.egldValue,
                  egldValue,
                )) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(egldValue) ^
      const DeepCollectionEquality().hash(weight) ^
      runtimeType.hashCode;
}

extension $WalletDtoExtension on WalletDto {
  WalletDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return WalletDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  WalletDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return WalletDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EsdtsDto {
  const EsdtsDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory EsdtsDto.fromJson(Map<String, dynamic> json) =>
      _$EsdtsDtoFromJson(json);

  static const toJsonFactory = _$EsdtsDtoToJson;
  Map<String, dynamic> toJson() => _$EsdtsDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$EsdtsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EsdtsDto &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.egldValue, egldValue) ||
                const DeepCollectionEquality().equals(
                  other.egldValue,
                  egldValue,
                )) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(egldValue) ^
      const DeepCollectionEquality().hash(weight) ^
      runtimeType.hashCode;
}

extension $EsdtsDtoExtension on EsdtsDto {
  EsdtsDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return EsdtsDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  EsdtsDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return EsdtsDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StablesDto {
  const StablesDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory StablesDto.fromJson(Map<String, dynamic> json) =>
      _$StablesDtoFromJson(json);

  static const toJsonFactory = _$StablesDtoToJson;
  Map<String, dynamic> toJson() => _$StablesDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$StablesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StablesDto &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.egldValue, egldValue) ||
                const DeepCollectionEquality().equals(
                  other.egldValue,
                  egldValue,
                )) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(egldValue) ^
      const DeepCollectionEquality().hash(weight) ^
      runtimeType.hashCode;
}

extension $StablesDtoExtension on StablesDto {
  StablesDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return StablesDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  StablesDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return StablesDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuiCoinObjectDto {
  const SuiCoinObjectDto({
    required this.objectId,
    required this.balance,
    required this.digest,
    required this.version,
  });

  factory SuiCoinObjectDto.fromJson(Map<String, dynamic> json) =>
      _$SuiCoinObjectDtoFromJson(json);

  static const toJsonFactory = _$SuiCoinObjectDtoToJson;
  Map<String, dynamic> toJson() => _$SuiCoinObjectDtoToJson(this);

  @JsonKey(name: 'objectId')
  final String objectId;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'digest')
  final String digest;
  @JsonKey(name: 'version')
  final String version;
  static const fromJsonFactory = _$SuiCoinObjectDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SuiCoinObjectDto &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality().equals(
                  other.objectId,
                  objectId,
                )) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.digest, digest) ||
                const DeepCollectionEquality().equals(other.digest, digest)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(digest) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $SuiCoinObjectDtoExtension on SuiCoinObjectDto {
  SuiCoinObjectDto copyWith({
    String? objectId,
    String? balance,
    String? digest,
    String? version,
  }) {
    return SuiCoinObjectDto(
      objectId: objectId ?? this.objectId,
      balance: balance ?? this.balance,
      digest: digest ?? this.digest,
      version: version ?? this.version,
    );
  }

  SuiCoinObjectDto copyWithWrapped({
    Wrapped<String>? objectId,
    Wrapped<String>? balance,
    Wrapped<String>? digest,
    Wrapped<String>? version,
  }) {
    return SuiCoinObjectDto(
      objectId: (objectId != null ? objectId.value : this.objectId),
      balance: (balance != null ? balance.value : this.balance),
      digest: (digest != null ? digest.value : this.digest),
      version: (version != null ? version.value : this.version),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TokenDataDocWithBalance {
  const TokenDataDocWithBalance({
    required this.identifier,
    required this.decimals,
    required this.ticker,
    required this.name,
    required this.svgUrl,
    required this.pngUrl,
    required this.chain,
    required this.usdPrice,
    required this.isAshSupported,
    required this.nonce,
    required this.balance,
    required this.shortBalance,
    required this.usdValue,
    required this.egldValue,
    required this.weight,
    this.objects,
  });

  factory TokenDataDocWithBalance.fromJson(Map<String, dynamic> json) =>
      _$TokenDataDocWithBalanceFromJson(json);

  static const toJsonFactory = _$TokenDataDocWithBalanceToJson;
  Map<String, dynamic> toJson() => _$TokenDataDocWithBalanceToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'ticker')
  final String ticker;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'svgUrl')
  final String svgUrl;
  @JsonKey(name: 'pngUrl')
  final String pngUrl;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainChainFromJson,
  )
  final enums.ActivityChain chain;
  static enums.ActivityChain activityChainChainFromJson(Object? value) =>
      activityChainFromJson(value, enums.ActivityChain.mvx);

  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  @JsonKey(name: 'isAshSupported')
  final bool isAshSupported;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'shortBalance')
  final double shortBalance;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  @JsonKey(name: 'objects', defaultValue: <SuiCoinObjectDto>[])
  final List<SuiCoinObjectDto>? objects;
  static const fromJsonFactory = _$TokenDataDocWithBalanceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TokenDataDocWithBalance &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.decimals, decimals) ||
                const DeepCollectionEquality().equals(
                  other.decimals,
                  decimals,
                )) &&
            (identical(other.ticker, ticker) ||
                const DeepCollectionEquality().equals(other.ticker, ticker)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.svgUrl, svgUrl) ||
                const DeepCollectionEquality().equals(other.svgUrl, svgUrl)) &&
            (identical(other.pngUrl, pngUrl) ||
                const DeepCollectionEquality().equals(other.pngUrl, pngUrl)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.usdPrice, usdPrice) ||
                const DeepCollectionEquality().equals(
                  other.usdPrice,
                  usdPrice,
                )) &&
            (identical(other.isAshSupported, isAshSupported) ||
                const DeepCollectionEquality().equals(
                  other.isAshSupported,
                  isAshSupported,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.shortBalance, shortBalance) ||
                const DeepCollectionEquality().equals(
                  other.shortBalance,
                  shortBalance,
                )) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.egldValue, egldValue) ||
                const DeepCollectionEquality().equals(
                  other.egldValue,
                  egldValue,
                )) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.objects, objects) ||
                const DeepCollectionEquality().equals(other.objects, objects)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(decimals) ^
      const DeepCollectionEquality().hash(ticker) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(svgUrl) ^
      const DeepCollectionEquality().hash(pngUrl) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(usdPrice) ^
      const DeepCollectionEquality().hash(isAshSupported) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(shortBalance) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(egldValue) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(objects) ^
      runtimeType.hashCode;
}

extension $TokenDataDocWithBalanceExtension on TokenDataDocWithBalance {
  TokenDataDocWithBalance copyWith({
    String? identifier,
    double? decimals,
    String? ticker,
    String? name,
    String? svgUrl,
    String? pngUrl,
    enums.ActivityChain? chain,
    double? usdPrice,
    bool? isAshSupported,
    double? nonce,
    String? balance,
    double? shortBalance,
    double? usdValue,
    double? egldValue,
    double? weight,
    List<SuiCoinObjectDto>? objects,
  }) {
    return TokenDataDocWithBalance(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      ticker: ticker ?? this.ticker,
      name: name ?? this.name,
      svgUrl: svgUrl ?? this.svgUrl,
      pngUrl: pngUrl ?? this.pngUrl,
      chain: chain ?? this.chain,
      usdPrice: usdPrice ?? this.usdPrice,
      isAshSupported: isAshSupported ?? this.isAshSupported,
      nonce: nonce ?? this.nonce,
      balance: balance ?? this.balance,
      shortBalance: shortBalance ?? this.shortBalance,
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
      objects: objects ?? this.objects,
    );
  }

  TokenDataDocWithBalance copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<double>? decimals,
    Wrapped<String>? ticker,
    Wrapped<String>? name,
    Wrapped<String>? svgUrl,
    Wrapped<String>? pngUrl,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<double>? usdPrice,
    Wrapped<bool>? isAshSupported,
    Wrapped<double>? nonce,
    Wrapped<String>? balance,
    Wrapped<double>? shortBalance,
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
    Wrapped<List<SuiCoinObjectDto>?>? objects,
  }) {
    return TokenDataDocWithBalance(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      ticker: (ticker != null ? ticker.value : this.ticker),
      name: (name != null ? name.value : this.name),
      svgUrl: (svgUrl != null ? svgUrl.value : this.svgUrl),
      pngUrl: (pngUrl != null ? pngUrl.value : this.pngUrl),
      chain: (chain != null ? chain.value : this.chain),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
      isAshSupported: (isAshSupported != null
          ? isAshSupported.value
          : this.isAshSupported),
      nonce: (nonce != null ? nonce.value : this.nonce),
      balance: (balance != null ? balance.value : this.balance),
      shortBalance: (shortBalance != null
          ? shortBalance.value
          : this.shortBalance),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
      objects: (objects != null ? objects.value : this.objects),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserTokenInventoryResponseDto {
  const UserTokenInventoryResponseDto({
    required this.wallet,
    required this.esdts,
    required this.stables,
    required this.tokens,
    required this.chain,
  });

  factory UserTokenInventoryResponseDto.fromJson(Map<String, dynamic> json) =>
      _$UserTokenInventoryResponseDtoFromJson(json);

  static const toJsonFactory = _$UserTokenInventoryResponseDtoToJson;
  Map<String, dynamic> toJson() => _$UserTokenInventoryResponseDtoToJson(this);

  @JsonKey(name: 'wallet')
  final WalletDto wallet;
  @JsonKey(name: 'esdts')
  final EsdtsDto esdts;
  @JsonKey(name: 'stables')
  final StablesDto stables;
  @JsonKey(name: 'tokens', defaultValue: <TokenDataDocWithBalance>[])
  final List<TokenDataDocWithBalance> tokens;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  static const fromJsonFactory = _$UserTokenInventoryResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserTokenInventoryResponseDto &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.esdts, esdts) ||
                const DeepCollectionEquality().equals(other.esdts, esdts)) &&
            (identical(other.stables, stables) ||
                const DeepCollectionEquality().equals(
                  other.stables,
                  stables,
                )) &&
            (identical(other.tokens, tokens) ||
                const DeepCollectionEquality().equals(other.tokens, tokens)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(esdts) ^
      const DeepCollectionEquality().hash(stables) ^
      const DeepCollectionEquality().hash(tokens) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $UserTokenInventoryResponseDtoExtension
    on UserTokenInventoryResponseDto {
  UserTokenInventoryResponseDto copyWith({
    WalletDto? wallet,
    EsdtsDto? esdts,
    StablesDto? stables,
    List<TokenDataDocWithBalance>? tokens,
    enums.ActivityChain? chain,
  }) {
    return UserTokenInventoryResponseDto(
      wallet: wallet ?? this.wallet,
      esdts: esdts ?? this.esdts,
      stables: stables ?? this.stables,
      tokens: tokens ?? this.tokens,
      chain: chain ?? this.chain,
    );
  }

  UserTokenInventoryResponseDto copyWithWrapped({
    Wrapped<WalletDto>? wallet,
    Wrapped<EsdtsDto>? esdts,
    Wrapped<StablesDto>? stables,
    Wrapped<List<TokenDataDocWithBalance>>? tokens,
    Wrapped<enums.ActivityChain>? chain,
  }) {
    return UserTokenInventoryResponseDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      esdts: (esdts != null ? esdts.value : this.esdts),
      stables: (stables != null ? stables.value : this.stables),
      tokens: (tokens != null ? tokens.value : this.tokens),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SocialsDto {
  const SocialsDto({
    this.twitter,
    this.instagram,
    this.website,
    this.telegram,
    this.discord,
    this.facebook,
    this.youtube,
  });

  factory SocialsDto.fromJson(Map<String, dynamic> json) =>
      _$SocialsDtoFromJson(json);

  static const toJsonFactory = _$SocialsDtoToJson;
  Map<String, dynamic> toJson() => _$SocialsDtoToJson(this);

  @JsonKey(name: 'twitter')
  final String? twitter;
  @JsonKey(name: 'instagram')
  final String? instagram;
  @JsonKey(name: 'website')
  final String? website;
  @JsonKey(name: 'telegram')
  final String? telegram;
  @JsonKey(name: 'discord')
  final String? discord;
  @JsonKey(name: 'facebook')
  final String? facebook;
  @JsonKey(name: 'youtube')
  final String? youtube;
  static const fromJsonFactory = _$SocialsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SocialsDto &&
            (identical(other.twitter, twitter) ||
                const DeepCollectionEquality().equals(
                  other.twitter,
                  twitter,
                )) &&
            (identical(other.instagram, instagram) ||
                const DeepCollectionEquality().equals(
                  other.instagram,
                  instagram,
                )) &&
            (identical(other.website, website) ||
                const DeepCollectionEquality().equals(
                  other.website,
                  website,
                )) &&
            (identical(other.telegram, telegram) ||
                const DeepCollectionEquality().equals(
                  other.telegram,
                  telegram,
                )) &&
            (identical(other.discord, discord) ||
                const DeepCollectionEquality().equals(
                  other.discord,
                  discord,
                )) &&
            (identical(other.facebook, facebook) ||
                const DeepCollectionEquality().equals(
                  other.facebook,
                  facebook,
                )) &&
            (identical(other.youtube, youtube) ||
                const DeepCollectionEquality().equals(other.youtube, youtube)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(twitter) ^
      const DeepCollectionEquality().hash(instagram) ^
      const DeepCollectionEquality().hash(website) ^
      const DeepCollectionEquality().hash(telegram) ^
      const DeepCollectionEquality().hash(discord) ^
      const DeepCollectionEquality().hash(facebook) ^
      const DeepCollectionEquality().hash(youtube) ^
      runtimeType.hashCode;
}

extension $SocialsDtoExtension on SocialsDto {
  SocialsDto copyWith({
    String? twitter,
    String? instagram,
    String? website,
    String? telegram,
    String? discord,
    String? facebook,
    String? youtube,
  }) {
    return SocialsDto(
      twitter: twitter ?? this.twitter,
      instagram: instagram ?? this.instagram,
      website: website ?? this.website,
      telegram: telegram ?? this.telegram,
      discord: discord ?? this.discord,
      facebook: facebook ?? this.facebook,
      youtube: youtube ?? this.youtube,
    );
  }

  SocialsDto copyWithWrapped({
    Wrapped<String?>? twitter,
    Wrapped<String?>? instagram,
    Wrapped<String?>? website,
    Wrapped<String?>? telegram,
    Wrapped<String?>? discord,
    Wrapped<String?>? facebook,
    Wrapped<String?>? youtube,
  }) {
    return SocialsDto(
      twitter: (twitter != null ? twitter.value : this.twitter),
      instagram: (instagram != null ? instagram.value : this.instagram),
      website: (website != null ? website.value : this.website),
      telegram: (telegram != null ? telegram.value : this.telegram),
      discord: (discord != null ? discord.value : this.discord),
      facebook: (facebook != null ? facebook.value : this.facebook),
      youtube: (youtube != null ? youtube.value : this.youtube),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserDeposit {
  const UserDeposit({
    required this.balance,
    required this.balanceShort,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.usdPrice,
  });

  factory UserDeposit.fromJson(Map<String, dynamic> json) =>
      _$UserDepositFromJson(json);

  static const toJsonFactory = _$UserDepositToJson;
  Map<String, dynamic> toJson() => _$UserDepositToJson(this);

  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'balanceShort')
  final double balanceShort;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  static const fromJsonFactory = _$UserDepositFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDeposit &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.balanceShort, balanceShort) ||
                const DeepCollectionEquality().equals(
                  other.balanceShort,
                  balanceShort,
                )) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.paymentTokenNonce, paymentTokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.paymentTokenNonce,
                  paymentTokenNonce,
                )) &&
            (identical(other.usdPrice, usdPrice) ||
                const DeepCollectionEquality().equals(
                  other.usdPrice,
                  usdPrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(balanceShort) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenNonce) ^
      const DeepCollectionEquality().hash(usdPrice) ^
      runtimeType.hashCode;
}

extension $UserDepositExtension on UserDeposit {
  UserDeposit copyWith({
    String? balance,
    double? balanceShort,
    String? paymentToken,
    double? paymentTokenNonce,
    double? usdPrice,
  }) {
    return UserDeposit(
      balance: balance ?? this.balance,
      balanceShort: balanceShort ?? this.balanceShort,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      usdPrice: usdPrice ?? this.usdPrice,
    );
  }

  UserDeposit copyWithWrapped({
    Wrapped<String>? balance,
    Wrapped<double>? balanceShort,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<double>? usdPrice,
  }) {
    return UserDeposit(
      balance: (balance != null ? balance.value : this.balance),
      balanceShort: (balanceShort != null
          ? balanceShort.value
          : this.balanceShort),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileDoc {
  const UserProfileDoc({
    required this.dataType,
    required this.address,
    required this.isBanned,
    required this.isVerified,
    required this.socials,
    required this.followCount,
    required this.joinedDate,
    required this.profile,
    required this.banner,
    required this.description,
    required this.herotag,
    required this.isCreator,
    required this.isPoolOwner,
    required this.shard,
    required this.userDeposit,
    required this.chain,
    required this.ts,
    required this.id,
    this.isBoberBattleUser,
  });

  factory UserProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$UserProfileDocFromJson(json);

  static const toJsonFactory = _$UserProfileDocToJson;
  Map<String, dynamic> toJson() => _$UserProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userProfileDocDataTypeToJson,
    fromJson: userProfileDocDataTypeFromJson,
  )
  final enums.UserProfileDocDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'isBanned')
  final bool isBanned;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'isPoolOwner')
  final bool isPoolOwner;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'userDeposit', defaultValue: <UserDeposit>[])
  final List<UserDeposit> userDeposit;
  @JsonKey(
    name: 'chain',
    toJson: userProfileDocChainToJson,
    fromJson: userProfileDocChainFromJson,
  )
  final enums.UserProfileDocChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  static const fromJsonFactory = _$UserProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.isBanned, isBanned) ||
                const DeepCollectionEquality().equals(
                  other.isBanned,
                  isBanned,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(
                  other.herotag,
                  herotag,
                )) &&
            (identical(other.isCreator, isCreator) ||
                const DeepCollectionEquality().equals(
                  other.isCreator,
                  isCreator,
                )) &&
            (identical(other.isPoolOwner, isPoolOwner) ||
                const DeepCollectionEquality().equals(
                  other.isPoolOwner,
                  isPoolOwner,
                )) &&
            (identical(other.shard, shard) ||
                const DeepCollectionEquality().equals(other.shard, shard)) &&
            (identical(other.userDeposit, userDeposit) ||
                const DeepCollectionEquality().equals(
                  other.userDeposit,
                  userDeposit,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.isBoberBattleUser, isBoberBattleUser) ||
                const DeepCollectionEquality().equals(
                  other.isBoberBattleUser,
                  isBoberBattleUser,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(isBanned) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(followCount) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(herotag) ^
      const DeepCollectionEquality().hash(isCreator) ^
      const DeepCollectionEquality().hash(isPoolOwner) ^
      const DeepCollectionEquality().hash(shard) ^
      const DeepCollectionEquality().hash(userDeposit) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(isBoberBattleUser) ^
      runtimeType.hashCode;
}

extension $UserProfileDocExtension on UserProfileDoc {
  UserProfileDoc copyWith({
    enums.UserProfileDocDataType? dataType,
    String? address,
    bool? isBanned,
    bool? isVerified,
    SocialsDto? socials,
    double? followCount,
    double? joinedDate,
    String? profile,
    String? banner,
    String? description,
    String? herotag,
    bool? isCreator,
    bool? isPoolOwner,
    double? shard,
    List<UserDeposit>? userDeposit,
    enums.UserProfileDocChain? chain,
    double? ts,
    String? id,
    bool? isBoberBattleUser,
  }) {
    return UserProfileDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      isBanned: isBanned ?? this.isBanned,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      followCount: followCount ?? this.followCount,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      description: description ?? this.description,
      herotag: herotag ?? this.herotag,
      isCreator: isCreator ?? this.isCreator,
      isPoolOwner: isPoolOwner ?? this.isPoolOwner,
      shard: shard ?? this.shard,
      userDeposit: userDeposit ?? this.userDeposit,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
    );
  }

  UserProfileDoc copyWithWrapped({
    Wrapped<enums.UserProfileDocDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<bool>? isBanned,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<double>? followCount,
    Wrapped<double>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<String>? description,
    Wrapped<String>? herotag,
    Wrapped<bool>? isCreator,
    Wrapped<bool>? isPoolOwner,
    Wrapped<double>? shard,
    Wrapped<List<UserDeposit>>? userDeposit,
    Wrapped<enums.UserProfileDocChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<bool?>? isBoberBattleUser,
  }) {
    return UserProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      isBanned: (isBanned != null ? isBanned.value : this.isBanned),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      followCount: (followCount != null ? followCount.value : this.followCount),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      description: (description != null ? description.value : this.description),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      isPoolOwner: (isPoolOwner != null ? isPoolOwner.value : this.isPoolOwner),
      shard: (shard != null ? shard.value : this.shard),
      userDeposit: (userDeposit != null ? userDeposit.value : this.userDeposit),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserEmailNotificationSettings {
  const UserEmailNotificationSettings({
    required this.enabled,
    required this.emailAddress,
    required this.isEmailVerificationPending,
    required this.isEmailVerified,
    required this.isWeb2User,
    this.timestamp,
  });

  factory UserEmailNotificationSettings.fromJson(Map<String, dynamic> json) =>
      _$UserEmailNotificationSettingsFromJson(json);

  static const toJsonFactory = _$UserEmailNotificationSettingsToJson;
  Map<String, dynamic> toJson() => _$UserEmailNotificationSettingsToJson(this);

  @JsonKey(name: 'enabled')
  final Object enabled;
  @JsonKey(name: 'emailAddress')
  final Object emailAddress;
  @JsonKey(name: 'isEmailVerificationPending')
  final Object isEmailVerificationPending;
  @JsonKey(name: 'isEmailVerified')
  final Object isEmailVerified;
  @JsonKey(name: 'isWeb2User')
  final Object isWeb2User;
  @JsonKey(name: 'timestamp')
  final double? timestamp;
  static const fromJsonFactory = _$UserEmailNotificationSettingsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserEmailNotificationSettings &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality().equals(
                  other.emailAddress,
                  emailAddress,
                )) &&
            (identical(
                  other.isEmailVerificationPending,
                  isEmailVerificationPending,
                ) ||
                const DeepCollectionEquality().equals(
                  other.isEmailVerificationPending,
                  isEmailVerificationPending,
                )) &&
            (identical(other.isEmailVerified, isEmailVerified) ||
                const DeepCollectionEquality().equals(
                  other.isEmailVerified,
                  isEmailVerified,
                )) &&
            (identical(other.isWeb2User, isWeb2User) ||
                const DeepCollectionEquality().equals(
                  other.isWeb2User,
                  isWeb2User,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(isEmailVerificationPending) ^
      const DeepCollectionEquality().hash(isEmailVerified) ^
      const DeepCollectionEquality().hash(isWeb2User) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $UserEmailNotificationSettingsExtension
    on UserEmailNotificationSettings {
  UserEmailNotificationSettings copyWith({
    Object? enabled,
    Object? emailAddress,
    Object? isEmailVerificationPending,
    Object? isEmailVerified,
    Object? isWeb2User,
    double? timestamp,
  }) {
    return UserEmailNotificationSettings(
      enabled: enabled ?? this.enabled,
      emailAddress: emailAddress ?? this.emailAddress,
      isEmailVerificationPending:
          isEmailVerificationPending ?? this.isEmailVerificationPending,
      isEmailVerified: isEmailVerified ?? this.isEmailVerified,
      isWeb2User: isWeb2User ?? this.isWeb2User,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  UserEmailNotificationSettings copyWithWrapped({
    Wrapped<Object>? enabled,
    Wrapped<Object>? emailAddress,
    Wrapped<Object>? isEmailVerificationPending,
    Wrapped<Object>? isEmailVerified,
    Wrapped<Object>? isWeb2User,
    Wrapped<double?>? timestamp,
  }) {
    return UserEmailNotificationSettings(
      enabled: (enabled != null ? enabled.value : this.enabled),
      emailAddress: (emailAddress != null
          ? emailAddress.value
          : this.emailAddress),
      isEmailVerificationPending: (isEmailVerificationPending != null
          ? isEmailVerificationPending.value
          : this.isEmailVerificationPending),
      isEmailVerified: (isEmailVerified != null
          ? isEmailVerified.value
          : this.isEmailVerified),
      isWeb2User: (isWeb2User != null ? isWeb2User.value : this.isWeb2User),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserNotificationPreferences {
  const UserNotificationPreferences({
    this.sales,
    this.bids,
    this.offersReceived,
    this.offersAccepted,
    this.offersRejected,
    this.deposits,
    this.eventUpdates,
    this.eventReminders,
    this.eventCheckIn,
    this.eventMarketing,
  });

  factory UserNotificationPreferences.fromJson(Map<String, dynamic> json) =>
      _$UserNotificationPreferencesFromJson(json);

  static const toJsonFactory = _$UserNotificationPreferencesToJson;
  Map<String, dynamic> toJson() => _$UserNotificationPreferencesToJson(this);

  @JsonKey(name: 'sales')
  final bool? sales;
  @JsonKey(name: 'bids')
  final bool? bids;
  @JsonKey(name: 'offersReceived')
  final bool? offersReceived;
  @JsonKey(name: 'offersAccepted')
  final bool? offersAccepted;
  @JsonKey(name: 'offersRejected')
  final bool? offersRejected;
  @JsonKey(name: 'deposits')
  final bool? deposits;
  @JsonKey(name: 'eventUpdates')
  final bool? eventUpdates;
  @JsonKey(name: 'eventReminders')
  final bool? eventReminders;
  @JsonKey(name: 'eventCheckIn')
  final bool? eventCheckIn;
  @JsonKey(name: 'eventMarketing')
  final bool? eventMarketing;
  static const fromJsonFactory = _$UserNotificationPreferencesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserNotificationPreferences &&
            (identical(other.sales, sales) ||
                const DeepCollectionEquality().equals(other.sales, sales)) &&
            (identical(other.bids, bids) ||
                const DeepCollectionEquality().equals(other.bids, bids)) &&
            (identical(other.offersReceived, offersReceived) ||
                const DeepCollectionEquality().equals(
                  other.offersReceived,
                  offersReceived,
                )) &&
            (identical(other.offersAccepted, offersAccepted) ||
                const DeepCollectionEquality().equals(
                  other.offersAccepted,
                  offersAccepted,
                )) &&
            (identical(other.offersRejected, offersRejected) ||
                const DeepCollectionEquality().equals(
                  other.offersRejected,
                  offersRejected,
                )) &&
            (identical(other.deposits, deposits) ||
                const DeepCollectionEquality().equals(
                  other.deposits,
                  deposits,
                )) &&
            (identical(other.eventUpdates, eventUpdates) ||
                const DeepCollectionEquality().equals(
                  other.eventUpdates,
                  eventUpdates,
                )) &&
            (identical(other.eventReminders, eventReminders) ||
                const DeepCollectionEquality().equals(
                  other.eventReminders,
                  eventReminders,
                )) &&
            (identical(other.eventCheckIn, eventCheckIn) ||
                const DeepCollectionEquality().equals(
                  other.eventCheckIn,
                  eventCheckIn,
                )) &&
            (identical(other.eventMarketing, eventMarketing) ||
                const DeepCollectionEquality().equals(
                  other.eventMarketing,
                  eventMarketing,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sales) ^
      const DeepCollectionEquality().hash(bids) ^
      const DeepCollectionEquality().hash(offersReceived) ^
      const DeepCollectionEquality().hash(offersAccepted) ^
      const DeepCollectionEquality().hash(offersRejected) ^
      const DeepCollectionEquality().hash(deposits) ^
      const DeepCollectionEquality().hash(eventUpdates) ^
      const DeepCollectionEquality().hash(eventReminders) ^
      const DeepCollectionEquality().hash(eventCheckIn) ^
      const DeepCollectionEquality().hash(eventMarketing) ^
      runtimeType.hashCode;
}

extension $UserNotificationPreferencesExtension on UserNotificationPreferences {
  UserNotificationPreferences copyWith({
    bool? sales,
    bool? bids,
    bool? offersReceived,
    bool? offersAccepted,
    bool? offersRejected,
    bool? deposits,
    bool? eventUpdates,
    bool? eventReminders,
    bool? eventCheckIn,
    bool? eventMarketing,
  }) {
    return UserNotificationPreferences(
      sales: sales ?? this.sales,
      bids: bids ?? this.bids,
      offersReceived: offersReceived ?? this.offersReceived,
      offersAccepted: offersAccepted ?? this.offersAccepted,
      offersRejected: offersRejected ?? this.offersRejected,
      deposits: deposits ?? this.deposits,
      eventUpdates: eventUpdates ?? this.eventUpdates,
      eventReminders: eventReminders ?? this.eventReminders,
      eventCheckIn: eventCheckIn ?? this.eventCheckIn,
      eventMarketing: eventMarketing ?? this.eventMarketing,
    );
  }

  UserNotificationPreferences copyWithWrapped({
    Wrapped<bool?>? sales,
    Wrapped<bool?>? bids,
    Wrapped<bool?>? offersReceived,
    Wrapped<bool?>? offersAccepted,
    Wrapped<bool?>? offersRejected,
    Wrapped<bool?>? deposits,
    Wrapped<bool?>? eventUpdates,
    Wrapped<bool?>? eventReminders,
    Wrapped<bool?>? eventCheckIn,
    Wrapped<bool?>? eventMarketing,
  }) {
    return UserNotificationPreferences(
      sales: (sales != null ? sales.value : this.sales),
      bids: (bids != null ? bids.value : this.bids),
      offersReceived: (offersReceived != null
          ? offersReceived.value
          : this.offersReceived),
      offersAccepted: (offersAccepted != null
          ? offersAccepted.value
          : this.offersAccepted),
      offersRejected: (offersRejected != null
          ? offersRejected.value
          : this.offersRejected),
      deposits: (deposits != null ? deposits.value : this.deposits),
      eventUpdates: (eventUpdates != null
          ? eventUpdates.value
          : this.eventUpdates),
      eventReminders: (eventReminders != null
          ? eventReminders.value
          : this.eventReminders),
      eventCheckIn: (eventCheckIn != null
          ? eventCheckIn.value
          : this.eventCheckIn),
      eventMarketing: (eventMarketing != null
          ? eventMarketing.value
          : this.eventMarketing),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSettingsDto {
  const UserSettingsDto({
    required this.emailNotifications,
    required this.notificationPreferences,
    required this.address,
    required this.id,
    required this.ts,
  });

  factory UserSettingsDto.fromJson(Map<String, dynamic> json) =>
      _$UserSettingsDtoFromJson(json);

  static const toJsonFactory = _$UserSettingsDtoToJson;
  Map<String, dynamic> toJson() => _$UserSettingsDtoToJson(this);

  @JsonKey(name: 'emailNotifications')
  final UserEmailNotificationSettings emailNotifications;
  @JsonKey(name: 'notificationPreferences')
  final UserNotificationPreferences notificationPreferences;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  static const fromJsonFactory = _$UserSettingsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserSettingsDto &&
            (identical(other.emailNotifications, emailNotifications) ||
                const DeepCollectionEquality().equals(
                  other.emailNotifications,
                  emailNotifications,
                )) &&
            (identical(
                  other.notificationPreferences,
                  notificationPreferences,
                ) ||
                const DeepCollectionEquality().equals(
                  other.notificationPreferences,
                  notificationPreferences,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(emailNotifications) ^
      const DeepCollectionEquality().hash(notificationPreferences) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $UserSettingsDtoExtension on UserSettingsDto {
  UserSettingsDto copyWith({
    UserEmailNotificationSettings? emailNotifications,
    UserNotificationPreferences? notificationPreferences,
    String? address,
    String? id,
    double? ts,
  }) {
    return UserSettingsDto(
      emailNotifications: emailNotifications ?? this.emailNotifications,
      notificationPreferences:
          notificationPreferences ?? this.notificationPreferences,
      address: address ?? this.address,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  UserSettingsDto copyWithWrapped({
    Wrapped<UserEmailNotificationSettings>? emailNotifications,
    Wrapped<UserNotificationPreferences>? notificationPreferences,
    Wrapped<String>? address,
    Wrapped<String>? id,
    Wrapped<double>? ts,
  }) {
    return UserSettingsDto(
      emailNotifications: (emailNotifications != null
          ? emailNotifications.value
          : this.emailNotifications),
      notificationPreferences: (notificationPreferences != null
          ? notificationPreferences.value
          : this.notificationPreferences),
      address: (address != null ? address.value : this.address),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileDto {
  const UserProfileDto({
    required this.dataType,
    required this.address,
    required this.isBanned,
    required this.isVerified,
    required this.socials,
    required this.followCount,
    required this.joinedDate,
    required this.profile,
    required this.banner,
    required this.description,
    required this.herotag,
    required this.isCreator,
    required this.isPoolOwner,
    required this.shard,
    required this.userDeposit,
    required this.chain,
    required this.ts,
    required this.id,
    this.isBoberBattleUser,
    this.userSettings,
  });

  factory UserProfileDto.fromJson(Map<String, dynamic> json) =>
      _$UserProfileDtoFromJson(json);

  static const toJsonFactory = _$UserProfileDtoToJson;
  Map<String, dynamic> toJson() => _$UserProfileDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userProfileDtoDataTypeToJson,
    fromJson: userProfileDtoDataTypeFromJson,
  )
  final enums.UserProfileDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'isBanned')
  final bool isBanned;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'isPoolOwner')
  final bool isPoolOwner;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'userDeposit', defaultValue: <UserDeposit>[])
  final List<UserDeposit> userDeposit;
  @JsonKey(
    name: 'chain',
    toJson: userProfileDtoChainToJson,
    fromJson: userProfileDtoChainFromJson,
  )
  final enums.UserProfileDtoChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  @JsonKey(name: 'userSettings')
  final UserSettingsDto? userSettings;
  static const fromJsonFactory = _$UserProfileDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserProfileDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.isBanned, isBanned) ||
                const DeepCollectionEquality().equals(
                  other.isBanned,
                  isBanned,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(
                  other.herotag,
                  herotag,
                )) &&
            (identical(other.isCreator, isCreator) ||
                const DeepCollectionEquality().equals(
                  other.isCreator,
                  isCreator,
                )) &&
            (identical(other.isPoolOwner, isPoolOwner) ||
                const DeepCollectionEquality().equals(
                  other.isPoolOwner,
                  isPoolOwner,
                )) &&
            (identical(other.shard, shard) ||
                const DeepCollectionEquality().equals(other.shard, shard)) &&
            (identical(other.userDeposit, userDeposit) ||
                const DeepCollectionEquality().equals(
                  other.userDeposit,
                  userDeposit,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.isBoberBattleUser, isBoberBattleUser) ||
                const DeepCollectionEquality().equals(
                  other.isBoberBattleUser,
                  isBoberBattleUser,
                )) &&
            (identical(other.userSettings, userSettings) ||
                const DeepCollectionEquality().equals(
                  other.userSettings,
                  userSettings,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(isBanned) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(followCount) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(herotag) ^
      const DeepCollectionEquality().hash(isCreator) ^
      const DeepCollectionEquality().hash(isPoolOwner) ^
      const DeepCollectionEquality().hash(shard) ^
      const DeepCollectionEquality().hash(userDeposit) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(isBoberBattleUser) ^
      const DeepCollectionEquality().hash(userSettings) ^
      runtimeType.hashCode;
}

extension $UserProfileDtoExtension on UserProfileDto {
  UserProfileDto copyWith({
    enums.UserProfileDtoDataType? dataType,
    String? address,
    bool? isBanned,
    bool? isVerified,
    SocialsDto? socials,
    double? followCount,
    double? joinedDate,
    String? profile,
    String? banner,
    String? description,
    String? herotag,
    bool? isCreator,
    bool? isPoolOwner,
    double? shard,
    List<UserDeposit>? userDeposit,
    enums.UserProfileDtoChain? chain,
    double? ts,
    String? id,
    bool? isBoberBattleUser,
    UserSettingsDto? userSettings,
  }) {
    return UserProfileDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      isBanned: isBanned ?? this.isBanned,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      followCount: followCount ?? this.followCount,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      description: description ?? this.description,
      herotag: herotag ?? this.herotag,
      isCreator: isCreator ?? this.isCreator,
      isPoolOwner: isPoolOwner ?? this.isPoolOwner,
      shard: shard ?? this.shard,
      userDeposit: userDeposit ?? this.userDeposit,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
      userSettings: userSettings ?? this.userSettings,
    );
  }

  UserProfileDto copyWithWrapped({
    Wrapped<enums.UserProfileDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<bool>? isBanned,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<double>? followCount,
    Wrapped<double>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<String>? description,
    Wrapped<String>? herotag,
    Wrapped<bool>? isCreator,
    Wrapped<bool>? isPoolOwner,
    Wrapped<double>? shard,
    Wrapped<List<UserDeposit>>? userDeposit,
    Wrapped<enums.UserProfileDtoChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<bool?>? isBoberBattleUser,
    Wrapped<UserSettingsDto?>? userSettings,
  }) {
    return UserProfileDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      isBanned: (isBanned != null ? isBanned.value : this.isBanned),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      followCount: (followCount != null ? followCount.value : this.followCount),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      description: (description != null ? description.value : this.description),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      isPoolOwner: (isPoolOwner != null ? isPoolOwner.value : this.isPoolOwner),
      shard: (shard != null ? shard.value : this.shard),
      userDeposit: (userDeposit != null ? userDeposit.value : this.userDeposit),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
      userSettings: (userSettings != null
          ? userSettings.value
          : this.userSettings),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBillingDetails {
  const UserBillingDetails({
    required this.isCompany,
    required this.name,
    this.companyRegistrationNumber,
    this.companyVatNumber,
    required this.email,
    required this.country,
    required this.city,
    required this.address1,
    this.address2,
    this.postalCode,
  });

  factory UserBillingDetails.fromJson(Map<String, dynamic> json) =>
      _$UserBillingDetailsFromJson(json);

  static const toJsonFactory = _$UserBillingDetailsToJson;
  Map<String, dynamic> toJson() => _$UserBillingDetailsToJson(this);

  @JsonKey(name: 'isCompany')
  final bool isCompany;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'companyRegistrationNumber')
  final String? companyRegistrationNumber;
  @JsonKey(name: 'companyVatNumber')
  final String? companyVatNumber;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'address1')
  final String address1;
  @JsonKey(name: 'address2')
  final String? address2;
  @JsonKey(name: 'postalCode')
  final String? postalCode;
  static const fromJsonFactory = _$UserBillingDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserBillingDetails &&
            (identical(other.isCompany, isCompany) ||
                const DeepCollectionEquality().equals(
                  other.isCompany,
                  isCompany,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(
                  other.companyRegistrationNumber,
                  companyRegistrationNumber,
                ) ||
                const DeepCollectionEquality().equals(
                  other.companyRegistrationNumber,
                  companyRegistrationNumber,
                )) &&
            (identical(other.companyVatNumber, companyVatNumber) ||
                const DeepCollectionEquality().equals(
                  other.companyVatNumber,
                  companyVatNumber,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.address1, address1) ||
                const DeepCollectionEquality().equals(
                  other.address1,
                  address1,
                )) &&
            (identical(other.address2, address2) ||
                const DeepCollectionEquality().equals(
                  other.address2,
                  address2,
                )) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality().equals(
                  other.postalCode,
                  postalCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isCompany) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(companyRegistrationNumber) ^
      const DeepCollectionEquality().hash(companyVatNumber) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(address1) ^
      const DeepCollectionEquality().hash(address2) ^
      const DeepCollectionEquality().hash(postalCode) ^
      runtimeType.hashCode;
}

extension $UserBillingDetailsExtension on UserBillingDetails {
  UserBillingDetails copyWith({
    bool? isCompany,
    String? name,
    String? companyRegistrationNumber,
    String? companyVatNumber,
    String? email,
    String? country,
    String? city,
    String? address1,
    String? address2,
    String? postalCode,
  }) {
    return UserBillingDetails(
      isCompany: isCompany ?? this.isCompany,
      name: name ?? this.name,
      companyRegistrationNumber:
          companyRegistrationNumber ?? this.companyRegistrationNumber,
      companyVatNumber: companyVatNumber ?? this.companyVatNumber,
      email: email ?? this.email,
      country: country ?? this.country,
      city: city ?? this.city,
      address1: address1 ?? this.address1,
      address2: address2 ?? this.address2,
      postalCode: postalCode ?? this.postalCode,
    );
  }

  UserBillingDetails copyWithWrapped({
    Wrapped<bool>? isCompany,
    Wrapped<String>? name,
    Wrapped<String?>? companyRegistrationNumber,
    Wrapped<String?>? companyVatNumber,
    Wrapped<String>? email,
    Wrapped<String>? country,
    Wrapped<String>? city,
    Wrapped<String>? address1,
    Wrapped<String?>? address2,
    Wrapped<String?>? postalCode,
  }) {
    return UserBillingDetails(
      isCompany: (isCompany != null ? isCompany.value : this.isCompany),
      name: (name != null ? name.value : this.name),
      companyRegistrationNumber: (companyRegistrationNumber != null
          ? companyRegistrationNumber.value
          : this.companyRegistrationNumber),
      companyVatNumber: (companyVatNumber != null
          ? companyVatNumber.value
          : this.companyVatNumber),
      email: (email != null ? email.value : this.email),
      country: (country != null ? country.value : this.country),
      city: (city != null ? city.value : this.city),
      address1: (address1 != null ? address1.value : this.address1),
      address2: (address2 != null ? address2.value : this.address2),
      postalCode: (postalCode != null ? postalCode.value : this.postalCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPhoneNotificationSettings {
  const UserPhoneNotificationSettings({
    required this.enabled,
    required this.phoneNumber,
    required this.isPhoneVerificationPending,
    required this.isPhoneVerified,
    this.timestamp,
  });

  factory UserPhoneNotificationSettings.fromJson(Map<String, dynamic> json) =>
      _$UserPhoneNotificationSettingsFromJson(json);

  static const toJsonFactory = _$UserPhoneNotificationSettingsToJson;
  Map<String, dynamic> toJson() => _$UserPhoneNotificationSettingsToJson(this);

  @JsonKey(name: 'enabled')
  final Object enabled;
  @JsonKey(name: 'phoneNumber')
  final Object phoneNumber;
  @JsonKey(name: 'isPhoneVerificationPending')
  final Object isPhoneVerificationPending;
  @JsonKey(name: 'isPhoneVerified')
  final Object isPhoneVerified;
  @JsonKey(name: 'timestamp')
  final double? timestamp;
  static const fromJsonFactory = _$UserPhoneNotificationSettingsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPhoneNotificationSettings &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.phoneNumber,
                  phoneNumber,
                )) &&
            (identical(
                  other.isPhoneVerificationPending,
                  isPhoneVerificationPending,
                ) ||
                const DeepCollectionEquality().equals(
                  other.isPhoneVerificationPending,
                  isPhoneVerificationPending,
                )) &&
            (identical(other.isPhoneVerified, isPhoneVerified) ||
                const DeepCollectionEquality().equals(
                  other.isPhoneVerified,
                  isPhoneVerified,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(isPhoneVerificationPending) ^
      const DeepCollectionEquality().hash(isPhoneVerified) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $UserPhoneNotificationSettingsExtension
    on UserPhoneNotificationSettings {
  UserPhoneNotificationSettings copyWith({
    Object? enabled,
    Object? phoneNumber,
    Object? isPhoneVerificationPending,
    Object? isPhoneVerified,
    double? timestamp,
  }) {
    return UserPhoneNotificationSettings(
      enabled: enabled ?? this.enabled,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      isPhoneVerificationPending:
          isPhoneVerificationPending ?? this.isPhoneVerificationPending,
      isPhoneVerified: isPhoneVerified ?? this.isPhoneVerified,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  UserPhoneNotificationSettings copyWithWrapped({
    Wrapped<Object>? enabled,
    Wrapped<Object>? phoneNumber,
    Wrapped<Object>? isPhoneVerificationPending,
    Wrapped<Object>? isPhoneVerified,
    Wrapped<double?>? timestamp,
  }) {
    return UserPhoneNotificationSettings(
      enabled: (enabled != null ? enabled.value : this.enabled),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
      isPhoneVerificationPending: (isPhoneVerificationPending != null
          ? isPhoneVerificationPending.value
          : this.isPhoneVerificationPending),
      isPhoneVerified: (isPhoneVerified != null
          ? isPhoneVerified.value
          : this.isPhoneVerified),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSettingsDoc {
  const UserSettingsDoc({
    required this.dataType,
    required this.address,
    this.name,
    this.billingDetails,
    required this.emailNotifications,
    this.phoneNotifications,
    required this.notificationPreferences,
    required this.id,
    this.ts,
  });

  factory UserSettingsDoc.fromJson(Map<String, dynamic> json) =>
      _$UserSettingsDocFromJson(json);

  static const toJsonFactory = _$UserSettingsDocToJson;
  Map<String, dynamic> toJson() => _$UserSettingsDocToJson(this);

  @JsonKey(name: 'dataType')
  final String dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'billingDetails')
  final UserBillingDetails? billingDetails;
  @JsonKey(name: 'emailNotifications')
  final UserEmailNotificationSettings emailNotifications;
  @JsonKey(name: 'phoneNotifications')
  final UserPhoneNotificationSettings? phoneNotifications;
  @JsonKey(name: 'notificationPreferences')
  final UserNotificationPreferences notificationPreferences;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$UserSettingsDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserSettingsDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.billingDetails, billingDetails) ||
                const DeepCollectionEquality().equals(
                  other.billingDetails,
                  billingDetails,
                )) &&
            (identical(other.emailNotifications, emailNotifications) ||
                const DeepCollectionEquality().equals(
                  other.emailNotifications,
                  emailNotifications,
                )) &&
            (identical(other.phoneNotifications, phoneNotifications) ||
                const DeepCollectionEquality().equals(
                  other.phoneNotifications,
                  phoneNotifications,
                )) &&
            (identical(
                  other.notificationPreferences,
                  notificationPreferences,
                ) ||
                const DeepCollectionEquality().equals(
                  other.notificationPreferences,
                  notificationPreferences,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(billingDetails) ^
      const DeepCollectionEquality().hash(emailNotifications) ^
      const DeepCollectionEquality().hash(phoneNotifications) ^
      const DeepCollectionEquality().hash(notificationPreferences) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $UserSettingsDocExtension on UserSettingsDoc {
  UserSettingsDoc copyWith({
    String? dataType,
    String? address,
    String? name,
    UserBillingDetails? billingDetails,
    UserEmailNotificationSettings? emailNotifications,
    UserPhoneNotificationSettings? phoneNotifications,
    UserNotificationPreferences? notificationPreferences,
    String? id,
    double? ts,
  }) {
    return UserSettingsDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      billingDetails: billingDetails ?? this.billingDetails,
      emailNotifications: emailNotifications ?? this.emailNotifications,
      phoneNotifications: phoneNotifications ?? this.phoneNotifications,
      notificationPreferences:
          notificationPreferences ?? this.notificationPreferences,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  UserSettingsDoc copyWithWrapped({
    Wrapped<String>? dataType,
    Wrapped<String>? address,
    Wrapped<String?>? name,
    Wrapped<UserBillingDetails?>? billingDetails,
    Wrapped<UserEmailNotificationSettings>? emailNotifications,
    Wrapped<UserPhoneNotificationSettings?>? phoneNotifications,
    Wrapped<UserNotificationPreferences>? notificationPreferences,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
  }) {
    return UserSettingsDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      billingDetails: (billingDetails != null
          ? billingDetails.value
          : this.billingDetails),
      emailNotifications: (emailNotifications != null
          ? emailNotifications.value
          : this.emailNotifications),
      phoneNotifications: (phoneNotifications != null
          ? phoneNotifications.value
          : this.phoneNotifications),
      notificationPreferences: (notificationPreferences != null
          ? notificationPreferences.value
          : this.notificationPreferences),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationPreferencesPostDto {
  const NotificationPreferencesPostDto({
    required this.sales,
    required this.bids,
    required this.offersReceived,
    required this.offersAccepted,
    required this.offersRejected,
    required this.deposits,
  });

  factory NotificationPreferencesPostDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationPreferencesPostDtoFromJson(json);

  static const toJsonFactory = _$NotificationPreferencesPostDtoToJson;
  Map<String, dynamic> toJson() => _$NotificationPreferencesPostDtoToJson(this);

  @JsonKey(name: 'sales')
  final bool sales;
  @JsonKey(name: 'bids')
  final bool bids;
  @JsonKey(name: 'offersReceived')
  final bool offersReceived;
  @JsonKey(name: 'offersAccepted')
  final bool offersAccepted;
  @JsonKey(name: 'offersRejected')
  final bool offersRejected;
  @JsonKey(name: 'deposits')
  final bool deposits;
  static const fromJsonFactory = _$NotificationPreferencesPostDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationPreferencesPostDto &&
            (identical(other.sales, sales) ||
                const DeepCollectionEquality().equals(other.sales, sales)) &&
            (identical(other.bids, bids) ||
                const DeepCollectionEquality().equals(other.bids, bids)) &&
            (identical(other.offersReceived, offersReceived) ||
                const DeepCollectionEquality().equals(
                  other.offersReceived,
                  offersReceived,
                )) &&
            (identical(other.offersAccepted, offersAccepted) ||
                const DeepCollectionEquality().equals(
                  other.offersAccepted,
                  offersAccepted,
                )) &&
            (identical(other.offersRejected, offersRejected) ||
                const DeepCollectionEquality().equals(
                  other.offersRejected,
                  offersRejected,
                )) &&
            (identical(other.deposits, deposits) ||
                const DeepCollectionEquality().equals(
                  other.deposits,
                  deposits,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sales) ^
      const DeepCollectionEquality().hash(bids) ^
      const DeepCollectionEquality().hash(offersReceived) ^
      const DeepCollectionEquality().hash(offersAccepted) ^
      const DeepCollectionEquality().hash(offersRejected) ^
      const DeepCollectionEquality().hash(deposits) ^
      runtimeType.hashCode;
}

extension $NotificationPreferencesPostDtoExtension
    on NotificationPreferencesPostDto {
  NotificationPreferencesPostDto copyWith({
    bool? sales,
    bool? bids,
    bool? offersReceived,
    bool? offersAccepted,
    bool? offersRejected,
    bool? deposits,
  }) {
    return NotificationPreferencesPostDto(
      sales: sales ?? this.sales,
      bids: bids ?? this.bids,
      offersReceived: offersReceived ?? this.offersReceived,
      offersAccepted: offersAccepted ?? this.offersAccepted,
      offersRejected: offersRejected ?? this.offersRejected,
      deposits: deposits ?? this.deposits,
    );
  }

  NotificationPreferencesPostDto copyWithWrapped({
    Wrapped<bool>? sales,
    Wrapped<bool>? bids,
    Wrapped<bool>? offersReceived,
    Wrapped<bool>? offersAccepted,
    Wrapped<bool>? offersRejected,
    Wrapped<bool>? deposits,
  }) {
    return NotificationPreferencesPostDto(
      sales: (sales != null ? sales.value : this.sales),
      bids: (bids != null ? bids.value : this.bids),
      offersReceived: (offersReceived != null
          ? offersReceived.value
          : this.offersReceived),
      offersAccepted: (offersAccepted != null
          ? offersAccepted.value
          : this.offersAccepted),
      offersRejected: (offersRejected != null
          ? offersRejected.value
          : this.offersRejected),
      deposits: (deposits != null ? deposits.value : this.deposits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SetEmailDto {
  const SetEmailDto({required this.enabled, this.emailAddress});

  factory SetEmailDto.fromJson(Map<String, dynamic> json) =>
      _$SetEmailDtoFromJson(json);

  static const toJsonFactory = _$SetEmailDtoToJson;
  Map<String, dynamic> toJson() => _$SetEmailDtoToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;
  static const fromJsonFactory = _$SetEmailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetEmailDto &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality().equals(
                  other.emailAddress,
                  emailAddress,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      runtimeType.hashCode;
}

extension $SetEmailDtoExtension on SetEmailDto {
  SetEmailDto copyWith({bool? enabled, String? emailAddress}) {
    return SetEmailDto(
      enabled: enabled ?? this.enabled,
      emailAddress: emailAddress ?? this.emailAddress,
    );
  }

  SetEmailDto copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String?>? emailAddress,
  }) {
    return SetEmailDto(
      enabled: (enabled != null ? enabled.value : this.enabled),
      emailAddress: (emailAddress != null
          ? emailAddress.value
          : this.emailAddress),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SetPhoneDto {
  const SetPhoneDto({required this.enabled, this.phoneNumber});

  factory SetPhoneDto.fromJson(Map<String, dynamic> json) =>
      _$SetPhoneDtoFromJson(json);

  static const toJsonFactory = _$SetPhoneDtoToJson;
  Map<String, dynamic> toJson() => _$SetPhoneDtoToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  static const fromJsonFactory = _$SetPhoneDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetPhoneDto &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(
                  other.enabled,
                  enabled,
                )) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.phoneNumber,
                  phoneNumber,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      runtimeType.hashCode;
}

extension $SetPhoneDtoExtension on SetPhoneDto {
  SetPhoneDto copyWith({bool? enabled, String? phoneNumber}) {
    return SetPhoneDto(
      enabled: enabled ?? this.enabled,
      phoneNumber: phoneNumber ?? this.phoneNumber,
    );
  }

  SetPhoneDto copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String?>? phoneNumber,
  }) {
    return SetPhoneDto(
      enabled: (enabled != null ? enabled.value : this.enabled),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyEmailDto {
  const VerifyEmailDto({required this.verificationCode});

  factory VerifyEmailDto.fromJson(Map<String, dynamic> json) =>
      _$VerifyEmailDtoFromJson(json);

  static const toJsonFactory = _$VerifyEmailDtoToJson;
  Map<String, dynamic> toJson() => _$VerifyEmailDtoToJson(this);

  @JsonKey(name: 'verificationCode')
  final String verificationCode;
  static const fromJsonFactory = _$VerifyEmailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifyEmailDto &&
            (identical(other.verificationCode, verificationCode) ||
                const DeepCollectionEquality().equals(
                  other.verificationCode,
                  verificationCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verificationCode) ^
      runtimeType.hashCode;
}

extension $VerifyEmailDtoExtension on VerifyEmailDto {
  VerifyEmailDto copyWith({String? verificationCode}) {
    return VerifyEmailDto(
      verificationCode: verificationCode ?? this.verificationCode,
    );
  }

  VerifyEmailDto copyWithWrapped({Wrapped<String>? verificationCode}) {
    return VerifyEmailDto(
      verificationCode: (verificationCode != null
          ? verificationCode.value
          : this.verificationCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradesilvaniaSignature {
  const TradesilvaniaSignature({required this.url});

  factory TradesilvaniaSignature.fromJson(Map<String, dynamic> json) =>
      _$TradesilvaniaSignatureFromJson(json);

  static const toJsonFactory = _$TradesilvaniaSignatureToJson;
  Map<String, dynamic> toJson() => _$TradesilvaniaSignatureToJson(this);

  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$TradesilvaniaSignatureFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TradesilvaniaSignature &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^ runtimeType.hashCode;
}

extension $TradesilvaniaSignatureExtension on TradesilvaniaSignature {
  TradesilvaniaSignature copyWith({String? url}) {
    return TradesilvaniaSignature(url: url ?? this.url);
  }

  TradesilvaniaSignature copyWithWrapped({Wrapped<String>? url}) {
    return TradesilvaniaSignature(url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileEditDto {
  const UserProfileEditDto({
    this.socials,
    this.profile,
    this.description,
    this.isBoberBattleUser,
  });

  factory UserProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$UserProfileEditDtoFromJson(json);

  static const toJsonFactory = _$UserProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$UserProfileEditDtoToJson(this);

  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  static const fromJsonFactory = _$UserProfileEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserProfileEditDto &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isBoberBattleUser, isBoberBattleUser) ||
                const DeepCollectionEquality().equals(
                  other.isBoberBattleUser,
                  isBoberBattleUser,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isBoberBattleUser) ^
      runtimeType.hashCode;
}

extension $UserProfileEditDtoExtension on UserProfileEditDto {
  UserProfileEditDto copyWith({
    SocialsDto? socials,
    String? profile,
    String? description,
    bool? isBoberBattleUser,
  }) {
    return UserProfileEditDto(
      socials: socials ?? this.socials,
      profile: profile ?? this.profile,
      description: description ?? this.description,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
    );
  }

  UserProfileEditDto copyWithWrapped({
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? profile,
    Wrapped<String?>? description,
    Wrapped<bool?>? isBoberBattleUser,
  }) {
    return UserProfileEditDto(
      socials: (socials != null ? socials.value : this.socials),
      profile: (profile != null ? profile.value : this.profile),
      description: (description != null ? description.value : this.description),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuccessDto {
  const SuccessDto({required this.success});

  factory SuccessDto.fromJson(Map<String, dynamic> json) =>
      _$SuccessDtoFromJson(json);

  static const toJsonFactory = _$SuccessDtoToJson;
  Map<String, dynamic> toJson() => _$SuccessDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  static const fromJsonFactory = _$SuccessDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SuccessDto &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(other.success, success)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^ runtimeType.hashCode;
}

extension $SuccessDtoExtension on SuccessDto {
  SuccessDto copyWith({bool? success}) {
    return SuccessDto(success: success ?? this.success);
  }

  SuccessDto copyWithWrapped({Wrapped<bool>? success}) {
    return SuccessDto(
      success: (success != null ? success.value : this.success),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorProfileDto {
  const CreatorProfileDto({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    required this.joinedDate,
    this.description,
    this.socials,
    this.id,
    this.ts,
    required this.followCount,
  });

  factory CreatorProfileDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorProfileDtoFromJson(json);

  static const toJsonFactory = _$CreatorProfileDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorProfileDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorProfileDtoDataTypeToJson,
    fromJson: creatorProfileDtoDataTypeFromJson,
  )
  final enums.CreatorProfileDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'followCount')
  final double followCount;
  static const fromJsonFactory = _$CreatorProfileDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatorProfileDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                ) ||
                const DeepCollectionEquality().equals(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(ticketingContractAddress) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(followCount) ^
      runtimeType.hashCode;
}

extension $CreatorProfileDtoExtension on CreatorProfileDto {
  CreatorProfileDto copyWith({
    enums.CreatorProfileDtoDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
    double? followCount,
  }) {
    return CreatorProfileDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      followCount: followCount ?? this.followCount,
    );
  }

  CreatorProfileDto copyWithWrapped({
    Wrapped<enums.CreatorProfileDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<double>? followCount,
  }) {
    return CreatorProfileDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorProfileDoc {
  const CreatorProfileDoc({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    required this.joinedDate,
    this.description,
    this.socials,
    this.id,
    this.ts,
  });

  factory CreatorProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$CreatorProfileDocFromJson(json);

  static const toJsonFactory = _$CreatorProfileDocToJson;
  Map<String, dynamic> toJson() => _$CreatorProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorProfileDocDataTypeToJson,
    fromJson: creatorProfileDocDataTypeFromJson,
  )
  final enums.CreatorProfileDocDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$CreatorProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatorProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                ) ||
                const DeepCollectionEquality().equals(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(ticketingContractAddress) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $CreatorProfileDocExtension on CreatorProfileDoc {
  CreatorProfileDoc copyWith({
    enums.CreatorProfileDocDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
  }) {
    return CreatorProfileDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  CreatorProfileDoc copyWithWrapped({
    Wrapped<enums.CreatorProfileDocDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
  }) {
    return CreatorProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RangeFilter {
  const RangeFilter({this.min, this.max, this.field});

  factory RangeFilter.fromJson(Map<String, dynamic> json) =>
      _$RangeFilterFromJson(json);

  static const toJsonFactory = _$RangeFilterToJson;
  Map<String, dynamic> toJson() => _$RangeFilterToJson(this);

  @JsonKey(name: 'min')
  final double? min;
  @JsonKey(name: 'max')
  final double? max;
  @JsonKey(name: 'field')
  final String? field;
  static const fromJsonFactory = _$RangeFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RangeFilter &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max) ^
      const DeepCollectionEquality().hash(field) ^
      runtimeType.hashCode;
}

extension $RangeFilterExtension on RangeFilter {
  RangeFilter copyWith({double? min, double? max, String? field}) {
    return RangeFilter(
      min: min ?? this.min,
      max: max ?? this.max,
      field: field ?? this.field,
    );
  }

  RangeFilter copyWithWrapped({
    Wrapped<double?>? min,
    Wrapped<double?>? max,
    Wrapped<String?>? field,
  }) {
    return RangeFilter(
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
      field: (field != null ? field.value : this.field),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsFilterCriteriaDto {
  const CollectionStatsFilterCriteriaDto({
    this.dataType,
    this.collection,
    this.verifiedOnly,
    this.range,
  });

  factory CollectionStatsFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionStatsFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$CollectionStatsFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionStatsFilterCriteriaDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionDataTypeNullableToJson,
    fromJson: collectionDataTypeNullableFromJson,
  )
  final enums.CollectionDataType? dataType;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'verifiedOnly')
  final bool? verifiedOnly;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$CollectionStatsFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionStatsFilterCriteriaDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.verifiedOnly, verifiedOnly) ||
                const DeepCollectionEquality().equals(
                  other.verifiedOnly,
                  verifiedOnly,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(verifiedOnly) ^
      const DeepCollectionEquality().hash(range) ^
      runtimeType.hashCode;
}

extension $CollectionStatsFilterCriteriaDtoExtension
    on CollectionStatsFilterCriteriaDto {
  CollectionStatsFilterCriteriaDto copyWith({
    enums.CollectionDataType? dataType,
    List<String>? collection,
    bool? verifiedOnly,
    List<RangeFilter>? range,
  }) {
    return CollectionStatsFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      verifiedOnly: verifiedOnly ?? this.verifiedOnly,
      range: range ?? this.range,
    );
  }

  CollectionStatsFilterCriteriaDto copyWithWrapped({
    Wrapped<enums.CollectionDataType?>? dataType,
    Wrapped<List<String>?>? collection,
    Wrapped<bool?>? verifiedOnly,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return CollectionStatsFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      verifiedOnly: (verifiedOnly != null
          ? verifiedOnly.value
          : this.verifiedOnly),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsFilter {
  const CollectionStatsFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory CollectionStatsFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsFilterFromJson(json);

  static const toJsonFactory = _$CollectionStatsFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final CollectionStatsFilterCriteriaDto filters;
  static const fromJsonFactory = _$CollectionStatsFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionStatsFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $CollectionStatsFilterExtension on CollectionStatsFilter {
  CollectionStatsFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    CollectionStatsFilterCriteriaDto? filters,
  }) {
    return CollectionStatsFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  CollectionStatsFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<CollectionStatsFilterCriteriaDto>? filters,
  }) {
    return CollectionStatsFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AllTimeHigh {
  const AllTimeHigh({
    required this.price,
    required this.timestamp,
    required this.txHash,
    required this.identifier,
  });

  factory AllTimeHigh.fromJson(Map<String, dynamic> json) =>
      _$AllTimeHighFromJson(json);

  static const toJsonFactory = _$AllTimeHighToJson;
  Map<String, dynamic> toJson() => _$AllTimeHighToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$AllTimeHighFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AllTimeHigh &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $AllTimeHighExtension on AllTimeHigh {
  AllTimeHigh copyWith({
    double? price,
    double? timestamp,
    String? txHash,
    String? identifier,
  }) {
    return AllTimeHigh(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      identifier: identifier ?? this.identifier,
    );
  }

  AllTimeHigh copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? identifier,
  }) {
    return AllTimeHigh(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingDataSummary {
  const TradingDataSummary({
    required this.volume,
    required this.volumeMargin,
    required this.trades,
    required this.tradesMargin,
    this.minPrice,
    this.maxPrice,
    this.averagePrice,
  });

  factory TradingDataSummary.fromJson(Map<String, dynamic> json) =>
      _$TradingDataSummaryFromJson(json);

  static const toJsonFactory = _$TradingDataSummaryToJson;
  Map<String, dynamic> toJson() => _$TradingDataSummaryToJson(this);

  @JsonKey(name: 'volume')
  final double volume;
  @JsonKey(name: 'volumeMargin')
  final double volumeMargin;
  @JsonKey(name: 'trades')
  final double trades;
  @JsonKey(name: 'tradesMargin')
  final double tradesMargin;
  @JsonKey(name: 'minPrice')
  final double? minPrice;
  @JsonKey(name: 'maxPrice')
  final double? maxPrice;
  @JsonKey(name: 'averagePrice')
  final double? averagePrice;
  static const fromJsonFactory = _$TradingDataSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TradingDataSummary &&
            (identical(other.volume, volume) ||
                const DeepCollectionEquality().equals(other.volume, volume)) &&
            (identical(other.volumeMargin, volumeMargin) ||
                const DeepCollectionEquality().equals(
                  other.volumeMargin,
                  volumeMargin,
                )) &&
            (identical(other.trades, trades) ||
                const DeepCollectionEquality().equals(other.trades, trades)) &&
            (identical(other.tradesMargin, tradesMargin) ||
                const DeepCollectionEquality().equals(
                  other.tradesMargin,
                  tradesMargin,
                )) &&
            (identical(other.minPrice, minPrice) ||
                const DeepCollectionEquality().equals(
                  other.minPrice,
                  minPrice,
                )) &&
            (identical(other.maxPrice, maxPrice) ||
                const DeepCollectionEquality().equals(
                  other.maxPrice,
                  maxPrice,
                )) &&
            (identical(other.averagePrice, averagePrice) ||
                const DeepCollectionEquality().equals(
                  other.averagePrice,
                  averagePrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(volume) ^
      const DeepCollectionEquality().hash(volumeMargin) ^
      const DeepCollectionEquality().hash(trades) ^
      const DeepCollectionEquality().hash(tradesMargin) ^
      const DeepCollectionEquality().hash(minPrice) ^
      const DeepCollectionEquality().hash(maxPrice) ^
      const DeepCollectionEquality().hash(averagePrice) ^
      runtimeType.hashCode;
}

extension $TradingDataSummaryExtension on TradingDataSummary {
  TradingDataSummary copyWith({
    double? volume,
    double? volumeMargin,
    double? trades,
    double? tradesMargin,
    double? minPrice,
    double? maxPrice,
    double? averagePrice,
  }) {
    return TradingDataSummary(
      volume: volume ?? this.volume,
      volumeMargin: volumeMargin ?? this.volumeMargin,
      trades: trades ?? this.trades,
      tradesMargin: tradesMargin ?? this.tradesMargin,
      minPrice: minPrice ?? this.minPrice,
      maxPrice: maxPrice ?? this.maxPrice,
      averagePrice: averagePrice ?? this.averagePrice,
    );
  }

  TradingDataSummary copyWithWrapped({
    Wrapped<double>? volume,
    Wrapped<double>? volumeMargin,
    Wrapped<double>? trades,
    Wrapped<double>? tradesMargin,
    Wrapped<double?>? minPrice,
    Wrapped<double?>? maxPrice,
    Wrapped<double?>? averagePrice,
  }) {
    return TradingDataSummary(
      volume: (volume != null ? volume.value : this.volume),
      volumeMargin: (volumeMargin != null
          ? volumeMargin.value
          : this.volumeMargin),
      trades: (trades != null ? trades.value : this.trades),
      tradesMargin: (tradesMargin != null
          ? tradesMargin.value
          : this.tradesMargin),
      minPrice: (minPrice != null ? minPrice.value : this.minPrice),
      maxPrice: (maxPrice != null ? maxPrice.value : this.maxPrice),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingStatistics {
  const TradingStatistics({
    required this.totalVolume,
    required this.totalTrades,
    this.averagePrice,
    required this.allTimeHigh,
    required this.day,
    required this.week,
    required this.month,
    required this.quarter,
    required this.halfYear,
    required this.year,
  });

  factory TradingStatistics.fromJson(Map<String, dynamic> json) =>
      _$TradingStatisticsFromJson(json);

  static const toJsonFactory = _$TradingStatisticsToJson;
  Map<String, dynamic> toJson() => _$TradingStatisticsToJson(this);

  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'averagePrice')
  final double? averagePrice;
  @JsonKey(name: 'allTimeHigh')
  final AllTimeHigh allTimeHigh;
  @JsonKey(name: 'day')
  final TradingDataSummary day;
  @JsonKey(name: 'week')
  final TradingDataSummary week;
  @JsonKey(name: 'month')
  final TradingDataSummary month;
  @JsonKey(name: 'quarter')
  final TradingDataSummary quarter;
  @JsonKey(name: 'halfYear')
  final TradingDataSummary halfYear;
  @JsonKey(name: 'year')
  final TradingDataSummary year;
  static const fromJsonFactory = _$TradingStatisticsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TradingStatistics &&
            (identical(other.totalVolume, totalVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalVolume,
                  totalVolume,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )) &&
            (identical(other.averagePrice, averagePrice) ||
                const DeepCollectionEquality().equals(
                  other.averagePrice,
                  averagePrice,
                )) &&
            (identical(other.allTimeHigh, allTimeHigh) ||
                const DeepCollectionEquality().equals(
                  other.allTimeHigh,
                  allTimeHigh,
                )) &&
            (identical(other.day, day) ||
                const DeepCollectionEquality().equals(other.day, day)) &&
            (identical(other.week, week) ||
                const DeepCollectionEquality().equals(other.week, week)) &&
            (identical(other.month, month) ||
                const DeepCollectionEquality().equals(other.month, month)) &&
            (identical(other.quarter, quarter) ||
                const DeepCollectionEquality().equals(
                  other.quarter,
                  quarter,
                )) &&
            (identical(other.halfYear, halfYear) ||
                const DeepCollectionEquality().equals(
                  other.halfYear,
                  halfYear,
                )) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalVolume) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      const DeepCollectionEquality().hash(averagePrice) ^
      const DeepCollectionEquality().hash(allTimeHigh) ^
      const DeepCollectionEquality().hash(day) ^
      const DeepCollectionEquality().hash(week) ^
      const DeepCollectionEquality().hash(month) ^
      const DeepCollectionEquality().hash(quarter) ^
      const DeepCollectionEquality().hash(halfYear) ^
      const DeepCollectionEquality().hash(year) ^
      runtimeType.hashCode;
}

extension $TradingStatisticsExtension on TradingStatistics {
  TradingStatistics copyWith({
    double? totalVolume,
    double? totalTrades,
    double? averagePrice,
    AllTimeHigh? allTimeHigh,
    TradingDataSummary? day,
    TradingDataSummary? week,
    TradingDataSummary? month,
    TradingDataSummary? quarter,
    TradingDataSummary? halfYear,
    TradingDataSummary? year,
  }) {
    return TradingStatistics(
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      averagePrice: averagePrice ?? this.averagePrice,
      allTimeHigh: allTimeHigh ?? this.allTimeHigh,
      day: day ?? this.day,
      week: week ?? this.week,
      month: month ?? this.month,
      quarter: quarter ?? this.quarter,
      halfYear: halfYear ?? this.halfYear,
      year: year ?? this.year,
    );
  }

  TradingStatistics copyWithWrapped({
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double?>? averagePrice,
    Wrapped<AllTimeHigh>? allTimeHigh,
    Wrapped<TradingDataSummary>? day,
    Wrapped<TradingDataSummary>? week,
    Wrapped<TradingDataSummary>? month,
    Wrapped<TradingDataSummary>? quarter,
    Wrapped<TradingDataSummary>? halfYear,
    Wrapped<TradingDataSummary>? year,
  }) {
    return TradingStatistics(
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
      allTimeHigh: (allTimeHigh != null ? allTimeHigh.value : this.allTimeHigh),
      day: (day != null ? day.value : this.day),
      week: (week != null ? week.value : this.week),
      month: (month != null ? month.value : this.month),
      quarter: (quarter != null ? quarter.value : this.quarter),
      halfYear: (halfYear != null ? halfYear.value : this.halfYear),
      year: (year != null ? year.value : this.year),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCollectionInfoDoc {
  const ShortCollectionInfoDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.socials,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.owner,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
    required this.volume,
  });

  factory ShortCollectionInfoDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCollectionInfoDocFromJson(json);

  static const toJsonFactory = _$ShortCollectionInfoDocToJson;
  Map<String, dynamic> toJson() => _$ShortCollectionInfoDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: shortCollectionInfoDocChainToJson,
    fromJson: shortCollectionInfoDocChainFromJson,
  )
  final enums.ShortCollectionInfoDocChain chain;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  @JsonKey(name: 'volume')
  final double volume;
  static const fromJsonFactory = _$ShortCollectionInfoDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortCollectionInfoDoc &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )) &&
            (identical(other.volume, volume) ||
                const DeepCollectionEquality().equals(other.volume, volume)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(followCount) ^
      const DeepCollectionEquality().hash(volume) ^
      runtimeType.hashCode;
}

extension $ShortCollectionInfoDocExtension on ShortCollectionInfoDoc {
  ShortCollectionInfoDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    SocialsDto? socials,
    String? profile,
    String? banner,
    enums.ShortCollectionInfoDocChain? chain,
    String? owner,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
    double? volume,
  }) {
    return ShortCollectionInfoDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      owner: owner ?? this.owner,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
      volume: volume ?? this.volume,
    );
  }

  ShortCollectionInfoDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.ShortCollectionInfoDocChain>? chain,
    Wrapped<String>? owner,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
    Wrapped<double>? volume,
  }) {
    return ShortCollectionInfoDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      owner: (owner != null ? owner.value : this.owner),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
      volume: (volume != null ? volume.value : this.volume),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsDocHydrated {
  const CollectionStatsDocHydrated({
    required this.dataType,
    required this.collection,
    this.floorPrice,
    required this.listedCount,
    required this.tradingStats,
    required this.chain,
    required this.ts,
    required this.id,
    this.collectionInfo,
  });

  factory CollectionStatsDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsDocHydratedFromJson(json);

  static const toJsonFactory = _$CollectionStatsDocHydratedToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsDocHydratedToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'floorPrice')
  final double? floorPrice;
  @JsonKey(name: 'listedCount')
  final double listedCount;
  @JsonKey(name: 'tradingStats')
  final TradingStatistics tradingStats;
  @JsonKey(
    name: 'chain',
    toJson: collectionStatsDocHydratedChainToJson,
    fromJson: collectionStatsDocHydratedChainFromJson,
  )
  final enums.CollectionStatsDocHydratedChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc? collectionInfo;
  static const fromJsonFactory = _$CollectionStatsDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionStatsDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.listedCount, listedCount) ||
                const DeepCollectionEquality().equals(
                  other.listedCount,
                  listedCount,
                )) &&
            (identical(other.tradingStats, tradingStats) ||
                const DeepCollectionEquality().equals(
                  other.tradingStats,
                  tradingStats,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(listedCount) ^
      const DeepCollectionEquality().hash(tradingStats) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      runtimeType.hashCode;
}

extension $CollectionStatsDocHydratedExtension on CollectionStatsDocHydrated {
  CollectionStatsDocHydrated copyWith({
    Object? dataType,
    String? collection,
    double? floorPrice,
    double? listedCount,
    TradingStatistics? tradingStats,
    enums.CollectionStatsDocHydratedChain? chain,
    double? ts,
    String? id,
    ShortCollectionInfoDoc? collectionInfo,
  }) {
    return CollectionStatsDocHydrated(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      floorPrice: floorPrice ?? this.floorPrice,
      listedCount: listedCount ?? this.listedCount,
      tradingStats: tradingStats ?? this.tradingStats,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  CollectionStatsDocHydrated copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? collection,
    Wrapped<double?>? floorPrice,
    Wrapped<double>? listedCount,
    Wrapped<TradingStatistics>? tradingStats,
    Wrapped<enums.CollectionStatsDocHydratedChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<ShortCollectionInfoDoc?>? collectionInfo,
  }) {
    return CollectionStatsDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      listedCount: (listedCount != null ? listedCount.value : this.listedCount),
      tradingStats: (tradingStats != null
          ? tradingStats.value
          : this.tradingStats),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsPaginated {
  const CollectionStatsPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionStatsPaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsPaginatedFromJson(json);

  static const toJsonFactory = _$CollectionStatsPaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <CollectionStatsDocHydrated>[])
  final List<CollectionStatsDocHydrated> resources;
  static const fromJsonFactory = _$CollectionStatsPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionStatsPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $CollectionStatsPaginatedExtension on CollectionStatsPaginated {
  CollectionStatsPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionStatsDocHydrated>? resources,
  }) {
    return CollectionStatsPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionStatsPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionStatsDocHydrated>>? resources,
  }) {
    return CollectionStatsPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CheckLikeStatusResponseDto {
  const CheckLikeStatusResponseDto({required this.isFavorite});

  factory CheckLikeStatusResponseDto.fromJson(Map<String, dynamic> json) =>
      _$CheckLikeStatusResponseDtoFromJson(json);

  static const toJsonFactory = _$CheckLikeStatusResponseDtoToJson;
  Map<String, dynamic> toJson() => _$CheckLikeStatusResponseDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  static const fromJsonFactory = _$CheckLikeStatusResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CheckLikeStatusResponseDto &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality().equals(
                  other.isFavorite,
                  isFavorite,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isFavorite) ^ runtimeType.hashCode;
}

extension $CheckLikeStatusResponseDtoExtension on CheckLikeStatusResponseDto {
  CheckLikeStatusResponseDto copyWith({bool? isFavorite}) {
    return CheckLikeStatusResponseDto(
      isFavorite: isFavorite ?? this.isFavorite,
    );
  }

  CheckLikeStatusResponseDto copyWithWrapped({Wrapped<bool>? isFavorite}) {
    return CheckLikeStatusResponseDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserFavoriteResponseDto {
  const UserFavoriteResponseDto({
    required this.isFavorite,
    required this.addressFavorite,
  });

  factory UserFavoriteResponseDto.fromJson(Map<String, dynamic> json) =>
      _$UserFavoriteResponseDtoFromJson(json);

  static const toJsonFactory = _$UserFavoriteResponseDtoToJson;
  Map<String, dynamic> toJson() => _$UserFavoriteResponseDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'addressFavorite')
  final String addressFavorite;
  static const fromJsonFactory = _$UserFavoriteResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserFavoriteResponseDto &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality().equals(
                  other.isFavorite,
                  isFavorite,
                )) &&
            (identical(other.addressFavorite, addressFavorite) ||
                const DeepCollectionEquality().equals(
                  other.addressFavorite,
                  addressFavorite,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isFavorite) ^
      const DeepCollectionEquality().hash(addressFavorite) ^
      runtimeType.hashCode;
}

extension $UserFavoriteResponseDtoExtension on UserFavoriteResponseDto {
  UserFavoriteResponseDto copyWith({
    bool? isFavorite,
    String? addressFavorite,
  }) {
    return UserFavoriteResponseDto(
      isFavorite: isFavorite ?? this.isFavorite,
      addressFavorite: addressFavorite ?? this.addressFavorite,
    );
  }

  UserFavoriteResponseDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String>? addressFavorite,
  }) {
    return UserFavoriteResponseDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      addressFavorite: (addressFavorite != null
          ? addressFavorite.value
          : this.addressFavorite),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TokenDataDocHydrated {
  const TokenDataDocHydrated({
    required this.identifier,
    required this.decimals,
    required this.ticker,
    required this.name,
    required this.svgUrl,
    required this.pngUrl,
    required this.chain,
    required this.id,
    required this.collection,
    required this.dataType,
    required this.type,
    required this.category,
    required this.ts,
    required this.usdPrice,
    required this.isAshSupported,
  });

  factory TokenDataDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$TokenDataDocHydratedFromJson(json);

  static const toJsonFactory = _$TokenDataDocHydratedToJson;
  Map<String, dynamic> toJson() => _$TokenDataDocHydratedToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'ticker')
  final String ticker;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'svgUrl')
  final String svgUrl;
  @JsonKey(name: 'pngUrl')
  final String pngUrl;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainChainFromJson,
  )
  final enums.ActivityChain chain;
  static enums.ActivityChain activityChainChainFromJson(Object? value) =>
      activityChainFromJson(value, enums.ActivityChain.mvx);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.fungibletokenprofile);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String> category;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  @JsonKey(name: 'isAshSupported')
  final bool isAshSupported;
  static const fromJsonFactory = _$TokenDataDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TokenDataDocHydrated &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.decimals, decimals) ||
                const DeepCollectionEquality().equals(
                  other.decimals,
                  decimals,
                )) &&
            (identical(other.ticker, ticker) ||
                const DeepCollectionEquality().equals(other.ticker, ticker)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.svgUrl, svgUrl) ||
                const DeepCollectionEquality().equals(other.svgUrl, svgUrl)) &&
            (identical(other.pngUrl, pngUrl) ||
                const DeepCollectionEquality().equals(other.pngUrl, pngUrl)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.usdPrice, usdPrice) ||
                const DeepCollectionEquality().equals(
                  other.usdPrice,
                  usdPrice,
                )) &&
            (identical(other.isAshSupported, isAshSupported) ||
                const DeepCollectionEquality().equals(
                  other.isAshSupported,
                  isAshSupported,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(decimals) ^
      const DeepCollectionEquality().hash(ticker) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(svgUrl) ^
      const DeepCollectionEquality().hash(pngUrl) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(usdPrice) ^
      const DeepCollectionEquality().hash(isAshSupported) ^
      runtimeType.hashCode;
}

extension $TokenDataDocHydratedExtension on TokenDataDocHydrated {
  TokenDataDocHydrated copyWith({
    String? identifier,
    double? decimals,
    String? ticker,
    String? name,
    String? svgUrl,
    String? pngUrl,
    enums.ActivityChain? chain,
    String? id,
    String? collection,
    enums.TokenDataType? dataType,
    String? type,
    List<String>? category,
    double? ts,
    double? usdPrice,
    bool? isAshSupported,
  }) {
    return TokenDataDocHydrated(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      ticker: ticker ?? this.ticker,
      name: name ?? this.name,
      svgUrl: svgUrl ?? this.svgUrl,
      pngUrl: pngUrl ?? this.pngUrl,
      chain: chain ?? this.chain,
      id: id ?? this.id,
      collection: collection ?? this.collection,
      dataType: dataType ?? this.dataType,
      type: type ?? this.type,
      category: category ?? this.category,
      ts: ts ?? this.ts,
      usdPrice: usdPrice ?? this.usdPrice,
      isAshSupported: isAshSupported ?? this.isAshSupported,
    );
  }

  TokenDataDocHydrated copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<double>? decimals,
    Wrapped<String>? ticker,
    Wrapped<String>? name,
    Wrapped<String>? svgUrl,
    Wrapped<String>? pngUrl,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String>? id,
    Wrapped<String>? collection,
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? type,
    Wrapped<List<String>>? category,
    Wrapped<double>? ts,
    Wrapped<double>? usdPrice,
    Wrapped<bool>? isAshSupported,
  }) {
    return TokenDataDocHydrated(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      ticker: (ticker != null ? ticker.value : this.ticker),
      name: (name != null ? name.value : this.name),
      svgUrl: (svgUrl != null ? svgUrl.value : this.svgUrl),
      pngUrl: (pngUrl != null ? pngUrl.value : this.pngUrl),
      chain: (chain != null ? chain.value : this.chain),
      id: (id != null ? id.value : this.id),
      collection: (collection != null ? collection.value : this.collection),
      dataType: (dataType != null ? dataType.value : this.dataType),
      type: (type != null ? type.value : this.type),
      category: (category != null ? category.value : this.category),
      ts: (ts != null ? ts.value : this.ts),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
      isAshSupported: (isAshSupported != null
          ? isAshSupported.value
          : this.isAshSupported),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RateType {
  const RateType({
    required this.rateShort,
    required this.rate,
    required this.reverseRate,
    required this.reverseRateShort,
  });

  factory RateType.fromJson(Map<String, dynamic> json) =>
      _$RateTypeFromJson(json);

  static const toJsonFactory = _$RateTypeToJson;
  Map<String, dynamic> toJson() => _$RateTypeToJson(this);

  @JsonKey(name: 'rateShort')
  final double rateShort;
  @JsonKey(name: 'rate')
  final String rate;
  @JsonKey(name: 'reverseRate')
  final String reverseRate;
  @JsonKey(name: 'reverseRateShort')
  final double reverseRateShort;
  static const fromJsonFactory = _$RateTypeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RateType &&
            (identical(other.rateShort, rateShort) ||
                const DeepCollectionEquality().equals(
                  other.rateShort,
                  rateShort,
                )) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.reverseRate, reverseRate) ||
                const DeepCollectionEquality().equals(
                  other.reverseRate,
                  reverseRate,
                )) &&
            (identical(other.reverseRateShort, reverseRateShort) ||
                const DeepCollectionEquality().equals(
                  other.reverseRateShort,
                  reverseRateShort,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rateShort) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(reverseRate) ^
      const DeepCollectionEquality().hash(reverseRateShort) ^
      runtimeType.hashCode;
}

extension $RateTypeExtension on RateType {
  RateType copyWith({
    double? rateShort,
    String? rate,
    String? reverseRate,
    double? reverseRateShort,
  }) {
    return RateType(
      rateShort: rateShort ?? this.rateShort,
      rate: rate ?? this.rate,
      reverseRate: reverseRate ?? this.reverseRate,
      reverseRateShort: reverseRateShort ?? this.reverseRateShort,
    );
  }

  RateType copyWithWrapped({
    Wrapped<double>? rateShort,
    Wrapped<String>? rate,
    Wrapped<String>? reverseRate,
    Wrapped<double>? reverseRateShort,
  }) {
    return RateType(
      rateShort: (rateShort != null ? rateShort.value : this.rateShort),
      rate: (rate != null ? rate.value : this.rate),
      reverseRate: (reverseRate != null ? reverseRate.value : this.reverseRate),
      reverseRateShort: (reverseRateShort != null
          ? reverseRateShort.value
          : this.reverseRateShort),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class IMetrics {
  const IMetrics({
    required this.supply,
    required this.minted,
    required this.burned,
    required this.initialMinted,
    required this.recomputedSupply,
    required this.burnedShort,
    required this.initialMintedShort,
    required this.minterShort,
    required this.supplyShort,
    required this.transfersCount,
    required this.holdersCount,
    required this.rateInfo,
    required this.apr,
    this.apy,
    required this.totalStakedCount,
    required this.totalStakedCountUsd,
    required this.totalRewardsPaid,
    required this.totalRewardsPaidUsd,
    required this.uniqueStakersCount,
    required this.instantUnstake,
    required this.instantPendingUnstake,
    required this.totalWithdrawn,
    required this.serviceFee,
  });

  factory IMetrics.fromJson(Map<String, dynamic> json) =>
      _$IMetricsFromJson(json);

  static const toJsonFactory = _$IMetricsToJson;
  Map<String, dynamic> toJson() => _$IMetricsToJson(this);

  @JsonKey(name: 'supply')
  final String supply;
  @JsonKey(name: 'minted')
  final String minted;
  @JsonKey(name: 'burned')
  final String burned;
  @JsonKey(name: 'initialMinted')
  final String initialMinted;
  @JsonKey(name: 'recomputedSupply')
  final bool recomputedSupply;
  @JsonKey(name: 'burnedShort')
  final double burnedShort;
  @JsonKey(name: 'initialMintedShort')
  final double initialMintedShort;
  @JsonKey(name: 'minterShort')
  final double minterShort;
  @JsonKey(name: 'supplyShort')
  final double supplyShort;
  @JsonKey(name: 'transfersCount')
  final double transfersCount;
  @JsonKey(name: 'holdersCount')
  final double holdersCount;
  @JsonKey(name: 'rateInfo')
  final RateType rateInfo;
  @JsonKey(name: 'apr')
  final double apr;
  @JsonKey(name: 'apy')
  final double? apy;
  @JsonKey(name: 'totalStakedCount')
  final double totalStakedCount;
  @JsonKey(name: 'totalStakedCountUsd')
  final double totalStakedCountUsd;
  @JsonKey(name: 'totalRewardsPaid')
  final double totalRewardsPaid;
  @JsonKey(name: 'totalRewardsPaidUsd')
  final double totalRewardsPaidUsd;
  @JsonKey(name: 'uniqueStakersCount')
  final double uniqueStakersCount;
  @JsonKey(name: 'instantUnstake')
  final String instantUnstake;
  @JsonKey(name: 'instantPendingUnstake')
  final String instantPendingUnstake;
  @JsonKey(name: 'totalWithdrawn')
  final double totalWithdrawn;
  @JsonKey(name: 'serviceFee')
  final double serviceFee;
  static const fromJsonFactory = _$IMetricsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IMetrics &&
            (identical(other.supply, supply) ||
                const DeepCollectionEquality().equals(other.supply, supply)) &&
            (identical(other.minted, minted) ||
                const DeepCollectionEquality().equals(other.minted, minted)) &&
            (identical(other.burned, burned) ||
                const DeepCollectionEquality().equals(other.burned, burned)) &&
            (identical(other.initialMinted, initialMinted) ||
                const DeepCollectionEquality().equals(
                  other.initialMinted,
                  initialMinted,
                )) &&
            (identical(other.recomputedSupply, recomputedSupply) ||
                const DeepCollectionEquality().equals(
                  other.recomputedSupply,
                  recomputedSupply,
                )) &&
            (identical(other.burnedShort, burnedShort) ||
                const DeepCollectionEquality().equals(
                  other.burnedShort,
                  burnedShort,
                )) &&
            (identical(other.initialMintedShort, initialMintedShort) ||
                const DeepCollectionEquality().equals(
                  other.initialMintedShort,
                  initialMintedShort,
                )) &&
            (identical(other.minterShort, minterShort) ||
                const DeepCollectionEquality().equals(
                  other.minterShort,
                  minterShort,
                )) &&
            (identical(other.supplyShort, supplyShort) ||
                const DeepCollectionEquality().equals(
                  other.supplyShort,
                  supplyShort,
                )) &&
            (identical(other.transfersCount, transfersCount) ||
                const DeepCollectionEquality().equals(
                  other.transfersCount,
                  transfersCount,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.rateInfo, rateInfo) ||
                const DeepCollectionEquality().equals(
                  other.rateInfo,
                  rateInfo,
                )) &&
            (identical(other.apr, apr) ||
                const DeepCollectionEquality().equals(other.apr, apr)) &&
            (identical(other.apy, apy) ||
                const DeepCollectionEquality().equals(other.apy, apy)) &&
            (identical(other.totalStakedCount, totalStakedCount) ||
                const DeepCollectionEquality().equals(
                  other.totalStakedCount,
                  totalStakedCount,
                )) &&
            (identical(other.totalStakedCountUsd, totalStakedCountUsd) ||
                const DeepCollectionEquality().equals(
                  other.totalStakedCountUsd,
                  totalStakedCountUsd,
                )) &&
            (identical(other.totalRewardsPaid, totalRewardsPaid) ||
                const DeepCollectionEquality().equals(
                  other.totalRewardsPaid,
                  totalRewardsPaid,
                )) &&
            (identical(other.totalRewardsPaidUsd, totalRewardsPaidUsd) ||
                const DeepCollectionEquality().equals(
                  other.totalRewardsPaidUsd,
                  totalRewardsPaidUsd,
                )) &&
            (identical(other.uniqueStakersCount, uniqueStakersCount) ||
                const DeepCollectionEquality().equals(
                  other.uniqueStakersCount,
                  uniqueStakersCount,
                )) &&
            (identical(other.instantUnstake, instantUnstake) ||
                const DeepCollectionEquality().equals(
                  other.instantUnstake,
                  instantUnstake,
                )) &&
            (identical(other.instantPendingUnstake, instantPendingUnstake) ||
                const DeepCollectionEquality().equals(
                  other.instantPendingUnstake,
                  instantPendingUnstake,
                )) &&
            (identical(other.totalWithdrawn, totalWithdrawn) ||
                const DeepCollectionEquality().equals(
                  other.totalWithdrawn,
                  totalWithdrawn,
                )) &&
            (identical(other.serviceFee, serviceFee) ||
                const DeepCollectionEquality().equals(
                  other.serviceFee,
                  serviceFee,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supply) ^
      const DeepCollectionEquality().hash(minted) ^
      const DeepCollectionEquality().hash(burned) ^
      const DeepCollectionEquality().hash(initialMinted) ^
      const DeepCollectionEquality().hash(recomputedSupply) ^
      const DeepCollectionEquality().hash(burnedShort) ^
      const DeepCollectionEquality().hash(initialMintedShort) ^
      const DeepCollectionEquality().hash(minterShort) ^
      const DeepCollectionEquality().hash(supplyShort) ^
      const DeepCollectionEquality().hash(transfersCount) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(rateInfo) ^
      const DeepCollectionEquality().hash(apr) ^
      const DeepCollectionEquality().hash(apy) ^
      const DeepCollectionEquality().hash(totalStakedCount) ^
      const DeepCollectionEquality().hash(totalStakedCountUsd) ^
      const DeepCollectionEquality().hash(totalRewardsPaid) ^
      const DeepCollectionEquality().hash(totalRewardsPaidUsd) ^
      const DeepCollectionEquality().hash(uniqueStakersCount) ^
      const DeepCollectionEquality().hash(instantUnstake) ^
      const DeepCollectionEquality().hash(instantPendingUnstake) ^
      const DeepCollectionEquality().hash(totalWithdrawn) ^
      const DeepCollectionEquality().hash(serviceFee) ^
      runtimeType.hashCode;
}

extension $IMetricsExtension on IMetrics {
  IMetrics copyWith({
    String? supply,
    String? minted,
    String? burned,
    String? initialMinted,
    bool? recomputedSupply,
    double? burnedShort,
    double? initialMintedShort,
    double? minterShort,
    double? supplyShort,
    double? transfersCount,
    double? holdersCount,
    RateType? rateInfo,
    double? apr,
    double? apy,
    double? totalStakedCount,
    double? totalStakedCountUsd,
    double? totalRewardsPaid,
    double? totalRewardsPaidUsd,
    double? uniqueStakersCount,
    String? instantUnstake,
    String? instantPendingUnstake,
    double? totalWithdrawn,
    double? serviceFee,
  }) {
    return IMetrics(
      supply: supply ?? this.supply,
      minted: minted ?? this.minted,
      burned: burned ?? this.burned,
      initialMinted: initialMinted ?? this.initialMinted,
      recomputedSupply: recomputedSupply ?? this.recomputedSupply,
      burnedShort: burnedShort ?? this.burnedShort,
      initialMintedShort: initialMintedShort ?? this.initialMintedShort,
      minterShort: minterShort ?? this.minterShort,
      supplyShort: supplyShort ?? this.supplyShort,
      transfersCount: transfersCount ?? this.transfersCount,
      holdersCount: holdersCount ?? this.holdersCount,
      rateInfo: rateInfo ?? this.rateInfo,
      apr: apr ?? this.apr,
      apy: apy ?? this.apy,
      totalStakedCount: totalStakedCount ?? this.totalStakedCount,
      totalStakedCountUsd: totalStakedCountUsd ?? this.totalStakedCountUsd,
      totalRewardsPaid: totalRewardsPaid ?? this.totalRewardsPaid,
      totalRewardsPaidUsd: totalRewardsPaidUsd ?? this.totalRewardsPaidUsd,
      uniqueStakersCount: uniqueStakersCount ?? this.uniqueStakersCount,
      instantUnstake: instantUnstake ?? this.instantUnstake,
      instantPendingUnstake:
          instantPendingUnstake ?? this.instantPendingUnstake,
      totalWithdrawn: totalWithdrawn ?? this.totalWithdrawn,
      serviceFee: serviceFee ?? this.serviceFee,
    );
  }

  IMetrics copyWithWrapped({
    Wrapped<String>? supply,
    Wrapped<String>? minted,
    Wrapped<String>? burned,
    Wrapped<String>? initialMinted,
    Wrapped<bool>? recomputedSupply,
    Wrapped<double>? burnedShort,
    Wrapped<double>? initialMintedShort,
    Wrapped<double>? minterShort,
    Wrapped<double>? supplyShort,
    Wrapped<double>? transfersCount,
    Wrapped<double>? holdersCount,
    Wrapped<RateType>? rateInfo,
    Wrapped<double>? apr,
    Wrapped<double?>? apy,
    Wrapped<double>? totalStakedCount,
    Wrapped<double>? totalStakedCountUsd,
    Wrapped<double>? totalRewardsPaid,
    Wrapped<double>? totalRewardsPaidUsd,
    Wrapped<double>? uniqueStakersCount,
    Wrapped<String>? instantUnstake,
    Wrapped<String>? instantPendingUnstake,
    Wrapped<double>? totalWithdrawn,
    Wrapped<double>? serviceFee,
  }) {
    return IMetrics(
      supply: (supply != null ? supply.value : this.supply),
      minted: (minted != null ? minted.value : this.minted),
      burned: (burned != null ? burned.value : this.burned),
      initialMinted: (initialMinted != null
          ? initialMinted.value
          : this.initialMinted),
      recomputedSupply: (recomputedSupply != null
          ? recomputedSupply.value
          : this.recomputedSupply),
      burnedShort: (burnedShort != null ? burnedShort.value : this.burnedShort),
      initialMintedShort: (initialMintedShort != null
          ? initialMintedShort.value
          : this.initialMintedShort),
      minterShort: (minterShort != null ? minterShort.value : this.minterShort),
      supplyShort: (supplyShort != null ? supplyShort.value : this.supplyShort),
      transfersCount: (transfersCount != null
          ? transfersCount.value
          : this.transfersCount),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      rateInfo: (rateInfo != null ? rateInfo.value : this.rateInfo),
      apr: (apr != null ? apr.value : this.apr),
      apy: (apy != null ? apy.value : this.apy),
      totalStakedCount: (totalStakedCount != null
          ? totalStakedCount.value
          : this.totalStakedCount),
      totalStakedCountUsd: (totalStakedCountUsd != null
          ? totalStakedCountUsd.value
          : this.totalStakedCountUsd),
      totalRewardsPaid: (totalRewardsPaid != null
          ? totalRewardsPaid.value
          : this.totalRewardsPaid),
      totalRewardsPaidUsd: (totalRewardsPaidUsd != null
          ? totalRewardsPaidUsd.value
          : this.totalRewardsPaidUsd),
      uniqueStakersCount: (uniqueStakersCount != null
          ? uniqueStakersCount.value
          : this.uniqueStakersCount),
      instantUnstake: (instantUnstake != null
          ? instantUnstake.value
          : this.instantUnstake),
      instantPendingUnstake: (instantPendingUnstake != null
          ? instantPendingUnstake.value
          : this.instantPendingUnstake),
      totalWithdrawn: (totalWithdrawn != null
          ? totalWithdrawn.value
          : this.totalWithdrawn),
      serviceFee: (serviceFee != null ? serviceFee.value : this.serviceFee),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoInfo {
  const XoxnoInfo({
    required this.price,
    required this.marketCap,
    required this.fdv,
    required this.tradeVol,
    required this.supply,
    required this.burnedShort,
    required this.circulatingSupply,
    required this.holdersCount,
    required this.totalSupply,
    required this.idoPrice,
    required this.listingDate,
  });

  factory XoxnoInfo.fromJson(Map<String, dynamic> json) =>
      _$XoxnoInfoFromJson(json);

  static const toJsonFactory = _$XoxnoInfoToJson;
  Map<String, dynamic> toJson() => _$XoxnoInfoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'marketCap')
  final double marketCap;
  @JsonKey(name: 'fdv')
  final double fdv;
  @JsonKey(name: 'tradeVol')
  final double tradeVol;
  @JsonKey(name: 'supply')
  final double supply;
  @JsonKey(name: 'burnedShort')
  final double burnedShort;
  @JsonKey(name: 'circulatingSupply')
  final double circulatingSupply;
  @JsonKey(name: 'holdersCount')
  final double holdersCount;
  @JsonKey(name: 'totalSupply')
  final double totalSupply;
  @JsonKey(name: 'idoPrice')
  final double idoPrice;
  @JsonKey(name: 'listingDate')
  final DateTime listingDate;
  static const fromJsonFactory = _$XoxnoInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is XoxnoInfo &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.marketCap, marketCap) ||
                const DeepCollectionEquality().equals(
                  other.marketCap,
                  marketCap,
                )) &&
            (identical(other.fdv, fdv) ||
                const DeepCollectionEquality().equals(other.fdv, fdv)) &&
            (identical(other.tradeVol, tradeVol) ||
                const DeepCollectionEquality().equals(
                  other.tradeVol,
                  tradeVol,
                )) &&
            (identical(other.supply, supply) ||
                const DeepCollectionEquality().equals(other.supply, supply)) &&
            (identical(other.burnedShort, burnedShort) ||
                const DeepCollectionEquality().equals(
                  other.burnedShort,
                  burnedShort,
                )) &&
            (identical(other.circulatingSupply, circulatingSupply) ||
                const DeepCollectionEquality().equals(
                  other.circulatingSupply,
                  circulatingSupply,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.totalSupply, totalSupply) ||
                const DeepCollectionEquality().equals(
                  other.totalSupply,
                  totalSupply,
                )) &&
            (identical(other.idoPrice, idoPrice) ||
                const DeepCollectionEquality().equals(
                  other.idoPrice,
                  idoPrice,
                )) &&
            (identical(other.listingDate, listingDate) ||
                const DeepCollectionEquality().equals(
                  other.listingDate,
                  listingDate,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(marketCap) ^
      const DeepCollectionEquality().hash(fdv) ^
      const DeepCollectionEquality().hash(tradeVol) ^
      const DeepCollectionEquality().hash(supply) ^
      const DeepCollectionEquality().hash(burnedShort) ^
      const DeepCollectionEquality().hash(circulatingSupply) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(totalSupply) ^
      const DeepCollectionEquality().hash(idoPrice) ^
      const DeepCollectionEquality().hash(listingDate) ^
      runtimeType.hashCode;
}

extension $XoxnoInfoExtension on XoxnoInfo {
  XoxnoInfo copyWith({
    double? price,
    double? marketCap,
    double? fdv,
    double? tradeVol,
    double? supply,
    double? burnedShort,
    double? circulatingSupply,
    double? holdersCount,
    double? totalSupply,
    double? idoPrice,
    DateTime? listingDate,
  }) {
    return XoxnoInfo(
      price: price ?? this.price,
      marketCap: marketCap ?? this.marketCap,
      fdv: fdv ?? this.fdv,
      tradeVol: tradeVol ?? this.tradeVol,
      supply: supply ?? this.supply,
      burnedShort: burnedShort ?? this.burnedShort,
      circulatingSupply: circulatingSupply ?? this.circulatingSupply,
      holdersCount: holdersCount ?? this.holdersCount,
      totalSupply: totalSupply ?? this.totalSupply,
      idoPrice: idoPrice ?? this.idoPrice,
      listingDate: listingDate ?? this.listingDate,
    );
  }

  XoxnoInfo copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? marketCap,
    Wrapped<double>? fdv,
    Wrapped<double>? tradeVol,
    Wrapped<double>? supply,
    Wrapped<double>? burnedShort,
    Wrapped<double>? circulatingSupply,
    Wrapped<double>? holdersCount,
    Wrapped<double>? totalSupply,
    Wrapped<double>? idoPrice,
    Wrapped<DateTime>? listingDate,
  }) {
    return XoxnoInfo(
      price: (price != null ? price.value : this.price),
      marketCap: (marketCap != null ? marketCap.value : this.marketCap),
      fdv: (fdv != null ? fdv.value : this.fdv),
      tradeVol: (tradeVol != null ? tradeVol.value : this.tradeVol),
      supply: (supply != null ? supply.value : this.supply),
      burnedShort: (burnedShort != null ? burnedShort.value : this.burnedShort),
      circulatingSupply: (circulatingSupply != null
          ? circulatingSupply.value
          : this.circulatingSupply),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      totalSupply: (totalSupply != null ? totalSupply.value : this.totalSupply),
      idoPrice: (idoPrice != null ? idoPrice.value : this.idoPrice),
      listingDate: (listingDate != null ? listingDate.value : this.listingDate),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoLiquidStatsDto {
  const XoxnoLiquidStatsDto({
    required this.participants,
    required this.totalRewards,
    required this.totalStaked,
    required this.yearlyAPR,
    this.apy,
    required this.totalRewardsUsdValue,
    required this.totalStakedUsdValue,
    required this.rateInfo,
    required this.serviceFee,
    required this.instantUnstake,
    required this.instantPendingUnstake,
  });

  factory XoxnoLiquidStatsDto.fromJson(Map<String, dynamic> json) =>
      _$XoxnoLiquidStatsDtoFromJson(json);

  static const toJsonFactory = _$XoxnoLiquidStatsDtoToJson;
  Map<String, dynamic> toJson() => _$XoxnoLiquidStatsDtoToJson(this);

  @JsonKey(name: 'participants')
  final double participants;
  @JsonKey(name: 'totalRewards')
  final double totalRewards;
  @JsonKey(name: 'totalStaked')
  final double totalStaked;
  @JsonKey(name: 'yearlyAPR')
  final double yearlyAPR;
  @JsonKey(name: 'apy')
  final double? apy;
  @JsonKey(name: 'totalRewardsUsdValue')
  final double totalRewardsUsdValue;
  @JsonKey(name: 'totalStakedUsdValue')
  final double totalStakedUsdValue;
  @JsonKey(name: 'rateInfo')
  final RateType rateInfo;
  @JsonKey(name: 'serviceFee')
  final double serviceFee;
  @JsonKey(name: 'instantUnstake')
  final String instantUnstake;
  @JsonKey(name: 'instantPendingUnstake')
  final String instantPendingUnstake;
  static const fromJsonFactory = _$XoxnoLiquidStatsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is XoxnoLiquidStatsDto &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality().equals(
                  other.participants,
                  participants,
                )) &&
            (identical(other.totalRewards, totalRewards) ||
                const DeepCollectionEquality().equals(
                  other.totalRewards,
                  totalRewards,
                )) &&
            (identical(other.totalStaked, totalStaked) ||
                const DeepCollectionEquality().equals(
                  other.totalStaked,
                  totalStaked,
                )) &&
            (identical(other.yearlyAPR, yearlyAPR) ||
                const DeepCollectionEquality().equals(
                  other.yearlyAPR,
                  yearlyAPR,
                )) &&
            (identical(other.apy, apy) ||
                const DeepCollectionEquality().equals(other.apy, apy)) &&
            (identical(other.totalRewardsUsdValue, totalRewardsUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.totalRewardsUsdValue,
                  totalRewardsUsdValue,
                )) &&
            (identical(other.totalStakedUsdValue, totalStakedUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.totalStakedUsdValue,
                  totalStakedUsdValue,
                )) &&
            (identical(other.rateInfo, rateInfo) ||
                const DeepCollectionEquality().equals(
                  other.rateInfo,
                  rateInfo,
                )) &&
            (identical(other.serviceFee, serviceFee) ||
                const DeepCollectionEquality().equals(
                  other.serviceFee,
                  serviceFee,
                )) &&
            (identical(other.instantUnstake, instantUnstake) ||
                const DeepCollectionEquality().equals(
                  other.instantUnstake,
                  instantUnstake,
                )) &&
            (identical(other.instantPendingUnstake, instantPendingUnstake) ||
                const DeepCollectionEquality().equals(
                  other.instantPendingUnstake,
                  instantPendingUnstake,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(participants) ^
      const DeepCollectionEquality().hash(totalRewards) ^
      const DeepCollectionEquality().hash(totalStaked) ^
      const DeepCollectionEquality().hash(yearlyAPR) ^
      const DeepCollectionEquality().hash(apy) ^
      const DeepCollectionEquality().hash(totalRewardsUsdValue) ^
      const DeepCollectionEquality().hash(totalStakedUsdValue) ^
      const DeepCollectionEquality().hash(rateInfo) ^
      const DeepCollectionEquality().hash(serviceFee) ^
      const DeepCollectionEquality().hash(instantUnstake) ^
      const DeepCollectionEquality().hash(instantPendingUnstake) ^
      runtimeType.hashCode;
}

extension $XoxnoLiquidStatsDtoExtension on XoxnoLiquidStatsDto {
  XoxnoLiquidStatsDto copyWith({
    double? participants,
    double? totalRewards,
    double? totalStaked,
    double? yearlyAPR,
    double? apy,
    double? totalRewardsUsdValue,
    double? totalStakedUsdValue,
    RateType? rateInfo,
    double? serviceFee,
    String? instantUnstake,
    String? instantPendingUnstake,
  }) {
    return XoxnoLiquidStatsDto(
      participants: participants ?? this.participants,
      totalRewards: totalRewards ?? this.totalRewards,
      totalStaked: totalStaked ?? this.totalStaked,
      yearlyAPR: yearlyAPR ?? this.yearlyAPR,
      apy: apy ?? this.apy,
      totalRewardsUsdValue: totalRewardsUsdValue ?? this.totalRewardsUsdValue,
      totalStakedUsdValue: totalStakedUsdValue ?? this.totalStakedUsdValue,
      rateInfo: rateInfo ?? this.rateInfo,
      serviceFee: serviceFee ?? this.serviceFee,
      instantUnstake: instantUnstake ?? this.instantUnstake,
      instantPendingUnstake:
          instantPendingUnstake ?? this.instantPendingUnstake,
    );
  }

  XoxnoLiquidStatsDto copyWithWrapped({
    Wrapped<double>? participants,
    Wrapped<double>? totalRewards,
    Wrapped<double>? totalStaked,
    Wrapped<double>? yearlyAPR,
    Wrapped<double?>? apy,
    Wrapped<double>? totalRewardsUsdValue,
    Wrapped<double>? totalStakedUsdValue,
    Wrapped<RateType>? rateInfo,
    Wrapped<double>? serviceFee,
    Wrapped<String>? instantUnstake,
    Wrapped<String>? instantPendingUnstake,
  }) {
    return XoxnoLiquidStatsDto(
      participants: (participants != null
          ? participants.value
          : this.participants),
      totalRewards: (totalRewards != null
          ? totalRewards.value
          : this.totalRewards),
      totalStaked: (totalStaked != null ? totalStaked.value : this.totalStaked),
      yearlyAPR: (yearlyAPR != null ? yearlyAPR.value : this.yearlyAPR),
      apy: (apy != null ? apy.value : this.apy),
      totalRewardsUsdValue: (totalRewardsUsdValue != null
          ? totalRewardsUsdValue.value
          : this.totalRewardsUsdValue),
      totalStakedUsdValue: (totalStakedUsdValue != null
          ? totalStakedUsdValue.value
          : this.totalStakedUsdValue),
      rateInfo: (rateInfo != null ? rateInfo.value : this.rateInfo),
      serviceFee: (serviceFee != null ? serviceFee.value : this.serviceFee),
      instantUnstake: (instantUnstake != null
          ? instantUnstake.value
          : this.instantUnstake),
      instantPendingUnstake: (instantPendingUnstake != null
          ? instantPendingUnstake.value
          : this.instantPendingUnstake),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsMarketplaceUniqueUsers {
  const AnalyticsMarketplaceUniqueUsers({
    required this.day,
    required this.uniqueUsers,
    required this.uniqueBuyers,
    required this.uniqueSellers,
  });

  factory AnalyticsMarketplaceUniqueUsers.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsMarketplaceUniqueUsersFromJson(json);

  static const toJsonFactory = _$AnalyticsMarketplaceUniqueUsersToJson;
  Map<String, dynamic> toJson() =>
      _$AnalyticsMarketplaceUniqueUsersToJson(this);

  @JsonKey(name: 'Day')
  final DateTime day;
  @JsonKey(name: 'UniqueUsers')
  final double uniqueUsers;
  @JsonKey(name: 'UniqueBuyers')
  final double uniqueBuyers;
  @JsonKey(name: 'UniqueSellers')
  final double uniqueSellers;
  static const fromJsonFactory = _$AnalyticsMarketplaceUniqueUsersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsMarketplaceUniqueUsers &&
            (identical(other.day, day) ||
                const DeepCollectionEquality().equals(other.day, day)) &&
            (identical(other.uniqueUsers, uniqueUsers) ||
                const DeepCollectionEquality().equals(
                  other.uniqueUsers,
                  uniqueUsers,
                )) &&
            (identical(other.uniqueBuyers, uniqueBuyers) ||
                const DeepCollectionEquality().equals(
                  other.uniqueBuyers,
                  uniqueBuyers,
                )) &&
            (identical(other.uniqueSellers, uniqueSellers) ||
                const DeepCollectionEquality().equals(
                  other.uniqueSellers,
                  uniqueSellers,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(day) ^
      const DeepCollectionEquality().hash(uniqueUsers) ^
      const DeepCollectionEquality().hash(uniqueBuyers) ^
      const DeepCollectionEquality().hash(uniqueSellers) ^
      runtimeType.hashCode;
}

extension $AnalyticsMarketplaceUniqueUsersExtension
    on AnalyticsMarketplaceUniqueUsers {
  AnalyticsMarketplaceUniqueUsers copyWith({
    DateTime? day,
    double? uniqueUsers,
    double? uniqueBuyers,
    double? uniqueSellers,
  }) {
    return AnalyticsMarketplaceUniqueUsers(
      day: day ?? this.day,
      uniqueUsers: uniqueUsers ?? this.uniqueUsers,
      uniqueBuyers: uniqueBuyers ?? this.uniqueBuyers,
      uniqueSellers: uniqueSellers ?? this.uniqueSellers,
    );
  }

  AnalyticsMarketplaceUniqueUsers copyWithWrapped({
    Wrapped<DateTime>? day,
    Wrapped<double>? uniqueUsers,
    Wrapped<double>? uniqueBuyers,
    Wrapped<double>? uniqueSellers,
  }) {
    return AnalyticsMarketplaceUniqueUsers(
      day: (day != null ? day.value : this.day),
      uniqueUsers: (uniqueUsers != null ? uniqueUsers.value : this.uniqueUsers),
      uniqueBuyers: (uniqueBuyers != null
          ? uniqueBuyers.value
          : this.uniqueBuyers),
      uniqueSellers: (uniqueSellers != null
          ? uniqueSellers.value
          : this.uniqueSellers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ProtocolAprType {
  const ProtocolAprType({required this.apr, this.apy});

  factory ProtocolAprType.fromJson(Map<String, dynamic> json) =>
      _$ProtocolAprTypeFromJson(json);

  static const toJsonFactory = _$ProtocolAprTypeToJson;
  Map<String, dynamic> toJson() => _$ProtocolAprTypeToJson(this);

  @JsonKey(name: 'apr')
  final double apr;
  @JsonKey(name: 'apy')
  final double? apy;
  static const fromJsonFactory = _$ProtocolAprTypeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProtocolAprType &&
            (identical(other.apr, apr) ||
                const DeepCollectionEquality().equals(other.apr, apr)) &&
            (identical(other.apy, apy) ||
                const DeepCollectionEquality().equals(other.apy, apy)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apr) ^
      const DeepCollectionEquality().hash(apy) ^
      runtimeType.hashCode;
}

extension $ProtocolAprTypeExtension on ProtocolAprType {
  ProtocolAprType copyWith({double? apr, double? apy}) {
    return ProtocolAprType(apr: apr ?? this.apr, apy: apy ?? this.apy);
  }

  ProtocolAprType copyWithWrapped({
    Wrapped<double>? apr,
    Wrapped<double?>? apy,
  }) {
    return ProtocolAprType(
      apr: (apr != null ? apr.value : this.apr),
      apy: (apy != null ? apy.value : this.apy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ProviderDto {
  const ProviderDto({
    required this.address,
    this.profile,
    this.name,
    this.delegationCap,
    this.nodes,
    this.apr,
    this.identity,
    required this.totalStaked,
    required this.protocolStakedAmount,
  });

  factory ProviderDto.fromJson(Map<String, dynamic> json) =>
      _$ProviderDtoFromJson(json);

  static const toJsonFactory = _$ProviderDtoToJson;
  Map<String, dynamic> toJson() => _$ProviderDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'delegationCap')
  final double? delegationCap;
  @JsonKey(name: 'nodes')
  final double? nodes;
  @JsonKey(name: 'apr')
  final double? apr;
  @JsonKey(name: 'identity')
  final String? identity;
  @JsonKey(name: 'totalStaked')
  final double totalStaked;
  @JsonKey(name: 'protocolStakedAmount')
  final double protocolStakedAmount;
  static const fromJsonFactory = _$ProviderDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProviderDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.delegationCap, delegationCap) ||
                const DeepCollectionEquality().equals(
                  other.delegationCap,
                  delegationCap,
                )) &&
            (identical(other.nodes, nodes) ||
                const DeepCollectionEquality().equals(other.nodes, nodes)) &&
            (identical(other.apr, apr) ||
                const DeepCollectionEquality().equals(other.apr, apr)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality().equals(
                  other.identity,
                  identity,
                )) &&
            (identical(other.totalStaked, totalStaked) ||
                const DeepCollectionEquality().equals(
                  other.totalStaked,
                  totalStaked,
                )) &&
            (identical(other.protocolStakedAmount, protocolStakedAmount) ||
                const DeepCollectionEquality().equals(
                  other.protocolStakedAmount,
                  protocolStakedAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(delegationCap) ^
      const DeepCollectionEquality().hash(nodes) ^
      const DeepCollectionEquality().hash(apr) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(totalStaked) ^
      const DeepCollectionEquality().hash(protocolStakedAmount) ^
      runtimeType.hashCode;
}

extension $ProviderDtoExtension on ProviderDto {
  ProviderDto copyWith({
    String? address,
    String? profile,
    String? name,
    double? delegationCap,
    double? nodes,
    double? apr,
    String? identity,
    double? totalStaked,
    double? protocolStakedAmount,
  }) {
    return ProviderDto(
      address: address ?? this.address,
      profile: profile ?? this.profile,
      name: name ?? this.name,
      delegationCap: delegationCap ?? this.delegationCap,
      nodes: nodes ?? this.nodes,
      apr: apr ?? this.apr,
      identity: identity ?? this.identity,
      totalStaked: totalStaked ?? this.totalStaked,
      protocolStakedAmount: protocolStakedAmount ?? this.protocolStakedAmount,
    );
  }

  ProviderDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String?>? profile,
    Wrapped<String?>? name,
    Wrapped<double?>? delegationCap,
    Wrapped<double?>? nodes,
    Wrapped<double?>? apr,
    Wrapped<String?>? identity,
    Wrapped<double>? totalStaked,
    Wrapped<double>? protocolStakedAmount,
  }) {
    return ProviderDto(
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
      name: (name != null ? name.value : this.name),
      delegationCap: (delegationCap != null
          ? delegationCap.value
          : this.delegationCap),
      nodes: (nodes != null ? nodes.value : this.nodes),
      apr: (apr != null ? apr.value : this.apr),
      identity: (identity != null ? identity.value : this.identity),
      totalStaked: (totalStaked != null ? totalStaked.value : this.totalStaked),
      protocolStakedAmount: (protocolStakedAmount != null
          ? protocolStakedAmount.value
          : this.protocolStakedAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DelegationDataOutput {
  const DelegationDataOutput({
    required this.address,
    required this.contract,
    required this.activeStake,
    required this.activeStakeShort,
    required this.unDelegateInfo,
    required this.claimableRewards,
    required this.claimableRewardsShort,
    required this.totalUnbondEligible,
  });

  factory DelegationDataOutput.fromJson(Map<String, dynamic> json) =>
      _$DelegationDataOutputFromJson(json);

  static const toJsonFactory = _$DelegationDataOutputToJson;
  Map<String, dynamic> toJson() => _$DelegationDataOutputToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'contract')
  final String contract;
  @JsonKey(name: 'activeStake')
  final String activeStake;
  @JsonKey(name: 'activeStakeShort')
  final double activeStakeShort;
  @JsonKey(name: 'unDelegateInfo', defaultValue: <List<Object?>>[])
  final List<List<Object?>> unDelegateInfo;
  @JsonKey(name: 'claimableRewards')
  final double claimableRewards;
  @JsonKey(name: 'claimableRewardsShort')
  final double claimableRewardsShort;
  @JsonKey(name: 'totalUnbondEligible')
  final String totalUnbondEligible;
  static const fromJsonFactory = _$DelegationDataOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DelegationDataOutput &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.contract, contract) ||
                const DeepCollectionEquality().equals(
                  other.contract,
                  contract,
                )) &&
            (identical(other.activeStake, activeStake) ||
                const DeepCollectionEquality().equals(
                  other.activeStake,
                  activeStake,
                )) &&
            (identical(other.activeStakeShort, activeStakeShort) ||
                const DeepCollectionEquality().equals(
                  other.activeStakeShort,
                  activeStakeShort,
                )) &&
            (identical(other.unDelegateInfo, unDelegateInfo) ||
                const DeepCollectionEquality().equals(
                  other.unDelegateInfo,
                  unDelegateInfo,
                )) &&
            (identical(other.claimableRewards, claimableRewards) ||
                const DeepCollectionEquality().equals(
                  other.claimableRewards,
                  claimableRewards,
                )) &&
            (identical(other.claimableRewardsShort, claimableRewardsShort) ||
                const DeepCollectionEquality().equals(
                  other.claimableRewardsShort,
                  claimableRewardsShort,
                )) &&
            (identical(other.totalUnbondEligible, totalUnbondEligible) ||
                const DeepCollectionEquality().equals(
                  other.totalUnbondEligible,
                  totalUnbondEligible,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(contract) ^
      const DeepCollectionEquality().hash(activeStake) ^
      const DeepCollectionEquality().hash(activeStakeShort) ^
      const DeepCollectionEquality().hash(unDelegateInfo) ^
      const DeepCollectionEquality().hash(claimableRewards) ^
      const DeepCollectionEquality().hash(claimableRewardsShort) ^
      const DeepCollectionEquality().hash(totalUnbondEligible) ^
      runtimeType.hashCode;
}

extension $DelegationDataOutputExtension on DelegationDataOutput {
  DelegationDataOutput copyWith({
    String? address,
    String? contract,
    String? activeStake,
    double? activeStakeShort,
    List<List<Object?>>? unDelegateInfo,
    double? claimableRewards,
    double? claimableRewardsShort,
    String? totalUnbondEligible,
  }) {
    return DelegationDataOutput(
      address: address ?? this.address,
      contract: contract ?? this.contract,
      activeStake: activeStake ?? this.activeStake,
      activeStakeShort: activeStakeShort ?? this.activeStakeShort,
      unDelegateInfo: unDelegateInfo ?? this.unDelegateInfo,
      claimableRewards: claimableRewards ?? this.claimableRewards,
      claimableRewardsShort:
          claimableRewardsShort ?? this.claimableRewardsShort,
      totalUnbondEligible: totalUnbondEligible ?? this.totalUnbondEligible,
    );
  }

  DelegationDataOutput copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? contract,
    Wrapped<String>? activeStake,
    Wrapped<double>? activeStakeShort,
    Wrapped<List<List<Object?>>>? unDelegateInfo,
    Wrapped<double>? claimableRewards,
    Wrapped<double>? claimableRewardsShort,
    Wrapped<String>? totalUnbondEligible,
  }) {
    return DelegationDataOutput(
      address: (address != null ? address.value : this.address),
      contract: (contract != null ? contract.value : this.contract),
      activeStake: (activeStake != null ? activeStake.value : this.activeStake),
      activeStakeShort: (activeStakeShort != null
          ? activeStakeShort.value
          : this.activeStakeShort),
      unDelegateInfo: (unDelegateInfo != null
          ? unDelegateInfo.value
          : this.unDelegateInfo),
      claimableRewards: (claimableRewards != null
          ? claimableRewards.value
          : this.claimableRewards),
      claimableRewardsShort: (claimableRewardsShort != null
          ? claimableRewardsShort.value
          : this.claimableRewardsShort),
      totalUnbondEligible: (totalUnbondEligible != null
          ? totalUnbondEligible.value
          : this.totalUnbondEligible),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SwapDto {
  const SwapDto({
    required this.poolId,
    required this.assetInIndex,
    required this.assetOutIndex,
    required this.amount,
    required this.returnAmount,
    required this.assetIn,
    required this.assetOut,
    required this.functionName,
    required this.arguments,
  });

  factory SwapDto.fromJson(Map<String, dynamic> json) =>
      _$SwapDtoFromJson(json);

  static const toJsonFactory = _$SwapDtoToJson;
  Map<String, dynamic> toJson() => _$SwapDtoToJson(this);

  @JsonKey(name: 'poolId')
  final String poolId;
  @JsonKey(name: 'assetInIndex')
  final double assetInIndex;
  @JsonKey(name: 'assetOutIndex')
  final double assetOutIndex;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'returnAmount')
  final String returnAmount;
  @JsonKey(name: 'assetIn')
  final String assetIn;
  @JsonKey(name: 'assetOut')
  final String assetOut;
  @JsonKey(name: 'functionName')
  final String functionName;
  @JsonKey(name: 'arguments', defaultValue: <List<Object?>>[])
  final List<List<Object?>> arguments;
  static const fromJsonFactory = _$SwapDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SwapDto &&
            (identical(other.poolId, poolId) ||
                const DeepCollectionEquality().equals(other.poolId, poolId)) &&
            (identical(other.assetInIndex, assetInIndex) ||
                const DeepCollectionEquality().equals(
                  other.assetInIndex,
                  assetInIndex,
                )) &&
            (identical(other.assetOutIndex, assetOutIndex) ||
                const DeepCollectionEquality().equals(
                  other.assetOutIndex,
                  assetOutIndex,
                )) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.returnAmount, returnAmount) ||
                const DeepCollectionEquality().equals(
                  other.returnAmount,
                  returnAmount,
                )) &&
            (identical(other.assetIn, assetIn) ||
                const DeepCollectionEquality().equals(
                  other.assetIn,
                  assetIn,
                )) &&
            (identical(other.assetOut, assetOut) ||
                const DeepCollectionEquality().equals(
                  other.assetOut,
                  assetOut,
                )) &&
            (identical(other.functionName, functionName) ||
                const DeepCollectionEquality().equals(
                  other.functionName,
                  functionName,
                )) &&
            (identical(other.arguments, arguments) ||
                const DeepCollectionEquality().equals(
                  other.arguments,
                  arguments,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(poolId) ^
      const DeepCollectionEquality().hash(assetInIndex) ^
      const DeepCollectionEquality().hash(assetOutIndex) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(returnAmount) ^
      const DeepCollectionEquality().hash(assetIn) ^
      const DeepCollectionEquality().hash(assetOut) ^
      const DeepCollectionEquality().hash(functionName) ^
      const DeepCollectionEquality().hash(arguments) ^
      runtimeType.hashCode;
}

extension $SwapDtoExtension on SwapDto {
  SwapDto copyWith({
    String? poolId,
    double? assetInIndex,
    double? assetOutIndex,
    String? amount,
    String? returnAmount,
    String? assetIn,
    String? assetOut,
    String? functionName,
    List<List<Object?>>? arguments,
  }) {
    return SwapDto(
      poolId: poolId ?? this.poolId,
      assetInIndex: assetInIndex ?? this.assetInIndex,
      assetOutIndex: assetOutIndex ?? this.assetOutIndex,
      amount: amount ?? this.amount,
      returnAmount: returnAmount ?? this.returnAmount,
      assetIn: assetIn ?? this.assetIn,
      assetOut: assetOut ?? this.assetOut,
      functionName: functionName ?? this.functionName,
      arguments: arguments ?? this.arguments,
    );
  }

  SwapDto copyWithWrapped({
    Wrapped<String>? poolId,
    Wrapped<double>? assetInIndex,
    Wrapped<double>? assetOutIndex,
    Wrapped<String>? amount,
    Wrapped<String>? returnAmount,
    Wrapped<String>? assetIn,
    Wrapped<String>? assetOut,
    Wrapped<String>? functionName,
    Wrapped<List<List<Object?>>>? arguments,
  }) {
    return SwapDto(
      poolId: (poolId != null ? poolId.value : this.poolId),
      assetInIndex: (assetInIndex != null
          ? assetInIndex.value
          : this.assetInIndex),
      assetOutIndex: (assetOutIndex != null
          ? assetOutIndex.value
          : this.assetOutIndex),
      amount: (amount != null ? amount.value : this.amount),
      returnAmount: (returnAmount != null
          ? returnAmount.value
          : this.returnAmount),
      assetIn: (assetIn != null ? assetIn.value : this.assetIn),
      assetOut: (assetOut != null ? assetOut.value : this.assetOut),
      functionName: (functionName != null
          ? functionName.value
          : this.functionName),
      arguments: (arguments != null ? arguments.value : this.arguments),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AshTokenDto {
  const AshTokenDto({required this.address, required this.decimal});

  factory AshTokenDto.fromJson(Map<String, dynamic> json) =>
      _$AshTokenDtoFromJson(json);

  static const toJsonFactory = _$AshTokenDtoToJson;
  Map<String, dynamic> toJson() => _$AshTokenDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'decimal')
  final double decimal;
  static const fromJsonFactory = _$AshTokenDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AshTokenDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.decimal, decimal) ||
                const DeepCollectionEquality().equals(other.decimal, decimal)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(decimal) ^
      runtimeType.hashCode;
}

extension $AshTokenDtoExtension on AshTokenDto {
  AshTokenDto copyWith({String? address, double? decimal}) {
    return AshTokenDto(
      address: address ?? this.address,
      decimal: decimal ?? this.decimal,
    );
  }

  AshTokenDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? decimal,
  }) {
    return AshTokenDto(
      address: (address != null ? address.value : this.address),
      decimal: (decimal != null ? decimal.value : this.decimal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PoolDto {
  const PoolDto({required this.allTokens, required this.type});

  factory PoolDto.fromJson(Map<String, dynamic> json) =>
      _$PoolDtoFromJson(json);

  static const toJsonFactory = _$PoolDtoToJson;
  Map<String, dynamic> toJson() => _$PoolDtoToJson(this);

  @JsonKey(name: 'allTokens', defaultValue: <AshTokenDto>[])
  final List<AshTokenDto> allTokens;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$PoolDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PoolDto &&
            (identical(other.allTokens, allTokens) ||
                const DeepCollectionEquality().equals(
                  other.allTokens,
                  allTokens,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(allTokens) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $PoolDtoExtension on PoolDto {
  PoolDto copyWith({List<AshTokenDto>? allTokens, String? type}) {
    return PoolDto(
      allTokens: allTokens ?? this.allTokens,
      type: type ?? this.type,
    );
  }

  PoolDto copyWithWrapped({
    Wrapped<List<AshTokenDto>>? allTokens,
    Wrapped<String>? type,
  }) {
    return PoolDto(
      allTokens: (allTokens != null ? allTokens.value : this.allTokens),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HopDto {
  const HopDto({
    required this.poolId,
    required this.pool,
    required this.tokenIn,
    required this.tokenInAmount,
    required this.tokenOut,
    required this.tokenOutAmount,
  });

  factory HopDto.fromJson(Map<String, dynamic> json) => _$HopDtoFromJson(json);

  static const toJsonFactory = _$HopDtoToJson;
  Map<String, dynamic> toJson() => _$HopDtoToJson(this);

  @JsonKey(name: 'poolId')
  final String poolId;
  @JsonKey(name: 'pool')
  final PoolDto pool;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenInAmount')
  final String tokenInAmount;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'tokenOutAmount')
  final String tokenOutAmount;
  static const fromJsonFactory = _$HopDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HopDto &&
            (identical(other.poolId, poolId) ||
                const DeepCollectionEquality().equals(other.poolId, poolId)) &&
            (identical(other.pool, pool) ||
                const DeepCollectionEquality().equals(other.pool, pool)) &&
            (identical(other.tokenIn, tokenIn) ||
                const DeepCollectionEquality().equals(
                  other.tokenIn,
                  tokenIn,
                )) &&
            (identical(other.tokenInAmount, tokenInAmount) ||
                const DeepCollectionEquality().equals(
                  other.tokenInAmount,
                  tokenInAmount,
                )) &&
            (identical(other.tokenOut, tokenOut) ||
                const DeepCollectionEquality().equals(
                  other.tokenOut,
                  tokenOut,
                )) &&
            (identical(other.tokenOutAmount, tokenOutAmount) ||
                const DeepCollectionEquality().equals(
                  other.tokenOutAmount,
                  tokenOutAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(poolId) ^
      const DeepCollectionEquality().hash(pool) ^
      const DeepCollectionEquality().hash(tokenIn) ^
      const DeepCollectionEquality().hash(tokenInAmount) ^
      const DeepCollectionEquality().hash(tokenOut) ^
      const DeepCollectionEquality().hash(tokenOutAmount) ^
      runtimeType.hashCode;
}

extension $HopDtoExtension on HopDto {
  HopDto copyWith({
    String? poolId,
    PoolDto? pool,
    String? tokenIn,
    String? tokenInAmount,
    String? tokenOut,
    String? tokenOutAmount,
  }) {
    return HopDto(
      poolId: poolId ?? this.poolId,
      pool: pool ?? this.pool,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenInAmount: tokenInAmount ?? this.tokenInAmount,
      tokenOut: tokenOut ?? this.tokenOut,
      tokenOutAmount: tokenOutAmount ?? this.tokenOutAmount,
    );
  }

  HopDto copyWithWrapped({
    Wrapped<String>? poolId,
    Wrapped<PoolDto>? pool,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenInAmount,
    Wrapped<String>? tokenOut,
    Wrapped<String>? tokenOutAmount,
  }) {
    return HopDto(
      poolId: (poolId != null ? poolId.value : this.poolId),
      pool: (pool != null ? pool.value : this.pool),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenInAmount: (tokenInAmount != null
          ? tokenInAmount.value
          : this.tokenInAmount),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      tokenOutAmount: (tokenOutAmount != null
          ? tokenOutAmount.value
          : this.tokenOutAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RouteDto {
  const RouteDto({
    required this.hops,
    required this.tokenIn,
    required this.tokenInAmount,
    required this.tokenOut,
    required this.tokenOutAmount,
  });

  factory RouteDto.fromJson(Map<String, dynamic> json) =>
      _$RouteDtoFromJson(json);

  static const toJsonFactory = _$RouteDtoToJson;
  Map<String, dynamic> toJson() => _$RouteDtoToJson(this);

  @JsonKey(name: 'hops', defaultValue: <HopDto>[])
  final List<HopDto> hops;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenInAmount')
  final String tokenInAmount;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'tokenOutAmount')
  final String tokenOutAmount;
  static const fromJsonFactory = _$RouteDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RouteDto &&
            (identical(other.hops, hops) ||
                const DeepCollectionEquality().equals(other.hops, hops)) &&
            (identical(other.tokenIn, tokenIn) ||
                const DeepCollectionEquality().equals(
                  other.tokenIn,
                  tokenIn,
                )) &&
            (identical(other.tokenInAmount, tokenInAmount) ||
                const DeepCollectionEquality().equals(
                  other.tokenInAmount,
                  tokenInAmount,
                )) &&
            (identical(other.tokenOut, tokenOut) ||
                const DeepCollectionEquality().equals(
                  other.tokenOut,
                  tokenOut,
                )) &&
            (identical(other.tokenOutAmount, tokenOutAmount) ||
                const DeepCollectionEquality().equals(
                  other.tokenOutAmount,
                  tokenOutAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hops) ^
      const DeepCollectionEquality().hash(tokenIn) ^
      const DeepCollectionEquality().hash(tokenInAmount) ^
      const DeepCollectionEquality().hash(tokenOut) ^
      const DeepCollectionEquality().hash(tokenOutAmount) ^
      runtimeType.hashCode;
}

extension $RouteDtoExtension on RouteDto {
  RouteDto copyWith({
    List<HopDto>? hops,
    String? tokenIn,
    String? tokenInAmount,
    String? tokenOut,
    String? tokenOutAmount,
  }) {
    return RouteDto(
      hops: hops ?? this.hops,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenInAmount: tokenInAmount ?? this.tokenInAmount,
      tokenOut: tokenOut ?? this.tokenOut,
      tokenOutAmount: tokenOutAmount ?? this.tokenOutAmount,
    );
  }

  RouteDto copyWithWrapped({
    Wrapped<List<HopDto>>? hops,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenInAmount,
    Wrapped<String>? tokenOut,
    Wrapped<String>? tokenOutAmount,
  }) {
    return RouteDto(
      hops: (hops != null ? hops.value : this.hops),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenInAmount: (tokenInAmount != null
          ? tokenInAmount.value
          : this.tokenInAmount),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      tokenOutAmount: (tokenOutAmount != null
          ? tokenOutAmount.value
          : this.tokenOutAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OriginalDto {
  const OriginalDto({
    required this.tokenAddresses,
    required this.swaps,
    required this.swapAmount,
    required this.returnAmount,
    required this.swapAmountWithDecimal,
    required this.returnAmountWithDecimal,
    required this.tokenIn,
    required this.tokenOut,
    required this.marketSp,
    required this.routes,
    required this.effectivePrice,
    required this.effectivePriceReserved,
    required this.priceImpact,
    required this.warning,
    required this.minReturnAmount,
    required this.minReturnAmountWithDecimal,
  });

  factory OriginalDto.fromJson(Map<String, dynamic> json) =>
      _$OriginalDtoFromJson(json);

  static const toJsonFactory = _$OriginalDtoToJson;
  Map<String, dynamic> toJson() => _$OriginalDtoToJson(this);

  @JsonKey(name: 'tokenAddresses', defaultValue: <String>[])
  final List<String> tokenAddresses;
  @JsonKey(name: 'swaps', defaultValue: <SwapDto>[])
  final List<SwapDto> swaps;
  @JsonKey(name: 'swapAmount')
  final String swapAmount;
  @JsonKey(name: 'returnAmount')
  final String returnAmount;
  @JsonKey(name: 'swapAmountWithDecimal')
  final String swapAmountWithDecimal;
  @JsonKey(name: 'returnAmountWithDecimal')
  final String returnAmountWithDecimal;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'marketSp')
  final String marketSp;
  @JsonKey(name: 'routes', defaultValue: <RouteDto>[])
  final List<RouteDto> routes;
  @JsonKey(name: 'effectivePrice')
  final double effectivePrice;
  @JsonKey(name: 'effectivePriceReserved')
  final double effectivePriceReserved;
  @JsonKey(name: 'priceImpact')
  final double priceImpact;
  @JsonKey(name: 'warning')
  final String warning;
  @JsonKey(name: 'minReturnAmount')
  final String minReturnAmount;
  @JsonKey(name: 'minReturnAmountWithDecimal')
  final String minReturnAmountWithDecimal;
  static const fromJsonFactory = _$OriginalDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OriginalDto &&
            (identical(other.tokenAddresses, tokenAddresses) ||
                const DeepCollectionEquality().equals(
                  other.tokenAddresses,
                  tokenAddresses,
                )) &&
            (identical(other.swaps, swaps) ||
                const DeepCollectionEquality().equals(other.swaps, swaps)) &&
            (identical(other.swapAmount, swapAmount) ||
                const DeepCollectionEquality().equals(
                  other.swapAmount,
                  swapAmount,
                )) &&
            (identical(other.returnAmount, returnAmount) ||
                const DeepCollectionEquality().equals(
                  other.returnAmount,
                  returnAmount,
                )) &&
            (identical(other.swapAmountWithDecimal, swapAmountWithDecimal) ||
                const DeepCollectionEquality().equals(
                  other.swapAmountWithDecimal,
                  swapAmountWithDecimal,
                )) &&
            (identical(
                  other.returnAmountWithDecimal,
                  returnAmountWithDecimal,
                ) ||
                const DeepCollectionEquality().equals(
                  other.returnAmountWithDecimal,
                  returnAmountWithDecimal,
                )) &&
            (identical(other.tokenIn, tokenIn) ||
                const DeepCollectionEquality().equals(
                  other.tokenIn,
                  tokenIn,
                )) &&
            (identical(other.tokenOut, tokenOut) ||
                const DeepCollectionEquality().equals(
                  other.tokenOut,
                  tokenOut,
                )) &&
            (identical(other.marketSp, marketSp) ||
                const DeepCollectionEquality().equals(
                  other.marketSp,
                  marketSp,
                )) &&
            (identical(other.routes, routes) ||
                const DeepCollectionEquality().equals(other.routes, routes)) &&
            (identical(other.effectivePrice, effectivePrice) ||
                const DeepCollectionEquality().equals(
                  other.effectivePrice,
                  effectivePrice,
                )) &&
            (identical(other.effectivePriceReserved, effectivePriceReserved) ||
                const DeepCollectionEquality().equals(
                  other.effectivePriceReserved,
                  effectivePriceReserved,
                )) &&
            (identical(other.priceImpact, priceImpact) ||
                const DeepCollectionEquality().equals(
                  other.priceImpact,
                  priceImpact,
                )) &&
            (identical(other.warning, warning) ||
                const DeepCollectionEquality().equals(
                  other.warning,
                  warning,
                )) &&
            (identical(other.minReturnAmount, minReturnAmount) ||
                const DeepCollectionEquality().equals(
                  other.minReturnAmount,
                  minReturnAmount,
                )) &&
            (identical(
                  other.minReturnAmountWithDecimal,
                  minReturnAmountWithDecimal,
                ) ||
                const DeepCollectionEquality().equals(
                  other.minReturnAmountWithDecimal,
                  minReturnAmountWithDecimal,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokenAddresses) ^
      const DeepCollectionEquality().hash(swaps) ^
      const DeepCollectionEquality().hash(swapAmount) ^
      const DeepCollectionEquality().hash(returnAmount) ^
      const DeepCollectionEquality().hash(swapAmountWithDecimal) ^
      const DeepCollectionEquality().hash(returnAmountWithDecimal) ^
      const DeepCollectionEquality().hash(tokenIn) ^
      const DeepCollectionEquality().hash(tokenOut) ^
      const DeepCollectionEquality().hash(marketSp) ^
      const DeepCollectionEquality().hash(routes) ^
      const DeepCollectionEquality().hash(effectivePrice) ^
      const DeepCollectionEquality().hash(effectivePriceReserved) ^
      const DeepCollectionEquality().hash(priceImpact) ^
      const DeepCollectionEquality().hash(warning) ^
      const DeepCollectionEquality().hash(minReturnAmount) ^
      const DeepCollectionEquality().hash(minReturnAmountWithDecimal) ^
      runtimeType.hashCode;
}

extension $OriginalDtoExtension on OriginalDto {
  OriginalDto copyWith({
    List<String>? tokenAddresses,
    List<SwapDto>? swaps,
    String? swapAmount,
    String? returnAmount,
    String? swapAmountWithDecimal,
    String? returnAmountWithDecimal,
    String? tokenIn,
    String? tokenOut,
    String? marketSp,
    List<RouteDto>? routes,
    double? effectivePrice,
    double? effectivePriceReserved,
    double? priceImpact,
    String? warning,
    String? minReturnAmount,
    String? minReturnAmountWithDecimal,
  }) {
    return OriginalDto(
      tokenAddresses: tokenAddresses ?? this.tokenAddresses,
      swaps: swaps ?? this.swaps,
      swapAmount: swapAmount ?? this.swapAmount,
      returnAmount: returnAmount ?? this.returnAmount,
      swapAmountWithDecimal:
          swapAmountWithDecimal ?? this.swapAmountWithDecimal,
      returnAmountWithDecimal:
          returnAmountWithDecimal ?? this.returnAmountWithDecimal,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenOut: tokenOut ?? this.tokenOut,
      marketSp: marketSp ?? this.marketSp,
      routes: routes ?? this.routes,
      effectivePrice: effectivePrice ?? this.effectivePrice,
      effectivePriceReserved:
          effectivePriceReserved ?? this.effectivePriceReserved,
      priceImpact: priceImpact ?? this.priceImpact,
      warning: warning ?? this.warning,
      minReturnAmount: minReturnAmount ?? this.minReturnAmount,
      minReturnAmountWithDecimal:
          minReturnAmountWithDecimal ?? this.minReturnAmountWithDecimal,
    );
  }

  OriginalDto copyWithWrapped({
    Wrapped<List<String>>? tokenAddresses,
    Wrapped<List<SwapDto>>? swaps,
    Wrapped<String>? swapAmount,
    Wrapped<String>? returnAmount,
    Wrapped<String>? swapAmountWithDecimal,
    Wrapped<String>? returnAmountWithDecimal,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenOut,
    Wrapped<String>? marketSp,
    Wrapped<List<RouteDto>>? routes,
    Wrapped<double>? effectivePrice,
    Wrapped<double>? effectivePriceReserved,
    Wrapped<double>? priceImpact,
    Wrapped<String>? warning,
    Wrapped<String>? minReturnAmount,
    Wrapped<String>? minReturnAmountWithDecimal,
  }) {
    return OriginalDto(
      tokenAddresses: (tokenAddresses != null
          ? tokenAddresses.value
          : this.tokenAddresses),
      swaps: (swaps != null ? swaps.value : this.swaps),
      swapAmount: (swapAmount != null ? swapAmount.value : this.swapAmount),
      returnAmount: (returnAmount != null
          ? returnAmount.value
          : this.returnAmount),
      swapAmountWithDecimal: (swapAmountWithDecimal != null
          ? swapAmountWithDecimal.value
          : this.swapAmountWithDecimal),
      returnAmountWithDecimal: (returnAmountWithDecimal != null
          ? returnAmountWithDecimal.value
          : this.returnAmountWithDecimal),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      marketSp: (marketSp != null ? marketSp.value : this.marketSp),
      routes: (routes != null ? routes.value : this.routes),
      effectivePrice: (effectivePrice != null
          ? effectivePrice.value
          : this.effectivePrice),
      effectivePriceReserved: (effectivePriceReserved != null
          ? effectivePriceReserved.value
          : this.effectivePriceReserved),
      priceImpact: (priceImpact != null ? priceImpact.value : this.priceImpact),
      warning: (warning != null ? warning.value : this.warning),
      minReturnAmount: (minReturnAmount != null
          ? minReturnAmount.value
          : this.minReturnAmount),
      minReturnAmountWithDecimal: (minReturnAmountWithDecimal != null
          ? minReturnAmountWithDecimal.value
          : this.minReturnAmountWithDecimal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FetchSwapRoutesResponseDto {
  const FetchSwapRoutesResponseDto({
    required this.argument,
    required this.limits,
    required this.extraGasLimit,
    required this.swapAmount,
    required this.paymentToken,
    required this.bigUintAmount,
    required this.original,
  });

  factory FetchSwapRoutesResponseDto.fromJson(Map<String, dynamic> json) =>
      _$FetchSwapRoutesResponseDtoFromJson(json);

  static const toJsonFactory = _$FetchSwapRoutesResponseDtoToJson;
  Map<String, dynamic> toJson() => _$FetchSwapRoutesResponseDtoToJson(this);

  @JsonKey(name: 'argument')
  final String argument;
  @JsonKey(name: 'limits')
  final String limits;
  @JsonKey(name: 'extraGasLimit')
  final double extraGasLimit;
  @JsonKey(name: 'swapAmount')
  final double swapAmount;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'bigUintAmount')
  final String bigUintAmount;
  @JsonKey(name: 'original')
  final OriginalDto original;
  static const fromJsonFactory = _$FetchSwapRoutesResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FetchSwapRoutesResponseDto &&
            (identical(other.argument, argument) ||
                const DeepCollectionEquality().equals(
                  other.argument,
                  argument,
                )) &&
            (identical(other.limits, limits) ||
                const DeepCollectionEquality().equals(other.limits, limits)) &&
            (identical(other.extraGasLimit, extraGasLimit) ||
                const DeepCollectionEquality().equals(
                  other.extraGasLimit,
                  extraGasLimit,
                )) &&
            (identical(other.swapAmount, swapAmount) ||
                const DeepCollectionEquality().equals(
                  other.swapAmount,
                  swapAmount,
                )) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.bigUintAmount, bigUintAmount) ||
                const DeepCollectionEquality().equals(
                  other.bigUintAmount,
                  bigUintAmount,
                )) &&
            (identical(other.original, original) ||
                const DeepCollectionEquality().equals(
                  other.original,
                  original,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(argument) ^
      const DeepCollectionEquality().hash(limits) ^
      const DeepCollectionEquality().hash(extraGasLimit) ^
      const DeepCollectionEquality().hash(swapAmount) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(bigUintAmount) ^
      const DeepCollectionEquality().hash(original) ^
      runtimeType.hashCode;
}

extension $FetchSwapRoutesResponseDtoExtension on FetchSwapRoutesResponseDto {
  FetchSwapRoutesResponseDto copyWith({
    String? argument,
    String? limits,
    double? extraGasLimit,
    double? swapAmount,
    String? paymentToken,
    String? bigUintAmount,
    OriginalDto? original,
  }) {
    return FetchSwapRoutesResponseDto(
      argument: argument ?? this.argument,
      limits: limits ?? this.limits,
      extraGasLimit: extraGasLimit ?? this.extraGasLimit,
      swapAmount: swapAmount ?? this.swapAmount,
      paymentToken: paymentToken ?? this.paymentToken,
      bigUintAmount: bigUintAmount ?? this.bigUintAmount,
      original: original ?? this.original,
    );
  }

  FetchSwapRoutesResponseDto copyWithWrapped({
    Wrapped<String>? argument,
    Wrapped<String>? limits,
    Wrapped<double>? extraGasLimit,
    Wrapped<double>? swapAmount,
    Wrapped<String>? paymentToken,
    Wrapped<String>? bigUintAmount,
    Wrapped<OriginalDto>? original,
  }) {
    return FetchSwapRoutesResponseDto(
      argument: (argument != null ? argument.value : this.argument),
      limits: (limits != null ? limits.value : this.limits),
      extraGasLimit: (extraGasLimit != null
          ? extraGasLimit.value
          : this.extraGasLimit),
      swapAmount: (swapAmount != null ? swapAmount.value : this.swapAmount),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      bigUintAmount: (bigUintAmount != null
          ? bigUintAmount.value
          : this.bigUintAmount),
      original: (original != null ? original.value : this.original),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ArdaSwapResultDto {
  const ArdaSwapResultDto({
    required this.tokenIn,
    required this.amountIn,
    required this.amountInShort,
    required this.tokenOut,
    required this.amountOut,
    required this.amountOutShort,
    required this.argument,
    required this.gasLimit,
  });

  factory ArdaSwapResultDto.fromJson(Map<String, dynamic> json) =>
      _$ArdaSwapResultDtoFromJson(json);

  static const toJsonFactory = _$ArdaSwapResultDtoToJson;
  Map<String, dynamic> toJson() => _$ArdaSwapResultDtoToJson(this);

  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'amountIn')
  final String amountIn;
  @JsonKey(name: 'amountInShort')
  final String amountInShort;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'amountOut')
  final String amountOut;
  @JsonKey(name: 'amountOutShort')
  final String amountOutShort;
  @JsonKey(name: 'argument')
  final String argument;
  @JsonKey(name: 'gasLimit')
  final double gasLimit;
  static const fromJsonFactory = _$ArdaSwapResultDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ArdaSwapResultDto &&
            (identical(other.tokenIn, tokenIn) ||
                const DeepCollectionEquality().equals(
                  other.tokenIn,
                  tokenIn,
                )) &&
            (identical(other.amountIn, amountIn) ||
                const DeepCollectionEquality().equals(
                  other.amountIn,
                  amountIn,
                )) &&
            (identical(other.amountInShort, amountInShort) ||
                const DeepCollectionEquality().equals(
                  other.amountInShort,
                  amountInShort,
                )) &&
            (identical(other.tokenOut, tokenOut) ||
                const DeepCollectionEquality().equals(
                  other.tokenOut,
                  tokenOut,
                )) &&
            (identical(other.amountOut, amountOut) ||
                const DeepCollectionEquality().equals(
                  other.amountOut,
                  amountOut,
                )) &&
            (identical(other.amountOutShort, amountOutShort) ||
                const DeepCollectionEquality().equals(
                  other.amountOutShort,
                  amountOutShort,
                )) &&
            (identical(other.argument, argument) ||
                const DeepCollectionEquality().equals(
                  other.argument,
                  argument,
                )) &&
            (identical(other.gasLimit, gasLimit) ||
                const DeepCollectionEquality().equals(
                  other.gasLimit,
                  gasLimit,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokenIn) ^
      const DeepCollectionEquality().hash(amountIn) ^
      const DeepCollectionEquality().hash(amountInShort) ^
      const DeepCollectionEquality().hash(tokenOut) ^
      const DeepCollectionEquality().hash(amountOut) ^
      const DeepCollectionEquality().hash(amountOutShort) ^
      const DeepCollectionEquality().hash(argument) ^
      const DeepCollectionEquality().hash(gasLimit) ^
      runtimeType.hashCode;
}

extension $ArdaSwapResultDtoExtension on ArdaSwapResultDto {
  ArdaSwapResultDto copyWith({
    String? tokenIn,
    String? amountIn,
    String? amountInShort,
    String? tokenOut,
    String? amountOut,
    String? amountOutShort,
    String? argument,
    double? gasLimit,
  }) {
    return ArdaSwapResultDto(
      tokenIn: tokenIn ?? this.tokenIn,
      amountIn: amountIn ?? this.amountIn,
      amountInShort: amountInShort ?? this.amountInShort,
      tokenOut: tokenOut ?? this.tokenOut,
      amountOut: amountOut ?? this.amountOut,
      amountOutShort: amountOutShort ?? this.amountOutShort,
      argument: argument ?? this.argument,
      gasLimit: gasLimit ?? this.gasLimit,
    );
  }

  ArdaSwapResultDto copyWithWrapped({
    Wrapped<String>? tokenIn,
    Wrapped<String>? amountIn,
    Wrapped<String>? amountInShort,
    Wrapped<String>? tokenOut,
    Wrapped<String>? amountOut,
    Wrapped<String>? amountOutShort,
    Wrapped<String>? argument,
    Wrapped<double>? gasLimit,
  }) {
    return ArdaSwapResultDto(
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      amountIn: (amountIn != null ? amountIn.value : this.amountIn),
      amountInShort: (amountInShort != null
          ? amountInShort.value
          : this.amountInShort),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      amountOut: (amountOut != null ? amountOut.value : this.amountOut),
      amountOutShort: (amountOutShort != null
          ? amountOutShort.value
          : this.amountOutShort),
      argument: (argument != null ? argument.value : this.argument),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OraclePriceFluctuation {
  const OraclePriceFluctuation({
    required this.firstUpperRatio,
    required this.firstLowerRatio,
    required this.lastUpperRatio,
    required this.lastLowerRatio,
  });

  factory OraclePriceFluctuation.fromJson(Map<String, dynamic> json) =>
      _$OraclePriceFluctuationFromJson(json);

  static const toJsonFactory = _$OraclePriceFluctuationToJson;
  Map<String, dynamic> toJson() => _$OraclePriceFluctuationToJson(this);

  @JsonKey(name: 'firstUpperRatio')
  final int firstUpperRatio;
  @JsonKey(name: 'firstLowerRatio')
  final int firstLowerRatio;
  @JsonKey(name: 'lastUpperRatio')
  final int lastUpperRatio;
  @JsonKey(name: 'lastLowerRatio')
  final int lastLowerRatio;
  static const fromJsonFactory = _$OraclePriceFluctuationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OraclePriceFluctuation &&
            (identical(other.firstUpperRatio, firstUpperRatio) ||
                const DeepCollectionEquality().equals(
                  other.firstUpperRatio,
                  firstUpperRatio,
                )) &&
            (identical(other.firstLowerRatio, firstLowerRatio) ||
                const DeepCollectionEquality().equals(
                  other.firstLowerRatio,
                  firstLowerRatio,
                )) &&
            (identical(other.lastUpperRatio, lastUpperRatio) ||
                const DeepCollectionEquality().equals(
                  other.lastUpperRatio,
                  lastUpperRatio,
                )) &&
            (identical(other.lastLowerRatio, lastLowerRatio) ||
                const DeepCollectionEquality().equals(
                  other.lastLowerRatio,
                  lastLowerRatio,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstUpperRatio) ^
      const DeepCollectionEquality().hash(firstLowerRatio) ^
      const DeepCollectionEquality().hash(lastUpperRatio) ^
      const DeepCollectionEquality().hash(lastLowerRatio) ^
      runtimeType.hashCode;
}

extension $OraclePriceFluctuationExtension on OraclePriceFluctuation {
  OraclePriceFluctuation copyWith({
    int? firstUpperRatio,
    int? firstLowerRatio,
    int? lastUpperRatio,
    int? lastLowerRatio,
  }) {
    return OraclePriceFluctuation(
      firstUpperRatio: firstUpperRatio ?? this.firstUpperRatio,
      firstLowerRatio: firstLowerRatio ?? this.firstLowerRatio,
      lastUpperRatio: lastUpperRatio ?? this.lastUpperRatio,
      lastLowerRatio: lastLowerRatio ?? this.lastLowerRatio,
    );
  }

  OraclePriceFluctuation copyWithWrapped({
    Wrapped<int>? firstUpperRatio,
    Wrapped<int>? firstLowerRatio,
    Wrapped<int>? lastUpperRatio,
    Wrapped<int>? lastLowerRatio,
  }) {
    return OraclePriceFluctuation(
      firstUpperRatio: (firstUpperRatio != null
          ? firstUpperRatio.value
          : this.firstUpperRatio),
      firstLowerRatio: (firstLowerRatio != null
          ? firstLowerRatio.value
          : this.firstLowerRatio),
      lastUpperRatio: (lastUpperRatio != null
          ? lastUpperRatio.value
          : this.lastUpperRatio),
      lastLowerRatio: (lastLowerRatio != null
          ? lastLowerRatio.value
          : this.lastLowerRatio),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingOracleUpdateStruct {
  const LendingOracleUpdateStruct({
    required this.baseTokenId,
    required this.quoteTokenId,
    required this.tolerance,
    required this.oracleContractAddress,
    required this.pricingMethod,
    required this.oracleType,
    required this.exchangeSource,
    required this.assetDecimals,
    required this.onedexPairId,
    required this.maxPriceStaleSeconds,
  });

  factory LendingOracleUpdateStruct.fromJson(Map<String, dynamic> json) =>
      _$LendingOracleUpdateStructFromJson(json);

  static const toJsonFactory = _$LendingOracleUpdateStructToJson;
  Map<String, dynamic> toJson() => _$LendingOracleUpdateStructToJson(this);

  @JsonKey(name: 'baseTokenId')
  final String baseTokenId;
  @JsonKey(name: 'quoteTokenId')
  final String quoteTokenId;
  @JsonKey(name: 'tolerance')
  final OraclePriceFluctuation tolerance;
  @JsonKey(name: 'oracleContractAddress')
  final String oracleContractAddress;
  @JsonKey(
    name: 'pricingMethod',
    toJson: pricingMethodToJson,
    fromJson: pricingMethodFromJson,
  )
  final enums.PricingMethod pricingMethod;
  @JsonKey(
    name: 'oracleType',
    toJson: oracleTypeToJson,
    fromJson: oracleTypeFromJson,
  )
  final enums.OracleType oracleType;
  @JsonKey(
    name: 'exchangeSource',
    toJson: exchangeSourceToJson,
    fromJson: exchangeSourceFromJson,
  )
  final enums.ExchangeSource exchangeSource;
  @JsonKey(name: 'assetDecimals')
  final double assetDecimals;
  @JsonKey(name: 'onedexPairId')
  final double onedexPairId;
  @JsonKey(name: 'maxPriceStaleSeconds')
  final double maxPriceStaleSeconds;
  static const fromJsonFactory = _$LendingOracleUpdateStructFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingOracleUpdateStruct &&
            (identical(other.baseTokenId, baseTokenId) ||
                const DeepCollectionEquality().equals(
                  other.baseTokenId,
                  baseTokenId,
                )) &&
            (identical(other.quoteTokenId, quoteTokenId) ||
                const DeepCollectionEquality().equals(
                  other.quoteTokenId,
                  quoteTokenId,
                )) &&
            (identical(other.tolerance, tolerance) ||
                const DeepCollectionEquality().equals(
                  other.tolerance,
                  tolerance,
                )) &&
            (identical(other.oracleContractAddress, oracleContractAddress) ||
                const DeepCollectionEquality().equals(
                  other.oracleContractAddress,
                  oracleContractAddress,
                )) &&
            (identical(other.pricingMethod, pricingMethod) ||
                const DeepCollectionEquality().equals(
                  other.pricingMethod,
                  pricingMethod,
                )) &&
            (identical(other.oracleType, oracleType) ||
                const DeepCollectionEquality().equals(
                  other.oracleType,
                  oracleType,
                )) &&
            (identical(other.exchangeSource, exchangeSource) ||
                const DeepCollectionEquality().equals(
                  other.exchangeSource,
                  exchangeSource,
                )) &&
            (identical(other.assetDecimals, assetDecimals) ||
                const DeepCollectionEquality().equals(
                  other.assetDecimals,
                  assetDecimals,
                )) &&
            (identical(other.onedexPairId, onedexPairId) ||
                const DeepCollectionEquality().equals(
                  other.onedexPairId,
                  onedexPairId,
                )) &&
            (identical(other.maxPriceStaleSeconds, maxPriceStaleSeconds) ||
                const DeepCollectionEquality().equals(
                  other.maxPriceStaleSeconds,
                  maxPriceStaleSeconds,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(baseTokenId) ^
      const DeepCollectionEquality().hash(quoteTokenId) ^
      const DeepCollectionEquality().hash(tolerance) ^
      const DeepCollectionEquality().hash(oracleContractAddress) ^
      const DeepCollectionEquality().hash(pricingMethod) ^
      const DeepCollectionEquality().hash(oracleType) ^
      const DeepCollectionEquality().hash(exchangeSource) ^
      const DeepCollectionEquality().hash(assetDecimals) ^
      const DeepCollectionEquality().hash(onedexPairId) ^
      const DeepCollectionEquality().hash(maxPriceStaleSeconds) ^
      runtimeType.hashCode;
}

extension $LendingOracleUpdateStructExtension on LendingOracleUpdateStruct {
  LendingOracleUpdateStruct copyWith({
    String? baseTokenId,
    String? quoteTokenId,
    OraclePriceFluctuation? tolerance,
    String? oracleContractAddress,
    enums.PricingMethod? pricingMethod,
    enums.OracleType? oracleType,
    enums.ExchangeSource? exchangeSource,
    double? assetDecimals,
    double? onedexPairId,
    double? maxPriceStaleSeconds,
  }) {
    return LendingOracleUpdateStruct(
      baseTokenId: baseTokenId ?? this.baseTokenId,
      quoteTokenId: quoteTokenId ?? this.quoteTokenId,
      tolerance: tolerance ?? this.tolerance,
      oracleContractAddress:
          oracleContractAddress ?? this.oracleContractAddress,
      pricingMethod: pricingMethod ?? this.pricingMethod,
      oracleType: oracleType ?? this.oracleType,
      exchangeSource: exchangeSource ?? this.exchangeSource,
      assetDecimals: assetDecimals ?? this.assetDecimals,
      onedexPairId: onedexPairId ?? this.onedexPairId,
      maxPriceStaleSeconds: maxPriceStaleSeconds ?? this.maxPriceStaleSeconds,
    );
  }

  LendingOracleUpdateStruct copyWithWrapped({
    Wrapped<String>? baseTokenId,
    Wrapped<String>? quoteTokenId,
    Wrapped<OraclePriceFluctuation>? tolerance,
    Wrapped<String>? oracleContractAddress,
    Wrapped<enums.PricingMethod>? pricingMethod,
    Wrapped<enums.OracleType>? oracleType,
    Wrapped<enums.ExchangeSource>? exchangeSource,
    Wrapped<double>? assetDecimals,
    Wrapped<double>? onedexPairId,
    Wrapped<double>? maxPriceStaleSeconds,
  }) {
    return LendingOracleUpdateStruct(
      baseTokenId: (baseTokenId != null ? baseTokenId.value : this.baseTokenId),
      quoteTokenId: (quoteTokenId != null
          ? quoteTokenId.value
          : this.quoteTokenId),
      tolerance: (tolerance != null ? tolerance.value : this.tolerance),
      oracleContractAddress: (oracleContractAddress != null
          ? oracleContractAddress.value
          : this.oracleContractAddress),
      pricingMethod: (pricingMethod != null
          ? pricingMethod.value
          : this.pricingMethod),
      oracleType: (oracleType != null ? oracleType.value : this.oracleType),
      exchangeSource: (exchangeSource != null
          ? exchangeSource.value
          : this.exchangeSource),
      assetDecimals: (assetDecimals != null
          ? assetDecimals.value
          : this.assetDecimals),
      onedexPairId: (onedexPairId != null
          ? onedexPairId.value
          : this.onedexPairId),
      maxPriceStaleSeconds: (maxPriceStaleSeconds != null
          ? maxPriceStaleSeconds.value
          : this.maxPriceStaleSeconds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketParticipants {
  const LendingMarketParticipants({required this.count, required this.wallets});

  factory LendingMarketParticipants.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketParticipantsFromJson(json);

  static const toJsonFactory = _$LendingMarketParticipantsToJson;
  Map<String, dynamic> toJson() => _$LendingMarketParticipantsToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'wallets', defaultValue: <List<Object?>>[])
  final List<List<Object?>> wallets;
  static const fromJsonFactory = _$LendingMarketParticipantsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketParticipants &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.wallets, wallets) ||
                const DeepCollectionEquality().equals(other.wallets, wallets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(wallets) ^
      runtimeType.hashCode;
}

extension $LendingMarketParticipantsExtension on LendingMarketParticipants {
  LendingMarketParticipants copyWith({
    double? count,
    List<List<Object?>>? wallets,
  }) {
    return LendingMarketParticipants(
      count: count ?? this.count,
      wallets: wallets ?? this.wallets,
    );
  }

  LendingMarketParticipants copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<List<List<Object?>>>? wallets,
  }) {
    return LendingMarketParticipants(
      count: (count != null ? count.value : this.count),
      wallets: (wallets != null ? wallets.value : this.wallets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketExtraApy {
  const MarketExtraApy({this.nativeApy, this.feesApr});

  factory MarketExtraApy.fromJson(Map<String, dynamic> json) =>
      _$MarketExtraApyFromJson(json);

  static const toJsonFactory = _$MarketExtraApyToJson;
  Map<String, dynamic> toJson() => _$MarketExtraApyToJson(this);

  @JsonKey(name: 'nativeApy')
  final double? nativeApy;
  @JsonKey(name: 'feesApr')
  final double? feesApr;
  static const fromJsonFactory = _$MarketExtraApyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketExtraApy &&
            (identical(other.nativeApy, nativeApy) ||
                const DeepCollectionEquality().equals(
                  other.nativeApy,
                  nativeApy,
                )) &&
            (identical(other.feesApr, feesApr) ||
                const DeepCollectionEquality().equals(other.feesApr, feesApr)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(nativeApy) ^
      const DeepCollectionEquality().hash(feesApr) ^
      runtimeType.hashCode;
}

extension $MarketExtraApyExtension on MarketExtraApy {
  MarketExtraApy copyWith({double? nativeApy, double? feesApr}) {
    return MarketExtraApy(
      nativeApy: nativeApy ?? this.nativeApy,
      feesApr: feesApr ?? this.feesApr,
    );
  }

  MarketExtraApy copyWithWrapped({
    Wrapped<double?>? nativeApy,
    Wrapped<double?>? feesApr,
  }) {
    return MarketExtraApy(
      nativeApy: (nativeApy != null ? nativeApy.value : this.nativeApy),
      feesApr: (feesApr != null ? feesApr.value : this.feesApr),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfile {
  const LendingMarketProfile({
    required this.dataType,
    required this.token,
    required this.name,
    required this.decimals,
    required this.address,
    required this.baseRate,
    required this.maxBorrowRate,
    required this.slopeRate1,
    required this.slopeRate2,
    required this.slopeRate3,
    required this.midUsageRate,
    required this.optimalUsageRate,
    required this.reserveFactor,
    required this.liquidationFee,
    required this.ltv,
    required this.liquidationBonus,
    required this.liquidationThreshold,
    required this.rewardsReserve,
    required this.rewardsReserveShort,
    required this.reserves,
    required this.reservesShort,
    required this.supplyAmount,
    required this.supplyAmountScaled,
    required this.borrowAmount,
    required this.supplyAmountShort,
    required this.borrowAmountShort,
    required this.borrowAmountScaled,
    required this.supplyCap,
    required this.borrowCap,
    required this.supplyCapShort,
    required this.borrowCapShort,
    required this.supplyIndex,
    required this.borrowIndex,
    required this.timestamp,
    required this.borrowApy,
    required this.supplyApy,
    required this.utilizationRate,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.eMode,
    required this.eModeCategories,
    required this.isolated,
    required this.maxDebtUsd,
    required this.maxDebtUsdShort,
    this.debtCeiling,
    this.debtCeilingShort,
    required this.siloed,
    required this.flashLoan,
    required this.flashLoanFee,
    required this.canBorrowInIsolation,
    required this.oracleProvider,
    required this.id,
    required this.pk,
    required this.ts,
    required this.eModeCategoryProfiles,
    required this.oraclePrice,
    required this.participants,
    this.extraApy,
  });

  factory LendingMarketProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'baseRate')
  final String baseRate;
  @JsonKey(name: 'maxBorrowRate')
  final String maxBorrowRate;
  @JsonKey(name: 'slopeRate1')
  final String slopeRate1;
  @JsonKey(name: 'slopeRate2')
  final String slopeRate2;
  @JsonKey(name: 'slopeRate3')
  final String slopeRate3;
  @JsonKey(name: 'midUsageRate')
  final String midUsageRate;
  @JsonKey(name: 'optimalUsageRate')
  final String optimalUsageRate;
  @JsonKey(name: 'reserveFactor')
  final String reserveFactor;
  @JsonKey(name: 'liquidationFee')
  final String liquidationFee;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'rewardsReserve')
  final Object rewardsReserve;
  @JsonKey(name: 'rewardsReserveShort')
  final Object rewardsReserveShort;
  @JsonKey(name: 'reserves')
  final Object reserves;
  @JsonKey(name: 'reservesShort')
  final Object reservesShort;
  @JsonKey(name: 'supplyAmount')
  final Object supplyAmount;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmount')
  final Object borrowAmount;
  @JsonKey(name: 'supplyAmountShort')
  final Object supplyAmountShort;
  @JsonKey(name: 'borrowAmountShort')
  final Object borrowAmountShort;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'supplyCap')
  final String supplyCap;
  @JsonKey(name: 'borrowCap')
  final String borrowCap;
  @JsonKey(name: 'supplyCapShort')
  final Object supplyCapShort;
  @JsonKey(name: 'borrowCapShort')
  final Object borrowCapShort;
  @JsonKey(name: 'supplyIndex')
  final Object supplyIndex;
  @JsonKey(name: 'borrowIndex')
  final Object borrowIndex;
  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'borrowApy')
  final Object borrowApy;
  @JsonKey(name: 'supplyApy')
  final Object supplyApy;
  @JsonKey(name: 'utilizationRate')
  final Object utilizationRate;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'eMode')
  final bool eMode;
  @JsonKey(name: 'eModeCategories', defaultValue: <List<Object?>>[])
  final List<List<Object?>> eModeCategories;
  @JsonKey(name: 'isolated')
  final bool isolated;
  @JsonKey(name: 'maxDebtUsd')
  final Object maxDebtUsd;
  @JsonKey(name: 'maxDebtUsdShort')
  final Object maxDebtUsdShort;
  @JsonKey(name: 'debtCeiling')
  final String? debtCeiling;
  @JsonKey(name: 'debtCeilingShort')
  final double? debtCeilingShort;
  @JsonKey(name: 'siloed')
  final bool siloed;
  @JsonKey(name: 'flashLoan')
  final bool flashLoan;
  @JsonKey(name: 'flashLoanFee')
  final String flashLoanFee;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool canBorrowInIsolation;
  @JsonKey(name: 'oracleProvider')
  final LendingOracleUpdateStruct oracleProvider;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'eModeCategoryProfiles', defaultValue: <List<Object?>>[])
  final List<List<Object?>> eModeCategoryProfiles;
  @JsonKey(name: 'oraclePrice')
  final String oraclePrice;
  @JsonKey(name: 'participants')
  final LendingMarketParticipants participants;
  @JsonKey(name: 'extraApy')
  final MarketExtraApy? extraApy;
  static const fromJsonFactory = _$LendingMarketProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketProfile &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.decimals, decimals) ||
                const DeepCollectionEquality().equals(
                  other.decimals,
                  decimals,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.baseRate, baseRate) ||
                const DeepCollectionEquality().equals(
                  other.baseRate,
                  baseRate,
                )) &&
            (identical(other.maxBorrowRate, maxBorrowRate) ||
                const DeepCollectionEquality().equals(
                  other.maxBorrowRate,
                  maxBorrowRate,
                )) &&
            (identical(other.slopeRate1, slopeRate1) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate1,
                  slopeRate1,
                )) &&
            (identical(other.slopeRate2, slopeRate2) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate2,
                  slopeRate2,
                )) &&
            (identical(other.slopeRate3, slopeRate3) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate3,
                  slopeRate3,
                )) &&
            (identical(other.midUsageRate, midUsageRate) ||
                const DeepCollectionEquality().equals(
                  other.midUsageRate,
                  midUsageRate,
                )) &&
            (identical(other.optimalUsageRate, optimalUsageRate) ||
                const DeepCollectionEquality().equals(
                  other.optimalUsageRate,
                  optimalUsageRate,
                )) &&
            (identical(other.reserveFactor, reserveFactor) ||
                const DeepCollectionEquality().equals(
                  other.reserveFactor,
                  reserveFactor,
                )) &&
            (identical(other.liquidationFee, liquidationFee) ||
                const DeepCollectionEquality().equals(
                  other.liquidationFee,
                  liquidationFee,
                )) &&
            (identical(other.ltv, ltv) ||
                const DeepCollectionEquality().equals(other.ltv, ltv)) &&
            (identical(other.liquidationBonus, liquidationBonus) ||
                const DeepCollectionEquality().equals(
                  other.liquidationBonus,
                  liquidationBonus,
                )) &&
            (identical(other.liquidationThreshold, liquidationThreshold) ||
                const DeepCollectionEquality().equals(
                  other.liquidationThreshold,
                  liquidationThreshold,
                )) &&
            (identical(other.rewardsReserve, rewardsReserve) ||
                const DeepCollectionEquality().equals(
                  other.rewardsReserve,
                  rewardsReserve,
                )) &&
            (identical(other.rewardsReserveShort, rewardsReserveShort) ||
                const DeepCollectionEquality().equals(
                  other.rewardsReserveShort,
                  rewardsReserveShort,
                )) &&
            (identical(other.reserves, reserves) ||
                const DeepCollectionEquality().equals(
                  other.reserves,
                  reserves,
                )) &&
            (identical(other.reservesShort, reservesShort) ||
                const DeepCollectionEquality().equals(
                  other.reservesShort,
                  reservesShort,
                )) &&
            (identical(other.supplyAmount, supplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmount,
                  supplyAmount,
                )) &&
            (identical(other.supplyAmountScaled, supplyAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmountScaled,
                  supplyAmountScaled,
                )) &&
            (identical(other.borrowAmount, borrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmount,
                  borrowAmount,
                )) &&
            (identical(other.supplyAmountShort, supplyAmountShort) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmountShort,
                  supplyAmountShort,
                )) &&
            (identical(other.borrowAmountShort, borrowAmountShort) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmountShort,
                  borrowAmountShort,
                )) &&
            (identical(other.borrowAmountScaled, borrowAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmountScaled,
                  borrowAmountScaled,
                )) &&
            (identical(other.supplyCap, supplyCap) ||
                const DeepCollectionEquality().equals(
                  other.supplyCap,
                  supplyCap,
                )) &&
            (identical(other.borrowCap, borrowCap) ||
                const DeepCollectionEquality().equals(
                  other.borrowCap,
                  borrowCap,
                )) &&
            (identical(other.supplyCapShort, supplyCapShort) ||
                const DeepCollectionEquality().equals(
                  other.supplyCapShort,
                  supplyCapShort,
                )) &&
            (identical(other.borrowCapShort, borrowCapShort) ||
                const DeepCollectionEquality().equals(
                  other.borrowCapShort,
                  borrowCapShort,
                )) &&
            (identical(other.supplyIndex, supplyIndex) ||
                const DeepCollectionEquality().equals(
                  other.supplyIndex,
                  supplyIndex,
                )) &&
            (identical(other.borrowIndex, borrowIndex) ||
                const DeepCollectionEquality().equals(
                  other.borrowIndex,
                  borrowIndex,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.borrowApy, borrowApy) ||
                const DeepCollectionEquality().equals(
                  other.borrowApy,
                  borrowApy,
                )) &&
            (identical(other.supplyApy, supplyApy) ||
                const DeepCollectionEquality().equals(
                  other.supplyApy,
                  supplyApy,
                )) &&
            (identical(other.utilizationRate, utilizationRate) ||
                const DeepCollectionEquality().equals(
                  other.utilizationRate,
                  utilizationRate,
                )) &&
            (identical(other.canBeCollateral, canBeCollateral) ||
                const DeepCollectionEquality().equals(
                  other.canBeCollateral,
                  canBeCollateral,
                )) &&
            (identical(other.canBeBorrowed, canBeBorrowed) ||
                const DeepCollectionEquality().equals(
                  other.canBeBorrowed,
                  canBeBorrowed,
                )) &&
            (identical(other.eMode, eMode) ||
                const DeepCollectionEquality().equals(other.eMode, eMode)) &&
            (identical(other.eModeCategories, eModeCategories) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategories,
                  eModeCategories,
                )) &&
            (identical(other.isolated, isolated) ||
                const DeepCollectionEquality().equals(
                  other.isolated,
                  isolated,
                )) &&
            (identical(other.maxDebtUsd, maxDebtUsd) ||
                const DeepCollectionEquality().equals(
                  other.maxDebtUsd,
                  maxDebtUsd,
                )) &&
            (identical(other.maxDebtUsdShort, maxDebtUsdShort) ||
                const DeepCollectionEquality().equals(
                  other.maxDebtUsdShort,
                  maxDebtUsdShort,
                )) &&
            (identical(other.debtCeiling, debtCeiling) ||
                const DeepCollectionEquality().equals(
                  other.debtCeiling,
                  debtCeiling,
                )) &&
            (identical(other.debtCeilingShort, debtCeilingShort) ||
                const DeepCollectionEquality().equals(
                  other.debtCeilingShort,
                  debtCeilingShort,
                )) &&
            (identical(other.siloed, siloed) ||
                const DeepCollectionEquality().equals(other.siloed, siloed)) &&
            (identical(other.flashLoan, flashLoan) ||
                const DeepCollectionEquality().equals(
                  other.flashLoan,
                  flashLoan,
                )) &&
            (identical(other.flashLoanFee, flashLoanFee) ||
                const DeepCollectionEquality().equals(
                  other.flashLoanFee,
                  flashLoanFee,
                )) &&
            (identical(other.canBorrowInIsolation, canBorrowInIsolation) ||
                const DeepCollectionEquality().equals(
                  other.canBorrowInIsolation,
                  canBorrowInIsolation,
                )) &&
            (identical(other.oracleProvider, oracleProvider) ||
                const DeepCollectionEquality().equals(
                  other.oracleProvider,
                  oracleProvider,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.eModeCategoryProfiles, eModeCategoryProfiles) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategoryProfiles,
                  eModeCategoryProfiles,
                )) &&
            (identical(other.oraclePrice, oraclePrice) ||
                const DeepCollectionEquality().equals(
                  other.oraclePrice,
                  oraclePrice,
                )) &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality().equals(
                  other.participants,
                  participants,
                )) &&
            (identical(other.extraApy, extraApy) ||
                const DeepCollectionEquality().equals(
                  other.extraApy,
                  extraApy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(decimals) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(baseRate) ^
      const DeepCollectionEquality().hash(maxBorrowRate) ^
      const DeepCollectionEquality().hash(slopeRate1) ^
      const DeepCollectionEquality().hash(slopeRate2) ^
      const DeepCollectionEquality().hash(slopeRate3) ^
      const DeepCollectionEquality().hash(midUsageRate) ^
      const DeepCollectionEquality().hash(optimalUsageRate) ^
      const DeepCollectionEquality().hash(reserveFactor) ^
      const DeepCollectionEquality().hash(liquidationFee) ^
      const DeepCollectionEquality().hash(ltv) ^
      const DeepCollectionEquality().hash(liquidationBonus) ^
      const DeepCollectionEquality().hash(liquidationThreshold) ^
      const DeepCollectionEquality().hash(rewardsReserve) ^
      const DeepCollectionEquality().hash(rewardsReserveShort) ^
      const DeepCollectionEquality().hash(reserves) ^
      const DeepCollectionEquality().hash(reservesShort) ^
      const DeepCollectionEquality().hash(supplyAmount) ^
      const DeepCollectionEquality().hash(supplyAmountScaled) ^
      const DeepCollectionEquality().hash(borrowAmount) ^
      const DeepCollectionEquality().hash(supplyAmountShort) ^
      const DeepCollectionEquality().hash(borrowAmountShort) ^
      const DeepCollectionEquality().hash(borrowAmountScaled) ^
      const DeepCollectionEquality().hash(supplyCap) ^
      const DeepCollectionEquality().hash(borrowCap) ^
      const DeepCollectionEquality().hash(supplyCapShort) ^
      const DeepCollectionEquality().hash(borrowCapShort) ^
      const DeepCollectionEquality().hash(supplyIndex) ^
      const DeepCollectionEquality().hash(borrowIndex) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(borrowApy) ^
      const DeepCollectionEquality().hash(supplyApy) ^
      const DeepCollectionEquality().hash(utilizationRate) ^
      const DeepCollectionEquality().hash(canBeCollateral) ^
      const DeepCollectionEquality().hash(canBeBorrowed) ^
      const DeepCollectionEquality().hash(eMode) ^
      const DeepCollectionEquality().hash(eModeCategories) ^
      const DeepCollectionEquality().hash(isolated) ^
      const DeepCollectionEquality().hash(maxDebtUsd) ^
      const DeepCollectionEquality().hash(maxDebtUsdShort) ^
      const DeepCollectionEquality().hash(debtCeiling) ^
      const DeepCollectionEquality().hash(debtCeilingShort) ^
      const DeepCollectionEquality().hash(siloed) ^
      const DeepCollectionEquality().hash(flashLoan) ^
      const DeepCollectionEquality().hash(flashLoanFee) ^
      const DeepCollectionEquality().hash(canBorrowInIsolation) ^
      const DeepCollectionEquality().hash(oracleProvider) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(eModeCategoryProfiles) ^
      const DeepCollectionEquality().hash(oraclePrice) ^
      const DeepCollectionEquality().hash(participants) ^
      const DeepCollectionEquality().hash(extraApy) ^
      runtimeType.hashCode;
}

extension $LendingMarketProfileExtension on LendingMarketProfile {
  LendingMarketProfile copyWith({
    enums.LendingDataType? dataType,
    String? token,
    String? name,
    double? decimals,
    String? address,
    String? baseRate,
    String? maxBorrowRate,
    String? slopeRate1,
    String? slopeRate2,
    String? slopeRate3,
    String? midUsageRate,
    String? optimalUsageRate,
    String? reserveFactor,
    String? liquidationFee,
    String? ltv,
    String? liquidationBonus,
    String? liquidationThreshold,
    Object? rewardsReserve,
    Object? rewardsReserveShort,
    Object? reserves,
    Object? reservesShort,
    Object? supplyAmount,
    Object? supplyAmountScaled,
    Object? borrowAmount,
    Object? supplyAmountShort,
    Object? borrowAmountShort,
    Object? borrowAmountScaled,
    String? supplyCap,
    String? borrowCap,
    Object? supplyCapShort,
    Object? borrowCapShort,
    Object? supplyIndex,
    Object? borrowIndex,
    Object? timestamp,
    Object? borrowApy,
    Object? supplyApy,
    Object? utilizationRate,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? eMode,
    List<List<Object?>>? eModeCategories,
    bool? isolated,
    Object? maxDebtUsd,
    Object? maxDebtUsdShort,
    String? debtCeiling,
    double? debtCeilingShort,
    bool? siloed,
    bool? flashLoan,
    String? flashLoanFee,
    bool? canBorrowInIsolation,
    LendingOracleUpdateStruct? oracleProvider,
    String? id,
    String? pk,
    double? ts,
    List<List<Object?>>? eModeCategoryProfiles,
    String? oraclePrice,
    LendingMarketParticipants? participants,
    MarketExtraApy? extraApy,
  }) {
    return LendingMarketProfile(
      dataType: dataType ?? this.dataType,
      token: token ?? this.token,
      name: name ?? this.name,
      decimals: decimals ?? this.decimals,
      address: address ?? this.address,
      baseRate: baseRate ?? this.baseRate,
      maxBorrowRate: maxBorrowRate ?? this.maxBorrowRate,
      slopeRate1: slopeRate1 ?? this.slopeRate1,
      slopeRate2: slopeRate2 ?? this.slopeRate2,
      slopeRate3: slopeRate3 ?? this.slopeRate3,
      midUsageRate: midUsageRate ?? this.midUsageRate,
      optimalUsageRate: optimalUsageRate ?? this.optimalUsageRate,
      reserveFactor: reserveFactor ?? this.reserveFactor,
      liquidationFee: liquidationFee ?? this.liquidationFee,
      ltv: ltv ?? this.ltv,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      rewardsReserve: rewardsReserve ?? this.rewardsReserve,
      rewardsReserveShort: rewardsReserveShort ?? this.rewardsReserveShort,
      reserves: reserves ?? this.reserves,
      reservesShort: reservesShort ?? this.reservesShort,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      supplyAmountShort: supplyAmountShort ?? this.supplyAmountShort,
      borrowAmountShort: borrowAmountShort ?? this.borrowAmountShort,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      supplyCap: supplyCap ?? this.supplyCap,
      borrowCap: borrowCap ?? this.borrowCap,
      supplyCapShort: supplyCapShort ?? this.supplyCapShort,
      borrowCapShort: borrowCapShort ?? this.borrowCapShort,
      supplyIndex: supplyIndex ?? this.supplyIndex,
      borrowIndex: borrowIndex ?? this.borrowIndex,
      timestamp: timestamp ?? this.timestamp,
      borrowApy: borrowApy ?? this.borrowApy,
      supplyApy: supplyApy ?? this.supplyApy,
      utilizationRate: utilizationRate ?? this.utilizationRate,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      eMode: eMode ?? this.eMode,
      eModeCategories: eModeCategories ?? this.eModeCategories,
      isolated: isolated ?? this.isolated,
      maxDebtUsd: maxDebtUsd ?? this.maxDebtUsd,
      maxDebtUsdShort: maxDebtUsdShort ?? this.maxDebtUsdShort,
      debtCeiling: debtCeiling ?? this.debtCeiling,
      debtCeilingShort: debtCeilingShort ?? this.debtCeilingShort,
      siloed: siloed ?? this.siloed,
      flashLoan: flashLoan ?? this.flashLoan,
      flashLoanFee: flashLoanFee ?? this.flashLoanFee,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      oracleProvider: oracleProvider ?? this.oracleProvider,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      eModeCategoryProfiles:
          eModeCategoryProfiles ?? this.eModeCategoryProfiles,
      oraclePrice: oraclePrice ?? this.oraclePrice,
      participants: participants ?? this.participants,
      extraApy: extraApy ?? this.extraApy,
    );
  }

  LendingMarketProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? token,
    Wrapped<String>? name,
    Wrapped<double>? decimals,
    Wrapped<String>? address,
    Wrapped<String>? baseRate,
    Wrapped<String>? maxBorrowRate,
    Wrapped<String>? slopeRate1,
    Wrapped<String>? slopeRate2,
    Wrapped<String>? slopeRate3,
    Wrapped<String>? midUsageRate,
    Wrapped<String>? optimalUsageRate,
    Wrapped<String>? reserveFactor,
    Wrapped<String>? liquidationFee,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationBonus,
    Wrapped<String>? liquidationThreshold,
    Wrapped<Object>? rewardsReserve,
    Wrapped<Object>? rewardsReserveShort,
    Wrapped<Object>? reserves,
    Wrapped<Object>? reservesShort,
    Wrapped<Object>? supplyAmount,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmount,
    Wrapped<Object>? supplyAmountShort,
    Wrapped<Object>? borrowAmountShort,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<String>? supplyCap,
    Wrapped<String>? borrowCap,
    Wrapped<Object>? supplyCapShort,
    Wrapped<Object>? borrowCapShort,
    Wrapped<Object>? supplyIndex,
    Wrapped<Object>? borrowIndex,
    Wrapped<Object>? timestamp,
    Wrapped<Object>? borrowApy,
    Wrapped<Object>? supplyApy,
    Wrapped<Object>? utilizationRate,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<bool>? eMode,
    Wrapped<List<List<Object?>>>? eModeCategories,
    Wrapped<bool>? isolated,
    Wrapped<Object>? maxDebtUsd,
    Wrapped<Object>? maxDebtUsdShort,
    Wrapped<String?>? debtCeiling,
    Wrapped<double?>? debtCeilingShort,
    Wrapped<bool>? siloed,
    Wrapped<bool>? flashLoan,
    Wrapped<String>? flashLoanFee,
    Wrapped<bool>? canBorrowInIsolation,
    Wrapped<LendingOracleUpdateStruct>? oracleProvider,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<List<List<Object?>>>? eModeCategoryProfiles,
    Wrapped<String>? oraclePrice,
    Wrapped<LendingMarketParticipants>? participants,
    Wrapped<MarketExtraApy?>? extraApy,
  }) {
    return LendingMarketProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      token: (token != null ? token.value : this.token),
      name: (name != null ? name.value : this.name),
      decimals: (decimals != null ? decimals.value : this.decimals),
      address: (address != null ? address.value : this.address),
      baseRate: (baseRate != null ? baseRate.value : this.baseRate),
      maxBorrowRate: (maxBorrowRate != null
          ? maxBorrowRate.value
          : this.maxBorrowRate),
      slopeRate1: (slopeRate1 != null ? slopeRate1.value : this.slopeRate1),
      slopeRate2: (slopeRate2 != null ? slopeRate2.value : this.slopeRate2),
      slopeRate3: (slopeRate3 != null ? slopeRate3.value : this.slopeRate3),
      midUsageRate: (midUsageRate != null
          ? midUsageRate.value
          : this.midUsageRate),
      optimalUsageRate: (optimalUsageRate != null
          ? optimalUsageRate.value
          : this.optimalUsageRate),
      reserveFactor: (reserveFactor != null
          ? reserveFactor.value
          : this.reserveFactor),
      liquidationFee: (liquidationFee != null
          ? liquidationFee.value
          : this.liquidationFee),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      rewardsReserve: (rewardsReserve != null
          ? rewardsReserve.value
          : this.rewardsReserve),
      rewardsReserveShort: (rewardsReserveShort != null
          ? rewardsReserveShort.value
          : this.rewardsReserveShort),
      reserves: (reserves != null ? reserves.value : this.reserves),
      reservesShort: (reservesShort != null
          ? reservesShort.value
          : this.reservesShort),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      supplyAmountShort: (supplyAmountShort != null
          ? supplyAmountShort.value
          : this.supplyAmountShort),
      borrowAmountShort: (borrowAmountShort != null
          ? borrowAmountShort.value
          : this.borrowAmountShort),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      supplyCap: (supplyCap != null ? supplyCap.value : this.supplyCap),
      borrowCap: (borrowCap != null ? borrowCap.value : this.borrowCap),
      supplyCapShort: (supplyCapShort != null
          ? supplyCapShort.value
          : this.supplyCapShort),
      borrowCapShort: (borrowCapShort != null
          ? borrowCapShort.value
          : this.borrowCapShort),
      supplyIndex: (supplyIndex != null ? supplyIndex.value : this.supplyIndex),
      borrowIndex: (borrowIndex != null ? borrowIndex.value : this.borrowIndex),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      borrowApy: (borrowApy != null ? borrowApy.value : this.borrowApy),
      supplyApy: (supplyApy != null ? supplyApy.value : this.supplyApy),
      utilizationRate: (utilizationRate != null
          ? utilizationRate.value
          : this.utilizationRate),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      eMode: (eMode != null ? eMode.value : this.eMode),
      eModeCategories: (eModeCategories != null
          ? eModeCategories.value
          : this.eModeCategories),
      isolated: (isolated != null ? isolated.value : this.isolated),
      maxDebtUsd: (maxDebtUsd != null ? maxDebtUsd.value : this.maxDebtUsd),
      maxDebtUsdShort: (maxDebtUsdShort != null
          ? maxDebtUsdShort.value
          : this.maxDebtUsdShort),
      debtCeiling: (debtCeiling != null ? debtCeiling.value : this.debtCeiling),
      debtCeilingShort: (debtCeilingShort != null
          ? debtCeilingShort.value
          : this.debtCeilingShort),
      siloed: (siloed != null ? siloed.value : this.siloed),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      flashLoanFee: (flashLoanFee != null
          ? flashLoanFee.value
          : this.flashLoanFee),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      oracleProvider: (oracleProvider != null
          ? oracleProvider.value
          : this.oracleProvider),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      eModeCategoryProfiles: (eModeCategoryProfiles != null
          ? eModeCategoryProfiles.value
          : this.eModeCategoryProfiles),
      oraclePrice: (oraclePrice != null ? oraclePrice.value : this.oraclePrice),
      participants: (participants != null
          ? participants.value
          : this.participants),
      extraApy: (extraApy != null ? extraApy.value : this.extraApy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileFilterCriteriaDto {
  const LendingMarketProfileFilterCriteriaDto({
    this.token,
    this.range,
    this.eMode,
    this.flashLoan,
    this.isolated,
    this.siloed,
    this.canBeCollateral,
    this.canBeBorrowed,
    this.canBorrowInIsolation,
    this.isDebtCeilingReached,
  });

  factory LendingMarketProfileFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$LendingMarketProfileFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$LendingMarketProfileFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'token', defaultValue: <String>[])
  final List<String>? token;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'eMode')
  final bool? eMode;
  @JsonKey(name: 'flashLoan')
  final bool? flashLoan;
  @JsonKey(name: 'isolated')
  final bool? isolated;
  @JsonKey(name: 'siloed')
  final bool? siloed;
  @JsonKey(name: 'canBeCollateral')
  final bool? canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool? canBeBorrowed;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool? canBorrowInIsolation;
  @JsonKey(name: 'isDebtCeilingReached')
  final bool? isDebtCeilingReached;
  static const fromJsonFactory =
      _$LendingMarketProfileFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketProfileFilterCriteriaDto &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.eMode, eMode) ||
                const DeepCollectionEquality().equals(other.eMode, eMode)) &&
            (identical(other.flashLoan, flashLoan) ||
                const DeepCollectionEquality().equals(
                  other.flashLoan,
                  flashLoan,
                )) &&
            (identical(other.isolated, isolated) ||
                const DeepCollectionEquality().equals(
                  other.isolated,
                  isolated,
                )) &&
            (identical(other.siloed, siloed) ||
                const DeepCollectionEquality().equals(other.siloed, siloed)) &&
            (identical(other.canBeCollateral, canBeCollateral) ||
                const DeepCollectionEquality().equals(
                  other.canBeCollateral,
                  canBeCollateral,
                )) &&
            (identical(other.canBeBorrowed, canBeBorrowed) ||
                const DeepCollectionEquality().equals(
                  other.canBeBorrowed,
                  canBeBorrowed,
                )) &&
            (identical(other.canBorrowInIsolation, canBorrowInIsolation) ||
                const DeepCollectionEquality().equals(
                  other.canBorrowInIsolation,
                  canBorrowInIsolation,
                )) &&
            (identical(other.isDebtCeilingReached, isDebtCeilingReached) ||
                const DeepCollectionEquality().equals(
                  other.isDebtCeilingReached,
                  isDebtCeilingReached,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(eMode) ^
      const DeepCollectionEquality().hash(flashLoan) ^
      const DeepCollectionEquality().hash(isolated) ^
      const DeepCollectionEquality().hash(siloed) ^
      const DeepCollectionEquality().hash(canBeCollateral) ^
      const DeepCollectionEquality().hash(canBeBorrowed) ^
      const DeepCollectionEquality().hash(canBorrowInIsolation) ^
      const DeepCollectionEquality().hash(isDebtCeilingReached) ^
      runtimeType.hashCode;
}

extension $LendingMarketProfileFilterCriteriaDtoExtension
    on LendingMarketProfileFilterCriteriaDto {
  LendingMarketProfileFilterCriteriaDto copyWith({
    List<String>? token,
    List<RangeFilter>? range,
    bool? eMode,
    bool? flashLoan,
    bool? isolated,
    bool? siloed,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? canBorrowInIsolation,
    bool? isDebtCeilingReached,
  }) {
    return LendingMarketProfileFilterCriteriaDto(
      token: token ?? this.token,
      range: range ?? this.range,
      eMode: eMode ?? this.eMode,
      flashLoan: flashLoan ?? this.flashLoan,
      isolated: isolated ?? this.isolated,
      siloed: siloed ?? this.siloed,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      isDebtCeilingReached: isDebtCeilingReached ?? this.isDebtCeilingReached,
    );
  }

  LendingMarketProfileFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? token,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<bool?>? eMode,
    Wrapped<bool?>? flashLoan,
    Wrapped<bool?>? isolated,
    Wrapped<bool?>? siloed,
    Wrapped<bool?>? canBeCollateral,
    Wrapped<bool?>? canBeBorrowed,
    Wrapped<bool?>? canBorrowInIsolation,
    Wrapped<bool?>? isDebtCeilingReached,
  }) {
    return LendingMarketProfileFilterCriteriaDto(
      token: (token != null ? token.value : this.token),
      range: (range != null ? range.value : this.range),
      eMode: (eMode != null ? eMode.value : this.eMode),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      isolated: (isolated != null ? isolated.value : this.isolated),
      siloed: (siloed != null ? siloed.value : this.siloed),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      isDebtCeilingReached: (isDebtCeilingReached != null
          ? isDebtCeilingReached.value
          : this.isDebtCeilingReached),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileExtraProperties {
  const LendingMarketProfileExtraProperties({
    this.eModeCategoryProfile,
    this.oraclePrice,
    this.participants,
  });

  factory LendingMarketProfileExtraProperties.fromJson(
    Map<String, dynamic> json,
  ) => _$LendingMarketProfileExtraPropertiesFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileExtraPropertiesToJson;
  Map<String, dynamic> toJson() =>
      _$LendingMarketProfileExtraPropertiesToJson(this);

  @JsonKey(name: 'eModeCategoryProfile')
  final bool? eModeCategoryProfile;
  @JsonKey(name: 'oraclePrice')
  final bool? oraclePrice;
  @JsonKey(name: 'participants')
  final bool? participants;
  static const fromJsonFactory = _$LendingMarketProfileExtraPropertiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketProfileExtraProperties &&
            (identical(other.eModeCategoryProfile, eModeCategoryProfile) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategoryProfile,
                  eModeCategoryProfile,
                )) &&
            (identical(other.oraclePrice, oraclePrice) ||
                const DeepCollectionEquality().equals(
                  other.oraclePrice,
                  oraclePrice,
                )) &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality().equals(
                  other.participants,
                  participants,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eModeCategoryProfile) ^
      const DeepCollectionEquality().hash(oraclePrice) ^
      const DeepCollectionEquality().hash(participants) ^
      runtimeType.hashCode;
}

extension $LendingMarketProfileExtraPropertiesExtension
    on LendingMarketProfileExtraProperties {
  LendingMarketProfileExtraProperties copyWith({
    bool? eModeCategoryProfile,
    bool? oraclePrice,
    bool? participants,
  }) {
    return LendingMarketProfileExtraProperties(
      eModeCategoryProfile: eModeCategoryProfile ?? this.eModeCategoryProfile,
      oraclePrice: oraclePrice ?? this.oraclePrice,
      participants: participants ?? this.participants,
    );
  }

  LendingMarketProfileExtraProperties copyWithWrapped({
    Wrapped<bool?>? eModeCategoryProfile,
    Wrapped<bool?>? oraclePrice,
    Wrapped<bool?>? participants,
  }) {
    return LendingMarketProfileExtraProperties(
      eModeCategoryProfile: (eModeCategoryProfile != null
          ? eModeCategoryProfile.value
          : this.eModeCategoryProfile),
      oraclePrice: (oraclePrice != null ? oraclePrice.value : this.oraclePrice),
      participants: (participants != null
          ? participants.value
          : this.participants),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileFilter {
  const LendingMarketProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
    this.extraProperties,
  });

  factory LendingMarketProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileFilterFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileFilterToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final LendingMarketProfileFilterCriteriaDto filters;
  @JsonKey(name: 'extraProperties')
  final LendingMarketProfileExtraProperties? extraProperties;
  static const fromJsonFactory = _$LendingMarketProfileFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketProfileFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(
                  other.filters,
                  filters,
                )) &&
            (identical(other.extraProperties, extraProperties) ||
                const DeepCollectionEquality().equals(
                  other.extraProperties,
                  extraProperties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      const DeepCollectionEquality().hash(extraProperties) ^
      runtimeType.hashCode;
}

extension $LendingMarketProfileFilterExtension on LendingMarketProfileFilter {
  LendingMarketProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    LendingMarketProfileFilterCriteriaDto? filters,
    LendingMarketProfileExtraProperties? extraProperties,
  }) {
    return LendingMarketProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  LendingMarketProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<LendingMarketProfileFilterCriteriaDto>? filters,
    Wrapped<LendingMarketProfileExtraProperties?>? extraProperties,
  }) {
    return LendingMarketProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileQuery {
  const LendingMarketProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory LendingMarketProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileQueryFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileQueryToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <LendingMarketProfile>[])
  final List<LendingMarketProfile> resources;
  static const fromJsonFactory = _$LendingMarketProfileQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketProfileQuery &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $LendingMarketProfileQueryExtension on LendingMarketProfileQuery {
  LendingMarketProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<LendingMarketProfile>? resources,
  }) {
    return LendingMarketProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  LendingMarketProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<LendingMarketProfile>>? resources,
  }) {
    return LendingMarketProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingEModeCategoryProfileDoc {
  const LendingEModeCategoryProfileDoc({
    required this.dataType,
    required this.name,
    required this.ltv,
    required this.liquidationThreshold,
    required this.liquidationBonus,
    required this.isDeprecated,
    required this.id,
    required this.pk,
    this.ts,
  });

  factory LendingEModeCategoryProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$LendingEModeCategoryProfileDocFromJson(json);

  static const toJsonFactory = _$LendingEModeCategoryProfileDocToJson;
  Map<String, dynamic> toJson() => _$LendingEModeCategoryProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'isDeprecated')
  final bool isDeprecated;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$LendingEModeCategoryProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingEModeCategoryProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.ltv, ltv) ||
                const DeepCollectionEquality().equals(other.ltv, ltv)) &&
            (identical(other.liquidationThreshold, liquidationThreshold) ||
                const DeepCollectionEquality().equals(
                  other.liquidationThreshold,
                  liquidationThreshold,
                )) &&
            (identical(other.liquidationBonus, liquidationBonus) ||
                const DeepCollectionEquality().equals(
                  other.liquidationBonus,
                  liquidationBonus,
                )) &&
            (identical(other.isDeprecated, isDeprecated) ||
                const DeepCollectionEquality().equals(
                  other.isDeprecated,
                  isDeprecated,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(ltv) ^
      const DeepCollectionEquality().hash(liquidationThreshold) ^
      const DeepCollectionEquality().hash(liquidationBonus) ^
      const DeepCollectionEquality().hash(isDeprecated) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $LendingEModeCategoryProfileDocExtension
    on LendingEModeCategoryProfileDoc {
  LendingEModeCategoryProfileDoc copyWith({
    enums.LendingDataType? dataType,
    String? name,
    String? ltv,
    String? liquidationThreshold,
    String? liquidationBonus,
    bool? isDeprecated,
    String? id,
    String? pk,
    double? ts,
  }) {
    return LendingEModeCategoryProfileDoc(
      dataType: dataType ?? this.dataType,
      name: name ?? this.name,
      ltv: ltv ?? this.ltv,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      isDeprecated: isDeprecated ?? this.isDeprecated,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  LendingEModeCategoryProfileDoc copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? name,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationThreshold,
    Wrapped<String>? liquidationBonus,
    Wrapped<bool>? isDeprecated,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
  }) {
    return LendingEModeCategoryProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      name: (name != null ? name.value : this.name),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      isDeprecated: (isDeprecated != null
          ? isDeprecated.value
          : this.isDeprecated),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PickTypeClass {
  const PickTypeClass({
    required this.token,
    required this.name,
    required this.decimals,
    required this.address,
    required this.baseRate,
    required this.maxBorrowRate,
    required this.slopeRate1,
    required this.slopeRate2,
    required this.slopeRate3,
    required this.midUsageRate,
    required this.optimalUsageRate,
    required this.reserveFactor,
    required this.liquidationFee,
    required this.ltv,
    required this.liquidationBonus,
    required this.liquidationThreshold,
    required this.rewardsReserve,
    required this.reserves,
    required this.supplyAmount,
    required this.supplyAmountScaled,
    required this.borrowAmount,
    required this.borrowAmountScaled,
    required this.supplyCap,
    required this.borrowCap,
    required this.supplyIndex,
    required this.borrowIndex,
    required this.timestamp,
    required this.borrowApy,
    required this.supplyApy,
    required this.utilizationRate,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.isolated,
    required this.maxDebtUsd,
    this.debtCeiling,
    required this.siloed,
    required this.flashLoan,
    required this.flashLoanFee,
    required this.canBorrowInIsolation,
    required this.oracleProvider,
    required this.oraclePrice,
    this.extraApy,
  });

  factory PickTypeClass.fromJson(Map<String, dynamic> json) =>
      _$PickTypeClassFromJson(json);

  static const toJsonFactory = _$PickTypeClassToJson;
  Map<String, dynamic> toJson() => _$PickTypeClassToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'baseRate')
  final String baseRate;
  @JsonKey(name: 'maxBorrowRate')
  final String maxBorrowRate;
  @JsonKey(name: 'slopeRate1')
  final String slopeRate1;
  @JsonKey(name: 'slopeRate2')
  final String slopeRate2;
  @JsonKey(name: 'slopeRate3')
  final String slopeRate3;
  @JsonKey(name: 'midUsageRate')
  final String midUsageRate;
  @JsonKey(name: 'optimalUsageRate')
  final String optimalUsageRate;
  @JsonKey(name: 'reserveFactor')
  final String reserveFactor;
  @JsonKey(name: 'liquidationFee')
  final String liquidationFee;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'rewardsReserve')
  final Object rewardsReserve;
  @JsonKey(name: 'reserves')
  final Object reserves;
  @JsonKey(name: 'supplyAmount')
  final Object supplyAmount;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmount')
  final Object borrowAmount;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'supplyCap')
  final String supplyCap;
  @JsonKey(name: 'borrowCap')
  final String borrowCap;
  @JsonKey(name: 'supplyIndex')
  final Object supplyIndex;
  @JsonKey(name: 'borrowIndex')
  final Object borrowIndex;
  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'borrowApy')
  final Object borrowApy;
  @JsonKey(name: 'supplyApy')
  final Object supplyApy;
  @JsonKey(name: 'utilizationRate')
  final Object utilizationRate;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'isolated')
  final bool isolated;
  @JsonKey(name: 'maxDebtUsd')
  final Object maxDebtUsd;
  @JsonKey(name: 'debtCeiling')
  final String? debtCeiling;
  @JsonKey(name: 'siloed')
  final bool siloed;
  @JsonKey(name: 'flashLoan')
  final bool flashLoan;
  @JsonKey(name: 'flashLoanFee')
  final String flashLoanFee;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool canBorrowInIsolation;
  @JsonKey(name: 'oracleProvider')
  final LendingOracleUpdateStruct oracleProvider;
  @JsonKey(name: 'oraclePrice')
  final String oraclePrice;
  @JsonKey(name: 'extraApy')
  final MarketExtraApy? extraApy;
  static const fromJsonFactory = _$PickTypeClassFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PickTypeClass &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.decimals, decimals) ||
                const DeepCollectionEquality().equals(
                  other.decimals,
                  decimals,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.baseRate, baseRate) ||
                const DeepCollectionEquality().equals(
                  other.baseRate,
                  baseRate,
                )) &&
            (identical(other.maxBorrowRate, maxBorrowRate) ||
                const DeepCollectionEquality().equals(
                  other.maxBorrowRate,
                  maxBorrowRate,
                )) &&
            (identical(other.slopeRate1, slopeRate1) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate1,
                  slopeRate1,
                )) &&
            (identical(other.slopeRate2, slopeRate2) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate2,
                  slopeRate2,
                )) &&
            (identical(other.slopeRate3, slopeRate3) ||
                const DeepCollectionEquality().equals(
                  other.slopeRate3,
                  slopeRate3,
                )) &&
            (identical(other.midUsageRate, midUsageRate) ||
                const DeepCollectionEquality().equals(
                  other.midUsageRate,
                  midUsageRate,
                )) &&
            (identical(other.optimalUsageRate, optimalUsageRate) ||
                const DeepCollectionEquality().equals(
                  other.optimalUsageRate,
                  optimalUsageRate,
                )) &&
            (identical(other.reserveFactor, reserveFactor) ||
                const DeepCollectionEquality().equals(
                  other.reserveFactor,
                  reserveFactor,
                )) &&
            (identical(other.liquidationFee, liquidationFee) ||
                const DeepCollectionEquality().equals(
                  other.liquidationFee,
                  liquidationFee,
                )) &&
            (identical(other.ltv, ltv) ||
                const DeepCollectionEquality().equals(other.ltv, ltv)) &&
            (identical(other.liquidationBonus, liquidationBonus) ||
                const DeepCollectionEquality().equals(
                  other.liquidationBonus,
                  liquidationBonus,
                )) &&
            (identical(other.liquidationThreshold, liquidationThreshold) ||
                const DeepCollectionEquality().equals(
                  other.liquidationThreshold,
                  liquidationThreshold,
                )) &&
            (identical(other.rewardsReserve, rewardsReserve) ||
                const DeepCollectionEquality().equals(
                  other.rewardsReserve,
                  rewardsReserve,
                )) &&
            (identical(other.reserves, reserves) ||
                const DeepCollectionEquality().equals(
                  other.reserves,
                  reserves,
                )) &&
            (identical(other.supplyAmount, supplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmount,
                  supplyAmount,
                )) &&
            (identical(other.supplyAmountScaled, supplyAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmountScaled,
                  supplyAmountScaled,
                )) &&
            (identical(other.borrowAmount, borrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmount,
                  borrowAmount,
                )) &&
            (identical(other.borrowAmountScaled, borrowAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmountScaled,
                  borrowAmountScaled,
                )) &&
            (identical(other.supplyCap, supplyCap) ||
                const DeepCollectionEquality().equals(
                  other.supplyCap,
                  supplyCap,
                )) &&
            (identical(other.borrowCap, borrowCap) ||
                const DeepCollectionEquality().equals(
                  other.borrowCap,
                  borrowCap,
                )) &&
            (identical(other.supplyIndex, supplyIndex) ||
                const DeepCollectionEquality().equals(
                  other.supplyIndex,
                  supplyIndex,
                )) &&
            (identical(other.borrowIndex, borrowIndex) ||
                const DeepCollectionEquality().equals(
                  other.borrowIndex,
                  borrowIndex,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.borrowApy, borrowApy) ||
                const DeepCollectionEquality().equals(
                  other.borrowApy,
                  borrowApy,
                )) &&
            (identical(other.supplyApy, supplyApy) ||
                const DeepCollectionEquality().equals(
                  other.supplyApy,
                  supplyApy,
                )) &&
            (identical(other.utilizationRate, utilizationRate) ||
                const DeepCollectionEquality().equals(
                  other.utilizationRate,
                  utilizationRate,
                )) &&
            (identical(other.canBeCollateral, canBeCollateral) ||
                const DeepCollectionEquality().equals(
                  other.canBeCollateral,
                  canBeCollateral,
                )) &&
            (identical(other.canBeBorrowed, canBeBorrowed) ||
                const DeepCollectionEquality().equals(
                  other.canBeBorrowed,
                  canBeBorrowed,
                )) &&
            (identical(other.isolated, isolated) ||
                const DeepCollectionEquality().equals(
                  other.isolated,
                  isolated,
                )) &&
            (identical(other.maxDebtUsd, maxDebtUsd) ||
                const DeepCollectionEquality().equals(
                  other.maxDebtUsd,
                  maxDebtUsd,
                )) &&
            (identical(other.debtCeiling, debtCeiling) ||
                const DeepCollectionEquality().equals(
                  other.debtCeiling,
                  debtCeiling,
                )) &&
            (identical(other.siloed, siloed) ||
                const DeepCollectionEquality().equals(other.siloed, siloed)) &&
            (identical(other.flashLoan, flashLoan) ||
                const DeepCollectionEquality().equals(
                  other.flashLoan,
                  flashLoan,
                )) &&
            (identical(other.flashLoanFee, flashLoanFee) ||
                const DeepCollectionEquality().equals(
                  other.flashLoanFee,
                  flashLoanFee,
                )) &&
            (identical(other.canBorrowInIsolation, canBorrowInIsolation) ||
                const DeepCollectionEquality().equals(
                  other.canBorrowInIsolation,
                  canBorrowInIsolation,
                )) &&
            (identical(other.oracleProvider, oracleProvider) ||
                const DeepCollectionEquality().equals(
                  other.oracleProvider,
                  oracleProvider,
                )) &&
            (identical(other.oraclePrice, oraclePrice) ||
                const DeepCollectionEquality().equals(
                  other.oraclePrice,
                  oraclePrice,
                )) &&
            (identical(other.extraApy, extraApy) ||
                const DeepCollectionEquality().equals(
                  other.extraApy,
                  extraApy,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(decimals) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(baseRate) ^
      const DeepCollectionEquality().hash(maxBorrowRate) ^
      const DeepCollectionEquality().hash(slopeRate1) ^
      const DeepCollectionEquality().hash(slopeRate2) ^
      const DeepCollectionEquality().hash(slopeRate3) ^
      const DeepCollectionEquality().hash(midUsageRate) ^
      const DeepCollectionEquality().hash(optimalUsageRate) ^
      const DeepCollectionEquality().hash(reserveFactor) ^
      const DeepCollectionEquality().hash(liquidationFee) ^
      const DeepCollectionEquality().hash(ltv) ^
      const DeepCollectionEquality().hash(liquidationBonus) ^
      const DeepCollectionEquality().hash(liquidationThreshold) ^
      const DeepCollectionEquality().hash(rewardsReserve) ^
      const DeepCollectionEquality().hash(reserves) ^
      const DeepCollectionEquality().hash(supplyAmount) ^
      const DeepCollectionEquality().hash(supplyAmountScaled) ^
      const DeepCollectionEquality().hash(borrowAmount) ^
      const DeepCollectionEquality().hash(borrowAmountScaled) ^
      const DeepCollectionEquality().hash(supplyCap) ^
      const DeepCollectionEquality().hash(borrowCap) ^
      const DeepCollectionEquality().hash(supplyIndex) ^
      const DeepCollectionEquality().hash(borrowIndex) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(borrowApy) ^
      const DeepCollectionEquality().hash(supplyApy) ^
      const DeepCollectionEquality().hash(utilizationRate) ^
      const DeepCollectionEquality().hash(canBeCollateral) ^
      const DeepCollectionEquality().hash(canBeBorrowed) ^
      const DeepCollectionEquality().hash(isolated) ^
      const DeepCollectionEquality().hash(maxDebtUsd) ^
      const DeepCollectionEquality().hash(debtCeiling) ^
      const DeepCollectionEquality().hash(siloed) ^
      const DeepCollectionEquality().hash(flashLoan) ^
      const DeepCollectionEquality().hash(flashLoanFee) ^
      const DeepCollectionEquality().hash(canBorrowInIsolation) ^
      const DeepCollectionEquality().hash(oracleProvider) ^
      const DeepCollectionEquality().hash(oraclePrice) ^
      const DeepCollectionEquality().hash(extraApy) ^
      runtimeType.hashCode;
}

extension $PickTypeClassExtension on PickTypeClass {
  PickTypeClass copyWith({
    String? token,
    String? name,
    double? decimals,
    String? address,
    String? baseRate,
    String? maxBorrowRate,
    String? slopeRate1,
    String? slopeRate2,
    String? slopeRate3,
    String? midUsageRate,
    String? optimalUsageRate,
    String? reserveFactor,
    String? liquidationFee,
    String? ltv,
    String? liquidationBonus,
    String? liquidationThreshold,
    Object? rewardsReserve,
    Object? reserves,
    Object? supplyAmount,
    Object? supplyAmountScaled,
    Object? borrowAmount,
    Object? borrowAmountScaled,
    String? supplyCap,
    String? borrowCap,
    Object? supplyIndex,
    Object? borrowIndex,
    Object? timestamp,
    Object? borrowApy,
    Object? supplyApy,
    Object? utilizationRate,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? isolated,
    Object? maxDebtUsd,
    String? debtCeiling,
    bool? siloed,
    bool? flashLoan,
    String? flashLoanFee,
    bool? canBorrowInIsolation,
    LendingOracleUpdateStruct? oracleProvider,
    String? oraclePrice,
    MarketExtraApy? extraApy,
  }) {
    return PickTypeClass(
      token: token ?? this.token,
      name: name ?? this.name,
      decimals: decimals ?? this.decimals,
      address: address ?? this.address,
      baseRate: baseRate ?? this.baseRate,
      maxBorrowRate: maxBorrowRate ?? this.maxBorrowRate,
      slopeRate1: slopeRate1 ?? this.slopeRate1,
      slopeRate2: slopeRate2 ?? this.slopeRate2,
      slopeRate3: slopeRate3 ?? this.slopeRate3,
      midUsageRate: midUsageRate ?? this.midUsageRate,
      optimalUsageRate: optimalUsageRate ?? this.optimalUsageRate,
      reserveFactor: reserveFactor ?? this.reserveFactor,
      liquidationFee: liquidationFee ?? this.liquidationFee,
      ltv: ltv ?? this.ltv,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      rewardsReserve: rewardsReserve ?? this.rewardsReserve,
      reserves: reserves ?? this.reserves,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      supplyCap: supplyCap ?? this.supplyCap,
      borrowCap: borrowCap ?? this.borrowCap,
      supplyIndex: supplyIndex ?? this.supplyIndex,
      borrowIndex: borrowIndex ?? this.borrowIndex,
      timestamp: timestamp ?? this.timestamp,
      borrowApy: borrowApy ?? this.borrowApy,
      supplyApy: supplyApy ?? this.supplyApy,
      utilizationRate: utilizationRate ?? this.utilizationRate,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      isolated: isolated ?? this.isolated,
      maxDebtUsd: maxDebtUsd ?? this.maxDebtUsd,
      debtCeiling: debtCeiling ?? this.debtCeiling,
      siloed: siloed ?? this.siloed,
      flashLoan: flashLoan ?? this.flashLoan,
      flashLoanFee: flashLoanFee ?? this.flashLoanFee,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      oracleProvider: oracleProvider ?? this.oracleProvider,
      oraclePrice: oraclePrice ?? this.oraclePrice,
      extraApy: extraApy ?? this.extraApy,
    );
  }

  PickTypeClass copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<String>? name,
    Wrapped<double>? decimals,
    Wrapped<String>? address,
    Wrapped<String>? baseRate,
    Wrapped<String>? maxBorrowRate,
    Wrapped<String>? slopeRate1,
    Wrapped<String>? slopeRate2,
    Wrapped<String>? slopeRate3,
    Wrapped<String>? midUsageRate,
    Wrapped<String>? optimalUsageRate,
    Wrapped<String>? reserveFactor,
    Wrapped<String>? liquidationFee,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationBonus,
    Wrapped<String>? liquidationThreshold,
    Wrapped<Object>? rewardsReserve,
    Wrapped<Object>? reserves,
    Wrapped<Object>? supplyAmount,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmount,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<String>? supplyCap,
    Wrapped<String>? borrowCap,
    Wrapped<Object>? supplyIndex,
    Wrapped<Object>? borrowIndex,
    Wrapped<Object>? timestamp,
    Wrapped<Object>? borrowApy,
    Wrapped<Object>? supplyApy,
    Wrapped<Object>? utilizationRate,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<bool>? isolated,
    Wrapped<Object>? maxDebtUsd,
    Wrapped<String?>? debtCeiling,
    Wrapped<bool>? siloed,
    Wrapped<bool>? flashLoan,
    Wrapped<String>? flashLoanFee,
    Wrapped<bool>? canBorrowInIsolation,
    Wrapped<LendingOracleUpdateStruct>? oracleProvider,
    Wrapped<String>? oraclePrice,
    Wrapped<MarketExtraApy?>? extraApy,
  }) {
    return PickTypeClass(
      token: (token != null ? token.value : this.token),
      name: (name != null ? name.value : this.name),
      decimals: (decimals != null ? decimals.value : this.decimals),
      address: (address != null ? address.value : this.address),
      baseRate: (baseRate != null ? baseRate.value : this.baseRate),
      maxBorrowRate: (maxBorrowRate != null
          ? maxBorrowRate.value
          : this.maxBorrowRate),
      slopeRate1: (slopeRate1 != null ? slopeRate1.value : this.slopeRate1),
      slopeRate2: (slopeRate2 != null ? slopeRate2.value : this.slopeRate2),
      slopeRate3: (slopeRate3 != null ? slopeRate3.value : this.slopeRate3),
      midUsageRate: (midUsageRate != null
          ? midUsageRate.value
          : this.midUsageRate),
      optimalUsageRate: (optimalUsageRate != null
          ? optimalUsageRate.value
          : this.optimalUsageRate),
      reserveFactor: (reserveFactor != null
          ? reserveFactor.value
          : this.reserveFactor),
      liquidationFee: (liquidationFee != null
          ? liquidationFee.value
          : this.liquidationFee),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      rewardsReserve: (rewardsReserve != null
          ? rewardsReserve.value
          : this.rewardsReserve),
      reserves: (reserves != null ? reserves.value : this.reserves),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      supplyCap: (supplyCap != null ? supplyCap.value : this.supplyCap),
      borrowCap: (borrowCap != null ? borrowCap.value : this.borrowCap),
      supplyIndex: (supplyIndex != null ? supplyIndex.value : this.supplyIndex),
      borrowIndex: (borrowIndex != null ? borrowIndex.value : this.borrowIndex),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      borrowApy: (borrowApy != null ? borrowApy.value : this.borrowApy),
      supplyApy: (supplyApy != null ? supplyApy.value : this.supplyApy),
      utilizationRate: (utilizationRate != null
          ? utilizationRate.value
          : this.utilizationRate),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      isolated: (isolated != null ? isolated.value : this.isolated),
      maxDebtUsd: (maxDebtUsd != null ? maxDebtUsd.value : this.maxDebtUsd),
      debtCeiling: (debtCeiling != null ? debtCeiling.value : this.debtCeiling),
      siloed: (siloed != null ? siloed.value : this.siloed),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      flashLoanFee: (flashLoanFee != null
          ? flashLoanFee.value
          : this.flashLoanFee),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      oracleProvider: (oracleProvider != null
          ? oracleProvider.value
          : this.oracleProvider),
      oraclePrice: (oraclePrice != null ? oraclePrice.value : this.oraclePrice),
      extraApy: (extraApy != null ? extraApy.value : this.extraApy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingAccountProfile {
  const LendingAccountProfile({
    required this.dataType,
    required this.identifier,
    required this.nonce,
    required this.token,
    required this.supplyAmountScaled,
    required this.borrowAmountScaled,
    required this.supplyIndex,
    required this.borrowIndex,
    required this.entryLiquidationThreshold,
    required this.entryLiquidationBonus,
    required this.entryLiquidationFee,
    required this.entryLtv,
    this.isolated,
    required this.positionMode,
    this.eModeCategory,
    required this.address,
    this.leverageInitialSupply,
    this.leverageInitialSupplyPrice,
    this.leverageInitialBorrow,
    this.leverageInitialBorrowPrice,
    required this.id,
    required this.pk,
    required this.ts,
    required this.supplyAmount,
    required this.borrowAmount,
    this.eModeCategoryProfile,
    required this.marketProfile,
  });

  factory LendingAccountProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingAccountProfileFromJson(json);

  static const toJsonFactory = _$LendingAccountProfileToJson;
  Map<String, dynamic> toJson() => _$LendingAccountProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'supplyIndex')
  final Object supplyIndex;
  @JsonKey(name: 'borrowIndex')
  final Object borrowIndex;
  @JsonKey(name: 'entryLiquidationThreshold')
  final String entryLiquidationThreshold;
  @JsonKey(name: 'entryLiquidationBonus')
  final String entryLiquidationBonus;
  @JsonKey(name: 'entryLiquidationFee')
  final String entryLiquidationFee;
  @JsonKey(name: 'entryLtv')
  final String entryLtv;
  @JsonKey(name: 'isolated')
  final bool? isolated;
  @JsonKey(
    name: 'positionMode',
    toJson: positionModeToJson,
    fromJson: positionModeFromJson,
  )
  final enums.PositionMode positionMode;
  @JsonKey(name: 'eModeCategory')
  final String? eModeCategory;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'leverageInitialSupply')
  final double? leverageInitialSupply;
  @JsonKey(name: 'leverageInitialSupplyPrice')
  final double? leverageInitialSupplyPrice;
  @JsonKey(name: 'leverageInitialBorrow')
  final double? leverageInitialBorrow;
  @JsonKey(name: 'leverageInitialBorrowPrice')
  final double? leverageInitialBorrowPrice;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'supplyAmount')
  final String supplyAmount;
  @JsonKey(name: 'borrowAmount')
  final String borrowAmount;
  @JsonKey(name: 'eModeCategoryProfile')
  final LendingEModeCategoryProfileDoc? eModeCategoryProfile;
  @JsonKey(name: 'marketProfile')
  final PickTypeClass marketProfile;
  static const fromJsonFactory = _$LendingAccountProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingAccountProfile &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.supplyAmountScaled, supplyAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmountScaled,
                  supplyAmountScaled,
                )) &&
            (identical(other.borrowAmountScaled, borrowAmountScaled) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmountScaled,
                  borrowAmountScaled,
                )) &&
            (identical(other.supplyIndex, supplyIndex) ||
                const DeepCollectionEquality().equals(
                  other.supplyIndex,
                  supplyIndex,
                )) &&
            (identical(other.borrowIndex, borrowIndex) ||
                const DeepCollectionEquality().equals(
                  other.borrowIndex,
                  borrowIndex,
                )) &&
            (identical(
                  other.entryLiquidationThreshold,
                  entryLiquidationThreshold,
                ) ||
                const DeepCollectionEquality().equals(
                  other.entryLiquidationThreshold,
                  entryLiquidationThreshold,
                )) &&
            (identical(other.entryLiquidationBonus, entryLiquidationBonus) ||
                const DeepCollectionEquality().equals(
                  other.entryLiquidationBonus,
                  entryLiquidationBonus,
                )) &&
            (identical(other.entryLiquidationFee, entryLiquidationFee) ||
                const DeepCollectionEquality().equals(
                  other.entryLiquidationFee,
                  entryLiquidationFee,
                )) &&
            (identical(other.entryLtv, entryLtv) ||
                const DeepCollectionEquality().equals(
                  other.entryLtv,
                  entryLtv,
                )) &&
            (identical(other.isolated, isolated) ||
                const DeepCollectionEquality().equals(
                  other.isolated,
                  isolated,
                )) &&
            (identical(other.positionMode, positionMode) ||
                const DeepCollectionEquality().equals(
                  other.positionMode,
                  positionMode,
                )) &&
            (identical(other.eModeCategory, eModeCategory) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategory,
                  eModeCategory,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.leverageInitialSupply, leverageInitialSupply) ||
                const DeepCollectionEquality().equals(
                  other.leverageInitialSupply,
                  leverageInitialSupply,
                )) &&
            (identical(
                  other.leverageInitialSupplyPrice,
                  leverageInitialSupplyPrice,
                ) ||
                const DeepCollectionEquality().equals(
                  other.leverageInitialSupplyPrice,
                  leverageInitialSupplyPrice,
                )) &&
            (identical(other.leverageInitialBorrow, leverageInitialBorrow) ||
                const DeepCollectionEquality().equals(
                  other.leverageInitialBorrow,
                  leverageInitialBorrow,
                )) &&
            (identical(
                  other.leverageInitialBorrowPrice,
                  leverageInitialBorrowPrice,
                ) ||
                const DeepCollectionEquality().equals(
                  other.leverageInitialBorrowPrice,
                  leverageInitialBorrowPrice,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.supplyAmount, supplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.supplyAmount,
                  supplyAmount,
                )) &&
            (identical(other.borrowAmount, borrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.borrowAmount,
                  borrowAmount,
                )) &&
            (identical(other.eModeCategoryProfile, eModeCategoryProfile) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategoryProfile,
                  eModeCategoryProfile,
                )) &&
            (identical(other.marketProfile, marketProfile) ||
                const DeepCollectionEquality().equals(
                  other.marketProfile,
                  marketProfile,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(supplyAmountScaled) ^
      const DeepCollectionEquality().hash(borrowAmountScaled) ^
      const DeepCollectionEquality().hash(supplyIndex) ^
      const DeepCollectionEquality().hash(borrowIndex) ^
      const DeepCollectionEquality().hash(entryLiquidationThreshold) ^
      const DeepCollectionEquality().hash(entryLiquidationBonus) ^
      const DeepCollectionEquality().hash(entryLiquidationFee) ^
      const DeepCollectionEquality().hash(entryLtv) ^
      const DeepCollectionEquality().hash(isolated) ^
      const DeepCollectionEquality().hash(positionMode) ^
      const DeepCollectionEquality().hash(eModeCategory) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(leverageInitialSupply) ^
      const DeepCollectionEquality().hash(leverageInitialSupplyPrice) ^
      const DeepCollectionEquality().hash(leverageInitialBorrow) ^
      const DeepCollectionEquality().hash(leverageInitialBorrowPrice) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(supplyAmount) ^
      const DeepCollectionEquality().hash(borrowAmount) ^
      const DeepCollectionEquality().hash(eModeCategoryProfile) ^
      const DeepCollectionEquality().hash(marketProfile) ^
      runtimeType.hashCode;
}

extension $LendingAccountProfileExtension on LendingAccountProfile {
  LendingAccountProfile copyWith({
    enums.LendingDataType? dataType,
    String? identifier,
    double? nonce,
    String? token,
    Object? supplyAmountScaled,
    Object? borrowAmountScaled,
    Object? supplyIndex,
    Object? borrowIndex,
    String? entryLiquidationThreshold,
    String? entryLiquidationBonus,
    String? entryLiquidationFee,
    String? entryLtv,
    bool? isolated,
    enums.PositionMode? positionMode,
    String? eModeCategory,
    String? address,
    double? leverageInitialSupply,
    double? leverageInitialSupplyPrice,
    double? leverageInitialBorrow,
    double? leverageInitialBorrowPrice,
    String? id,
    String? pk,
    double? ts,
    String? supplyAmount,
    String? borrowAmount,
    LendingEModeCategoryProfileDoc? eModeCategoryProfile,
    PickTypeClass? marketProfile,
  }) {
    return LendingAccountProfile(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      nonce: nonce ?? this.nonce,
      token: token ?? this.token,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      supplyIndex: supplyIndex ?? this.supplyIndex,
      borrowIndex: borrowIndex ?? this.borrowIndex,
      entryLiquidationThreshold:
          entryLiquidationThreshold ?? this.entryLiquidationThreshold,
      entryLiquidationBonus:
          entryLiquidationBonus ?? this.entryLiquidationBonus,
      entryLiquidationFee: entryLiquidationFee ?? this.entryLiquidationFee,
      entryLtv: entryLtv ?? this.entryLtv,
      isolated: isolated ?? this.isolated,
      positionMode: positionMode ?? this.positionMode,
      eModeCategory: eModeCategory ?? this.eModeCategory,
      address: address ?? this.address,
      leverageInitialSupply:
          leverageInitialSupply ?? this.leverageInitialSupply,
      leverageInitialSupplyPrice:
          leverageInitialSupplyPrice ?? this.leverageInitialSupplyPrice,
      leverageInitialBorrow:
          leverageInitialBorrow ?? this.leverageInitialBorrow,
      leverageInitialBorrowPrice:
          leverageInitialBorrowPrice ?? this.leverageInitialBorrowPrice,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      eModeCategoryProfile: eModeCategoryProfile ?? this.eModeCategoryProfile,
      marketProfile: marketProfile ?? this.marketProfile,
    );
  }

  LendingAccountProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<double>? nonce,
    Wrapped<String>? token,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<Object>? supplyIndex,
    Wrapped<Object>? borrowIndex,
    Wrapped<String>? entryLiquidationThreshold,
    Wrapped<String>? entryLiquidationBonus,
    Wrapped<String>? entryLiquidationFee,
    Wrapped<String>? entryLtv,
    Wrapped<bool?>? isolated,
    Wrapped<enums.PositionMode>? positionMode,
    Wrapped<String?>? eModeCategory,
    Wrapped<String>? address,
    Wrapped<double?>? leverageInitialSupply,
    Wrapped<double?>? leverageInitialSupplyPrice,
    Wrapped<double?>? leverageInitialBorrow,
    Wrapped<double?>? leverageInitialBorrowPrice,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<String>? supplyAmount,
    Wrapped<String>? borrowAmount,
    Wrapped<LendingEModeCategoryProfileDoc?>? eModeCategoryProfile,
    Wrapped<PickTypeClass>? marketProfile,
  }) {
    return LendingAccountProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      nonce: (nonce != null ? nonce.value : this.nonce),
      token: (token != null ? token.value : this.token),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      supplyIndex: (supplyIndex != null ? supplyIndex.value : this.supplyIndex),
      borrowIndex: (borrowIndex != null ? borrowIndex.value : this.borrowIndex),
      entryLiquidationThreshold: (entryLiquidationThreshold != null
          ? entryLiquidationThreshold.value
          : this.entryLiquidationThreshold),
      entryLiquidationBonus: (entryLiquidationBonus != null
          ? entryLiquidationBonus.value
          : this.entryLiquidationBonus),
      entryLiquidationFee: (entryLiquidationFee != null
          ? entryLiquidationFee.value
          : this.entryLiquidationFee),
      entryLtv: (entryLtv != null ? entryLtv.value : this.entryLtv),
      isolated: (isolated != null ? isolated.value : this.isolated),
      positionMode: (positionMode != null
          ? positionMode.value
          : this.positionMode),
      eModeCategory: (eModeCategory != null
          ? eModeCategory.value
          : this.eModeCategory),
      address: (address != null ? address.value : this.address),
      leverageInitialSupply: (leverageInitialSupply != null
          ? leverageInitialSupply.value
          : this.leverageInitialSupply),
      leverageInitialSupplyPrice: (leverageInitialSupplyPrice != null
          ? leverageInitialSupplyPrice.value
          : this.leverageInitialSupplyPrice),
      leverageInitialBorrow: (leverageInitialBorrow != null
          ? leverageInitialBorrow.value
          : this.leverageInitialBorrow),
      leverageInitialBorrowPrice: (leverageInitialBorrowPrice != null
          ? leverageInitialBorrowPrice.value
          : this.leverageInitialBorrowPrice),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      eModeCategoryProfile: (eModeCategoryProfile != null
          ? eModeCategoryProfile.value
          : this.eModeCategoryProfile),
      marketProfile: (marketProfile != null
          ? marketProfile.value
          : this.marketProfile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortLendingTokenEModeProfileDoc {
  const ShortLendingTokenEModeProfileDoc({
    required this.token,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.eModeCategory,
  });

  factory ShortLendingTokenEModeProfileDoc.fromJson(
    Map<String, dynamic> json,
  ) => _$ShortLendingTokenEModeProfileDocFromJson(json);

  static const toJsonFactory = _$ShortLendingTokenEModeProfileDocToJson;
  Map<String, dynamic> toJson() =>
      _$ShortLendingTokenEModeProfileDocToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'eModeCategory')
  final String eModeCategory;
  static const fromJsonFactory = _$ShortLendingTokenEModeProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortLendingTokenEModeProfileDoc &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.canBeCollateral, canBeCollateral) ||
                const DeepCollectionEquality().equals(
                  other.canBeCollateral,
                  canBeCollateral,
                )) &&
            (identical(other.canBeBorrowed, canBeBorrowed) ||
                const DeepCollectionEquality().equals(
                  other.canBeBorrowed,
                  canBeBorrowed,
                )) &&
            (identical(other.eModeCategory, eModeCategory) ||
                const DeepCollectionEquality().equals(
                  other.eModeCategory,
                  eModeCategory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(canBeCollateral) ^
      const DeepCollectionEquality().hash(canBeBorrowed) ^
      const DeepCollectionEquality().hash(eModeCategory) ^
      runtimeType.hashCode;
}

extension $ShortLendingTokenEModeProfileDocExtension
    on ShortLendingTokenEModeProfileDoc {
  ShortLendingTokenEModeProfileDoc copyWith({
    String? token,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    String? eModeCategory,
  }) {
    return ShortLendingTokenEModeProfileDoc(
      token: token ?? this.token,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      eModeCategory: eModeCategory ?? this.eModeCategory,
    );
  }

  ShortLendingTokenEModeProfileDoc copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<String>? eModeCategory,
  }) {
    return ShortLendingTokenEModeProfileDoc(
      token: (token != null ? token.value : this.token),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      eModeCategory: (eModeCategory != null
          ? eModeCategory.value
          : this.eModeCategory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingEModeCategoryProfile {
  const LendingEModeCategoryProfile({
    required this.dataType,
    required this.name,
    required this.ltv,
    required this.liquidationThreshold,
    required this.liquidationBonus,
    required this.isDeprecated,
    required this.id,
    required this.pk,
    this.ts,
    required this.eModeTokenProfiles,
  });

  factory LendingEModeCategoryProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingEModeCategoryProfileFromJson(json);

  static const toJsonFactory = _$LendingEModeCategoryProfileToJson;
  Map<String, dynamic> toJson() => _$LendingEModeCategoryProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'isDeprecated')
  final bool isDeprecated;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(
    name: 'eModeTokenProfiles',
    defaultValue: <ShortLendingTokenEModeProfileDoc>[],
  )
  final List<ShortLendingTokenEModeProfileDoc> eModeTokenProfiles;
  static const fromJsonFactory = _$LendingEModeCategoryProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingEModeCategoryProfile &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.ltv, ltv) ||
                const DeepCollectionEquality().equals(other.ltv, ltv)) &&
            (identical(other.liquidationThreshold, liquidationThreshold) ||
                const DeepCollectionEquality().equals(
                  other.liquidationThreshold,
                  liquidationThreshold,
                )) &&
            (identical(other.liquidationBonus, liquidationBonus) ||
                const DeepCollectionEquality().equals(
                  other.liquidationBonus,
                  liquidationBonus,
                )) &&
            (identical(other.isDeprecated, isDeprecated) ||
                const DeepCollectionEquality().equals(
                  other.isDeprecated,
                  isDeprecated,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.eModeTokenProfiles, eModeTokenProfiles) ||
                const DeepCollectionEquality().equals(
                  other.eModeTokenProfiles,
                  eModeTokenProfiles,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(ltv) ^
      const DeepCollectionEquality().hash(liquidationThreshold) ^
      const DeepCollectionEquality().hash(liquidationBonus) ^
      const DeepCollectionEquality().hash(isDeprecated) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(eModeTokenProfiles) ^
      runtimeType.hashCode;
}

extension $LendingEModeCategoryProfileExtension on LendingEModeCategoryProfile {
  LendingEModeCategoryProfile copyWith({
    enums.LendingDataType? dataType,
    String? name,
    String? ltv,
    String? liquidationThreshold,
    String? liquidationBonus,
    bool? isDeprecated,
    String? id,
    String? pk,
    double? ts,
    List<ShortLendingTokenEModeProfileDoc>? eModeTokenProfiles,
  }) {
    return LendingEModeCategoryProfile(
      dataType: dataType ?? this.dataType,
      name: name ?? this.name,
      ltv: ltv ?? this.ltv,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      isDeprecated: isDeprecated ?? this.isDeprecated,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      eModeTokenProfiles: eModeTokenProfiles ?? this.eModeTokenProfiles,
    );
  }

  LendingEModeCategoryProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? name,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationThreshold,
    Wrapped<String>? liquidationBonus,
    Wrapped<bool>? isDeprecated,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
    Wrapped<List<ShortLendingTokenEModeProfileDoc>>? eModeTokenProfiles,
  }) {
    return LendingEModeCategoryProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      name: (name != null ? name.value : this.name),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      isDeprecated: (isDeprecated != null
          ? isDeprecated.value
          : this.isDeprecated),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      eModeTokenProfiles: (eModeTokenProfiles != null
          ? eModeTokenProfiles.value
          : this.eModeTokenProfiles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketAnalyticsGraph {
  const LendingMarketAnalyticsGraph({
    required this.token,
    required this.timestamp,
    required this.minSupplyApy,
    required this.maxSupplyApy,
    required this.avgSupplyApy,
    required this.minBorrowApy,
    required this.maxBorrowApy,
    required this.avgBorrowApy,
    required this.minUtilizationRate,
    required this.maxUtilizationRate,
    required this.avgUtilizationRate,
    required this.minSupplyAmount,
    required this.maxSupplyAmount,
    required this.avgSupplyAmount,
    required this.minBorrowAmount,
    required this.maxBorrowAmount,
    required this.avgBorrowAmount,
  });

  factory LendingMarketAnalyticsGraph.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketAnalyticsGraphFromJson(json);

  static const toJsonFactory = _$LendingMarketAnalyticsGraphToJson;
  Map<String, dynamic> toJson() => _$LendingMarketAnalyticsGraphToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'timestamp', defaultValue: <List<Object?>>[])
  final List<List<Object?>> timestamp;
  @JsonKey(name: 'minSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minSupplyApy;
  @JsonKey(name: 'maxSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxSupplyApy;
  @JsonKey(name: 'avgSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgSupplyApy;
  @JsonKey(name: 'minBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minBorrowApy;
  @JsonKey(name: 'maxBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxBorrowApy;
  @JsonKey(name: 'avgBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgBorrowApy;
  @JsonKey(name: 'minUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minUtilizationRate;
  @JsonKey(name: 'maxUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxUtilizationRate;
  @JsonKey(name: 'avgUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgUtilizationRate;
  @JsonKey(name: 'minSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minSupplyAmount;
  @JsonKey(name: 'maxSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxSupplyAmount;
  @JsonKey(name: 'avgSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgSupplyAmount;
  @JsonKey(name: 'minBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minBorrowAmount;
  @JsonKey(name: 'maxBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxBorrowAmount;
  @JsonKey(name: 'avgBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgBorrowAmount;
  static const fromJsonFactory = _$LendingMarketAnalyticsGraphFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingMarketAnalyticsGraph &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.minSupplyApy, minSupplyApy) ||
                const DeepCollectionEquality().equals(
                  other.minSupplyApy,
                  minSupplyApy,
                )) &&
            (identical(other.maxSupplyApy, maxSupplyApy) ||
                const DeepCollectionEquality().equals(
                  other.maxSupplyApy,
                  maxSupplyApy,
                )) &&
            (identical(other.avgSupplyApy, avgSupplyApy) ||
                const DeepCollectionEquality().equals(
                  other.avgSupplyApy,
                  avgSupplyApy,
                )) &&
            (identical(other.minBorrowApy, minBorrowApy) ||
                const DeepCollectionEquality().equals(
                  other.minBorrowApy,
                  minBorrowApy,
                )) &&
            (identical(other.maxBorrowApy, maxBorrowApy) ||
                const DeepCollectionEquality().equals(
                  other.maxBorrowApy,
                  maxBorrowApy,
                )) &&
            (identical(other.avgBorrowApy, avgBorrowApy) ||
                const DeepCollectionEquality().equals(
                  other.avgBorrowApy,
                  avgBorrowApy,
                )) &&
            (identical(other.minUtilizationRate, minUtilizationRate) ||
                const DeepCollectionEquality().equals(
                  other.minUtilizationRate,
                  minUtilizationRate,
                )) &&
            (identical(other.maxUtilizationRate, maxUtilizationRate) ||
                const DeepCollectionEquality().equals(
                  other.maxUtilizationRate,
                  maxUtilizationRate,
                )) &&
            (identical(other.avgUtilizationRate, avgUtilizationRate) ||
                const DeepCollectionEquality().equals(
                  other.avgUtilizationRate,
                  avgUtilizationRate,
                )) &&
            (identical(other.minSupplyAmount, minSupplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.minSupplyAmount,
                  minSupplyAmount,
                )) &&
            (identical(other.maxSupplyAmount, maxSupplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxSupplyAmount,
                  maxSupplyAmount,
                )) &&
            (identical(other.avgSupplyAmount, avgSupplyAmount) ||
                const DeepCollectionEquality().equals(
                  other.avgSupplyAmount,
                  avgSupplyAmount,
                )) &&
            (identical(other.minBorrowAmount, minBorrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.minBorrowAmount,
                  minBorrowAmount,
                )) &&
            (identical(other.maxBorrowAmount, maxBorrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxBorrowAmount,
                  maxBorrowAmount,
                )) &&
            (identical(other.avgBorrowAmount, avgBorrowAmount) ||
                const DeepCollectionEquality().equals(
                  other.avgBorrowAmount,
                  avgBorrowAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(minSupplyApy) ^
      const DeepCollectionEquality().hash(maxSupplyApy) ^
      const DeepCollectionEquality().hash(avgSupplyApy) ^
      const DeepCollectionEquality().hash(minBorrowApy) ^
      const DeepCollectionEquality().hash(maxBorrowApy) ^
      const DeepCollectionEquality().hash(avgBorrowApy) ^
      const DeepCollectionEquality().hash(minUtilizationRate) ^
      const DeepCollectionEquality().hash(maxUtilizationRate) ^
      const DeepCollectionEquality().hash(avgUtilizationRate) ^
      const DeepCollectionEquality().hash(minSupplyAmount) ^
      const DeepCollectionEquality().hash(maxSupplyAmount) ^
      const DeepCollectionEquality().hash(avgSupplyAmount) ^
      const DeepCollectionEquality().hash(minBorrowAmount) ^
      const DeepCollectionEquality().hash(maxBorrowAmount) ^
      const DeepCollectionEquality().hash(avgBorrowAmount) ^
      runtimeType.hashCode;
}

extension $LendingMarketAnalyticsGraphExtension on LendingMarketAnalyticsGraph {
  LendingMarketAnalyticsGraph copyWith({
    String? token,
    List<List<Object?>>? timestamp,
    List<List<Object?>>? minSupplyApy,
    List<List<Object?>>? maxSupplyApy,
    List<List<Object?>>? avgSupplyApy,
    List<List<Object?>>? minBorrowApy,
    List<List<Object?>>? maxBorrowApy,
    List<List<Object?>>? avgBorrowApy,
    List<List<Object?>>? minUtilizationRate,
    List<List<Object?>>? maxUtilizationRate,
    List<List<Object?>>? avgUtilizationRate,
    List<List<Object?>>? minSupplyAmount,
    List<List<Object?>>? maxSupplyAmount,
    List<List<Object?>>? avgSupplyAmount,
    List<List<Object?>>? minBorrowAmount,
    List<List<Object?>>? maxBorrowAmount,
    List<List<Object?>>? avgBorrowAmount,
  }) {
    return LendingMarketAnalyticsGraph(
      token: token ?? this.token,
      timestamp: timestamp ?? this.timestamp,
      minSupplyApy: minSupplyApy ?? this.minSupplyApy,
      maxSupplyApy: maxSupplyApy ?? this.maxSupplyApy,
      avgSupplyApy: avgSupplyApy ?? this.avgSupplyApy,
      minBorrowApy: minBorrowApy ?? this.minBorrowApy,
      maxBorrowApy: maxBorrowApy ?? this.maxBorrowApy,
      avgBorrowApy: avgBorrowApy ?? this.avgBorrowApy,
      minUtilizationRate: minUtilizationRate ?? this.minUtilizationRate,
      maxUtilizationRate: maxUtilizationRate ?? this.maxUtilizationRate,
      avgUtilizationRate: avgUtilizationRate ?? this.avgUtilizationRate,
      minSupplyAmount: minSupplyAmount ?? this.minSupplyAmount,
      maxSupplyAmount: maxSupplyAmount ?? this.maxSupplyAmount,
      avgSupplyAmount: avgSupplyAmount ?? this.avgSupplyAmount,
      minBorrowAmount: minBorrowAmount ?? this.minBorrowAmount,
      maxBorrowAmount: maxBorrowAmount ?? this.maxBorrowAmount,
      avgBorrowAmount: avgBorrowAmount ?? this.avgBorrowAmount,
    );
  }

  LendingMarketAnalyticsGraph copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<List<List<Object?>>>? timestamp,
    Wrapped<List<List<Object?>>>? minSupplyApy,
    Wrapped<List<List<Object?>>>? maxSupplyApy,
    Wrapped<List<List<Object?>>>? avgSupplyApy,
    Wrapped<List<List<Object?>>>? minBorrowApy,
    Wrapped<List<List<Object?>>>? maxBorrowApy,
    Wrapped<List<List<Object?>>>? avgBorrowApy,
    Wrapped<List<List<Object?>>>? minUtilizationRate,
    Wrapped<List<List<Object?>>>? maxUtilizationRate,
    Wrapped<List<List<Object?>>>? avgUtilizationRate,
    Wrapped<List<List<Object?>>>? minSupplyAmount,
    Wrapped<List<List<Object?>>>? maxSupplyAmount,
    Wrapped<List<List<Object?>>>? avgSupplyAmount,
    Wrapped<List<List<Object?>>>? minBorrowAmount,
    Wrapped<List<List<Object?>>>? maxBorrowAmount,
    Wrapped<List<List<Object?>>>? avgBorrowAmount,
  }) {
    return LendingMarketAnalyticsGraph(
      token: (token != null ? token.value : this.token),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minSupplyApy: (minSupplyApy != null
          ? minSupplyApy.value
          : this.minSupplyApy),
      maxSupplyApy: (maxSupplyApy != null
          ? maxSupplyApy.value
          : this.maxSupplyApy),
      avgSupplyApy: (avgSupplyApy != null
          ? avgSupplyApy.value
          : this.avgSupplyApy),
      minBorrowApy: (minBorrowApy != null
          ? minBorrowApy.value
          : this.minBorrowApy),
      maxBorrowApy: (maxBorrowApy != null
          ? maxBorrowApy.value
          : this.maxBorrowApy),
      avgBorrowApy: (avgBorrowApy != null
          ? avgBorrowApy.value
          : this.avgBorrowApy),
      minUtilizationRate: (minUtilizationRate != null
          ? minUtilizationRate.value
          : this.minUtilizationRate),
      maxUtilizationRate: (maxUtilizationRate != null
          ? maxUtilizationRate.value
          : this.maxUtilizationRate),
      avgUtilizationRate: (avgUtilizationRate != null
          ? avgUtilizationRate.value
          : this.avgUtilizationRate),
      minSupplyAmount: (minSupplyAmount != null
          ? minSupplyAmount.value
          : this.minSupplyAmount),
      maxSupplyAmount: (maxSupplyAmount != null
          ? maxSupplyAmount.value
          : this.maxSupplyAmount),
      avgSupplyAmount: (avgSupplyAmount != null
          ? avgSupplyAmount.value
          : this.avgSupplyAmount),
      minBorrowAmount: (minBorrowAmount != null
          ? minBorrowAmount.value
          : this.minBorrowAmount),
      maxBorrowAmount: (maxBorrowAmount != null
          ? maxBorrowAmount.value
          : this.maxBorrowAmount),
      avgBorrowAmount: (avgBorrowAmount != null
          ? avgBorrowAmount.value
          : this.avgBorrowAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OwnerDto {
  const OwnerDto({
    required this.username,
    required this.address,
    required this.profile,
  });

  factory OwnerDto.fromJson(Map<String, dynamic> json) =>
      _$OwnerDtoFromJson(json);

  static const toJsonFactory = _$OwnerDtoToJson;
  Map<String, dynamic> toJson() => _$OwnerDtoToJson(this);

  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String profile;
  static const fromJsonFactory = _$OwnerDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OwnerDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(profile) ^
      runtimeType.hashCode;
}

extension $OwnerDtoExtension on OwnerDto {
  OwnerDto copyWith({String? username, String? address, String? profile}) {
    return OwnerDto(
      username: username ?? this.username,
      address: address ?? this.address,
      profile: profile ?? this.profile,
    );
  }

  OwnerDto copyWithWrapped({
    Wrapped<String>? username,
    Wrapped<String>? address,
    Wrapped<String>? profile,
  }) {
    return OwnerDto(
      username: (username != null ? username.value : this.username),
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingPositionStatus {
  const LendingPositionStatus({
    required this.position,
    required this.identifier,
    required this.supplied,
    required this.borrowed,
    required this.healthFactor,
    required this.wallet,
  });

  factory LendingPositionStatus.fromJson(Map<String, dynamic> json) =>
      _$LendingPositionStatusFromJson(json);

  static const toJsonFactory = _$LendingPositionStatusToJson;
  Map<String, dynamic> toJson() => _$LendingPositionStatusToJson(this);

  @JsonKey(name: 'position')
  final double position;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'supplied')
  final double supplied;
  @JsonKey(name: 'borrowed')
  final double borrowed;
  @JsonKey(name: 'healthFactor')
  final double healthFactor;
  @JsonKey(name: 'wallet')
  final OwnerDto wallet;
  static const fromJsonFactory = _$LendingPositionStatusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingPositionStatus &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.supplied, supplied) ||
                const DeepCollectionEquality().equals(
                  other.supplied,
                  supplied,
                )) &&
            (identical(other.borrowed, borrowed) ||
                const DeepCollectionEquality().equals(
                  other.borrowed,
                  borrowed,
                )) &&
            (identical(other.healthFactor, healthFactor) ||
                const DeepCollectionEquality().equals(
                  other.healthFactor,
                  healthFactor,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(supplied) ^
      const DeepCollectionEquality().hash(borrowed) ^
      const DeepCollectionEquality().hash(healthFactor) ^
      const DeepCollectionEquality().hash(wallet) ^
      runtimeType.hashCode;
}

extension $LendingPositionStatusExtension on LendingPositionStatus {
  LendingPositionStatus copyWith({
    double? position,
    String? identifier,
    double? supplied,
    double? borrowed,
    double? healthFactor,
    OwnerDto? wallet,
  }) {
    return LendingPositionStatus(
      position: position ?? this.position,
      identifier: identifier ?? this.identifier,
      supplied: supplied ?? this.supplied,
      borrowed: borrowed ?? this.borrowed,
      healthFactor: healthFactor ?? this.healthFactor,
      wallet: wallet ?? this.wallet,
    );
  }

  LendingPositionStatus copyWithWrapped({
    Wrapped<double>? position,
    Wrapped<String>? identifier,
    Wrapped<double>? supplied,
    Wrapped<double>? borrowed,
    Wrapped<double>? healthFactor,
    Wrapped<OwnerDto>? wallet,
  }) {
    return LendingPositionStatus(
      position: (position != null ? position.value : this.position),
      identifier: (identifier != null ? identifier.value : this.identifier),
      supplied: (supplied != null ? supplied.value : this.supplied),
      borrowed: (borrowed != null ? borrowed.value : this.borrowed),
      healthFactor: (healthFactor != null
          ? healthFactor.value
          : this.healthFactor),
      wallet: (wallet != null ? wallet.value : this.wallet),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingOverallStats {
  const LendingOverallStats({
    required this.topMarkets,
    required this.marketCount,
    required this.supplied,
    required this.participantsCount,
    required this.bestApy,
    required this.borrowed,
    required this.suppliedMargin,
    required this.borrowedMargin,
  });

  factory LendingOverallStats.fromJson(Map<String, dynamic> json) =>
      _$LendingOverallStatsFromJson(json);

  static const toJsonFactory = _$LendingOverallStatsToJson;
  Map<String, dynamic> toJson() => _$LendingOverallStatsToJson(this);

  @JsonKey(name: 'topMarkets', defaultValue: <String>[])
  final List<String> topMarkets;
  @JsonKey(name: 'marketCount')
  final double marketCount;
  @JsonKey(name: 'supplied')
  final double supplied;
  @JsonKey(name: 'participantsCount')
  final double participantsCount;
  @JsonKey(name: 'bestApy')
  final double bestApy;
  @JsonKey(name: 'borrowed')
  final double borrowed;
  @JsonKey(name: 'suppliedMargin')
  final double suppliedMargin;
  @JsonKey(name: 'borrowedMargin')
  final double borrowedMargin;
  static const fromJsonFactory = _$LendingOverallStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingOverallStats &&
            (identical(other.topMarkets, topMarkets) ||
                const DeepCollectionEquality().equals(
                  other.topMarkets,
                  topMarkets,
                )) &&
            (identical(other.marketCount, marketCount) ||
                const DeepCollectionEquality().equals(
                  other.marketCount,
                  marketCount,
                )) &&
            (identical(other.supplied, supplied) ||
                const DeepCollectionEquality().equals(
                  other.supplied,
                  supplied,
                )) &&
            (identical(other.participantsCount, participantsCount) ||
                const DeepCollectionEquality().equals(
                  other.participantsCount,
                  participantsCount,
                )) &&
            (identical(other.bestApy, bestApy) ||
                const DeepCollectionEquality().equals(
                  other.bestApy,
                  bestApy,
                )) &&
            (identical(other.borrowed, borrowed) ||
                const DeepCollectionEquality().equals(
                  other.borrowed,
                  borrowed,
                )) &&
            (identical(other.suppliedMargin, suppliedMargin) ||
                const DeepCollectionEquality().equals(
                  other.suppliedMargin,
                  suppliedMargin,
                )) &&
            (identical(other.borrowedMargin, borrowedMargin) ||
                const DeepCollectionEquality().equals(
                  other.borrowedMargin,
                  borrowedMargin,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(topMarkets) ^
      const DeepCollectionEquality().hash(marketCount) ^
      const DeepCollectionEquality().hash(supplied) ^
      const DeepCollectionEquality().hash(participantsCount) ^
      const DeepCollectionEquality().hash(bestApy) ^
      const DeepCollectionEquality().hash(borrowed) ^
      const DeepCollectionEquality().hash(suppliedMargin) ^
      const DeepCollectionEquality().hash(borrowedMargin) ^
      runtimeType.hashCode;
}

extension $LendingOverallStatsExtension on LendingOverallStats {
  LendingOverallStats copyWith({
    List<String>? topMarkets,
    double? marketCount,
    double? supplied,
    double? participantsCount,
    double? bestApy,
    double? borrowed,
    double? suppliedMargin,
    double? borrowedMargin,
  }) {
    return LendingOverallStats(
      topMarkets: topMarkets ?? this.topMarkets,
      marketCount: marketCount ?? this.marketCount,
      supplied: supplied ?? this.supplied,
      participantsCount: participantsCount ?? this.participantsCount,
      bestApy: bestApy ?? this.bestApy,
      borrowed: borrowed ?? this.borrowed,
      suppliedMargin: suppliedMargin ?? this.suppliedMargin,
      borrowedMargin: borrowedMargin ?? this.borrowedMargin,
    );
  }

  LendingOverallStats copyWithWrapped({
    Wrapped<List<String>>? topMarkets,
    Wrapped<double>? marketCount,
    Wrapped<double>? supplied,
    Wrapped<double>? participantsCount,
    Wrapped<double>? bestApy,
    Wrapped<double>? borrowed,
    Wrapped<double>? suppliedMargin,
    Wrapped<double>? borrowedMargin,
  }) {
    return LendingOverallStats(
      topMarkets: (topMarkets != null ? topMarkets.value : this.topMarkets),
      marketCount: (marketCount != null ? marketCount.value : this.marketCount),
      supplied: (supplied != null ? supplied.value : this.supplied),
      participantsCount: (participantsCount != null
          ? participantsCount.value
          : this.participantsCount),
      bestApy: (bestApy != null ? bestApy.value : this.bestApy),
      borrowed: (borrowed != null ? borrowed.value : this.borrowed),
      suppliedMargin: (suppliedMargin != null
          ? suppliedMargin.value
          : this.suppliedMargin),
      borrowedMargin: (borrowedMargin != null
          ? borrowedMargin.value
          : this.borrowedMargin),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SaleInfoFilterDto {
  const SaleInfoFilterDto({
    this.seller,
    this.paymentToken,
    this.marketplace,
    this.auctionType,
  });

  factory SaleInfoFilterDto.fromJson(Map<String, dynamic> json) =>
      _$SaleInfoFilterDtoFromJson(json);

  static const toJsonFactory = _$SaleInfoFilterDtoToJson;
  Map<String, dynamic> toJson() => _$SaleInfoFilterDtoToJson(this);

  @JsonKey(name: 'seller', defaultValue: <String>[])
  final List<String>? seller;
  @JsonKey(name: 'paymentToken', defaultValue: <String>[])
  final List<String>? paymentToken;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'auctionType', defaultValue: <String>[])
  final List<String>? auctionType;
  static const fromJsonFactory = _$SaleInfoFilterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SaleInfoFilterDto &&
            (identical(other.seller, seller) ||
                const DeepCollectionEquality().equals(other.seller, seller)) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.auctionType, auctionType) ||
                const DeepCollectionEquality().equals(
                  other.auctionType,
                  auctionType,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seller) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(auctionType) ^
      runtimeType.hashCode;
}

extension $SaleInfoFilterDtoExtension on SaleInfoFilterDto {
  SaleInfoFilterDto copyWith({
    List<String>? seller,
    List<String>? paymentToken,
    List<String>? marketplace,
    List<String>? auctionType,
  }) {
    return SaleInfoFilterDto(
      seller: seller ?? this.seller,
      paymentToken: paymentToken ?? this.paymentToken,
      marketplace: marketplace ?? this.marketplace,
      auctionType: auctionType ?? this.auctionType,
    );
  }

  SaleInfoFilterDto copyWithWrapped({
    Wrapped<List<String>?>? seller,
    Wrapped<List<String>?>? paymentToken,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<String>?>? auctionType,
  }) {
    return SaleInfoFilterDto(
      seller: (seller != null ? seller.value : this.seller),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Rarity {
  const Rarity({required this.rank, this.rarityScore});

  factory Rarity.fromJson(Map<String, dynamic> json) => _$RarityFromJson(json);

  static const toJsonFactory = _$RarityToJson;
  Map<String, dynamic> toJson() => _$RarityToJson(this);

  @JsonKey(name: 'rank')
  final double rank;
  @JsonKey(name: 'rarityScore')
  final double? rarityScore;
  static const fromJsonFactory = _$RarityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Rarity &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.rarityScore, rarityScore) ||
                const DeepCollectionEquality().equals(
                  other.rarityScore,
                  rarityScore,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(rarityScore) ^
      runtimeType.hashCode;
}

extension $RarityExtension on Rarity {
  Rarity copyWith({double? rank, double? rarityScore}) {
    return Rarity(
      rank: rank ?? this.rank,
      rarityScore: rarityScore ?? this.rarityScore,
    );
  }

  Rarity copyWithWrapped({
    Wrapped<double>? rank,
    Wrapped<double?>? rarityScore,
  }) {
    return Rarity(
      rank: (rank != null ? rank.value : this.rank),
      rarityScore: (rarityScore != null ? rarityScore.value : this.rarityScore),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataAttributes {
  const NftMetadataAttributes({required this.traitType, required this.$value});

  factory NftMetadataAttributes.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataAttributesFromJson(json);

  static const toJsonFactory = _$NftMetadataAttributesToJson;
  Map<String, dynamic> toJson() => _$NftMetadataAttributesToJson(this);

  @JsonKey(name: 'trait_type')
  final String traitType;
  @JsonKey(name: 'value')
  final String $value;
  static const fromJsonFactory = _$NftMetadataAttributesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftMetadataAttributes &&
            (identical(other.traitType, traitType) ||
                const DeepCollectionEquality().equals(
                  other.traitType,
                  traitType,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(traitType) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $NftMetadataAttributesExtension on NftMetadataAttributes {
  NftMetadataAttributes copyWith({String? traitType, String? $value}) {
    return NftMetadataAttributes(
      traitType: traitType ?? this.traitType,
      $value: $value ?? this.$value,
    );
  }

  NftMetadataAttributes copyWithWrapped({
    Wrapped<String>? traitType,
    Wrapped<String>? $value,
  }) {
    return NftMetadataAttributes(
      traitType: (traitType != null ? traitType.value : this.traitType),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadata {
  const NftMetadata({
    this.description,
    this.rarity,
    this.extraAttributes,
    this.attributes,
  });

  factory NftMetadata.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataFromJson(json);

  static const toJsonFactory = _$NftMetadataToJson;
  Map<String, dynamic> toJson() => _$NftMetadataToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'rarity')
  final Rarity? rarity;
  @JsonKey(name: 'extraAttributes', defaultValue: <Object>[])
  final List<Object>? extraAttributes;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes>? attributes;
  static const fromJsonFactory = _$NftMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftMetadata &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.rarity, rarity) ||
                const DeepCollectionEquality().equals(other.rarity, rarity)) &&
            (identical(other.extraAttributes, extraAttributes) ||
                const DeepCollectionEquality().equals(
                  other.extraAttributes,
                  extraAttributes,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(rarity) ^
      const DeepCollectionEquality().hash(extraAttributes) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $NftMetadataExtension on NftMetadata {
  NftMetadata copyWith({
    String? description,
    Rarity? rarity,
    List<Object>? extraAttributes,
    List<NftMetadataAttributes>? attributes,
  }) {
    return NftMetadata(
      description: description ?? this.description,
      rarity: rarity ?? this.rarity,
      extraAttributes: extraAttributes ?? this.extraAttributes,
      attributes: attributes ?? this.attributes,
    );
  }

  NftMetadata copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<Rarity?>? rarity,
    Wrapped<List<Object>?>? extraAttributes,
    Wrapped<List<NftMetadataAttributes>?>? attributes,
  }) {
    return NftMetadata(
      description: (description != null ? description.value : this.description),
      rarity: (rarity != null ? rarity.value : this.rarity),
      extraAttributes: (extraAttributes != null
          ? extraAttributes.value
          : this.extraAttributes),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFilterCriteriaDto {
  const NftDocFilterCriteriaDto({
    this.dataType,
    this.identifier,
    this.collection,
    this.nonce,
    this.type,
    this.onSale,
    this.owner,
    this.currentOwner,
    this.saleInfo,
    this.range,
    this.metadata,
    this.wasProcessed,
    this.cpStaked,
    this.activeAuction,
    this.verifiedOnly,
    this.sftOriginalDoc,
  });

  factory NftDocFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$NftDocFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$NftDocFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$NftDocFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'dataType', defaultValue: <String>[])
  final List<String>? dataType;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'nonce', defaultValue: <double>[])
  final List<double>? nonce;
  @JsonKey(name: 'type', defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'onSale')
  final bool? onSale;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'currentOwner', defaultValue: <String>[])
  final List<String>? currentOwner;
  @JsonKey(name: 'saleInfo')
  final SaleInfoFilterDto? saleInfo;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'metadata')
  final NftMetadata? metadata;
  @JsonKey(name: 'wasProcessed')
  final bool? wasProcessed;
  @JsonKey(name: 'cp_staked')
  final bool? cpStaked;
  @JsonKey(name: 'activeAuction')
  final bool? activeAuction;
  @JsonKey(name: 'verifiedOnly')
  final bool? verifiedOnly;
  @JsonKey(name: 'sftOriginalDoc')
  final bool? sftOriginalDoc;
  static const fromJsonFactory = _$NftDocFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftDocFilterCriteriaDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.onSale, onSale) ||
                const DeepCollectionEquality().equals(other.onSale, onSale)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.currentOwner, currentOwner) ||
                const DeepCollectionEquality().equals(
                  other.currentOwner,
                  currentOwner,
                )) &&
            (identical(other.saleInfo, saleInfo) ||
                const DeepCollectionEquality().equals(
                  other.saleInfo,
                  saleInfo,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.cpStaked, cpStaked) ||
                const DeepCollectionEquality().equals(
                  other.cpStaked,
                  cpStaked,
                )) &&
            (identical(other.activeAuction, activeAuction) ||
                const DeepCollectionEquality().equals(
                  other.activeAuction,
                  activeAuction,
                )) &&
            (identical(other.verifiedOnly, verifiedOnly) ||
                const DeepCollectionEquality().equals(
                  other.verifiedOnly,
                  verifiedOnly,
                )) &&
            (identical(other.sftOriginalDoc, sftOriginalDoc) ||
                const DeepCollectionEquality().equals(
                  other.sftOriginalDoc,
                  sftOriginalDoc,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(onSale) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(currentOwner) ^
      const DeepCollectionEquality().hash(saleInfo) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(cpStaked) ^
      const DeepCollectionEquality().hash(activeAuction) ^
      const DeepCollectionEquality().hash(verifiedOnly) ^
      const DeepCollectionEquality().hash(sftOriginalDoc) ^
      runtimeType.hashCode;
}

extension $NftDocFilterCriteriaDtoExtension on NftDocFilterCriteriaDto {
  NftDocFilterCriteriaDto copyWith({
    List<String>? dataType,
    List<String>? identifier,
    List<String>? collection,
    List<double>? nonce,
    List<String>? type,
    bool? onSale,
    List<String>? owner,
    List<String>? currentOwner,
    SaleInfoFilterDto? saleInfo,
    List<RangeFilter>? range,
    NftMetadata? metadata,
    bool? wasProcessed,
    bool? cpStaked,
    bool? activeAuction,
    bool? verifiedOnly,
    bool? sftOriginalDoc,
  }) {
    return NftDocFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      onSale: onSale ?? this.onSale,
      owner: owner ?? this.owner,
      currentOwner: currentOwner ?? this.currentOwner,
      saleInfo: saleInfo ?? this.saleInfo,
      range: range ?? this.range,
      metadata: metadata ?? this.metadata,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      cpStaked: cpStaked ?? this.cpStaked,
      activeAuction: activeAuction ?? this.activeAuction,
      verifiedOnly: verifiedOnly ?? this.verifiedOnly,
      sftOriginalDoc: sftOriginalDoc ?? this.sftOriginalDoc,
    );
  }

  NftDocFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? dataType,
    Wrapped<List<String>?>? identifier,
    Wrapped<List<String>?>? collection,
    Wrapped<List<double>?>? nonce,
    Wrapped<List<String>?>? type,
    Wrapped<bool?>? onSale,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? currentOwner,
    Wrapped<SaleInfoFilterDto?>? saleInfo,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<NftMetadata?>? metadata,
    Wrapped<bool?>? wasProcessed,
    Wrapped<bool?>? cpStaked,
    Wrapped<bool?>? activeAuction,
    Wrapped<bool?>? verifiedOnly,
    Wrapped<bool?>? sftOriginalDoc,
  }) {
    return NftDocFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      onSale: (onSale != null ? onSale.value : this.onSale),
      owner: (owner != null ? owner.value : this.owner),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      range: (range != null ? range.value : this.range),
      metadata: (metadata != null ? metadata.value : this.metadata),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      cpStaked: (cpStaked != null ? cpStaked.value : this.cpStaked),
      activeAuction: (activeAuction != null
          ? activeAuction.value
          : this.activeAuction),
      verifiedOnly: (verifiedOnly != null
          ? verifiedOnly.value
          : this.verifiedOnly),
      sftOriginalDoc: (sftOriginalDoc != null
          ? sftOriginalDoc.value
          : this.sftOriginalDoc),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFilter {
  const NftDocFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
    this.applyNftExtraDetails,
  });

  factory NftDocFilter.fromJson(Map<String, dynamic> json) =>
      _$NftDocFilterFromJson(json);

  static const toJsonFactory = _$NftDocFilterToJson;
  Map<String, dynamic> toJson() => _$NftDocFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftDocFilterCriteriaDto? filters;
  @JsonKey(name: 'applyNftExtraDetails')
  final bool? applyNftExtraDetails;
  static const fromJsonFactory = _$NftDocFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftDocFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(
                  other.filters,
                  filters,
                )) &&
            (identical(other.applyNftExtraDetails, applyNftExtraDetails) ||
                const DeepCollectionEquality().equals(
                  other.applyNftExtraDetails,
                  applyNftExtraDetails,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      const DeepCollectionEquality().hash(applyNftExtraDetails) ^
      runtimeType.hashCode;
}

extension $NftDocFilterExtension on NftDocFilter {
  NftDocFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftDocFilterCriteriaDto? filters,
    bool? applyNftExtraDetails,
  }) {
    return NftDocFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      applyNftExtraDetails: applyNftExtraDetails ?? this.applyNftExtraDetails,
    );
  }

  NftDocFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftDocFilterCriteriaDto?>? filters,
    Wrapped<bool?>? applyNftExtraDetails,
  }) {
    return NftDocFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      applyNftExtraDetails: (applyNftExtraDetails != null
          ? applyNftExtraDetails.value
          : this.applyNftExtraDetails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OriginalMedia {
  const OriginalMedia({required this.contentType, required this.contentLength});

  factory OriginalMedia.fromJson(Map<String, dynamic> json) =>
      _$OriginalMediaFromJson(json);

  static const toJsonFactory = _$OriginalMediaToJson;
  Map<String, dynamic> toJson() => _$OriginalMediaToJson(this);

  @JsonKey(name: 'contentType')
  final String contentType;
  @JsonKey(name: 'contentLength')
  final double contentLength;
  static const fromJsonFactory = _$OriginalMediaFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OriginalMedia &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality().equals(
                  other.contentType,
                  contentType,
                )) &&
            (identical(other.contentLength, contentLength) ||
                const DeepCollectionEquality().equals(
                  other.contentLength,
                  contentLength,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(contentLength) ^
      runtimeType.hashCode;
}

extension $OriginalMediaExtension on OriginalMedia {
  OriginalMedia copyWith({String? contentType, double? contentLength}) {
    return OriginalMedia(
      contentType: contentType ?? this.contentType,
      contentLength: contentLength ?? this.contentLength,
    );
  }

  OriginalMedia copyWithWrapped({
    Wrapped<String>? contentType,
    Wrapped<double>? contentLength,
  }) {
    return OriginalMedia(
      contentType: (contentType != null ? contentType.value : this.contentType),
      contentLength: (contentLength != null
          ? contentLength.value
          : this.contentLength),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMedia {
  const NftMedia({
    required this.avifUrl,
    required this.webpUrl,
    required this.retries,
    required this.originalMedia,
  });

  factory NftMedia.fromJson(Map<String, dynamic> json) =>
      _$NftMediaFromJson(json);

  static const toJsonFactory = _$NftMediaToJson;
  Map<String, dynamic> toJson() => _$NftMediaToJson(this);

  @JsonKey(name: 'avifUrl')
  final String avifUrl;
  @JsonKey(name: 'webpUrl')
  final String webpUrl;
  @JsonKey(name: 'retries')
  final double retries;
  @JsonKey(name: 'originalMedia')
  final OriginalMedia originalMedia;
  static const fromJsonFactory = _$NftMediaFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftMedia &&
            (identical(other.avifUrl, avifUrl) ||
                const DeepCollectionEquality().equals(
                  other.avifUrl,
                  avifUrl,
                )) &&
            (identical(other.webpUrl, webpUrl) ||
                const DeepCollectionEquality().equals(
                  other.webpUrl,
                  webpUrl,
                )) &&
            (identical(other.retries, retries) ||
                const DeepCollectionEquality().equals(
                  other.retries,
                  retries,
                )) &&
            (identical(other.originalMedia, originalMedia) ||
                const DeepCollectionEquality().equals(
                  other.originalMedia,
                  originalMedia,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(avifUrl) ^
      const DeepCollectionEquality().hash(webpUrl) ^
      const DeepCollectionEquality().hash(retries) ^
      const DeepCollectionEquality().hash(originalMedia) ^
      runtimeType.hashCode;
}

extension $NftMediaExtension on NftMedia {
  NftMedia copyWith({
    String? avifUrl,
    String? webpUrl,
    double? retries,
    OriginalMedia? originalMedia,
  }) {
    return NftMedia(
      avifUrl: avifUrl ?? this.avifUrl,
      webpUrl: webpUrl ?? this.webpUrl,
      retries: retries ?? this.retries,
      originalMedia: originalMedia ?? this.originalMedia,
    );
  }

  NftMedia copyWithWrapped({
    Wrapped<String>? avifUrl,
    Wrapped<String>? webpUrl,
    Wrapped<double>? retries,
    Wrapped<OriginalMedia>? originalMedia,
  }) {
    return NftMedia(
      avifUrl: (avifUrl != null ? avifUrl.value : this.avifUrl),
      webpUrl: (webpUrl != null ? webpUrl.value : this.webpUrl),
      retries: (retries != null ? retries.value : this.retries),
      originalMedia: (originalMedia != null
          ? originalMedia.value
          : this.originalMedia),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftStats {
  const NftStats({this.likedCount});

  factory NftStats.fromJson(Map<String, dynamic> json) =>
      _$NftStatsFromJson(json);

  static const toJsonFactory = _$NftStatsToJson;
  Map<String, dynamic> toJson() => _$NftStatsToJson(this);

  @JsonKey(name: 'likedCount')
  final double? likedCount;
  static const fromJsonFactory = _$NftStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftStats &&
            (identical(other.likedCount, likedCount) ||
                const DeepCollectionEquality().equals(
                  other.likedCount,
                  likedCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(likedCount) ^ runtimeType.hashCode;
}

extension $NftStatsExtension on NftStats {
  NftStats copyWith({double? likedCount}) {
    return NftStats(likedCount: likedCount ?? this.likedCount);
  }

  NftStats copyWithWrapped({Wrapped<double?>? likedCount}) {
    return NftStats(
      likedCount: (likedCount != null ? likedCount.value : this.likedCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NFTEventData {
  const NFTEventData({
    required this.eventId,
    required this.ticketId,
    required this.checkInStatus,
  });

  factory NFTEventData.fromJson(Map<String, dynamic> json) =>
      _$NFTEventDataFromJson(json);

  static const toJsonFactory = _$NFTEventDataToJson;
  Map<String, dynamic> toJson() => _$NFTEventDataToJson(this);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'checkInStatus')
  final Object checkInStatus;
  static const fromJsonFactory = _$NFTEventDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NFTEventData &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.checkInStatus, checkInStatus) ||
                const DeepCollectionEquality().equals(
                  other.checkInStatus,
                  checkInStatus,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(checkInStatus) ^
      runtimeType.hashCode;
}

extension $NFTEventDataExtension on NFTEventData {
  NFTEventData copyWith({
    String? eventId,
    String? ticketId,
    Object? checkInStatus,
  }) {
    return NFTEventData(
      eventId: eventId ?? this.eventId,
      ticketId: ticketId ?? this.ticketId,
      checkInStatus: checkInStatus ?? this.checkInStatus,
    );
  }

  NFTEventData copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<String>? ticketId,
    Wrapped<Object>? checkInStatus,
  }) {
    return NFTEventData(
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      checkInStatus: (checkInStatus != null
          ? checkInStatus.value
          : this.checkInStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftSaleInfoHydrated {
  const NftSaleInfoHydrated({
    required this.auctionId,
    required this.seller,
    required this.minBid,
    required this.maxBid,
    this.currentBid,
    required this.startTime,
    required this.deadline,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.auctionType,
    required this.timestamp,
    required this.minBidShort,
    this.minBidUsdValue,
    required this.maxBidShort,
    this.maxBidUsdValue,
    this.currentBidShort,
    required this.quantity,
    required this.marketplace,
    this.royalties,
    this.currentWinner,
  });

  factory NftSaleInfoHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftSaleInfoHydratedFromJson(json);

  static const toJsonFactory = _$NftSaleInfoHydratedToJson;
  Map<String, dynamic> toJson() => _$NftSaleInfoHydratedToJson(this);

  @JsonKey(name: 'auctionId')
  final double auctionId;
  @JsonKey(name: 'seller')
  final String seller;
  @JsonKey(name: 'minBid')
  final String minBid;
  @JsonKey(name: 'maxBid')
  final String maxBid;
  @JsonKey(name: 'currentBid')
  final String? currentBid;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'deadline')
  final double deadline;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(
    name: 'auctionType',
    toJson: xoxnoAuctionTypeStringToJson,
    fromJson: xoxnoAuctionTypeStringFromJson,
  )
  final enums.XoxnoAuctionTypeString auctionType;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'minBidUsdValue')
  final double? minBidUsdValue;
  @JsonKey(name: 'maxBidShort')
  final double maxBidShort;
  @JsonKey(name: 'maxBidUsdValue')
  final double? maxBidUsdValue;
  @JsonKey(name: 'currentBidShort')
  final double? currentBidShort;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(
    name: 'marketplace',
    toJson: marketplacesOnSaleNamesToJson,
    fromJson: marketplacesOnSaleNamesFromJson,
  )
  final enums.MarketplacesOnSaleNames marketplace;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'currentWinner')
  final OwnerDto? currentWinner;
  static const fromJsonFactory = _$NftSaleInfoHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftSaleInfoHydrated &&
            (identical(other.auctionId, auctionId) ||
                const DeepCollectionEquality().equals(
                  other.auctionId,
                  auctionId,
                )) &&
            (identical(other.seller, seller) ||
                const DeepCollectionEquality().equals(other.seller, seller)) &&
            (identical(other.minBid, minBid) ||
                const DeepCollectionEquality().equals(other.minBid, minBid)) &&
            (identical(other.maxBid, maxBid) ||
                const DeepCollectionEquality().equals(other.maxBid, maxBid)) &&
            (identical(other.currentBid, currentBid) ||
                const DeepCollectionEquality().equals(
                  other.currentBid,
                  currentBid,
                )) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.deadline, deadline) ||
                const DeepCollectionEquality().equals(
                  other.deadline,
                  deadline,
                )) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.paymentTokenNonce, paymentTokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.paymentTokenNonce,
                  paymentTokenNonce,
                )) &&
            (identical(other.auctionType, auctionType) ||
                const DeepCollectionEquality().equals(
                  other.auctionType,
                  auctionType,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.minBidShort, minBidShort) ||
                const DeepCollectionEquality().equals(
                  other.minBidShort,
                  minBidShort,
                )) &&
            (identical(other.minBidUsdValue, minBidUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.minBidUsdValue,
                  minBidUsdValue,
                )) &&
            (identical(other.maxBidShort, maxBidShort) ||
                const DeepCollectionEquality().equals(
                  other.maxBidShort,
                  maxBidShort,
                )) &&
            (identical(other.maxBidUsdValue, maxBidUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.maxBidUsdValue,
                  maxBidUsdValue,
                )) &&
            (identical(other.currentBidShort, currentBidShort) ||
                const DeepCollectionEquality().equals(
                  other.currentBidShort,
                  currentBidShort,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.currentWinner, currentWinner) ||
                const DeepCollectionEquality().equals(
                  other.currentWinner,
                  currentWinner,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auctionId) ^
      const DeepCollectionEquality().hash(seller) ^
      const DeepCollectionEquality().hash(minBid) ^
      const DeepCollectionEquality().hash(maxBid) ^
      const DeepCollectionEquality().hash(currentBid) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(deadline) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenNonce) ^
      const DeepCollectionEquality().hash(auctionType) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(minBidShort) ^
      const DeepCollectionEquality().hash(minBidUsdValue) ^
      const DeepCollectionEquality().hash(maxBidShort) ^
      const DeepCollectionEquality().hash(maxBidUsdValue) ^
      const DeepCollectionEquality().hash(currentBidShort) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(currentWinner) ^
      runtimeType.hashCode;
}

extension $NftSaleInfoHydratedExtension on NftSaleInfoHydrated {
  NftSaleInfoHydrated copyWith({
    double? auctionId,
    String? seller,
    String? minBid,
    String? maxBid,
    String? currentBid,
    double? startTime,
    double? deadline,
    String? paymentToken,
    double? paymentTokenNonce,
    enums.XoxnoAuctionTypeString? auctionType,
    double? timestamp,
    double? minBidShort,
    double? minBidUsdValue,
    double? maxBidShort,
    double? maxBidUsdValue,
    double? currentBidShort,
    double? quantity,
    enums.MarketplacesOnSaleNames? marketplace,
    double? royalties,
    OwnerDto? currentWinner,
  }) {
    return NftSaleInfoHydrated(
      auctionId: auctionId ?? this.auctionId,
      seller: seller ?? this.seller,
      minBid: minBid ?? this.minBid,
      maxBid: maxBid ?? this.maxBid,
      currentBid: currentBid ?? this.currentBid,
      startTime: startTime ?? this.startTime,
      deadline: deadline ?? this.deadline,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      auctionType: auctionType ?? this.auctionType,
      timestamp: timestamp ?? this.timestamp,
      minBidShort: minBidShort ?? this.minBidShort,
      minBidUsdValue: minBidUsdValue ?? this.minBidUsdValue,
      maxBidShort: maxBidShort ?? this.maxBidShort,
      maxBidUsdValue: maxBidUsdValue ?? this.maxBidUsdValue,
      currentBidShort: currentBidShort ?? this.currentBidShort,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      royalties: royalties ?? this.royalties,
      currentWinner: currentWinner ?? this.currentWinner,
    );
  }

  NftSaleInfoHydrated copyWithWrapped({
    Wrapped<double>? auctionId,
    Wrapped<String>? seller,
    Wrapped<String>? minBid,
    Wrapped<String>? maxBid,
    Wrapped<String?>? currentBid,
    Wrapped<double>? startTime,
    Wrapped<double>? deadline,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<enums.XoxnoAuctionTypeString>? auctionType,
    Wrapped<double>? timestamp,
    Wrapped<double>? minBidShort,
    Wrapped<double?>? minBidUsdValue,
    Wrapped<double>? maxBidShort,
    Wrapped<double?>? maxBidUsdValue,
    Wrapped<double?>? currentBidShort,
    Wrapped<double>? quantity,
    Wrapped<enums.MarketplacesOnSaleNames>? marketplace,
    Wrapped<double?>? royalties,
    Wrapped<OwnerDto?>? currentWinner,
  }) {
    return NftSaleInfoHydrated(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      seller: (seller != null ? seller.value : this.seller),
      minBid: (minBid != null ? minBid.value : this.minBid),
      maxBid: (maxBid != null ? maxBid.value : this.maxBid),
      currentBid: (currentBid != null ? currentBid.value : this.currentBid),
      startTime: (startTime != null ? startTime.value : this.startTime),
      deadline: (deadline != null ? deadline.value : this.deadline),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      minBidUsdValue: (minBidUsdValue != null
          ? minBidUsdValue.value
          : this.minBidUsdValue),
      maxBidShort: (maxBidShort != null ? maxBidShort.value : this.maxBidShort),
      maxBidUsdValue: (maxBidUsdValue != null
          ? maxBidUsdValue.value
          : this.maxBidUsdValue),
      currentBidShort: (currentBidShort != null
          ? currentBidShort.value
          : this.currentBidShort),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      royalties: (royalties != null ? royalties.value : this.royalties),
      currentWinner: (currentWinner != null
          ? currentWinner.value
          : this.currentWinner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataAttributesHydrated {
  const NftMetadataAttributesHydrated({
    required this.traitType,
    required this.$value,
    required this.occurance,
    required this.frequency,
    required this.floorPrice,
    required this.onSaleCount,
    required this.usdValue,
  });

  factory NftMetadataAttributesHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataAttributesHydratedFromJson(json);

  static const toJsonFactory = _$NftMetadataAttributesHydratedToJson;
  Map<String, dynamic> toJson() => _$NftMetadataAttributesHydratedToJson(this);

  @JsonKey(name: 'trait_type')
  final String traitType;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'occurance')
  final double occurance;
  @JsonKey(name: 'frequency')
  final double frequency;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'onSaleCount')
  final double onSaleCount;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  static const fromJsonFactory = _$NftMetadataAttributesHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftMetadataAttributesHydrated &&
            (identical(other.traitType, traitType) ||
                const DeepCollectionEquality().equals(
                  other.traitType,
                  traitType,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.occurance, occurance) ||
                const DeepCollectionEquality().equals(
                  other.occurance,
                  occurance,
                )) &&
            (identical(other.frequency, frequency) ||
                const DeepCollectionEquality().equals(
                  other.frequency,
                  frequency,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.onSaleCount, onSaleCount) ||
                const DeepCollectionEquality().equals(
                  other.onSaleCount,
                  onSaleCount,
                )) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(traitType) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(occurance) ^
      const DeepCollectionEquality().hash(frequency) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(onSaleCount) ^
      const DeepCollectionEquality().hash(usdValue) ^
      runtimeType.hashCode;
}

extension $NftMetadataAttributesHydratedExtension
    on NftMetadataAttributesHydrated {
  NftMetadataAttributesHydrated copyWith({
    String? traitType,
    String? $value,
    double? occurance,
    double? frequency,
    double? floorPrice,
    double? onSaleCount,
    double? usdValue,
  }) {
    return NftMetadataAttributesHydrated(
      traitType: traitType ?? this.traitType,
      $value: $value ?? this.$value,
      occurance: occurance ?? this.occurance,
      frequency: frequency ?? this.frequency,
      floorPrice: floorPrice ?? this.floorPrice,
      onSaleCount: onSaleCount ?? this.onSaleCount,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  NftMetadataAttributesHydrated copyWithWrapped({
    Wrapped<String>? traitType,
    Wrapped<String>? $value,
    Wrapped<double>? occurance,
    Wrapped<double>? frequency,
    Wrapped<double>? floorPrice,
    Wrapped<double>? onSaleCount,
    Wrapped<double>? usdValue,
  }) {
    return NftMetadataAttributesHydrated(
      traitType: (traitType != null ? traitType.value : this.traitType),
      $value: ($value != null ? $value.value : this.$value),
      occurance: (occurance != null ? occurance.value : this.occurance),
      frequency: (frequency != null ? frequency.value : this.frequency),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      onSaleCount: (onSaleCount != null ? onSaleCount.value : this.onSaleCount),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataHydrated {
  const NftMetadataHydrated({
    this.description,
    this.rarity,
    this.extraAttributes,
    this.attributes,
  });

  factory NftMetadataHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataHydratedFromJson(json);

  static const toJsonFactory = _$NftMetadataHydratedToJson;
  Map<String, dynamic> toJson() => _$NftMetadataHydratedToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'rarity')
  final Rarity? rarity;
  @JsonKey(name: 'extraAttributes', defaultValue: <Object>[])
  final List<Object>? extraAttributes;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributesHydrated>[])
  final List<NftMetadataAttributesHydrated>? attributes;
  static const fromJsonFactory = _$NftMetadataHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftMetadataHydrated &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.rarity, rarity) ||
                const DeepCollectionEquality().equals(other.rarity, rarity)) &&
            (identical(other.extraAttributes, extraAttributes) ||
                const DeepCollectionEquality().equals(
                  other.extraAttributes,
                  extraAttributes,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(rarity) ^
      const DeepCollectionEquality().hash(extraAttributes) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $NftMetadataHydratedExtension on NftMetadataHydrated {
  NftMetadataHydrated copyWith({
    String? description,
    Rarity? rarity,
    List<Object>? extraAttributes,
    List<NftMetadataAttributesHydrated>? attributes,
  }) {
    return NftMetadataHydrated(
      description: description ?? this.description,
      rarity: rarity ?? this.rarity,
      extraAttributes: extraAttributes ?? this.extraAttributes,
      attributes: attributes ?? this.attributes,
    );
  }

  NftMetadataHydrated copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<Rarity?>? rarity,
    Wrapped<List<Object>?>? extraAttributes,
    Wrapped<List<NftMetadataAttributesHydrated>?>? attributes,
  }) {
    return NftMetadataHydrated(
      description: (description != null ? description.value : this.description),
      rarity: (rarity != null ? rarity.value : this.rarity),
      extraAttributes: (extraAttributes != null
          ? extraAttributes.value
          : this.extraAttributes),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionExtraFeesConfig {
  const CollectionExtraFeesConfig({
    required this.amount,
    required this.address,
  });

  factory CollectionExtraFeesConfig.fromJson(Map<String, dynamic> json) =>
      _$CollectionExtraFeesConfigFromJson(json);

  static const toJsonFactory = _$CollectionExtraFeesConfigToJson;
  Map<String, dynamic> toJson() => _$CollectionExtraFeesConfigToJson(this);

  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$CollectionExtraFeesConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionExtraFeesConfig &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $CollectionExtraFeesConfigExtension on CollectionExtraFeesConfig {
  CollectionExtraFeesConfig copyWith({double? amount, String? address}) {
    return CollectionExtraFeesConfig(
      amount: amount ?? this.amount,
      address: address ?? this.address,
    );
  }

  CollectionExtraFeesConfig copyWithWrapped({
    Wrapped<double>? amount,
    Wrapped<String>? address,
  }) {
    return CollectionExtraFeesConfig(
      amount: (amount != null ? amount.value : this.amount),
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoMarketplaceScCollectionConfig {
  const XoxnoMarketplaceScCollectionConfig({
    required this.reversedCutFees,
    required this.reversedRoyalties,
    required this.customRoyalties,
    required this.minRoyalties,
    required this.maxRoyalties,
    this.extraFees,
    this.adminAddress,
  });

  factory XoxnoMarketplaceScCollectionConfig.fromJson(
    Map<String, dynamic> json,
  ) => _$XoxnoMarketplaceScCollectionConfigFromJson(json);

  static const toJsonFactory = _$XoxnoMarketplaceScCollectionConfigToJson;
  Map<String, dynamic> toJson() =>
      _$XoxnoMarketplaceScCollectionConfigToJson(this);

  @JsonKey(name: 'reversedCutFees', defaultValue: false)
  final bool reversedCutFees;
  @JsonKey(name: 'reversedRoyalties', defaultValue: false)
  final bool reversedRoyalties;
  @JsonKey(name: 'customRoyalties', defaultValue: false)
  final bool customRoyalties;
  @JsonKey(name: 'minRoyalties')
  final double minRoyalties;
  @JsonKey(name: 'maxRoyalties')
  final double maxRoyalties;
  @JsonKey(name: 'extraFees')
  final CollectionExtraFeesConfig? extraFees;
  @JsonKey(name: 'adminAddress')
  final String? adminAddress;
  static const fromJsonFactory = _$XoxnoMarketplaceScCollectionConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is XoxnoMarketplaceScCollectionConfig &&
            (identical(other.reversedCutFees, reversedCutFees) ||
                const DeepCollectionEquality().equals(
                  other.reversedCutFees,
                  reversedCutFees,
                )) &&
            (identical(other.reversedRoyalties, reversedRoyalties) ||
                const DeepCollectionEquality().equals(
                  other.reversedRoyalties,
                  reversedRoyalties,
                )) &&
            (identical(other.customRoyalties, customRoyalties) ||
                const DeepCollectionEquality().equals(
                  other.customRoyalties,
                  customRoyalties,
                )) &&
            (identical(other.minRoyalties, minRoyalties) ||
                const DeepCollectionEquality().equals(
                  other.minRoyalties,
                  minRoyalties,
                )) &&
            (identical(other.maxRoyalties, maxRoyalties) ||
                const DeepCollectionEquality().equals(
                  other.maxRoyalties,
                  maxRoyalties,
                )) &&
            (identical(other.extraFees, extraFees) ||
                const DeepCollectionEquality().equals(
                  other.extraFees,
                  extraFees,
                )) &&
            (identical(other.adminAddress, adminAddress) ||
                const DeepCollectionEquality().equals(
                  other.adminAddress,
                  adminAddress,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reversedCutFees) ^
      const DeepCollectionEquality().hash(reversedRoyalties) ^
      const DeepCollectionEquality().hash(customRoyalties) ^
      const DeepCollectionEquality().hash(minRoyalties) ^
      const DeepCollectionEquality().hash(maxRoyalties) ^
      const DeepCollectionEquality().hash(extraFees) ^
      const DeepCollectionEquality().hash(adminAddress) ^
      runtimeType.hashCode;
}

extension $XoxnoMarketplaceScCollectionConfigExtension
    on XoxnoMarketplaceScCollectionConfig {
  XoxnoMarketplaceScCollectionConfig copyWith({
    bool? reversedCutFees,
    bool? reversedRoyalties,
    bool? customRoyalties,
    double? minRoyalties,
    double? maxRoyalties,
    CollectionExtraFeesConfig? extraFees,
    String? adminAddress,
  }) {
    return XoxnoMarketplaceScCollectionConfig(
      reversedCutFees: reversedCutFees ?? this.reversedCutFees,
      reversedRoyalties: reversedRoyalties ?? this.reversedRoyalties,
      customRoyalties: customRoyalties ?? this.customRoyalties,
      minRoyalties: minRoyalties ?? this.minRoyalties,
      maxRoyalties: maxRoyalties ?? this.maxRoyalties,
      extraFees: extraFees ?? this.extraFees,
      adminAddress: adminAddress ?? this.adminAddress,
    );
  }

  XoxnoMarketplaceScCollectionConfig copyWithWrapped({
    Wrapped<bool>? reversedCutFees,
    Wrapped<bool>? reversedRoyalties,
    Wrapped<bool>? customRoyalties,
    Wrapped<double>? minRoyalties,
    Wrapped<double>? maxRoyalties,
    Wrapped<CollectionExtraFeesConfig?>? extraFees,
    Wrapped<String?>? adminAddress,
  }) {
    return XoxnoMarketplaceScCollectionConfig(
      reversedCutFees: (reversedCutFees != null
          ? reversedCutFees.value
          : this.reversedCutFees),
      reversedRoyalties: (reversedRoyalties != null
          ? reversedRoyalties.value
          : this.reversedRoyalties),
      customRoyalties: (customRoyalties != null
          ? customRoyalties.value
          : this.customRoyalties),
      minRoyalties: (minRoyalties != null
          ? minRoyalties.value
          : this.minRoyalties),
      maxRoyalties: (maxRoyalties != null
          ? maxRoyalties.value
          : this.maxRoyalties),
      extraFees: (extraFees != null ? extraFees.value : this.extraFees),
      adminAddress: (adminAddress != null
          ? adminAddress.value
          : this.adminAddress),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortNftCollectionInfoDoc {
  const ShortNftCollectionInfoDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.roles,
    this.customConfig,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
  });

  factory ShortNftCollectionInfoDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortNftCollectionInfoDocFromJson(json);

  static const toJsonFactory = _$ShortNftCollectionInfoDocToJson;
  Map<String, dynamic> toJson() => _$ShortNftCollectionInfoDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: shortNftCollectionInfoDocChainToJson,
    fromJson: shortNftCollectionInfoDocChainFromJson,
  )
  final enums.ShortNftCollectionInfoDocChain chain;
  @JsonKey(name: 'roles')
  final Map<String, dynamic> roles;
  @JsonKey(name: 'customConfig')
  final XoxnoMarketplaceScCollectionConfig? customConfig;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  static const fromJsonFactory = _$ShortNftCollectionInfoDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortNftCollectionInfoDoc &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.customConfig, customConfig) ||
                const DeepCollectionEquality().equals(
                  other.customConfig,
                  customConfig,
                )) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(customConfig) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(followCount) ^
      runtimeType.hashCode;
}

extension $ShortNftCollectionInfoDocExtension on ShortNftCollectionInfoDoc {
  ShortNftCollectionInfoDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    String? banner,
    enums.ShortNftCollectionInfoDocChain? chain,
    Map<String, dynamic>? roles,
    XoxnoMarketplaceScCollectionConfig? customConfig,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
  }) {
    return ShortNftCollectionInfoDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      roles: roles ?? this.roles,
      customConfig: customConfig ?? this.customConfig,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
    );
  }

  ShortNftCollectionInfoDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.ShortNftCollectionInfoDocChain>? chain,
    Wrapped<Map<String, dynamic>>? roles,
    Wrapped<XoxnoMarketplaceScCollectionConfig?>? customConfig,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
  }) {
    return ShortNftCollectionInfoDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      roles: (roles != null ? roles.value : this.roles),
      customConfig: (customConfig != null
          ? customConfig.value
          : this.customConfig),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ExtraProperties {
  const ExtraProperties({this.currentEpoch, this.level});

  factory ExtraProperties.fromJson(Map<String, dynamic> json) =>
      _$ExtraPropertiesFromJson(json);

  static const toJsonFactory = _$ExtraPropertiesToJson;
  Map<String, dynamic> toJson() => _$ExtraPropertiesToJson(this);

  @JsonKey(name: 'currentEpoch')
  final double? currentEpoch;
  @JsonKey(name: 'level')
  final double? level;
  static const fromJsonFactory = _$ExtraPropertiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExtraProperties &&
            (identical(other.currentEpoch, currentEpoch) ||
                const DeepCollectionEquality().equals(
                  other.currentEpoch,
                  currentEpoch,
                )) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentEpoch) ^
      const DeepCollectionEquality().hash(level) ^
      runtimeType.hashCode;
}

extension $ExtraPropertiesExtension on ExtraProperties {
  ExtraProperties copyWith({double? currentEpoch, double? level}) {
    return ExtraProperties(
      currentEpoch: currentEpoch ?? this.currentEpoch,
      level: level ?? this.level,
    );
  }

  ExtraProperties copyWithWrapped({
    Wrapped<double?>? currentEpoch,
    Wrapped<double?>? level,
  }) {
    return ExtraProperties(
      currentEpoch: (currentEpoch != null
          ? currentEpoch.value
          : this.currentEpoch),
      level: (level != null ? level.value : this.level),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocHydrated {
  const NftDocHydrated({
    required this.dataType,
    required this.identifier,
    required this.collection,
    this.originalCollection,
    this.attributes,
    required this.nonce,
    required this.type,
    this.subType,
    required this.supply,
    this.supplyLong,
    required this.name,
    required this.royalties,
    required this.url,
    this.uris,
    required this.wasProcessed,
    this.media,
    this.statistics,
    this.isTicket,
    this.eventData,
    required this.chain,
    this.tags,
    this.kiosk,
    required this.onSale,
    this.id,
    this.ts,
    this.creator,
    this.currentOwner,
    this.owner,
    this.saleInfo,
    this.metadata,
    required this.collectionInfo,
    this.balance,
    this.balanceLong,
    this.unboundDaysLeft,
    this.unboundEpoch,
    this.extraProperties,
  });

  factory NftDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftDocHydratedFromJson(json);

  static const toJsonFactory = _$NftDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.nft);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String? originalCollection;
  @JsonKey(name: 'attributes')
  final String? attributes;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(
    name: 'type',
    toJson: esdtTokenTypeToJson,
    fromJson: esdtTokenTypeFromJson,
  )
  final enums.EsdtTokenType type;
  @JsonKey(
    name: 'subType',
    toJson: esdtTokenSubTypeNullableToJson,
    fromJson: esdtTokenSubTypeNullableFromJson,
  )
  final enums.EsdtTokenSubType? subType;
  @JsonKey(name: 'supply')
  final double supply;
  @JsonKey(name: 'supplyLong')
  final String? supplyLong;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'uris')
  final String? uris;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'statistics')
  final NftStats? statistics;
  @JsonKey(name: 'isTicket')
  final bool? isTicket;
  @JsonKey(name: 'eventData')
  final NFTEventData? eventData;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  @JsonKey(name: 'tags')
  final String? tags;
  @JsonKey(name: 'kiosk')
  final String? kiosk;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'creator')
  final OwnerDto? creator;
  @JsonKey(name: 'currentOwner')
  final OwnerDto? currentOwner;
  @JsonKey(name: 'owner')
  final OwnerDto? owner;
  @JsonKey(name: 'saleInfo')
  final NftSaleInfoHydrated? saleInfo;
  @JsonKey(name: 'metadata')
  final NftMetadataHydrated? metadata;
  @JsonKey(name: 'collectionInfo')
  final ShortNftCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'balance')
  final double? balance;
  @JsonKey(name: 'balanceLong')
  final String? balanceLong;
  @JsonKey(name: 'unboundDaysLeft')
  final double? unboundDaysLeft;
  @JsonKey(name: 'unboundEpoch')
  final double? unboundEpoch;
  @JsonKey(name: 'extraProperties')
  final ExtraProperties? extraProperties;
  static const fromJsonFactory = _$NftDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.originalCollection, originalCollection) ||
                const DeepCollectionEquality().equals(
                  other.originalCollection,
                  originalCollection,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality().equals(
                  other.subType,
                  subType,
                )) &&
            (identical(other.supply, supply) ||
                const DeepCollectionEquality().equals(other.supply, supply)) &&
            (identical(other.supplyLong, supplyLong) ||
                const DeepCollectionEquality().equals(
                  other.supplyLong,
                  supplyLong,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.uris, uris) ||
                const DeepCollectionEquality().equals(other.uris, uris)) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality().equals(
                  other.statistics,
                  statistics,
                )) &&
            (identical(other.isTicket, isTicket) ||
                const DeepCollectionEquality().equals(
                  other.isTicket,
                  isTicket,
                )) &&
            (identical(other.eventData, eventData) ||
                const DeepCollectionEquality().equals(
                  other.eventData,
                  eventData,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.kiosk, kiosk) ||
                const DeepCollectionEquality().equals(other.kiosk, kiosk)) &&
            (identical(other.onSale, onSale) ||
                const DeepCollectionEquality().equals(other.onSale, onSale)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.creator, creator) ||
                const DeepCollectionEquality().equals(
                  other.creator,
                  creator,
                )) &&
            (identical(other.currentOwner, currentOwner) ||
                const DeepCollectionEquality().equals(
                  other.currentOwner,
                  currentOwner,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.saleInfo, saleInfo) ||
                const DeepCollectionEquality().equals(
                  other.saleInfo,
                  saleInfo,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.balanceLong, balanceLong) ||
                const DeepCollectionEquality().equals(
                  other.balanceLong,
                  balanceLong,
                )) &&
            (identical(other.unboundDaysLeft, unboundDaysLeft) ||
                const DeepCollectionEquality().equals(
                  other.unboundDaysLeft,
                  unboundDaysLeft,
                )) &&
            (identical(other.unboundEpoch, unboundEpoch) ||
                const DeepCollectionEquality().equals(
                  other.unboundEpoch,
                  unboundEpoch,
                )) &&
            (identical(other.extraProperties, extraProperties) ||
                const DeepCollectionEquality().equals(
                  other.extraProperties,
                  extraProperties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(originalCollection) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(supply) ^
      const DeepCollectionEquality().hash(supplyLong) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(uris) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(isTicket) ^
      const DeepCollectionEquality().hash(eventData) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(kiosk) ^
      const DeepCollectionEquality().hash(onSale) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(creator) ^
      const DeepCollectionEquality().hash(currentOwner) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(saleInfo) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(balanceLong) ^
      const DeepCollectionEquality().hash(unboundDaysLeft) ^
      const DeepCollectionEquality().hash(unboundEpoch) ^
      const DeepCollectionEquality().hash(extraProperties) ^
      runtimeType.hashCode;
}

extension $NftDocHydratedExtension on NftDocHydrated {
  NftDocHydrated copyWith({
    enums.TokenDataType? dataType,
    String? identifier,
    String? collection,
    String? originalCollection,
    String? attributes,
    double? nonce,
    enums.EsdtTokenType? type,
    enums.EsdtTokenSubType? subType,
    double? supply,
    String? supplyLong,
    String? name,
    double? royalties,
    String? url,
    String? uris,
    bool? wasProcessed,
    NftMedia? media,
    NftStats? statistics,
    bool? isTicket,
    NFTEventData? eventData,
    enums.ActivityChain? chain,
    String? tags,
    String? kiosk,
    bool? onSale,
    String? id,
    double? ts,
    OwnerDto? creator,
    OwnerDto? currentOwner,
    OwnerDto? owner,
    NftSaleInfoHydrated? saleInfo,
    NftMetadataHydrated? metadata,
    ShortNftCollectionInfoDoc? collectionInfo,
    double? balance,
    String? balanceLong,
    double? unboundDaysLeft,
    double? unboundEpoch,
    ExtraProperties? extraProperties,
  }) {
    return NftDocHydrated(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      attributes: attributes ?? this.attributes,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      supply: supply ?? this.supply,
      supplyLong: supplyLong ?? this.supplyLong,
      name: name ?? this.name,
      royalties: royalties ?? this.royalties,
      url: url ?? this.url,
      uris: uris ?? this.uris,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      statistics: statistics ?? this.statistics,
      isTicket: isTicket ?? this.isTicket,
      eventData: eventData ?? this.eventData,
      chain: chain ?? this.chain,
      tags: tags ?? this.tags,
      kiosk: kiosk ?? this.kiosk,
      onSale: onSale ?? this.onSale,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      creator: creator ?? this.creator,
      currentOwner: currentOwner ?? this.currentOwner,
      owner: owner ?? this.owner,
      saleInfo: saleInfo ?? this.saleInfo,
      metadata: metadata ?? this.metadata,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      balance: balance ?? this.balance,
      balanceLong: balanceLong ?? this.balanceLong,
      unboundDaysLeft: unboundDaysLeft ?? this.unboundDaysLeft,
      unboundEpoch: unboundEpoch ?? this.unboundEpoch,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  NftDocHydrated copyWithWrapped({
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String?>? originalCollection,
    Wrapped<String?>? attributes,
    Wrapped<double>? nonce,
    Wrapped<enums.EsdtTokenType>? type,
    Wrapped<enums.EsdtTokenSubType?>? subType,
    Wrapped<double>? supply,
    Wrapped<String?>? supplyLong,
    Wrapped<String>? name,
    Wrapped<double>? royalties,
    Wrapped<String>? url,
    Wrapped<String?>? uris,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftStats?>? statistics,
    Wrapped<bool?>? isTicket,
    Wrapped<NFTEventData?>? eventData,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String?>? tags,
    Wrapped<String?>? kiosk,
    Wrapped<bool>? onSale,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<OwnerDto?>? creator,
    Wrapped<OwnerDto?>? currentOwner,
    Wrapped<OwnerDto?>? owner,
    Wrapped<NftSaleInfoHydrated?>? saleInfo,
    Wrapped<NftMetadataHydrated?>? metadata,
    Wrapped<ShortNftCollectionInfoDoc>? collectionInfo,
    Wrapped<double?>? balance,
    Wrapped<String?>? balanceLong,
    Wrapped<double?>? unboundDaysLeft,
    Wrapped<double?>? unboundEpoch,
    Wrapped<ExtraProperties?>? extraProperties,
  }) {
    return NftDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      attributes: (attributes != null ? attributes.value : this.attributes),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      supply: (supply != null ? supply.value : this.supply),
      supplyLong: (supplyLong != null ? supplyLong.value : this.supplyLong),
      name: (name != null ? name.value : this.name),
      royalties: (royalties != null ? royalties.value : this.royalties),
      url: (url != null ? url.value : this.url),
      uris: (uris != null ? uris.value : this.uris),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      statistics: (statistics != null ? statistics.value : this.statistics),
      isTicket: (isTicket != null ? isTicket.value : this.isTicket),
      eventData: (eventData != null ? eventData.value : this.eventData),
      chain: (chain != null ? chain.value : this.chain),
      tags: (tags != null ? tags.value : this.tags),
      kiosk: (kiosk != null ? kiosk.value : this.kiosk),
      onSale: (onSale != null ? onSale.value : this.onSale),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      creator: (creator != null ? creator.value : this.creator),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      owner: (owner != null ? owner.value : this.owner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      metadata: (metadata != null ? metadata.value : this.metadata),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      balance: (balance != null ? balance.value : this.balance),
      balanceLong: (balanceLong != null ? balanceLong.value : this.balanceLong),
      unboundDaysLeft: (unboundDaysLeft != null
          ? unboundDaysLeft.value
          : this.unboundDaysLeft),
      unboundEpoch: (unboundEpoch != null
          ? unboundEpoch.value
          : this.unboundEpoch),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftPaginated {
  const NftPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftPaginatedFromJson(json);

  static const toJsonFactory = _$NftPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated> resources;
  static const fromJsonFactory = _$NftPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $NftPaginatedExtension on NftPaginated {
  NftPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftDocHydrated>? resources,
  }) {
    return NftPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftDocHydrated>>? resources,
  }) {
    return NftPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LikeNftDto {
  const LikeNftDto({
    required this.isFavorite,
    required this.collection,
    required this.identifier,
  });

  factory LikeNftDto.fromJson(Map<String, dynamic> json) =>
      _$LikeNftDtoFromJson(json);

  static const toJsonFactory = _$LikeNftDtoToJson;
  Map<String, dynamic> toJson() => _$LikeNftDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$LikeNftDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LikeNftDto &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality().equals(
                  other.isFavorite,
                  isFavorite,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isFavorite) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $LikeNftDtoExtension on LikeNftDto {
  LikeNftDto copyWith({
    bool? isFavorite,
    String? collection,
    String? identifier,
  }) {
    return LikeNftDto(
      isFavorite: isFavorite ?? this.isFavorite,
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
    );
  }

  LikeNftDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String>? collection,
    Wrapped<String>? identifier,
  }) {
    return LikeNftDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class InventorySummaryDtoHydrated {
  const InventorySummaryDtoHydrated({
    required this.collection,
    required this.inventoryCount,
    required this.listedCount,
    required this.stakedCount,
    required this.floorPrice,
    required this.name,
    required this.isVerified,
    required this.isVisible,
    required this.profile,
    required this.banner,
    required this.$value,
    this.chain,
  });

  factory InventorySummaryDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$InventorySummaryDtoHydratedFromJson(json);

  static const toJsonFactory = _$InventorySummaryDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$InventorySummaryDtoHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'inventoryCount')
  final double inventoryCount;
  @JsonKey(name: 'listedCount')
  final double listedCount;
  @JsonKey(name: 'stakedCount')
  final double stakedCount;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'value')
  final double $value;
  @JsonKey(
    name: 'chain',
    toJson: inventorySummaryDtoHydratedChainNullableToJson,
    fromJson: inventorySummaryDtoHydratedChainNullableFromJson,
  )
  final enums.InventorySummaryDtoHydratedChain? chain;
  static const fromJsonFactory = _$InventorySummaryDtoHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InventorySummaryDtoHydrated &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.inventoryCount, inventoryCount) ||
                const DeepCollectionEquality().equals(
                  other.inventoryCount,
                  inventoryCount,
                )) &&
            (identical(other.listedCount, listedCount) ||
                const DeepCollectionEquality().equals(
                  other.listedCount,
                  listedCount,
                )) &&
            (identical(other.stakedCount, stakedCount) ||
                const DeepCollectionEquality().equals(
                  other.stakedCount,
                  stakedCount,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(inventoryCount) ^
      const DeepCollectionEquality().hash(listedCount) ^
      const DeepCollectionEquality().hash(stakedCount) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $InventorySummaryDtoHydratedExtension on InventorySummaryDtoHydrated {
  InventorySummaryDtoHydrated copyWith({
    String? collection,
    double? inventoryCount,
    double? listedCount,
    double? stakedCount,
    double? floorPrice,
    String? name,
    bool? isVerified,
    bool? isVisible,
    String? profile,
    String? banner,
    double? $value,
    enums.InventorySummaryDtoHydratedChain? chain,
  }) {
    return InventorySummaryDtoHydrated(
      collection: collection ?? this.collection,
      inventoryCount: inventoryCount ?? this.inventoryCount,
      listedCount: listedCount ?? this.listedCount,
      stakedCount: stakedCount ?? this.stakedCount,
      floorPrice: floorPrice ?? this.floorPrice,
      name: name ?? this.name,
      isVerified: isVerified ?? this.isVerified,
      isVisible: isVisible ?? this.isVisible,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      $value: $value ?? this.$value,
      chain: chain ?? this.chain,
    );
  }

  InventorySummaryDtoHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? inventoryCount,
    Wrapped<double>? listedCount,
    Wrapped<double>? stakedCount,
    Wrapped<double>? floorPrice,
    Wrapped<String>? name,
    Wrapped<bool>? isVerified,
    Wrapped<bool>? isVisible,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double>? $value,
    Wrapped<enums.InventorySummaryDtoHydratedChain?>? chain,
  }) {
    return InventorySummaryDtoHydrated(
      collection: (collection != null ? collection.value : this.collection),
      inventoryCount: (inventoryCount != null
          ? inventoryCount.value
          : this.inventoryCount),
      listedCount: (listedCount != null ? listedCount.value : this.listedCount),
      stakedCount: (stakedCount != null ? stakedCount.value : this.stakedCount),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      name: (name != null ? name.value : this.name),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      $value: ($value != null ? $value.value : this.$value),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocHydrated {
  const NftOfferDocHydrated({
    required this.dataType,
    required this.identifier,
    required this.collection,
    required this.offerId,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.price,
    required this.priceShort,
    this.priceUsd,
    this.floorPriceMargin,
    required this.deadline,
    required this.timestamp,
    this.nftOwner,
    required this.quantity,
    required this.marketplace,
    this.auctionId,
    required this.isActive,
    required this.chain,
    required this.id,
    required this.ts,
    required this.owner,
    required this.usdValue,
    required this.floorPrice,
    required this.nftInfo,
  });

  factory NftOfferDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocHydratedFromJson(json);

  static const toJsonFactory = _$NftOfferDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: nftOfferDocHydratedDataTypeToJson,
    fromJson: nftOfferDocHydratedDataTypeFromJson,
  )
  final enums.NftOfferDocHydratedDataType dataType;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'offerId')
  final double offerId;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'price')
  final String price;
  @JsonKey(name: 'priceShort')
  final double priceShort;
  @JsonKey(name: 'priceUsd')
  final double? priceUsd;
  @JsonKey(name: 'floorPriceMargin')
  final double? floorPriceMargin;
  @JsonKey(name: 'deadline')
  final double deadline;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'nftOwner')
  final String? nftOwner;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'auctionId')
  final double? auctionId;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(
    name: 'chain',
    toJson: nftOfferDocHydratedChainToJson,
    fromJson: nftOfferDocHydratedChainFromJson,
  )
  final enums.NftOfferDocHydratedChain chain;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'owner')
  final OwnerDto owner;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'nftInfo')
  final NftDocHydrated nftInfo;
  static const fromJsonFactory = _$NftOfferDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftOfferDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.offerId, offerId) ||
                const DeepCollectionEquality().equals(
                  other.offerId,
                  offerId,
                )) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.paymentTokenNonce, paymentTokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.paymentTokenNonce,
                  paymentTokenNonce,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.priceShort, priceShort) ||
                const DeepCollectionEquality().equals(
                  other.priceShort,
                  priceShort,
                )) &&
            (identical(other.priceUsd, priceUsd) ||
                const DeepCollectionEquality().equals(
                  other.priceUsd,
                  priceUsd,
                )) &&
            (identical(other.floorPriceMargin, floorPriceMargin) ||
                const DeepCollectionEquality().equals(
                  other.floorPriceMargin,
                  floorPriceMargin,
                )) &&
            (identical(other.deadline, deadline) ||
                const DeepCollectionEquality().equals(
                  other.deadline,
                  deadline,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.nftOwner, nftOwner) ||
                const DeepCollectionEquality().equals(
                  other.nftOwner,
                  nftOwner,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.auctionId, auctionId) ||
                const DeepCollectionEquality().equals(
                  other.auctionId,
                  auctionId,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.nftInfo, nftInfo) ||
                const DeepCollectionEquality().equals(other.nftInfo, nftInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(offerId) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenNonce) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(priceShort) ^
      const DeepCollectionEquality().hash(priceUsd) ^
      const DeepCollectionEquality().hash(floorPriceMargin) ^
      const DeepCollectionEquality().hash(deadline) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(nftOwner) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(auctionId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(nftInfo) ^
      runtimeType.hashCode;
}

extension $NftOfferDocHydratedExtension on NftOfferDocHydrated {
  NftOfferDocHydrated copyWith({
    enums.NftOfferDocHydratedDataType? dataType,
    String? identifier,
    String? collection,
    double? offerId,
    String? paymentToken,
    double? paymentTokenNonce,
    String? price,
    double? priceShort,
    double? priceUsd,
    double? floorPriceMargin,
    double? deadline,
    double? timestamp,
    String? nftOwner,
    double? quantity,
    String? marketplace,
    double? auctionId,
    bool? isActive,
    enums.NftOfferDocHydratedChain? chain,
    String? id,
    double? ts,
    OwnerDto? owner,
    double? usdValue,
    double? floorPrice,
    NftDocHydrated? nftInfo,
  }) {
    return NftOfferDocHydrated(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      offerId: offerId ?? this.offerId,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      price: price ?? this.price,
      priceShort: priceShort ?? this.priceShort,
      priceUsd: priceUsd ?? this.priceUsd,
      floorPriceMargin: floorPriceMargin ?? this.floorPriceMargin,
      deadline: deadline ?? this.deadline,
      timestamp: timestamp ?? this.timestamp,
      nftOwner: nftOwner ?? this.nftOwner,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      auctionId: auctionId ?? this.auctionId,
      isActive: isActive ?? this.isActive,
      chain: chain ?? this.chain,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      owner: owner ?? this.owner,
      usdValue: usdValue ?? this.usdValue,
      floorPrice: floorPrice ?? this.floorPrice,
      nftInfo: nftInfo ?? this.nftInfo,
    );
  }

  NftOfferDocHydrated copyWithWrapped({
    Wrapped<enums.NftOfferDocHydratedDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<double>? offerId,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<String>? price,
    Wrapped<double>? priceShort,
    Wrapped<double?>? priceUsd,
    Wrapped<double?>? floorPriceMargin,
    Wrapped<double>? deadline,
    Wrapped<double>? timestamp,
    Wrapped<String?>? nftOwner,
    Wrapped<double>? quantity,
    Wrapped<String>? marketplace,
    Wrapped<double?>? auctionId,
    Wrapped<bool>? isActive,
    Wrapped<enums.NftOfferDocHydratedChain>? chain,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? owner,
    Wrapped<double>? usdValue,
    Wrapped<double>? floorPrice,
    Wrapped<NftDocHydrated>? nftInfo,
  }) {
    return NftOfferDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      offerId: (offerId != null ? offerId.value : this.offerId),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      price: (price != null ? price.value : this.price),
      priceShort: (priceShort != null ? priceShort.value : this.priceShort),
      priceUsd: (priceUsd != null ? priceUsd.value : this.priceUsd),
      floorPriceMargin: (floorPriceMargin != null
          ? floorPriceMargin.value
          : this.floorPriceMargin),
      deadline: (deadline != null ? deadline.value : this.deadline),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      nftOwner: (nftOwner != null ? nftOwner.value : this.nftOwner),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      chain: (chain != null ? chain.value : this.chain),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      owner: (owner != null ? owner.value : this.owner),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferPaginated {
  const NftOfferPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftOfferPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftOfferPaginatedFromJson(json);

  static const toJsonFactory = _$NftOfferPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftOfferPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftOfferDocHydrated>[])
  final List<NftOfferDocHydrated> resources;
  static const fromJsonFactory = _$NftOfferPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftOfferPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $NftOfferPaginatedExtension on NftOfferPaginated {
  NftOfferPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftOfferDocHydrated>? resources,
  }) {
    return NftOfferPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftOfferPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftOfferDocHydrated>>? resources,
  }) {
    return NftOfferPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocFilterCriteria {
  const NftOfferDocFilterCriteria({
    this.isActive,
    this.identifier,
    this.collection,
    this.owner,
    this.nftOwner,
    this.marketplace,
    this.range,
  });

  factory NftOfferDocFilterCriteria.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocFilterCriteriaFromJson(json);

  static const toJsonFactory = _$NftOfferDocFilterCriteriaToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocFilterCriteriaToJson(this);

  @JsonKey(name: 'isActive', defaultValue: <bool>[])
  final List<bool>? isActive;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'nftOwner', defaultValue: <String>[])
  final List<String>? nftOwner;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$NftOfferDocFilterCriteriaFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftOfferDocFilterCriteria &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.nftOwner, nftOwner) ||
                const DeepCollectionEquality().equals(
                  other.nftOwner,
                  nftOwner,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(nftOwner) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(range) ^
      runtimeType.hashCode;
}

extension $NftOfferDocFilterCriteriaExtension on NftOfferDocFilterCriteria {
  NftOfferDocFilterCriteria copyWith({
    List<bool>? isActive,
    List<String>? identifier,
    List<String>? collection,
    List<String>? owner,
    List<String>? nftOwner,
    List<String>? marketplace,
    List<RangeFilter>? range,
  }) {
    return NftOfferDocFilterCriteria(
      isActive: isActive ?? this.isActive,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      owner: owner ?? this.owner,
      nftOwner: nftOwner ?? this.nftOwner,
      marketplace: marketplace ?? this.marketplace,
      range: range ?? this.range,
    );
  }

  NftOfferDocFilterCriteria copyWithWrapped({
    Wrapped<List<bool>?>? isActive,
    Wrapped<List<String>?>? identifier,
    Wrapped<List<String>?>? collection,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? nftOwner,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return NftOfferDocFilterCriteria(
      isActive: (isActive != null ? isActive.value : this.isActive),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      owner: (owner != null ? owner.value : this.owner),
      nftOwner: (nftOwner != null ? nftOwner.value : this.nftOwner),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocFilter {
  const NftOfferDocFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory NftOfferDocFilter.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocFilterFromJson(json);

  static const toJsonFactory = _$NftOfferDocFilterToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftOfferDocFilterCriteria? filters;
  static const fromJsonFactory = _$NftOfferDocFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftOfferDocFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $NftOfferDocFilterExtension on NftOfferDocFilter {
  NftOfferDocFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftOfferDocFilterCriteria? filters,
  }) {
    return NftOfferDocFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  NftOfferDocFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftOfferDocFilterCriteria?>? filters,
  }) {
    return NftOfferDocFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionRanksDTO {
  const CollectionRanksDTO({
    required this.identifier,
    required this.name,
    required this.rank,
  });

  factory CollectionRanksDTO.fromJson(Map<String, dynamic> json) =>
      _$CollectionRanksDTOFromJson(json);

  static const toJsonFactory = _$CollectionRanksDTOToJson;
  Map<String, dynamic> toJson() => _$CollectionRanksDTOToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'rank')
  final double rank;
  static const fromJsonFactory = _$CollectionRanksDTOFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionRanksDTO &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rank) ^
      runtimeType.hashCode;
}

extension $CollectionRanksDTOExtension on CollectionRanksDTO {
  CollectionRanksDTO copyWith({
    String? identifier,
    String? name,
    double? rank,
  }) {
    return CollectionRanksDTO(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      rank: rank ?? this.rank,
    );
  }

  CollectionRanksDTO copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<double>? rank,
  }) {
    return CollectionRanksDTO(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DensityDto {
  const DensityDto({
    required this.key,
    required this.intervalName,
    required this.intervalCount,
    required this.totalCount,
  });

  factory DensityDto.fromJson(Map<String, dynamic> json) =>
      _$DensityDtoFromJson(json);

  static const toJsonFactory = _$DensityDtoToJson;
  Map<String, dynamic> toJson() => _$DensityDtoToJson(this);

  @JsonKey(name: 'key')
  final String key;
  @JsonKey(name: 'intervalName')
  final String intervalName;
  @JsonKey(name: 'intervalCount')
  final double intervalCount;
  @JsonKey(name: 'totalCount')
  final double totalCount;
  static const fromJsonFactory = _$DensityDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DensityDto &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.intervalName, intervalName) ||
                const DeepCollectionEquality().equals(
                  other.intervalName,
                  intervalName,
                )) &&
            (identical(other.intervalCount, intervalCount) ||
                const DeepCollectionEquality().equals(
                  other.intervalCount,
                  intervalCount,
                )) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality().equals(
                  other.totalCount,
                  totalCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(intervalName) ^
      const DeepCollectionEquality().hash(intervalCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      runtimeType.hashCode;
}

extension $DensityDtoExtension on DensityDto {
  DensityDto copyWith({
    String? key,
    String? intervalName,
    double? intervalCount,
    double? totalCount,
  }) {
    return DensityDto(
      key: key ?? this.key,
      intervalName: intervalName ?? this.intervalName,
      intervalCount: intervalCount ?? this.intervalCount,
      totalCount: totalCount ?? this.totalCount,
    );
  }

  DensityDto copyWithWrapped({
    Wrapped<String>? key,
    Wrapped<String>? intervalName,
    Wrapped<double>? intervalCount,
    Wrapped<double>? totalCount,
  }) {
    return DensityDto(
      key: (key != null ? key.value : this.key),
      intervalName: (intervalName != null
          ? intervalName.value
          : this.intervalName),
      intervalCount: (intervalCount != null
          ? intervalCount.value
          : this.intervalCount),
      totalCount: (totalCount != null ? totalCount.value : this.totalCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RarityDto {
  const RarityDto({required this.rank});

  factory RarityDto.fromJson(Map<String, dynamic> json) =>
      _$RarityDtoFromJson(json);

  static const toJsonFactory = _$RarityDtoToJson;
  Map<String, dynamic> toJson() => _$RarityDtoToJson(this);

  @JsonKey(name: 'rank')
  final double rank;
  static const fromJsonFactory = _$RarityDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RarityDto &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rank) ^ runtimeType.hashCode;
}

extension $RarityDtoExtension on RarityDto {
  RarityDto copyWith({double? rank}) {
    return RarityDto(rank: rank ?? this.rank);
  }

  RarityDto copyWithWrapped({Wrapped<double>? rank}) {
    return RarityDto(rank: (rank != null ? rank.value : this.rank));
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataDto {
  const MetadataDto({required this.rarity});

  factory MetadataDto.fromJson(Map<String, dynamic> json) =>
      _$MetadataDtoFromJson(json);

  static const toJsonFactory = _$MetadataDtoToJson;
  Map<String, dynamic> toJson() => _$MetadataDtoToJson(this);

  @JsonKey(name: 'rarity')
  final RarityDto rarity;
  static const fromJsonFactory = _$MetadataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MetadataDto &&
            (identical(other.rarity, rarity) ||
                const DeepCollectionEquality().equals(other.rarity, rarity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rarity) ^ runtimeType.hashCode;
}

extension $MetadataDtoExtension on MetadataDto {
  MetadataDto copyWith({RarityDto? rarity}) {
    return MetadataDto(rarity: rarity ?? this.rarity);
  }

  MetadataDto copyWithWrapped({Wrapped<RarityDto>? rarity}) {
    return MetadataDto(rarity: (rarity != null ? rarity.value : this.rarity));
  }
}

@JsonSerializable(explicitToJson: true)
class SaleInfoDto {
  const SaleInfoDto({required this.minBidShort, required this.marketplace});

  factory SaleInfoDto.fromJson(Map<String, dynamic> json) =>
      _$SaleInfoDtoFromJson(json);

  static const toJsonFactory = _$SaleInfoDtoToJson;
  Map<String, dynamic> toJson() => _$SaleInfoDtoToJson(this);

  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  static const fromJsonFactory = _$SaleInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SaleInfoDto &&
            (identical(other.minBidShort, minBidShort) ||
                const DeepCollectionEquality().equals(
                  other.minBidShort,
                  minBidShort,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minBidShort) ^
      const DeepCollectionEquality().hash(marketplace) ^
      runtimeType.hashCode;
}

extension $SaleInfoDtoExtension on SaleInfoDto {
  SaleInfoDto copyWith({double? minBidShort, String? marketplace}) {
    return SaleInfoDto(
      minBidShort: minBidShort ?? this.minBidShort,
      marketplace: marketplace ?? this.marketplace,
    );
  }

  SaleInfoDto copyWithWrapped({
    Wrapped<double>? minBidShort,
    Wrapped<String>? marketplace,
  }) {
    return SaleInfoDto(
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ListingDto {
  const ListingDto({
    required this.identifier,
    required this.name,
    required this.collection,
    required this.metadata,
    required this.url,
    required this.media,
    required this.wasProcessed,
    required this.saleInfo,
  });

  factory ListingDto.fromJson(Map<String, dynamic> json) =>
      _$ListingDtoFromJson(json);

  static const toJsonFactory = _$ListingDtoToJson;
  Map<String, dynamic> toJson() => _$ListingDtoToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'metadata')
  final MetadataDto metadata;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'media')
  final NftMedia media;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'saleInfo')
  final SaleInfoDto saleInfo;
  static const fromJsonFactory = _$ListingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListingDto &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.saleInfo, saleInfo) ||
                const DeepCollectionEquality().equals(
                  other.saleInfo,
                  saleInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(saleInfo) ^
      runtimeType.hashCode;
}

extension $ListingDtoExtension on ListingDto {
  ListingDto copyWith({
    String? identifier,
    String? name,
    String? collection,
    MetadataDto? metadata,
    String? url,
    NftMedia? media,
    bool? wasProcessed,
    SaleInfoDto? saleInfo,
  }) {
    return ListingDto(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      collection: collection ?? this.collection,
      metadata: metadata ?? this.metadata,
      url: url ?? this.url,
      media: media ?? this.media,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      saleInfo: saleInfo ?? this.saleInfo,
    );
  }

  ListingDto copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<String>? collection,
    Wrapped<MetadataDto>? metadata,
    Wrapped<String>? url,
    Wrapped<NftMedia>? media,
    Wrapped<bool>? wasProcessed,
    Wrapped<SaleInfoDto>? saleInfo,
  }) {
    return ListingDto(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      collection: (collection != null ? collection.value : this.collection),
      metadata: (metadata != null ? metadata.value : this.metadata),
      url: (url != null ? url.value : this.url),
      media: (media != null ? media.value : this.media),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ListingsResponseDto {
  const ListingsResponseDto({required this.density, required this.listings});

  factory ListingsResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ListingsResponseDtoFromJson(json);

  static const toJsonFactory = _$ListingsResponseDtoToJson;
  Map<String, dynamic> toJson() => _$ListingsResponseDtoToJson(this);

  @JsonKey(name: 'density', defaultValue: <DensityDto>[])
  final List<DensityDto> density;
  @JsonKey(name: 'listings', defaultValue: <ListingDto>[])
  final List<ListingDto> listings;
  static const fromJsonFactory = _$ListingsResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListingsResponseDto &&
            (identical(other.density, density) ||
                const DeepCollectionEquality().equals(
                  other.density,
                  density,
                )) &&
            (identical(other.listings, listings) ||
                const DeepCollectionEquality().equals(
                  other.listings,
                  listings,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(density) ^
      const DeepCollectionEquality().hash(listings) ^
      runtimeType.hashCode;
}

extension $ListingsResponseDtoExtension on ListingsResponseDto {
  ListingsResponseDto copyWith({
    List<DensityDto>? density,
    List<ListingDto>? listings,
  }) {
    return ListingsResponseDto(
      density: density ?? this.density,
      listings: listings ?? this.listings,
    );
  }

  ListingsResponseDto copyWithWrapped({
    Wrapped<List<DensityDto>>? density,
    Wrapped<List<ListingDto>>? listings,
  }) {
    return ListingsResponseDto(
      density: (density != null ? density.value : this.density),
      listings: (listings != null ? listings.value : this.listings),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignWithdrawDto {
  const SignWithdrawDto({required this.auctionId});

  factory SignWithdrawDto.fromJson(Map<String, dynamic> json) =>
      _$SignWithdrawDtoFromJson(json);

  static const toJsonFactory = _$SignWithdrawDtoToJson;
  Map<String, dynamic> toJson() => _$SignWithdrawDtoToJson(this);

  @JsonKey(name: 'auctionId', defaultValue: <double>[])
  final List<double> auctionId;
  static const fromJsonFactory = _$SignWithdrawDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignWithdrawDto &&
            (identical(other.auctionId, auctionId) ||
                const DeepCollectionEquality().equals(
                  other.auctionId,
                  auctionId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auctionId) ^ runtimeType.hashCode;
}

extension $SignWithdrawDtoExtension on SignWithdrawDto {
  SignWithdrawDto copyWith({List<double>? auctionId}) {
    return SignWithdrawDto(auctionId: auctionId ?? this.auctionId);
  }

  SignWithdrawDto copyWithWrapped({Wrapped<List<double>>? auctionId}) {
    return SignWithdrawDto(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignDataDto {
  const SignDataDto({required this.data, required this.signature});

  factory SignDataDto.fromJson(Map<String, dynamic> json) =>
      _$SignDataDtoFromJson(json);

  static const toJsonFactory = _$SignDataDtoToJson;
  Map<String, dynamic> toJson() => _$SignDataDtoToJson(this);

  @JsonKey(name: 'data')
  final String data;
  @JsonKey(name: 'signature')
  final String signature;
  static const fromJsonFactory = _$SignDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignDataDto &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(signature) ^
      runtimeType.hashCode;
}

extension $SignDataDtoExtension on SignDataDto {
  SignDataDto copyWith({String? data, String? signature}) {
    return SignDataDto(
      data: data ?? this.data,
      signature: signature ?? this.signature,
    );
  }

  SignDataDto copyWithWrapped({
    Wrapped<String>? data,
    Wrapped<String>? signature,
  }) {
    return SignDataDto(
      data: (data != null ? data.value : this.data),
      signature: (signature != null ? signature.value : this.signature),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignAcceptGlobalOfferDto {
  const SignAcceptGlobalOfferDto({
    required this.offerId,
    required this.identifier,
  });

  factory SignAcceptGlobalOfferDto.fromJson(Map<String, dynamic> json) =>
      _$SignAcceptGlobalOfferDtoFromJson(json);

  static const toJsonFactory = _$SignAcceptGlobalOfferDtoToJson;
  Map<String, dynamic> toJson() => _$SignAcceptGlobalOfferDtoToJson(this);

  @JsonKey(name: 'offerId')
  final double offerId;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String> identifier;
  static const fromJsonFactory = _$SignAcceptGlobalOfferDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignAcceptGlobalOfferDto &&
            (identical(other.offerId, offerId) ||
                const DeepCollectionEquality().equals(
                  other.offerId,
                  offerId,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(offerId) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $SignAcceptGlobalOfferDtoExtension on SignAcceptGlobalOfferDto {
  SignAcceptGlobalOfferDto copyWith({
    double? offerId,
    List<String>? identifier,
  }) {
    return SignAcceptGlobalOfferDto(
      offerId: offerId ?? this.offerId,
      identifier: identifier ?? this.identifier,
    );
  }

  SignAcceptGlobalOfferDto copyWithWrapped({
    Wrapped<double>? offerId,
    Wrapped<List<String>>? identifier,
  }) {
    return SignAcceptGlobalOfferDto(
      offerId: (offerId != null ? offerId.value : this.offerId),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignMintDto {
  const SignMintDto({required this.quantity, required this.stage});

  factory SignMintDto.fromJson(Map<String, dynamic> json) =>
      _$SignMintDtoFromJson(json);

  static const toJsonFactory = _$SignMintDtoToJson;
  Map<String, dynamic> toJson() => _$SignMintDtoToJson(this);

  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'stage')
  final String stage;
  static const fromJsonFactory = _$SignMintDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignMintDto &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.stage, stage) ||
                const DeepCollectionEquality().equals(other.stage, stage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(stage) ^
      runtimeType.hashCode;
}

extension $SignMintDtoExtension on SignMintDto {
  SignMintDto copyWith({double? quantity, String? stage}) {
    return SignMintDto(
      quantity: quantity ?? this.quantity,
      stage: stage ?? this.stage,
    );
  }

  SignMintDto copyWithWrapped({
    Wrapped<double>? quantity,
    Wrapped<String>? stage,
  }) {
    return SignMintDto(
      quantity: (quantity != null ? quantity.value : this.quantity),
      stage: (stage != null ? stage.value : this.stage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCollectionDoc {
  const ShortCollectionDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.chain,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
  });

  factory ShortCollectionDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCollectionDocFromJson(json);

  static const toJsonFactory = _$ShortCollectionDocToJson;
  Map<String, dynamic> toJson() => _$ShortCollectionDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(
    name: 'chain',
    toJson: shortCollectionDocChainToJson,
    fromJson: shortCollectionDocChainFromJson,
  )
  final enums.ShortCollectionDocChain chain;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  static const fromJsonFactory = _$ShortCollectionDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortCollectionDoc &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(followCount) ^
      runtimeType.hashCode;
}

extension $ShortCollectionDocExtension on ShortCollectionDoc {
  ShortCollectionDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    enums.ShortCollectionDocChain? chain,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
  }) {
    return ShortCollectionDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      chain: chain ?? this.chain,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
    );
  }

  ShortCollectionDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<enums.ShortCollectionDocChain>? chain,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
  }) {
    return ShortCollectionDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      chain: (chain != null ? chain.value : this.chain),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalOfferDocHydrated {
  const GlobalOfferDocHydrated({
    required this.dataType,
    required this.offerId,
    required this.collection,
    required this.price,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.quantity,
    required this.marketplace,
    required this.timestamp,
    required this.attributes,
    required this.priceShort,
    this.floorPriceMargin,
    this.floorPrice,
    required this.isActive,
    required this.chain,
    this.usdValue,
    required this.id,
    required this.ts,
    required this.owner,
    required this.collectionInfo,
  });

  factory GlobalOfferDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$GlobalOfferDocHydratedFromJson(json);

  static const toJsonFactory = _$GlobalOfferDocHydratedToJson;
  Map<String, dynamic> toJson() => _$GlobalOfferDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: globalOfferDocHydratedDataTypeToJson,
    fromJson: globalOfferDocHydratedDataTypeFromJson,
  )
  final enums.GlobalOfferDocHydratedDataType dataType;
  @JsonKey(name: 'offerId')
  final double offerId;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'price')
  final String price;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes> attributes;
  @JsonKey(name: 'priceShort')
  final double priceShort;
  @JsonKey(name: 'floorPriceMargin')
  final double? floorPriceMargin;
  @JsonKey(name: 'floorPrice')
  final double? floorPrice;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(
    name: 'chain',
    toJson: globalOfferDocHydratedChainToJson,
    fromJson: globalOfferDocHydratedChainFromJson,
  )
  final enums.GlobalOfferDocHydratedChain chain;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'owner')
  final OwnerDto owner;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$GlobalOfferDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalOfferDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.offerId, offerId) ||
                const DeepCollectionEquality().equals(
                  other.offerId,
                  offerId,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.paymentTokenNonce, paymentTokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.paymentTokenNonce,
                  paymentTokenNonce,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.priceShort, priceShort) ||
                const DeepCollectionEquality().equals(
                  other.priceShort,
                  priceShort,
                )) &&
            (identical(other.floorPriceMargin, floorPriceMargin) ||
                const DeepCollectionEquality().equals(
                  other.floorPriceMargin,
                  floorPriceMargin,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(offerId) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenNonce) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(priceShort) ^
      const DeepCollectionEquality().hash(floorPriceMargin) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      runtimeType.hashCode;
}

extension $GlobalOfferDocHydratedExtension on GlobalOfferDocHydrated {
  GlobalOfferDocHydrated copyWith({
    enums.GlobalOfferDocHydratedDataType? dataType,
    double? offerId,
    String? collection,
    String? price,
    String? paymentToken,
    double? paymentTokenNonce,
    double? quantity,
    String? marketplace,
    double? timestamp,
    List<NftMetadataAttributes>? attributes,
    double? priceShort,
    double? floorPriceMargin,
    double? floorPrice,
    bool? isActive,
    enums.GlobalOfferDocHydratedChain? chain,
    double? usdValue,
    String? id,
    double? ts,
    OwnerDto? owner,
    ShortCollectionDoc? collectionInfo,
  }) {
    return GlobalOfferDocHydrated(
      dataType: dataType ?? this.dataType,
      offerId: offerId ?? this.offerId,
      collection: collection ?? this.collection,
      price: price ?? this.price,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      attributes: attributes ?? this.attributes,
      priceShort: priceShort ?? this.priceShort,
      floorPriceMargin: floorPriceMargin ?? this.floorPriceMargin,
      floorPrice: floorPrice ?? this.floorPrice,
      isActive: isActive ?? this.isActive,
      chain: chain ?? this.chain,
      usdValue: usdValue ?? this.usdValue,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      owner: owner ?? this.owner,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  GlobalOfferDocHydrated copyWithWrapped({
    Wrapped<enums.GlobalOfferDocHydratedDataType>? dataType,
    Wrapped<double>? offerId,
    Wrapped<String>? collection,
    Wrapped<String>? price,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<double>? quantity,
    Wrapped<String>? marketplace,
    Wrapped<double>? timestamp,
    Wrapped<List<NftMetadataAttributes>>? attributes,
    Wrapped<double>? priceShort,
    Wrapped<double?>? floorPriceMargin,
    Wrapped<double?>? floorPrice,
    Wrapped<bool>? isActive,
    Wrapped<enums.GlobalOfferDocHydratedChain>? chain,
    Wrapped<double?>? usdValue,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? owner,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return GlobalOfferDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      offerId: (offerId != null ? offerId.value : this.offerId),
      collection: (collection != null ? collection.value : this.collection),
      price: (price != null ? price.value : this.price),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      attributes: (attributes != null ? attributes.value : this.attributes),
      priceShort: (priceShort != null ? priceShort.value : this.priceShort),
      floorPriceMargin: (floorPriceMargin != null
          ? floorPriceMargin.value
          : this.floorPriceMargin),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      isActive: (isActive != null ? isActive.value : this.isActive),
      chain: (chain != null ? chain.value : this.chain),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      owner: (owner != null ? owner.value : this.owner),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFull {
  const NftDocFull({
    required this.dataType,
    required this.identifier,
    required this.collection,
    this.originalCollection,
    this.attributes,
    required this.nonce,
    required this.type,
    this.subType,
    required this.supply,
    this.supplyLong,
    required this.name,
    required this.royalties,
    required this.url,
    this.uris,
    required this.wasProcessed,
    this.media,
    this.statistics,
    this.isTicket,
    this.eventData,
    required this.chain,
    this.tags,
    this.kiosk,
    required this.onSale,
    this.id,
    this.ts,
    this.creator,
    this.currentOwner,
    this.owner,
    this.saleInfo,
    this.metadata,
    required this.collectionInfo,
    this.balance,
    this.balanceLong,
    this.unboundDaysLeft,
    this.unboundEpoch,
    this.extraProperties,
    this.globalOffer,
  });

  factory NftDocFull.fromJson(Map<String, dynamic> json) =>
      _$NftDocFullFromJson(json);

  static const toJsonFactory = _$NftDocFullToJson;
  Map<String, dynamic> toJson() => _$NftDocFullToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.nft);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String? originalCollection;
  @JsonKey(name: 'attributes')
  final String? attributes;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(
    name: 'type',
    toJson: esdtTokenTypeToJson,
    fromJson: esdtTokenTypeFromJson,
  )
  final enums.EsdtTokenType type;
  @JsonKey(
    name: 'subType',
    toJson: esdtTokenSubTypeNullableToJson,
    fromJson: esdtTokenSubTypeNullableFromJson,
  )
  final enums.EsdtTokenSubType? subType;
  @JsonKey(name: 'supply')
  final double supply;
  @JsonKey(name: 'supplyLong')
  final String? supplyLong;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'uris')
  final String? uris;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'statistics')
  final NftStats? statistics;
  @JsonKey(name: 'isTicket')
  final bool? isTicket;
  @JsonKey(name: 'eventData')
  final NFTEventData? eventData;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  @JsonKey(name: 'tags')
  final String? tags;
  @JsonKey(name: 'kiosk')
  final String? kiosk;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'creator')
  final OwnerDto? creator;
  @JsonKey(name: 'currentOwner')
  final OwnerDto? currentOwner;
  @JsonKey(name: 'owner')
  final OwnerDto? owner;
  @JsonKey(name: 'saleInfo')
  final NftSaleInfoHydrated? saleInfo;
  @JsonKey(name: 'metadata')
  final NftMetadataHydrated? metadata;
  @JsonKey(name: 'collectionInfo')
  final ShortNftCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'balance')
  final double? balance;
  @JsonKey(name: 'balanceLong')
  final String? balanceLong;
  @JsonKey(name: 'unboundDaysLeft')
  final double? unboundDaysLeft;
  @JsonKey(name: 'unboundEpoch')
  final double? unboundEpoch;
  @JsonKey(name: 'extraProperties')
  final ExtraProperties? extraProperties;
  @JsonKey(name: 'globalOffer')
  final GlobalOfferDocHydrated? globalOffer;
  static const fromJsonFactory = _$NftDocFullFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftDocFull &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.originalCollection, originalCollection) ||
                const DeepCollectionEquality().equals(
                  other.originalCollection,
                  originalCollection,
                )) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality().equals(
                  other.subType,
                  subType,
                )) &&
            (identical(other.supply, supply) ||
                const DeepCollectionEquality().equals(other.supply, supply)) &&
            (identical(other.supplyLong, supplyLong) ||
                const DeepCollectionEquality().equals(
                  other.supplyLong,
                  supplyLong,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.uris, uris) ||
                const DeepCollectionEquality().equals(other.uris, uris)) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality().equals(
                  other.statistics,
                  statistics,
                )) &&
            (identical(other.isTicket, isTicket) ||
                const DeepCollectionEquality().equals(
                  other.isTicket,
                  isTicket,
                )) &&
            (identical(other.eventData, eventData) ||
                const DeepCollectionEquality().equals(
                  other.eventData,
                  eventData,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.kiosk, kiosk) ||
                const DeepCollectionEquality().equals(other.kiosk, kiosk)) &&
            (identical(other.onSale, onSale) ||
                const DeepCollectionEquality().equals(other.onSale, onSale)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.creator, creator) ||
                const DeepCollectionEquality().equals(
                  other.creator,
                  creator,
                )) &&
            (identical(other.currentOwner, currentOwner) ||
                const DeepCollectionEquality().equals(
                  other.currentOwner,
                  currentOwner,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.saleInfo, saleInfo) ||
                const DeepCollectionEquality().equals(
                  other.saleInfo,
                  saleInfo,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.balanceLong, balanceLong) ||
                const DeepCollectionEquality().equals(
                  other.balanceLong,
                  balanceLong,
                )) &&
            (identical(other.unboundDaysLeft, unboundDaysLeft) ||
                const DeepCollectionEquality().equals(
                  other.unboundDaysLeft,
                  unboundDaysLeft,
                )) &&
            (identical(other.unboundEpoch, unboundEpoch) ||
                const DeepCollectionEquality().equals(
                  other.unboundEpoch,
                  unboundEpoch,
                )) &&
            (identical(other.extraProperties, extraProperties) ||
                const DeepCollectionEquality().equals(
                  other.extraProperties,
                  extraProperties,
                )) &&
            (identical(other.globalOffer, globalOffer) ||
                const DeepCollectionEquality().equals(
                  other.globalOffer,
                  globalOffer,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(originalCollection) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(supply) ^
      const DeepCollectionEquality().hash(supplyLong) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(uris) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(isTicket) ^
      const DeepCollectionEquality().hash(eventData) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(kiosk) ^
      const DeepCollectionEquality().hash(onSale) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(creator) ^
      const DeepCollectionEquality().hash(currentOwner) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(saleInfo) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(balanceLong) ^
      const DeepCollectionEquality().hash(unboundDaysLeft) ^
      const DeepCollectionEquality().hash(unboundEpoch) ^
      const DeepCollectionEquality().hash(extraProperties) ^
      const DeepCollectionEquality().hash(globalOffer) ^
      runtimeType.hashCode;
}

extension $NftDocFullExtension on NftDocFull {
  NftDocFull copyWith({
    enums.TokenDataType? dataType,
    String? identifier,
    String? collection,
    String? originalCollection,
    String? attributes,
    double? nonce,
    enums.EsdtTokenType? type,
    enums.EsdtTokenSubType? subType,
    double? supply,
    String? supplyLong,
    String? name,
    double? royalties,
    String? url,
    String? uris,
    bool? wasProcessed,
    NftMedia? media,
    NftStats? statistics,
    bool? isTicket,
    NFTEventData? eventData,
    enums.ActivityChain? chain,
    String? tags,
    String? kiosk,
    bool? onSale,
    String? id,
    double? ts,
    OwnerDto? creator,
    OwnerDto? currentOwner,
    OwnerDto? owner,
    NftSaleInfoHydrated? saleInfo,
    NftMetadataHydrated? metadata,
    ShortNftCollectionInfoDoc? collectionInfo,
    double? balance,
    String? balanceLong,
    double? unboundDaysLeft,
    double? unboundEpoch,
    ExtraProperties? extraProperties,
    GlobalOfferDocHydrated? globalOffer,
  }) {
    return NftDocFull(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      attributes: attributes ?? this.attributes,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      supply: supply ?? this.supply,
      supplyLong: supplyLong ?? this.supplyLong,
      name: name ?? this.name,
      royalties: royalties ?? this.royalties,
      url: url ?? this.url,
      uris: uris ?? this.uris,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      statistics: statistics ?? this.statistics,
      isTicket: isTicket ?? this.isTicket,
      eventData: eventData ?? this.eventData,
      chain: chain ?? this.chain,
      tags: tags ?? this.tags,
      kiosk: kiosk ?? this.kiosk,
      onSale: onSale ?? this.onSale,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      creator: creator ?? this.creator,
      currentOwner: currentOwner ?? this.currentOwner,
      owner: owner ?? this.owner,
      saleInfo: saleInfo ?? this.saleInfo,
      metadata: metadata ?? this.metadata,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      balance: balance ?? this.balance,
      balanceLong: balanceLong ?? this.balanceLong,
      unboundDaysLeft: unboundDaysLeft ?? this.unboundDaysLeft,
      unboundEpoch: unboundEpoch ?? this.unboundEpoch,
      extraProperties: extraProperties ?? this.extraProperties,
      globalOffer: globalOffer ?? this.globalOffer,
    );
  }

  NftDocFull copyWithWrapped({
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String?>? originalCollection,
    Wrapped<String?>? attributes,
    Wrapped<double>? nonce,
    Wrapped<enums.EsdtTokenType>? type,
    Wrapped<enums.EsdtTokenSubType?>? subType,
    Wrapped<double>? supply,
    Wrapped<String?>? supplyLong,
    Wrapped<String>? name,
    Wrapped<double>? royalties,
    Wrapped<String>? url,
    Wrapped<String?>? uris,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftStats?>? statistics,
    Wrapped<bool?>? isTicket,
    Wrapped<NFTEventData?>? eventData,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String?>? tags,
    Wrapped<String?>? kiosk,
    Wrapped<bool>? onSale,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<OwnerDto?>? creator,
    Wrapped<OwnerDto?>? currentOwner,
    Wrapped<OwnerDto?>? owner,
    Wrapped<NftSaleInfoHydrated?>? saleInfo,
    Wrapped<NftMetadataHydrated?>? metadata,
    Wrapped<ShortNftCollectionInfoDoc>? collectionInfo,
    Wrapped<double?>? balance,
    Wrapped<String?>? balanceLong,
    Wrapped<double?>? unboundDaysLeft,
    Wrapped<double?>? unboundEpoch,
    Wrapped<ExtraProperties?>? extraProperties,
    Wrapped<GlobalOfferDocHydrated?>? globalOffer,
  }) {
    return NftDocFull(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      attributes: (attributes != null ? attributes.value : this.attributes),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      supply: (supply != null ? supply.value : this.supply),
      supplyLong: (supplyLong != null ? supplyLong.value : this.supplyLong),
      name: (name != null ? name.value : this.name),
      royalties: (royalties != null ? royalties.value : this.royalties),
      url: (url != null ? url.value : this.url),
      uris: (uris != null ? uris.value : this.uris),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      statistics: (statistics != null ? statistics.value : this.statistics),
      isTicket: (isTicket != null ? isTicket.value : this.isTicket),
      eventData: (eventData != null ? eventData.value : this.eventData),
      chain: (chain != null ? chain.value : this.chain),
      tags: (tags != null ? tags.value : this.tags),
      kiosk: (kiosk != null ? kiosk.value : this.kiosk),
      onSale: (onSale != null ? onSale.value : this.onSale),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      creator: (creator != null ? creator.value : this.creator),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      owner: (owner != null ? owner.value : this.owner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      metadata: (metadata != null ? metadata.value : this.metadata),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      balance: (balance != null ? balance.value : this.balance),
      balanceLong: (balanceLong != null ? balanceLong.value : this.balanceLong),
      unboundDaysLeft: (unboundDaysLeft != null
          ? unboundDaysLeft.value
          : this.unboundDaysLeft),
      unboundEpoch: (unboundEpoch != null
          ? unboundEpoch.value
          : this.unboundEpoch),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
      globalOffer: (globalOffer != null ? globalOffer.value : this.globalOffer),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsOtherDto {
  const StatisticsOtherDto({
    required this.followCount,
    required this.nftCount,
    this.holdersCount,
  });

  factory StatisticsOtherDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsOtherDtoFromJson(json);

  static const toJsonFactory = _$StatisticsOtherDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsOtherDtoToJson(this);

  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'nftCount')
  final double nftCount;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  static const fromJsonFactory = _$StatisticsOtherDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StatisticsOtherDto &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )) &&
            (identical(other.nftCount, nftCount) ||
                const DeepCollectionEquality().equals(
                  other.nftCount,
                  nftCount,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(followCount) ^
      const DeepCollectionEquality().hash(nftCount) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      runtimeType.hashCode;
}

extension $StatisticsOtherDtoExtension on StatisticsOtherDto {
  StatisticsOtherDto copyWith({
    double? followCount,
    double? nftCount,
    double? holdersCount,
  }) {
    return StatisticsOtherDto(
      followCount: followCount ?? this.followCount,
      nftCount: nftCount ?? this.nftCount,
      holdersCount: holdersCount ?? this.holdersCount,
    );
  }

  StatisticsOtherDto copyWithWrapped({
    Wrapped<double>? followCount,
    Wrapped<double>? nftCount,
    Wrapped<double?>? holdersCount,
  }) {
    return StatisticsOtherDto(
      followCount: (followCount != null ? followCount.value : this.followCount),
      nftCount: (nftCount != null ? nftCount.value : this.nftCount),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsTradeDataDto {
  const StatisticsTradeDataDto({
    required this.dayEgldVolume,
    required this.weekEgldVolume,
    required this.totalEgldVolume,
    required this.averageEgldPrice,
    required this.athEgldPrice,
    required this.athTxHash,
    required this.totalTrades,
  });

  factory StatisticsTradeDataDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsTradeDataDtoFromJson(json);

  static const toJsonFactory = _$StatisticsTradeDataDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsTradeDataDtoToJson(this);

  @JsonKey(name: 'dayEgldVolume')
  final double dayEgldVolume;
  @JsonKey(name: 'weekEgldVolume')
  final double weekEgldVolume;
  @JsonKey(name: 'totalEgldVolume')
  final double totalEgldVolume;
  @JsonKey(name: 'averageEgldPrice')
  final double averageEgldPrice;
  @JsonKey(name: 'athEgldPrice')
  final double athEgldPrice;
  @JsonKey(name: 'athTxHash')
  final String athTxHash;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  static const fromJsonFactory = _$StatisticsTradeDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StatisticsTradeDataDto &&
            (identical(other.dayEgldVolume, dayEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.dayEgldVolume,
                  dayEgldVolume,
                )) &&
            (identical(other.weekEgldVolume, weekEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.weekEgldVolume,
                  weekEgldVolume,
                )) &&
            (identical(other.totalEgldVolume, totalEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalEgldVolume,
                  totalEgldVolume,
                )) &&
            (identical(other.averageEgldPrice, averageEgldPrice) ||
                const DeepCollectionEquality().equals(
                  other.averageEgldPrice,
                  averageEgldPrice,
                )) &&
            (identical(other.athEgldPrice, athEgldPrice) ||
                const DeepCollectionEquality().equals(
                  other.athEgldPrice,
                  athEgldPrice,
                )) &&
            (identical(other.athTxHash, athTxHash) ||
                const DeepCollectionEquality().equals(
                  other.athTxHash,
                  athTxHash,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dayEgldVolume) ^
      const DeepCollectionEquality().hash(weekEgldVolume) ^
      const DeepCollectionEquality().hash(totalEgldVolume) ^
      const DeepCollectionEquality().hash(averageEgldPrice) ^
      const DeepCollectionEquality().hash(athEgldPrice) ^
      const DeepCollectionEquality().hash(athTxHash) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      runtimeType.hashCode;
}

extension $StatisticsTradeDataDtoExtension on StatisticsTradeDataDto {
  StatisticsTradeDataDto copyWith({
    double? dayEgldVolume,
    double? weekEgldVolume,
    double? totalEgldVolume,
    double? averageEgldPrice,
    double? athEgldPrice,
    String? athTxHash,
    double? totalTrades,
  }) {
    return StatisticsTradeDataDto(
      dayEgldVolume: dayEgldVolume ?? this.dayEgldVolume,
      weekEgldVolume: weekEgldVolume ?? this.weekEgldVolume,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      averageEgldPrice: averageEgldPrice ?? this.averageEgldPrice,
      athEgldPrice: athEgldPrice ?? this.athEgldPrice,
      athTxHash: athTxHash ?? this.athTxHash,
      totalTrades: totalTrades ?? this.totalTrades,
    );
  }

  StatisticsTradeDataDto copyWithWrapped({
    Wrapped<double>? dayEgldVolume,
    Wrapped<double>? weekEgldVolume,
    Wrapped<double>? totalEgldVolume,
    Wrapped<double>? averageEgldPrice,
    Wrapped<double>? athEgldPrice,
    Wrapped<String>? athTxHash,
    Wrapped<double>? totalTrades,
  }) {
    return StatisticsTradeDataDto(
      dayEgldVolume: (dayEgldVolume != null
          ? dayEgldVolume.value
          : this.dayEgldVolume),
      weekEgldVolume: (weekEgldVolume != null
          ? weekEgldVolume.value
          : this.weekEgldVolume),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      averageEgldPrice: (averageEgldPrice != null
          ? averageEgldPrice.value
          : this.averageEgldPrice),
      athEgldPrice: (athEgldPrice != null
          ? athEgldPrice.value
          : this.athEgldPrice),
      athTxHash: (athTxHash != null ? athTxHash.value : this.athTxHash),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsMintDataDto {
  const StatisticsMintDataDto({
    required this.totalMintEgldVolume,
    required this.weekMintEgldVolume,
    required this.dayMintEgldVolume,
  });

  factory StatisticsMintDataDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsMintDataDtoFromJson(json);

  static const toJsonFactory = _$StatisticsMintDataDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsMintDataDtoToJson(this);

  @JsonKey(name: 'totalMintEgldVolume')
  final double totalMintEgldVolume;
  @JsonKey(name: 'weekMintEgldVolume')
  final double weekMintEgldVolume;
  @JsonKey(name: 'dayMintEgldVolume')
  final double dayMintEgldVolume;
  static const fromJsonFactory = _$StatisticsMintDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StatisticsMintDataDto &&
            (identical(other.totalMintEgldVolume, totalMintEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalMintEgldVolume,
                  totalMintEgldVolume,
                )) &&
            (identical(other.weekMintEgldVolume, weekMintEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.weekMintEgldVolume,
                  weekMintEgldVolume,
                )) &&
            (identical(other.dayMintEgldVolume, dayMintEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.dayMintEgldVolume,
                  dayMintEgldVolume,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalMintEgldVolume) ^
      const DeepCollectionEquality().hash(weekMintEgldVolume) ^
      const DeepCollectionEquality().hash(dayMintEgldVolume) ^
      runtimeType.hashCode;
}

extension $StatisticsMintDataDtoExtension on StatisticsMintDataDto {
  StatisticsMintDataDto copyWith({
    double? totalMintEgldVolume,
    double? weekMintEgldVolume,
    double? dayMintEgldVolume,
  }) {
    return StatisticsMintDataDto(
      totalMintEgldVolume: totalMintEgldVolume ?? this.totalMintEgldVolume,
      weekMintEgldVolume: weekMintEgldVolume ?? this.weekMintEgldVolume,
      dayMintEgldVolume: dayMintEgldVolume ?? this.dayMintEgldVolume,
    );
  }

  StatisticsMintDataDto copyWithWrapped({
    Wrapped<double>? totalMintEgldVolume,
    Wrapped<double>? weekMintEgldVolume,
    Wrapped<double>? dayMintEgldVolume,
  }) {
    return StatisticsMintDataDto(
      totalMintEgldVolume: (totalMintEgldVolume != null
          ? totalMintEgldVolume.value
          : this.totalMintEgldVolume),
      weekMintEgldVolume: (weekMintEgldVolume != null
          ? weekMintEgldVolume.value
          : this.weekMintEgldVolume),
      dayMintEgldVolume: (dayMintEgldVolume != null
          ? dayMintEgldVolume.value
          : this.dayMintEgldVolume),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsDto {
  const StatisticsDto({
    required this.other,
    required this.tradeData,
    this.mintData,
  });

  factory StatisticsDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsDtoFromJson(json);

  static const toJsonFactory = _$StatisticsDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsDtoToJson(this);

  @JsonKey(name: 'other')
  final StatisticsOtherDto other;
  @JsonKey(name: 'tradeData')
  final StatisticsTradeDataDto tradeData;
  @JsonKey(name: 'mintData')
  final StatisticsMintDataDto? mintData;
  static const fromJsonFactory = _$StatisticsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StatisticsDto &&
            (identical(other.other, other) ||
                const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.tradeData, tradeData) ||
                const DeepCollectionEquality().equals(
                  other.tradeData,
                  tradeData,
                )) &&
            (identical(other.mintData, mintData) ||
                const DeepCollectionEquality().equals(
                  other.mintData,
                  mintData,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(tradeData) ^
      const DeepCollectionEquality().hash(mintData) ^
      runtimeType.hashCode;
}

extension $StatisticsDtoExtension on StatisticsDto {
  StatisticsDto copyWith({
    StatisticsOtherDto? other,
    StatisticsTradeDataDto? tradeData,
    StatisticsMintDataDto? mintData,
  }) {
    return StatisticsDto(
      other: other ?? this.other,
      tradeData: tradeData ?? this.tradeData,
      mintData: mintData ?? this.mintData,
    );
  }

  StatisticsDto copyWithWrapped({
    Wrapped<StatisticsOtherDto>? other,
    Wrapped<StatisticsTradeDataDto>? tradeData,
    Wrapped<StatisticsMintDataDto?>? mintData,
  }) {
    return StatisticsDto(
      other: (other != null ? other.value : this.other),
      tradeData: (tradeData != null ? tradeData.value : this.tradeData),
      mintData: (mintData != null ? mintData.value : this.mintData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransferPolicy {
  const TransferPolicy({
    required this.id,
    required this.type,
    required this.rules,
    required this.isOriginByte,
  });

  factory TransferPolicy.fromJson(Map<String, dynamic> json) =>
      _$TransferPolicyFromJson(json);

  static const toJsonFactory = _$TransferPolicyToJson;
  Map<String, dynamic> toJson() => _$TransferPolicyToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'rules', defaultValue: <String>[])
  final List<String> rules;
  @JsonKey(name: 'is_origin_byte')
  final bool isOriginByte;
  static const fromJsonFactory = _$TransferPolicyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransferPolicy &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rules, rules) ||
                const DeepCollectionEquality().equals(other.rules, rules)) &&
            (identical(other.isOriginByte, isOriginByte) ||
                const DeepCollectionEquality().equals(
                  other.isOriginByte,
                  isOriginByte,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rules) ^
      const DeepCollectionEquality().hash(isOriginByte) ^
      runtimeType.hashCode;
}

extension $TransferPolicyExtension on TransferPolicy {
  TransferPolicy copyWith({
    String? id,
    String? type,
    List<String>? rules,
    bool? isOriginByte,
  }) {
    return TransferPolicy(
      id: id ?? this.id,
      type: type ?? this.type,
      rules: rules ?? this.rules,
      isOriginByte: isOriginByte ?? this.isOriginByte,
    );
  }

  TransferPolicy copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? type,
    Wrapped<List<String>>? rules,
    Wrapped<bool>? isOriginByte,
  }) {
    return TransferPolicy(
      id: (id != null ? id.value : this.id),
      type: (type != null ? type.value : this.type),
      rules: (rules != null ? rules.value : this.rules),
      isOriginByte: (isOriginByte != null
          ? isOriginByte.value
          : this.isOriginByte),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileDoc {
  const CollectionProfileDoc({
    required this.dataType,
    required this.collection,
    required this.originalCollection,
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.socials,
    required this.type,
    this.subType,
    required this.profile,
    required this.banner,
    required this.statistics,
    required this.chain,
    required this.transferPolicies,
    required this.owner,
    required this.creator,
    required this.isMintable,
    required this.hasStaking,
    required this.isEvent,
    required this.roles,
    this.eventId,
    this.pinnedAtDrops,
    this.pinnedAt,
    this.customConfig,
    this.royalty,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
    this.minSalePrice,
    this.id,
    this.ts,
  });

  factory CollectionProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileDocFromJson(json);

  static const toJsonFactory = _$CollectionProfileDocToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionProfileDocDataTypeToJson,
    fromJson: collectionProfileDocDataTypeFromJson,
  )
  final enums.CollectionProfileDocDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String originalCollection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(
    name: 'type',
    toJson: collectionProfileDocTypeToJson,
    fromJson: collectionProfileDocTypeFromJson,
  )
  final enums.CollectionProfileDocType type;
  @JsonKey(
    name: 'subType',
    toJson: collectionProfileDocSubTypeNullableToJson,
    fromJson: collectionProfileDocSubTypeNullableFromJson,
  )
  final enums.CollectionProfileDocSubType? subType;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'statistics')
  final StatisticsDto statistics;
  @JsonKey(
    name: 'chain',
    toJson: collectionProfileDocChainToJson,
    fromJson: collectionProfileDocChainFromJson,
  )
  final enums.CollectionProfileDocChain chain;
  @JsonKey(name: 'transferPolicies', defaultValue: <TransferPolicy>[])
  final List<TransferPolicy> transferPolicies;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'creator')
  final String creator;
  @JsonKey(name: 'isMintable')
  final bool isMintable;
  @JsonKey(name: 'hasStaking')
  final bool hasStaking;
  @JsonKey(name: 'isEvent')
  final bool isEvent;
  @JsonKey(name: 'roles')
  final Map<String, dynamic> roles;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'pinnedAtDrops')
  final double? pinnedAtDrops;
  @JsonKey(name: 'pinnedAt')
  final double? pinnedAt;
  @JsonKey(name: 'customConfig')
  final XoxnoMarketplaceScCollectionConfig? customConfig;
  @JsonKey(name: 'royalty')
  final double? royalty;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  @JsonKey(name: 'minSalePrice')
  final String? minSalePrice;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$CollectionProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.originalCollection, originalCollection) ||
                const DeepCollectionEquality().equals(
                  other.originalCollection,
                  originalCollection,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality().equals(
                  other.subType,
                  subType,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality().equals(
                  other.statistics,
                  statistics,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.transferPolicies, transferPolicies) ||
                const DeepCollectionEquality().equals(
                  other.transferPolicies,
                  transferPolicies,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.creator, creator) ||
                const DeepCollectionEquality().equals(
                  other.creator,
                  creator,
                )) &&
            (identical(other.isMintable, isMintable) ||
                const DeepCollectionEquality().equals(
                  other.isMintable,
                  isMintable,
                )) &&
            (identical(other.hasStaking, hasStaking) ||
                const DeepCollectionEquality().equals(
                  other.hasStaking,
                  hasStaking,
                )) &&
            (identical(other.isEvent, isEvent) ||
                const DeepCollectionEquality().equals(
                  other.isEvent,
                  isEvent,
                )) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.pinnedAtDrops, pinnedAtDrops) ||
                const DeepCollectionEquality().equals(
                  other.pinnedAtDrops,
                  pinnedAtDrops,
                )) &&
            (identical(other.pinnedAt, pinnedAt) ||
                const DeepCollectionEquality().equals(
                  other.pinnedAt,
                  pinnedAt,
                )) &&
            (identical(other.customConfig, customConfig) ||
                const DeepCollectionEquality().equals(
                  other.customConfig,
                  customConfig,
                )) &&
            (identical(other.royalty, royalty) ||
                const DeepCollectionEquality().equals(
                  other.royalty,
                  royalty,
                )) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.holdersCount, holdersCount) ||
                const DeepCollectionEquality().equals(
                  other.holdersCount,
                  holdersCount,
                )) &&
            (identical(other.followCount, followCount) ||
                const DeepCollectionEquality().equals(
                  other.followCount,
                  followCount,
                )) &&
            (identical(other.minSalePrice, minSalePrice) ||
                const DeepCollectionEquality().equals(
                  other.minSalePrice,
                  minSalePrice,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(originalCollection) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(transferPolicies) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(creator) ^
      const DeepCollectionEquality().hash(isMintable) ^
      const DeepCollectionEquality().hash(hasStaking) ^
      const DeepCollectionEquality().hash(isEvent) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(pinnedAtDrops) ^
      const DeepCollectionEquality().hash(pinnedAt) ^
      const DeepCollectionEquality().hash(customConfig) ^
      const DeepCollectionEquality().hash(royalty) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(holdersCount) ^
      const DeepCollectionEquality().hash(followCount) ^
      const DeepCollectionEquality().hash(minSalePrice) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $CollectionProfileDocExtension on CollectionProfileDoc {
  CollectionProfileDoc copyWith({
    enums.CollectionProfileDocDataType? dataType,
    String? collection,
    String? originalCollection,
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    SocialsDto? socials,
    enums.CollectionProfileDocType? type,
    enums.CollectionProfileDocSubType? subType,
    String? profile,
    String? banner,
    StatisticsDto? statistics,
    enums.CollectionProfileDocChain? chain,
    List<TransferPolicy>? transferPolicies,
    String? owner,
    String? creator,
    bool? isMintable,
    bool? hasStaking,
    bool? isEvent,
    Map<String, dynamic>? roles,
    String? eventId,
    double? pinnedAtDrops,
    double? pinnedAt,
    XoxnoMarketplaceScCollectionConfig? customConfig,
    double? royalty,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
    String? minSalePrice,
    String? id,
    double? ts,
  }) {
    return CollectionProfileDoc(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      statistics: statistics ?? this.statistics,
      chain: chain ?? this.chain,
      transferPolicies: transferPolicies ?? this.transferPolicies,
      owner: owner ?? this.owner,
      creator: creator ?? this.creator,
      isMintable: isMintable ?? this.isMintable,
      hasStaking: hasStaking ?? this.hasStaking,
      isEvent: isEvent ?? this.isEvent,
      roles: roles ?? this.roles,
      eventId: eventId ?? this.eventId,
      pinnedAtDrops: pinnedAtDrops ?? this.pinnedAtDrops,
      pinnedAt: pinnedAt ?? this.pinnedAt,
      customConfig: customConfig ?? this.customConfig,
      royalty: royalty ?? this.royalty,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
      minSalePrice: minSalePrice ?? this.minSalePrice,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  CollectionProfileDoc copyWithWrapped({
    Wrapped<enums.CollectionProfileDocDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? originalCollection,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<enums.CollectionProfileDocType>? type,
    Wrapped<enums.CollectionProfileDocSubType?>? subType,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<StatisticsDto>? statistics,
    Wrapped<enums.CollectionProfileDocChain>? chain,
    Wrapped<List<TransferPolicy>>? transferPolicies,
    Wrapped<String>? owner,
    Wrapped<String>? creator,
    Wrapped<bool>? isMintable,
    Wrapped<bool>? hasStaking,
    Wrapped<bool>? isEvent,
    Wrapped<Map<String, dynamic>>? roles,
    Wrapped<String?>? eventId,
    Wrapped<double?>? pinnedAtDrops,
    Wrapped<double?>? pinnedAt,
    Wrapped<XoxnoMarketplaceScCollectionConfig?>? customConfig,
    Wrapped<double?>? royalty,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
    Wrapped<String?>? minSalePrice,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
  }) {
    return CollectionProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      statistics: (statistics != null ? statistics.value : this.statistics),
      chain: (chain != null ? chain.value : this.chain),
      transferPolicies: (transferPolicies != null
          ? transferPolicies.value
          : this.transferPolicies),
      owner: (owner != null ? owner.value : this.owner),
      creator: (creator != null ? creator.value : this.creator),
      isMintable: (isMintable != null ? isMintable.value : this.isMintable),
      hasStaking: (hasStaking != null ? hasStaking.value : this.hasStaking),
      isEvent: (isEvent != null ? isEvent.value : this.isEvent),
      roles: (roles != null ? roles.value : this.roles),
      eventId: (eventId != null ? eventId.value : this.eventId),
      pinnedAtDrops: (pinnedAtDrops != null
          ? pinnedAtDrops.value
          : this.pinnedAtDrops),
      pinnedAt: (pinnedAt != null ? pinnedAt.value : this.pinnedAt),
      customConfig: (customConfig != null
          ? customConfig.value
          : this.customConfig),
      royalty: (royalty != null ? royalty.value : this.royalty),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
      minSalePrice: (minSalePrice != null
          ? minSalePrice.value
          : this.minSalePrice),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorPriceDto {
  const FloorPriceDto({
    required this.collection,
    required this.price,
    required this.usdPrice,
  });

  factory FloorPriceDto.fromJson(Map<String, dynamic> json) =>
      _$FloorPriceDtoFromJson(json);

  static const toJsonFactory = _$FloorPriceDtoToJson;
  Map<String, dynamic> toJson() => _$FloorPriceDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  static const fromJsonFactory = _$FloorPriceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorPriceDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.usdPrice, usdPrice) ||
                const DeepCollectionEquality().equals(
                  other.usdPrice,
                  usdPrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(usdPrice) ^
      runtimeType.hashCode;
}

extension $FloorPriceDtoExtension on FloorPriceDto {
  FloorPriceDto copyWith({
    String? collection,
    double? price,
    double? usdPrice,
  }) {
    return FloorPriceDto(
      collection: collection ?? this.collection,
      price: price ?? this.price,
      usdPrice: usdPrice ?? this.usdPrice,
    );
  }

  FloorPriceDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? price,
    Wrapped<double>? usdPrice,
  }) {
    return FloorPriceDto(
      collection: (collection != null ? collection.value : this.collection),
      price: (price != null ? price.value : this.price),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PinnedCollectionDto {
  const PinnedCollectionDto({
    required this.collection,
    required this.name,
    required this.description,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.creator,
    required this.isMintable,
  });

  factory PinnedCollectionDto.fromJson(Map<String, dynamic> json) =>
      _$PinnedCollectionDtoFromJson(json);

  static const toJsonFactory = _$PinnedCollectionDtoToJson;
  Map<String, dynamic> toJson() => _$PinnedCollectionDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: pinnedCollectionDtoChainToJson,
    fromJson: pinnedCollectionDtoChainFromJson,
  )
  final enums.PinnedCollectionDtoChain chain;
  @JsonKey(name: 'creator')
  final String creator;
  @JsonKey(name: 'isMintable')
  final bool isMintable;
  static const fromJsonFactory = _$PinnedCollectionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PinnedCollectionDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.creator, creator) ||
                const DeepCollectionEquality().equals(
                  other.creator,
                  creator,
                )) &&
            (identical(other.isMintable, isMintable) ||
                const DeepCollectionEquality().equals(
                  other.isMintable,
                  isMintable,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(creator) ^
      const DeepCollectionEquality().hash(isMintable) ^
      runtimeType.hashCode;
}

extension $PinnedCollectionDtoExtension on PinnedCollectionDto {
  PinnedCollectionDto copyWith({
    String? collection,
    String? name,
    String? description,
    bool? isVerified,
    String? profile,
    String? banner,
    enums.PinnedCollectionDtoChain? chain,
    String? creator,
    bool? isMintable,
  }) {
    return PinnedCollectionDto(
      collection: collection ?? this.collection,
      name: name ?? this.name,
      description: description ?? this.description,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      creator: creator ?? this.creator,
      isMintable: isMintable ?? this.isMintable,
    );
  }

  PinnedCollectionDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.PinnedCollectionDtoChain>? chain,
    Wrapped<String>? creator,
    Wrapped<bool>? isMintable,
  }) {
    return PinnedCollectionDto(
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      creator: (creator != null ? creator.value : this.creator),
      isMintable: (isMintable != null ? isMintable.value : this.isMintable),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EgldOrEsdtTokenPayment {
  const EgldOrEsdtTokenPayment({
    required this.tokenIdentifier,
    required this.tokenNonce,
    required this.amount,
    this.amountShort,
    this.usdValue,
    this.decimals,
  });

  factory EgldOrEsdtTokenPayment.fromJson(Map<String, dynamic> json) =>
      _$EgldOrEsdtTokenPaymentFromJson(json);

  static const toJsonFactory = _$EgldOrEsdtTokenPaymentToJson;
  Map<String, dynamic> toJson() => _$EgldOrEsdtTokenPaymentToJson(this);

  @JsonKey(name: 'tokenIdentifier')
  final String tokenIdentifier;
  @JsonKey(name: 'tokenNonce')
  final double tokenNonce;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'amountShort')
  final double? amountShort;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  @JsonKey(name: 'decimals')
  final double? decimals;
  static const fromJsonFactory = _$EgldOrEsdtTokenPaymentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EgldOrEsdtTokenPayment &&
            (identical(other.tokenIdentifier, tokenIdentifier) ||
                const DeepCollectionEquality().equals(
                  other.tokenIdentifier,
                  tokenIdentifier,
                )) &&
            (identical(other.tokenNonce, tokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.tokenNonce,
                  tokenNonce,
                )) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.amountShort, amountShort) ||
                const DeepCollectionEquality().equals(
                  other.amountShort,
                  amountShort,
                )) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.decimals, decimals) ||
                const DeepCollectionEquality().equals(
                  other.decimals,
                  decimals,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokenIdentifier) ^
      const DeepCollectionEquality().hash(tokenNonce) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(amountShort) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(decimals) ^
      runtimeType.hashCode;
}

extension $EgldOrEsdtTokenPaymentExtension on EgldOrEsdtTokenPayment {
  EgldOrEsdtTokenPayment copyWith({
    String? tokenIdentifier,
    double? tokenNonce,
    String? amount,
    double? amountShort,
    double? usdValue,
    double? decimals,
  }) {
    return EgldOrEsdtTokenPayment(
      tokenIdentifier: tokenIdentifier ?? this.tokenIdentifier,
      tokenNonce: tokenNonce ?? this.tokenNonce,
      amount: amount ?? this.amount,
      amountShort: amountShort ?? this.amountShort,
      usdValue: usdValue ?? this.usdValue,
      decimals: decimals ?? this.decimals,
    );
  }

  EgldOrEsdtTokenPayment copyWithWrapped({
    Wrapped<String>? tokenIdentifier,
    Wrapped<double>? tokenNonce,
    Wrapped<String>? amount,
    Wrapped<double?>? amountShort,
    Wrapped<double?>? usdValue,
    Wrapped<double?>? decimals,
  }) {
    return EgldOrEsdtTokenPayment(
      tokenIdentifier: (tokenIdentifier != null
          ? tokenIdentifier.value
          : this.tokenIdentifier),
      tokenNonce: (tokenNonce != null ? tokenNonce.value : this.tokenNonce),
      amount: (amount != null ? amount.value : this.amount),
      amountShort: (amountShort != null ? amountShort.value : this.amountShort),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      decimals: (decimals != null ? decimals.value : this.decimals),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCreatorDoc {
  const ShortCreatorDoc({
    required this.name,
    this.contractAddress,
    required this.profile,
  });

  factory ShortCreatorDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCreatorDocFromJson(json);

  static const toJsonFactory = _$ShortCreatorDocToJson;
  Map<String, dynamic> toJson() => _$ShortCreatorDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  static const fromJsonFactory = _$ShortCreatorDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortCreatorDoc &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(profile) ^
      runtimeType.hashCode;
}

extension $ShortCreatorDocExtension on ShortCreatorDoc {
  ShortCreatorDoc copyWith({
    String? name,
    String? contractAddress,
    String? profile,
  }) {
    return ShortCreatorDoc(
      name: name ?? this.name,
      contractAddress: contractAddress ?? this.contractAddress,
      profile: profile ?? this.profile,
    );
  }

  ShortCreatorDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? contractAddress,
    Wrapped<String>? profile,
  }) {
    return ShortCreatorDoc(
      name: (name != null ? name.value : this.name),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      profile: (profile != null ? profile.value : this.profile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileDocHydrated {
  const CollectionMintProfileDocHydrated({
    required this.dataType,
    required this.collection,
    required this.creatorTag,
    required this.creatorName,
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.baseNftName,
    required this.hasAttributes,
    required this.ownerTransferred,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.royalties,
    required this.oldVersion,
    required this.nameShuffle,
    required this.nftTransferLimited,
    this.allowsPublicBurn,
    required this.kycRequired,
    required this.allowsRefund,
    required this.hasBotProtection,
    required this.hasReveal,
    required this.tags,
    required this.prices,
    required this.startTime,
    required this.endTime,
    required this.isSoldOut,
    required this.id,
    this.ts,
    required this.collectionInfo,
    required this.creatorInfo,
  });

  factory CollectionMintProfileDocHydrated.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionMintProfileDocHydratedFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileDocHydratedToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionMintProfileDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionMintProfileDocHydratedDataTypeToJson,
    fromJson: collectionMintProfileDocHydratedDataTypeFromJson,
  )
  final enums.CollectionMintProfileDocHydratedDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'creatorName')
  final String creatorName;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'baseNftName')
  final String baseNftName;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'ownerTransferred')
  final bool ownerTransferred;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'oldVersion')
  final bool oldVersion;
  @JsonKey(name: 'nameShuffle')
  final bool nameShuffle;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'allowsPublicBurn')
  final bool? allowsPublicBurn;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'allowsRefund')
  final bool allowsRefund;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'hasReveal')
  final bool hasReveal;
  @JsonKey(name: 'tags')
  final Object tags;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'isSoldOut')
  final bool isSoldOut;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'creatorInfo')
  final ShortCreatorDoc creatorInfo;
  static const fromJsonFactory = _$CollectionMintProfileDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionMintProfileDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.creatorName, creatorName) ||
                const DeepCollectionEquality().equals(
                  other.creatorName,
                  creatorName,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.collectionTag, collectionTag) ||
                const DeepCollectionEquality().equals(
                  other.collectionTag,
                  collectionTag,
                )) &&
            (identical(other.cid, cid) ||
                const DeepCollectionEquality().equals(other.cid, cid)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality().equals(
                  other.mediaType,
                  mediaType,
                )) &&
            (identical(other.baseNftName, baseNftName) ||
                const DeepCollectionEquality().equals(
                  other.baseNftName,
                  baseNftName,
                )) &&
            (identical(other.hasAttributes, hasAttributes) ||
                const DeepCollectionEquality().equals(
                  other.hasAttributes,
                  hasAttributes,
                )) &&
            (identical(other.ownerTransferred, ownerTransferred) ||
                const DeepCollectionEquality().equals(
                  other.ownerTransferred,
                  ownerTransferred,
                )) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.totalNftMinted, totalNftMinted) ||
                const DeepCollectionEquality().equals(
                  other.totalNftMinted,
                  totalNftMinted,
                )) &&
            (identical(other.globalWalletLimit, globalWalletLimit) ||
                const DeepCollectionEquality().equals(
                  other.globalWalletLimit,
                  globalWalletLimit,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.oldVersion, oldVersion) ||
                const DeepCollectionEquality().equals(
                  other.oldVersion,
                  oldVersion,
                )) &&
            (identical(other.nameShuffle, nameShuffle) ||
                const DeepCollectionEquality().equals(
                  other.nameShuffle,
                  nameShuffle,
                )) &&
            (identical(other.nftTransferLimited, nftTransferLimited) ||
                const DeepCollectionEquality().equals(
                  other.nftTransferLimited,
                  nftTransferLimited,
                )) &&
            (identical(other.allowsPublicBurn, allowsPublicBurn) ||
                const DeepCollectionEquality().equals(
                  other.allowsPublicBurn,
                  allowsPublicBurn,
                )) &&
            (identical(other.kycRequired, kycRequired) ||
                const DeepCollectionEquality().equals(
                  other.kycRequired,
                  kycRequired,
                )) &&
            (identical(other.allowsRefund, allowsRefund) ||
                const DeepCollectionEquality().equals(
                  other.allowsRefund,
                  allowsRefund,
                )) &&
            (identical(other.hasBotProtection, hasBotProtection) ||
                const DeepCollectionEquality().equals(
                  other.hasBotProtection,
                  hasBotProtection,
                )) &&
            (identical(other.hasReveal, hasReveal) ||
                const DeepCollectionEquality().equals(
                  other.hasReveal,
                  hasReveal,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.isSoldOut, isSoldOut) ||
                const DeepCollectionEquality().equals(
                  other.isSoldOut,
                  isSoldOut,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )) &&
            (identical(other.creatorInfo, creatorInfo) ||
                const DeepCollectionEquality().equals(
                  other.creatorInfo,
                  creatorInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(creatorName) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(collectionTag) ^
      const DeepCollectionEquality().hash(cid) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(baseNftName) ^
      const DeepCollectionEquality().hash(hasAttributes) ^
      const DeepCollectionEquality().hash(ownerTransferred) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(totalNftMinted) ^
      const DeepCollectionEquality().hash(globalWalletLimit) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(oldVersion) ^
      const DeepCollectionEquality().hash(nameShuffle) ^
      const DeepCollectionEquality().hash(nftTransferLimited) ^
      const DeepCollectionEquality().hash(allowsPublicBurn) ^
      const DeepCollectionEquality().hash(kycRequired) ^
      const DeepCollectionEquality().hash(allowsRefund) ^
      const DeepCollectionEquality().hash(hasBotProtection) ^
      const DeepCollectionEquality().hash(hasReveal) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(prices) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(isSoldOut) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      const DeepCollectionEquality().hash(creatorInfo) ^
      runtimeType.hashCode;
}

extension $CollectionMintProfileDocHydratedExtension
    on CollectionMintProfileDocHydrated {
  CollectionMintProfileDocHydrated copyWith({
    enums.CollectionMintProfileDocHydratedDataType? dataType,
    String? collection,
    String? creatorTag,
    String? creatorName,
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    String? baseNftName,
    bool? hasAttributes,
    bool? ownerTransferred,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    double? royalties,
    bool? oldVersion,
    bool? nameShuffle,
    bool? nftTransferLimited,
    bool? allowsPublicBurn,
    bool? kycRequired,
    bool? allowsRefund,
    bool? hasBotProtection,
    bool? hasReveal,
    Object? tags,
    List<EgldOrEsdtTokenPayment>? prices,
    double? startTime,
    double? endTime,
    bool? isSoldOut,
    String? id,
    double? ts,
    ShortCollectionInfoDoc? collectionInfo,
    ShortCreatorDoc? creatorInfo,
  }) {
    return CollectionMintProfileDocHydrated(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      creatorTag: creatorTag ?? this.creatorTag,
      creatorName: creatorName ?? this.creatorName,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      baseNftName: baseNftName ?? this.baseNftName,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      ownerTransferred: ownerTransferred ?? this.ownerTransferred,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      royalties: royalties ?? this.royalties,
      oldVersion: oldVersion ?? this.oldVersion,
      nameShuffle: nameShuffle ?? this.nameShuffle,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      allowsPublicBurn: allowsPublicBurn ?? this.allowsPublicBurn,
      kycRequired: kycRequired ?? this.kycRequired,
      allowsRefund: allowsRefund ?? this.allowsRefund,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      hasReveal: hasReveal ?? this.hasReveal,
      tags: tags ?? this.tags,
      prices: prices ?? this.prices,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isSoldOut: isSoldOut ?? this.isSoldOut,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      creatorInfo: creatorInfo ?? this.creatorInfo,
    );
  }

  CollectionMintProfileDocHydrated copyWithWrapped({
    Wrapped<enums.CollectionMintProfileDocHydratedDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? creatorTag,
    Wrapped<String>? creatorName,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<String>? baseNftName,
    Wrapped<bool>? hasAttributes,
    Wrapped<bool>? ownerTransferred,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<double>? royalties,
    Wrapped<bool>? oldVersion,
    Wrapped<bool>? nameShuffle,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool?>? allowsPublicBurn,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? allowsRefund,
    Wrapped<bool>? hasBotProtection,
    Wrapped<bool>? hasReveal,
    Wrapped<Object>? tags,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<bool>? isSoldOut,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
    Wrapped<ShortCreatorDoc>? creatorInfo,
  }) {
    return CollectionMintProfileDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      baseNftName: (baseNftName != null ? baseNftName.value : this.baseNftName),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      ownerTransferred: (ownerTransferred != null
          ? ownerTransferred.value
          : this.ownerTransferred),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      royalties: (royalties != null ? royalties.value : this.royalties),
      oldVersion: (oldVersion != null ? oldVersion.value : this.oldVersion),
      nameShuffle: (nameShuffle != null ? nameShuffle.value : this.nameShuffle),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      allowsPublicBurn: (allowsPublicBurn != null
          ? allowsPublicBurn.value
          : this.allowsPublicBurn),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      allowsRefund: (allowsRefund != null
          ? allowsRefund.value
          : this.allowsRefund),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      hasReveal: (hasReveal != null ? hasReveal.value : this.hasReveal),
      tags: (tags != null ? tags.value : this.tags),
      prices: (prices != null ? prices.value : this.prices),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      isSoldOut: (isSoldOut != null ? isSoldOut.value : this.isSoldOut),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      creatorInfo: (creatorInfo != null ? creatorInfo.value : this.creatorInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionPinnedStatusDto {
  const CollectionPinnedStatusDto({
    required this.collection,
    required this.status,
  });

  factory CollectionPinnedStatusDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionPinnedStatusDtoFromJson(json);

  static const toJsonFactory = _$CollectionPinnedStatusDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionPinnedStatusDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'status')
  final bool status;
  static const fromJsonFactory = _$CollectionPinnedStatusDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionPinnedStatusDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $CollectionPinnedStatusDtoExtension on CollectionPinnedStatusDto {
  CollectionPinnedStatusDto copyWith({String? collection, bool? status}) {
    return CollectionPinnedStatusDto(
      collection: collection ?? this.collection,
      status: status ?? this.status,
    );
  }

  CollectionPinnedStatusDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<bool>? status,
  }) {
    return CollectionPinnedStatusDto(
      collection: (collection != null ? collection.value : this.collection),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileEditDto {
  const CollectionProfileEditDto({this.name, this.description, this.socials});

  factory CollectionProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileEditDtoFromJson(json);

  static const toJsonFactory = _$CollectionProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  static const fromJsonFactory = _$CollectionProfileEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionProfileEditDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(other.socials, socials)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(socials) ^
      runtimeType.hashCode;
}

extension $CollectionProfileEditDtoExtension on CollectionProfileEditDto {
  CollectionProfileEditDto copyWith({
    String? name,
    String? description,
    SocialsDto? socials,
  }) {
    return CollectionProfileEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
      socials: socials ?? this.socials,
    );
  }

  CollectionProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
  }) {
    return CollectionProfileEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FollowCollectionDto {
  const FollowCollectionDto({required this.isFavorite, this.collection});

  factory FollowCollectionDto.fromJson(Map<String, dynamic> json) =>
      _$FollowCollectionDtoFromJson(json);

  static const toJsonFactory = _$FollowCollectionDtoToJson;
  Map<String, dynamic> toJson() => _$FollowCollectionDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'collection')
  final String? collection;
  static const fromJsonFactory = _$FollowCollectionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FollowCollectionDto &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality().equals(
                  other.isFavorite,
                  isFavorite,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isFavorite) ^
      const DeepCollectionEquality().hash(collection) ^
      runtimeType.hashCode;
}

extension $FollowCollectionDtoExtension on FollowCollectionDto {
  FollowCollectionDto copyWith({bool? isFavorite, String? collection}) {
    return FollowCollectionDto(
      isFavorite: isFavorite ?? this.isFavorite,
      collection: collection ?? this.collection,
    );
  }

  FollowCollectionDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String?>? collection,
  }) {
    return FollowCollectionDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      collection: (collection != null ? collection.value : this.collection),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileFilter {
  const CollectionProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
  });

  factory CollectionProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileFilterFromJson(json);

  static const toJsonFactory = _$CollectionProfileFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  static const fromJsonFactory = _$CollectionProfileFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionProfileFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      runtimeType.hashCode;
}

extension $CollectionProfileFilterExtension on CollectionProfileFilter {
  CollectionProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
  }) {
    return CollectionProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
    );
  }

  CollectionProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
  }) {
    return CollectionProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfilePaginated {
  const CollectionProfilePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionProfilePaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfilePaginatedFromJson(json);

  static const toJsonFactory = _$CollectionProfilePaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionProfilePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <CollectionProfileDoc>[])
  final List<CollectionProfileDoc> resources;
  static const fromJsonFactory = _$CollectionProfilePaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionProfilePaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $CollectionProfilePaginatedExtension on CollectionProfilePaginated {
  CollectionProfilePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionProfileDoc>? resources,
  }) {
    return CollectionProfilePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionProfilePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionProfileDoc>>? resources,
  }) {
    return CollectionProfilePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileFilter {
  const CollectionMintProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
  });

  factory CollectionMintProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionMintProfileFilterFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionMintProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  static const fromJsonFactory = _$CollectionMintProfileFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionMintProfileFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      runtimeType.hashCode;
}

extension $CollectionMintProfileFilterExtension on CollectionMintProfileFilter {
  CollectionMintProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
  }) {
    return CollectionMintProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
    );
  }

  CollectionMintProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
  }) {
    return CollectionMintProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfilePaginated {
  const CollectionMintProfilePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionMintProfilePaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionMintProfilePaginatedFromJson(json);

  static const toJsonFactory = _$CollectionMintProfilePaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionMintProfilePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(
    name: 'resources',
    defaultValue: <CollectionMintProfileDocHydrated>[],
  )
  final List<CollectionMintProfileDocHydrated> resources;
  static const fromJsonFactory = _$CollectionMintProfilePaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionMintProfilePaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $CollectionMintProfilePaginatedExtension
    on CollectionMintProfilePaginated {
  CollectionMintProfilePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionMintProfileDocHydrated>? resources,
  }) {
    return CollectionMintProfilePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionMintProfilePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionMintProfileDocHydrated>>? resources,
  }) {
    return CollectionMintProfilePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MintStageDto {
  const MintStageDto({
    required this.dataType,
    required this.collection,
    required this.contractAddress,
    required this.collectionTag,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.mintCount,
    required this.mintLimit,
    required this.mintEnabled,
    required this.isWhitelist,
    required this.walletLimit,
    required this.prices,
    required this.id,
    required this.ts,
    required this.walletLimitReached,
    this.maxBuyable,
    this.userMintsPerStage,
  });

  factory MintStageDto.fromJson(Map<String, dynamic> json) =>
      _$MintStageDtoFromJson(json);

  static const toJsonFactory = _$MintStageDtoToJson;
  Map<String, dynamic> toJson() => _$MintStageDtoToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'mintCount')
  final double mintCount;
  @JsonKey(name: 'mintLimit')
  final double mintLimit;
  @JsonKey(name: 'mintEnabled')
  final bool mintEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'walletLimit')
  final double walletLimit;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'walletLimitReached')
  final bool walletLimitReached;
  @JsonKey(name: 'maxBuyable')
  final Object? maxBuyable;
  @JsonKey(name: 'userMintsPerStage')
  final double? userMintsPerStage;
  static const fromJsonFactory = _$MintStageDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MintStageDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.collectionTag, collectionTag) ||
                const DeepCollectionEquality().equals(
                  other.collectionTag,
                  collectionTag,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.mintCount, mintCount) ||
                const DeepCollectionEquality().equals(
                  other.mintCount,
                  mintCount,
                )) &&
            (identical(other.mintLimit, mintLimit) ||
                const DeepCollectionEquality().equals(
                  other.mintLimit,
                  mintLimit,
                )) &&
            (identical(other.mintEnabled, mintEnabled) ||
                const DeepCollectionEquality().equals(
                  other.mintEnabled,
                  mintEnabled,
                )) &&
            (identical(other.isWhitelist, isWhitelist) ||
                const DeepCollectionEquality().equals(
                  other.isWhitelist,
                  isWhitelist,
                )) &&
            (identical(other.walletLimit, walletLimit) ||
                const DeepCollectionEquality().equals(
                  other.walletLimit,
                  walletLimit,
                )) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.walletLimitReached, walletLimitReached) ||
                const DeepCollectionEquality().equals(
                  other.walletLimitReached,
                  walletLimitReached,
                )) &&
            (identical(other.maxBuyable, maxBuyable) ||
                const DeepCollectionEquality().equals(
                  other.maxBuyable,
                  maxBuyable,
                )) &&
            (identical(other.userMintsPerStage, userMintsPerStage) ||
                const DeepCollectionEquality().equals(
                  other.userMintsPerStage,
                  userMintsPerStage,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(collectionTag) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(mintCount) ^
      const DeepCollectionEquality().hash(mintLimit) ^
      const DeepCollectionEquality().hash(mintEnabled) ^
      const DeepCollectionEquality().hash(isWhitelist) ^
      const DeepCollectionEquality().hash(walletLimit) ^
      const DeepCollectionEquality().hash(prices) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(walletLimitReached) ^
      const DeepCollectionEquality().hash(maxBuyable) ^
      const DeepCollectionEquality().hash(userMintsPerStage) ^
      runtimeType.hashCode;
}

extension $MintStageDtoExtension on MintStageDto {
  MintStageDto copyWith({
    Object? dataType,
    String? collection,
    String? contractAddress,
    String? collectionTag,
    String? name,
    double? startTime,
    double? endTime,
    double? mintCount,
    double? mintLimit,
    bool? mintEnabled,
    bool? isWhitelist,
    double? walletLimit,
    List<EgldOrEsdtTokenPayment>? prices,
    String? id,
    double? ts,
    bool? walletLimitReached,
    Object? maxBuyable,
    double? userMintsPerStage,
  }) {
    return MintStageDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      mintCount: mintCount ?? this.mintCount,
      mintLimit: mintLimit ?? this.mintLimit,
      mintEnabled: mintEnabled ?? this.mintEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      walletLimit: walletLimit ?? this.walletLimit,
      prices: prices ?? this.prices,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      walletLimitReached: walletLimitReached ?? this.walletLimitReached,
      maxBuyable: maxBuyable ?? this.maxBuyable,
      userMintsPerStage: userMintsPerStage ?? this.userMintsPerStage,
    );
  }

  MintStageDto copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? name,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<double>? mintCount,
    Wrapped<double>? mintLimit,
    Wrapped<bool>? mintEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<double>? walletLimit,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<bool>? walletLimitReached,
    Wrapped<Object?>? maxBuyable,
    Wrapped<double?>? userMintsPerStage,
  }) {
    return MintStageDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      mintCount: (mintCount != null ? mintCount.value : this.mintCount),
      mintLimit: (mintLimit != null ? mintLimit.value : this.mintLimit),
      mintEnabled: (mintEnabled != null ? mintEnabled.value : this.mintEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      walletLimit: (walletLimit != null ? walletLimit.value : this.walletLimit),
      prices: (prices != null ? prices.value : this.prices),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      walletLimitReached: (walletLimitReached != null
          ? walletLimitReached.value
          : this.walletLimitReached),
      maxBuyable: (maxBuyable != null ? maxBuyable.value : this.maxBuyable),
      userMintsPerStage: (userMintsPerStage != null
          ? userMintsPerStage.value
          : this.userMintsPerStage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileDocWithStages {
  const CollectionMintProfileDocWithStages({
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.hasAttributes,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.nftTransferLimited,
    required this.kycRequired,
    required this.hasBotProtection,
    required this.collectionInfo,
    required this.collection,
    required this.isExcludedFromMint,
    required this.userMintsGlobal,
    required this.mintStages,
    required this.creatorInfo,
  });

  factory CollectionMintProfileDocWithStages.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionMintProfileDocWithStagesFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileDocWithStagesToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionMintProfileDocWithStagesToJson(this);

  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'isExcludedFromMint')
  final bool isExcludedFromMint;
  @JsonKey(name: 'userMintsGlobal')
  final double userMintsGlobal;
  @JsonKey(name: 'mintStages', defaultValue: <MintStageDto>[])
  final List<MintStageDto> mintStages;
  @JsonKey(name: 'creatorInfo')
  final CreatorProfileDoc creatorInfo;
  static const fromJsonFactory = _$CollectionMintProfileDocWithStagesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionMintProfileDocWithStages &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.collectionTag, collectionTag) ||
                const DeepCollectionEquality().equals(
                  other.collectionTag,
                  collectionTag,
                )) &&
            (identical(other.cid, cid) ||
                const DeepCollectionEquality().equals(other.cid, cid)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality().equals(
                  other.mediaType,
                  mediaType,
                )) &&
            (identical(other.hasAttributes, hasAttributes) ||
                const DeepCollectionEquality().equals(
                  other.hasAttributes,
                  hasAttributes,
                )) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.totalNftMinted, totalNftMinted) ||
                const DeepCollectionEquality().equals(
                  other.totalNftMinted,
                  totalNftMinted,
                )) &&
            (identical(other.globalWalletLimit, globalWalletLimit) ||
                const DeepCollectionEquality().equals(
                  other.globalWalletLimit,
                  globalWalletLimit,
                )) &&
            (identical(other.nftTransferLimited, nftTransferLimited) ||
                const DeepCollectionEquality().equals(
                  other.nftTransferLimited,
                  nftTransferLimited,
                )) &&
            (identical(other.kycRequired, kycRequired) ||
                const DeepCollectionEquality().equals(
                  other.kycRequired,
                  kycRequired,
                )) &&
            (identical(other.hasBotProtection, hasBotProtection) ||
                const DeepCollectionEquality().equals(
                  other.hasBotProtection,
                  hasBotProtection,
                )) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.isExcludedFromMint, isExcludedFromMint) ||
                const DeepCollectionEquality().equals(
                  other.isExcludedFromMint,
                  isExcludedFromMint,
                )) &&
            (identical(other.userMintsGlobal, userMintsGlobal) ||
                const DeepCollectionEquality().equals(
                  other.userMintsGlobal,
                  userMintsGlobal,
                )) &&
            (identical(other.mintStages, mintStages) ||
                const DeepCollectionEquality().equals(
                  other.mintStages,
                  mintStages,
                )) &&
            (identical(other.creatorInfo, creatorInfo) ||
                const DeepCollectionEquality().equals(
                  other.creatorInfo,
                  creatorInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(collectionTag) ^
      const DeepCollectionEquality().hash(cid) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(hasAttributes) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(totalNftMinted) ^
      const DeepCollectionEquality().hash(globalWalletLimit) ^
      const DeepCollectionEquality().hash(nftTransferLimited) ^
      const DeepCollectionEquality().hash(kycRequired) ^
      const DeepCollectionEquality().hash(hasBotProtection) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(isExcludedFromMint) ^
      const DeepCollectionEquality().hash(userMintsGlobal) ^
      const DeepCollectionEquality().hash(mintStages) ^
      const DeepCollectionEquality().hash(creatorInfo) ^
      runtimeType.hashCode;
}

extension $CollectionMintProfileDocWithStagesExtension
    on CollectionMintProfileDocWithStages {
  CollectionMintProfileDocWithStages copyWith({
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    bool? hasAttributes,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    bool? nftTransferLimited,
    bool? kycRequired,
    bool? hasBotProtection,
    ShortCollectionInfoDoc? collectionInfo,
    String? collection,
    bool? isExcludedFromMint,
    double? userMintsGlobal,
    List<MintStageDto>? mintStages,
    CreatorProfileDoc? creatorInfo,
  }) {
    return CollectionMintProfileDocWithStages(
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      kycRequired: kycRequired ?? this.kycRequired,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      collection: collection ?? this.collection,
      isExcludedFromMint: isExcludedFromMint ?? this.isExcludedFromMint,
      userMintsGlobal: userMintsGlobal ?? this.userMintsGlobal,
      mintStages: mintStages ?? this.mintStages,
      creatorInfo: creatorInfo ?? this.creatorInfo,
    );
  }

  CollectionMintProfileDocWithStages copyWithWrapped({
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<bool>? hasAttributes,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? hasBotProtection,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
    Wrapped<String>? collection,
    Wrapped<bool>? isExcludedFromMint,
    Wrapped<double>? userMintsGlobal,
    Wrapped<List<MintStageDto>>? mintStages,
    Wrapped<CreatorProfileDoc>? creatorInfo,
  }) {
    return CollectionMintProfileDocWithStages(
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      collection: (collection != null ? collection.value : this.collection),
      isExcludedFromMint: (isExcludedFromMint != null
          ? isExcludedFromMint.value
          : this.isExcludedFromMint),
      userMintsGlobal: (userMintsGlobal != null
          ? userMintsGlobal.value
          : this.userMintsGlobal),
      mintStages: (mintStages != null ? mintStages.value : this.mintStages),
      creatorInfo: (creatorInfo != null ? creatorInfo.value : this.creatorInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WalletDetailDto {
  const WalletDetailDto({
    required this.count,
    required this.weight,
    required this.address,
    required this.username,
    required this.type,
  });

  factory WalletDetailDto.fromJson(Map<String, dynamic> json) =>
      _$WalletDetailDtoFromJson(json);

  static const toJsonFactory = _$WalletDetailDtoToJson;
  Map<String, dynamic> toJson() => _$WalletDetailDtoToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'weight')
  final double weight;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$WalletDetailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletDetailDto &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $WalletDetailDtoExtension on WalletDetailDto {
  WalletDetailDto copyWith({
    double? count,
    double? weight,
    String? address,
    String? username,
    String? type,
  }) {
    return WalletDetailDto(
      count: count ?? this.count,
      weight: weight ?? this.weight,
      address: address ?? this.address,
      username: username ?? this.username,
      type: type ?? this.type,
    );
  }

  WalletDetailDto copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<double>? weight,
    Wrapped<String>? address,
    Wrapped<String>? username,
    Wrapped<String>? type,
  }) {
    return WalletDetailDto(
      count: (count != null ? count.value : this.count),
      weight: (weight != null ? weight.value : this.weight),
      address: (address != null ? address.value : this.address),
      username: (username != null ? username.value : this.username),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionHoldersDto {
  const CollectionHoldersDto({
    required this.totalSupply,
    required this.walletDetails,
    required this.onMarket,
    required this.staked,
    required this.otherSCs,
    required this.burnWallet,
    required this.uniqueHolders,
    required this.holded,
  });

  factory CollectionHoldersDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionHoldersDtoFromJson(json);

  static const toJsonFactory = _$CollectionHoldersDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionHoldersDtoToJson(this);

  @JsonKey(name: 'totalSupply')
  final double totalSupply;
  @JsonKey(name: 'walletDetails', defaultValue: <WalletDetailDto>[])
  final List<WalletDetailDto> walletDetails;
  @JsonKey(name: 'onMarket')
  final Object onMarket;
  @JsonKey(name: 'staked')
  final Object staked;
  @JsonKey(name: 'otherSCs')
  final Object otherSCs;
  @JsonKey(name: 'burnWallet')
  final Object burnWallet;
  @JsonKey(name: 'uniqueHolders')
  final Object uniqueHolders;
  @JsonKey(name: 'holded')
  final Object holded;
  static const fromJsonFactory = _$CollectionHoldersDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionHoldersDto &&
            (identical(other.totalSupply, totalSupply) ||
                const DeepCollectionEquality().equals(
                  other.totalSupply,
                  totalSupply,
                )) &&
            (identical(other.walletDetails, walletDetails) ||
                const DeepCollectionEquality().equals(
                  other.walletDetails,
                  walletDetails,
                )) &&
            (identical(other.onMarket, onMarket) ||
                const DeepCollectionEquality().equals(
                  other.onMarket,
                  onMarket,
                )) &&
            (identical(other.staked, staked) ||
                const DeepCollectionEquality().equals(other.staked, staked)) &&
            (identical(other.otherSCs, otherSCs) ||
                const DeepCollectionEquality().equals(
                  other.otherSCs,
                  otherSCs,
                )) &&
            (identical(other.burnWallet, burnWallet) ||
                const DeepCollectionEquality().equals(
                  other.burnWallet,
                  burnWallet,
                )) &&
            (identical(other.uniqueHolders, uniqueHolders) ||
                const DeepCollectionEquality().equals(
                  other.uniqueHolders,
                  uniqueHolders,
                )) &&
            (identical(other.holded, holded) ||
                const DeepCollectionEquality().equals(other.holded, holded)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalSupply) ^
      const DeepCollectionEquality().hash(walletDetails) ^
      const DeepCollectionEquality().hash(onMarket) ^
      const DeepCollectionEquality().hash(staked) ^
      const DeepCollectionEquality().hash(otherSCs) ^
      const DeepCollectionEquality().hash(burnWallet) ^
      const DeepCollectionEquality().hash(uniqueHolders) ^
      const DeepCollectionEquality().hash(holded) ^
      runtimeType.hashCode;
}

extension $CollectionHoldersDtoExtension on CollectionHoldersDto {
  CollectionHoldersDto copyWith({
    double? totalSupply,
    List<WalletDetailDto>? walletDetails,
    Object? onMarket,
    Object? staked,
    Object? otherSCs,
    Object? burnWallet,
    Object? uniqueHolders,
    Object? holded,
  }) {
    return CollectionHoldersDto(
      totalSupply: totalSupply ?? this.totalSupply,
      walletDetails: walletDetails ?? this.walletDetails,
      onMarket: onMarket ?? this.onMarket,
      staked: staked ?? this.staked,
      otherSCs: otherSCs ?? this.otherSCs,
      burnWallet: burnWallet ?? this.burnWallet,
      uniqueHolders: uniqueHolders ?? this.uniqueHolders,
      holded: holded ?? this.holded,
    );
  }

  CollectionHoldersDto copyWithWrapped({
    Wrapped<double>? totalSupply,
    Wrapped<List<WalletDetailDto>>? walletDetails,
    Wrapped<Object>? onMarket,
    Wrapped<Object>? staked,
    Wrapped<Object>? otherSCs,
    Wrapped<Object>? burnWallet,
    Wrapped<Object>? uniqueHolders,
    Wrapped<Object>? holded,
  }) {
    return CollectionHoldersDto(
      totalSupply: (totalSupply != null ? totalSupply.value : this.totalSupply),
      walletDetails: (walletDetails != null
          ? walletDetails.value
          : this.walletDetails),
      onMarket: (onMarket != null ? onMarket.value : this.onMarket),
      staked: (staked != null ? staked.value : this.staked),
      otherSCs: (otherSCs != null ? otherSCs.value : this.otherSCs),
      burnWallet: (burnWallet != null ? burnWallet.value : this.burnWallet),
      uniqueHolders: (uniqueHolders != null
          ? uniqueHolders.value
          : this.uniqueHolders),
      holded: (holded != null ? holded.value : this.holded),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionHoldersExportDto {
  const CollectionHoldersExportDto();

  factory CollectionHoldersExportDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionHoldersExportDtoFromJson(json);

  static const toJsonFactory = _$CollectionHoldersExportDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionHoldersExportDtoToJson(this);

  static const fromJsonFactory = _$CollectionHoldersExportDtoFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class CollectionOwnerDto {
  const CollectionOwnerDto({required this.owner});

  factory CollectionOwnerDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionOwnerDtoFromJson(json);

  static const toJsonFactory = _$CollectionOwnerDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionOwnerDtoToJson(this);

  @JsonKey(name: 'owner')
  final String owner;
  static const fromJsonFactory = _$CollectionOwnerDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionOwnerDto &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(owner) ^ runtimeType.hashCode;
}

extension $CollectionOwnerDtoExtension on CollectionOwnerDto {
  CollectionOwnerDto copyWith({String? owner}) {
    return CollectionOwnerDto(owner: owner ?? this.owner);
  }

  CollectionOwnerDto copyWithWrapped({Wrapped<String>? owner}) {
    return CollectionOwnerDto(
      owner: (owner != null ? owner.value : this.owner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionOffersFilterCriteriaDto {
  const CollectionOffersFilterCriteriaDto({
    this.dataType,
    this.collection,
    this.offerId,
    this.owner,
    this.marketplace,
    this.range,
    this.attributes,
    this.isActive,
    this.withAttributes,
  });

  factory CollectionOffersFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionOffersFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$CollectionOffersFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionOffersFilterCriteriaDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionDataTypeNullableToJson,
    fromJson: collectionDataTypeNullableFromJson,
  )
  final enums.CollectionDataType? dataType;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'offerId', defaultValue: <double>[])
  final List<double>? offerId;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes>? attributes;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'withAttributes')
  final bool? withAttributes;
  static const fromJsonFactory = _$CollectionOffersFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionOffersFilterCriteriaDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.offerId, offerId) ||
                const DeepCollectionEquality().equals(
                  other.offerId,
                  offerId,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality().equals(
                  other.attributes,
                  attributes,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.withAttributes, withAttributes) ||
                const DeepCollectionEquality().equals(
                  other.withAttributes,
                  withAttributes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(offerId) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(withAttributes) ^
      runtimeType.hashCode;
}

extension $CollectionOffersFilterCriteriaDtoExtension
    on CollectionOffersFilterCriteriaDto {
  CollectionOffersFilterCriteriaDto copyWith({
    enums.CollectionDataType? dataType,
    List<String>? collection,
    List<double>? offerId,
    List<String>? owner,
    List<String>? marketplace,
    List<RangeFilter>? range,
    List<NftMetadataAttributes>? attributes,
    bool? isActive,
    bool? withAttributes,
  }) {
    return CollectionOffersFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      offerId: offerId ?? this.offerId,
      owner: owner ?? this.owner,
      marketplace: marketplace ?? this.marketplace,
      range: range ?? this.range,
      attributes: attributes ?? this.attributes,
      isActive: isActive ?? this.isActive,
      withAttributes: withAttributes ?? this.withAttributes,
    );
  }

  CollectionOffersFilterCriteriaDto copyWithWrapped({
    Wrapped<enums.CollectionDataType?>? dataType,
    Wrapped<List<String>?>? collection,
    Wrapped<List<double>?>? offerId,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<List<NftMetadataAttributes>?>? attributes,
    Wrapped<bool?>? isActive,
    Wrapped<bool?>? withAttributes,
  }) {
    return CollectionOffersFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      offerId: (offerId != null ? offerId.value : this.offerId),
      owner: (owner != null ? owner.value : this.owner),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      range: (range != null ? range.value : this.range),
      attributes: (attributes != null ? attributes.value : this.attributes),
      isActive: (isActive != null ? isActive.value : this.isActive),
      withAttributes: (withAttributes != null
          ? withAttributes.value
          : this.withAttributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionOffersFilter {
  const CollectionOffersFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory CollectionOffersFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionOffersFilterFromJson(json);

  static const toJsonFactory = _$CollectionOffersFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionOffersFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final CollectionOffersFilterCriteriaDto? filters;
  static const fromJsonFactory = _$CollectionOffersFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionOffersFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $CollectionOffersFilterExtension on CollectionOffersFilter {
  CollectionOffersFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    CollectionOffersFilterCriteriaDto? filters,
  }) {
    return CollectionOffersFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  CollectionOffersFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<CollectionOffersFilterCriteriaDto?>? filters,
  }) {
    return CollectionOffersFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalOfferPaginated {
  const GlobalOfferPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory GlobalOfferPaginated.fromJson(Map<String, dynamic> json) =>
      _$GlobalOfferPaginatedFromJson(json);

  static const toJsonFactory = _$GlobalOfferPaginatedToJson;
  Map<String, dynamic> toJson() => _$GlobalOfferPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <GlobalOfferDocHydrated>[])
  final List<GlobalOfferDocHydrated> resources;
  static const fromJsonFactory = _$GlobalOfferPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalOfferPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $GlobalOfferPaginatedExtension on GlobalOfferPaginated {
  GlobalOfferPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<GlobalOfferDocHydrated>? resources,
  }) {
    return GlobalOfferPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  GlobalOfferPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<GlobalOfferDocHydrated>>? resources,
  }) {
    return GlobalOfferPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MintingListingDto {
  const MintingListingDto({
    required this.dataType,
    required this.collection,
    required this.creatorTag,
    required this.creatorName,
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.baseNftName,
    required this.hasAttributes,
    required this.ownerTransferred,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.royalties,
    required this.oldVersion,
    required this.nameShuffle,
    required this.nftTransferLimited,
    this.allowsPublicBurn,
    required this.kycRequired,
    required this.allowsRefund,
    required this.hasBotProtection,
    required this.hasReveal,
    required this.tags,
    required this.prices,
    required this.startTime,
    required this.endTime,
    required this.isSoldOut,
    required this.id,
    this.ts,
    required this.collectionInfo,
  });

  factory MintingListingDto.fromJson(Map<String, dynamic> json) =>
      _$MintingListingDtoFromJson(json);

  static const toJsonFactory = _$MintingListingDtoToJson;
  Map<String, dynamic> toJson() => _$MintingListingDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: mintingListingDtoDataTypeToJson,
    fromJson: mintingListingDtoDataTypeFromJson,
  )
  final enums.MintingListingDtoDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'creatorName')
  final String creatorName;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'baseNftName')
  final String baseNftName;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'ownerTransferred')
  final bool ownerTransferred;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'oldVersion')
  final bool oldVersion;
  @JsonKey(name: 'nameShuffle')
  final bool nameShuffle;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'allowsPublicBurn')
  final bool? allowsPublicBurn;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'allowsRefund')
  final bool allowsRefund;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'hasReveal')
  final bool hasReveal;
  @JsonKey(name: 'tags')
  final Object tags;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'isSoldOut')
  final bool isSoldOut;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  static const fromJsonFactory = _$MintingListingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MintingListingDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.creatorName, creatorName) ||
                const DeepCollectionEquality().equals(
                  other.creatorName,
                  creatorName,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.collectionTag, collectionTag) ||
                const DeepCollectionEquality().equals(
                  other.collectionTag,
                  collectionTag,
                )) &&
            (identical(other.cid, cid) ||
                const DeepCollectionEquality().equals(other.cid, cid)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality().equals(
                  other.mediaType,
                  mediaType,
                )) &&
            (identical(other.baseNftName, baseNftName) ||
                const DeepCollectionEquality().equals(
                  other.baseNftName,
                  baseNftName,
                )) &&
            (identical(other.hasAttributes, hasAttributes) ||
                const DeepCollectionEquality().equals(
                  other.hasAttributes,
                  hasAttributes,
                )) &&
            (identical(other.ownerTransferred, ownerTransferred) ||
                const DeepCollectionEquality().equals(
                  other.ownerTransferred,
                  ownerTransferred,
                )) &&
            (identical(other.collectionSize, collectionSize) ||
                const DeepCollectionEquality().equals(
                  other.collectionSize,
                  collectionSize,
                )) &&
            (identical(other.totalNftMinted, totalNftMinted) ||
                const DeepCollectionEquality().equals(
                  other.totalNftMinted,
                  totalNftMinted,
                )) &&
            (identical(other.globalWalletLimit, globalWalletLimit) ||
                const DeepCollectionEquality().equals(
                  other.globalWalletLimit,
                  globalWalletLimit,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.oldVersion, oldVersion) ||
                const DeepCollectionEquality().equals(
                  other.oldVersion,
                  oldVersion,
                )) &&
            (identical(other.nameShuffle, nameShuffle) ||
                const DeepCollectionEquality().equals(
                  other.nameShuffle,
                  nameShuffle,
                )) &&
            (identical(other.nftTransferLimited, nftTransferLimited) ||
                const DeepCollectionEquality().equals(
                  other.nftTransferLimited,
                  nftTransferLimited,
                )) &&
            (identical(other.allowsPublicBurn, allowsPublicBurn) ||
                const DeepCollectionEquality().equals(
                  other.allowsPublicBurn,
                  allowsPublicBurn,
                )) &&
            (identical(other.kycRequired, kycRequired) ||
                const DeepCollectionEquality().equals(
                  other.kycRequired,
                  kycRequired,
                )) &&
            (identical(other.allowsRefund, allowsRefund) ||
                const DeepCollectionEquality().equals(
                  other.allowsRefund,
                  allowsRefund,
                )) &&
            (identical(other.hasBotProtection, hasBotProtection) ||
                const DeepCollectionEquality().equals(
                  other.hasBotProtection,
                  hasBotProtection,
                )) &&
            (identical(other.hasReveal, hasReveal) ||
                const DeepCollectionEquality().equals(
                  other.hasReveal,
                  hasReveal,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.isSoldOut, isSoldOut) ||
                const DeepCollectionEquality().equals(
                  other.isSoldOut,
                  isSoldOut,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(creatorName) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(collectionTag) ^
      const DeepCollectionEquality().hash(cid) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(baseNftName) ^
      const DeepCollectionEquality().hash(hasAttributes) ^
      const DeepCollectionEquality().hash(ownerTransferred) ^
      const DeepCollectionEquality().hash(collectionSize) ^
      const DeepCollectionEquality().hash(totalNftMinted) ^
      const DeepCollectionEquality().hash(globalWalletLimit) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(oldVersion) ^
      const DeepCollectionEquality().hash(nameShuffle) ^
      const DeepCollectionEquality().hash(nftTransferLimited) ^
      const DeepCollectionEquality().hash(allowsPublicBurn) ^
      const DeepCollectionEquality().hash(kycRequired) ^
      const DeepCollectionEquality().hash(allowsRefund) ^
      const DeepCollectionEquality().hash(hasBotProtection) ^
      const DeepCollectionEquality().hash(hasReveal) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(prices) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(isSoldOut) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      runtimeType.hashCode;
}

extension $MintingListingDtoExtension on MintingListingDto {
  MintingListingDto copyWith({
    enums.MintingListingDtoDataType? dataType,
    String? collection,
    String? creatorTag,
    String? creatorName,
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    String? baseNftName,
    bool? hasAttributes,
    bool? ownerTransferred,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    double? royalties,
    bool? oldVersion,
    bool? nameShuffle,
    bool? nftTransferLimited,
    bool? allowsPublicBurn,
    bool? kycRequired,
    bool? allowsRefund,
    bool? hasBotProtection,
    bool? hasReveal,
    Object? tags,
    List<EgldOrEsdtTokenPayment>? prices,
    double? startTime,
    double? endTime,
    bool? isSoldOut,
    String? id,
    double? ts,
    ShortCollectionInfoDoc? collectionInfo,
  }) {
    return MintingListingDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      creatorTag: creatorTag ?? this.creatorTag,
      creatorName: creatorName ?? this.creatorName,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      baseNftName: baseNftName ?? this.baseNftName,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      ownerTransferred: ownerTransferred ?? this.ownerTransferred,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      royalties: royalties ?? this.royalties,
      oldVersion: oldVersion ?? this.oldVersion,
      nameShuffle: nameShuffle ?? this.nameShuffle,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      allowsPublicBurn: allowsPublicBurn ?? this.allowsPublicBurn,
      kycRequired: kycRequired ?? this.kycRequired,
      allowsRefund: allowsRefund ?? this.allowsRefund,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      hasReveal: hasReveal ?? this.hasReveal,
      tags: tags ?? this.tags,
      prices: prices ?? this.prices,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isSoldOut: isSoldOut ?? this.isSoldOut,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  MintingListingDto copyWithWrapped({
    Wrapped<enums.MintingListingDtoDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? creatorTag,
    Wrapped<String>? creatorName,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<String>? baseNftName,
    Wrapped<bool>? hasAttributes,
    Wrapped<bool>? ownerTransferred,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<double>? royalties,
    Wrapped<bool>? oldVersion,
    Wrapped<bool>? nameShuffle,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool?>? allowsPublicBurn,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? allowsRefund,
    Wrapped<bool>? hasBotProtection,
    Wrapped<bool>? hasReveal,
    Wrapped<Object>? tags,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<bool>? isSoldOut,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
  }) {
    return MintingListingDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      baseNftName: (baseNftName != null ? baseNftName.value : this.baseNftName),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      ownerTransferred: (ownerTransferred != null
          ? ownerTransferred.value
          : this.ownerTransferred),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      royalties: (royalties != null ? royalties.value : this.royalties),
      oldVersion: (oldVersion != null ? oldVersion.value : this.oldVersion),
      nameShuffle: (nameShuffle != null ? nameShuffle.value : this.nameShuffle),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      allowsPublicBurn: (allowsPublicBurn != null
          ? allowsPublicBurn.value
          : this.allowsPublicBurn),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      allowsRefund: (allowsRefund != null
          ? allowsRefund.value
          : this.allowsRefund),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      hasReveal: (hasReveal != null ? hasReveal.value : this.hasReveal),
      tags: (tags != null ? tags.value : this.tags),
      prices: (prices != null ? prices.value : this.prices),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      isSoldOut: (isSoldOut != null ? isSoldOut.value : this.isSoldOut),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventLocationDto {
  const EventLocationDto({
    this.address,
    this.placeId,
    this.lat,
    this.long,
    this.instructions,
    this.onlineLink,
    this.city,
    this.country,
  });

  factory EventLocationDto.fromJson(Map<String, dynamic> json) =>
      _$EventLocationDtoFromJson(json);

  static const toJsonFactory = _$EventLocationDtoToJson;
  Map<String, dynamic> toJson() => _$EventLocationDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'placeId')
  final String? placeId;
  @JsonKey(name: 'lat')
  final double? lat;
  @JsonKey(name: 'long')
  final double? long;
  @JsonKey(name: 'instructions')
  final String? instructions;
  @JsonKey(name: 'onlineLink')
  final String? onlineLink;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$EventLocationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventLocationDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.placeId, placeId) ||
                const DeepCollectionEquality().equals(
                  other.placeId,
                  placeId,
                )) &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.long, long) ||
                const DeepCollectionEquality().equals(other.long, long)) &&
            (identical(other.instructions, instructions) ||
                const DeepCollectionEquality().equals(
                  other.instructions,
                  instructions,
                )) &&
            (identical(other.onlineLink, onlineLink) ||
                const DeepCollectionEquality().equals(
                  other.onlineLink,
                  onlineLink,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(placeId) ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(long) ^
      const DeepCollectionEquality().hash(instructions) ^
      const DeepCollectionEquality().hash(onlineLink) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $EventLocationDtoExtension on EventLocationDto {
  EventLocationDto copyWith({
    String? address,
    String? placeId,
    double? lat,
    double? long,
    String? instructions,
    String? onlineLink,
    String? city,
    String? country,
  }) {
    return EventLocationDto(
      address: address ?? this.address,
      placeId: placeId ?? this.placeId,
      lat: lat ?? this.lat,
      long: long ?? this.long,
      instructions: instructions ?? this.instructions,
      onlineLink: onlineLink ?? this.onlineLink,
      city: city ?? this.city,
      country: country ?? this.country,
    );
  }

  EventLocationDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String?>? placeId,
    Wrapped<double?>? lat,
    Wrapped<double?>? long,
    Wrapped<String?>? instructions,
    Wrapped<String?>? onlineLink,
    Wrapped<String?>? city,
    Wrapped<String?>? country,
  }) {
    return EventLocationDto(
      address: (address != null ? address.value : this.address),
      placeId: (placeId != null ? placeId.value : this.placeId),
      lat: (lat != null ? lat.value : this.lat),
      long: (long != null ? long.value : this.long),
      instructions: (instructions != null
          ? instructions.value
          : this.instructions),
      onlineLink: (onlineLink != null ? onlineLink.value : this.onlineLink),
      city: (city != null ? city.value : this.city),
      country: (country != null ? country.value : this.country),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RegistrationDetailsDto {
  const RegistrationDetailsDto({
    required this.visibility,
    required this.maxLimit,
    required this.userLimit,
    required this.requireKYC,
    required this.requireName,
    required this.requireEmail,
    required this.requirePhoneNumber,
    required this.isPublished,
    required this.hasSideEvents,
    required this.hasWaitlist,
    required this.showGuestCount,
    required this.refundable,
    required this.nameWithNumber,
    required this.botProtection,
    this.acceptCrypto,
    this.soldCount,
    this.hasCustomQuestions,
    this.emailSender,
  });

  factory RegistrationDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$RegistrationDetailsDtoFromJson(json);

  static const toJsonFactory = _$RegistrationDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$RegistrationDetailsDtoToJson(this);

  @JsonKey(
    name: 'visibility',
    toJson: visibilityToJson,
    fromJson: visibilityFromJson,
  )
  final enums.Visibility visibility;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'requireKYC')
  final bool requireKYC;
  @JsonKey(name: 'requireName')
  final bool requireName;
  @JsonKey(name: 'requireEmail')
  final bool requireEmail;
  @JsonKey(name: 'requirePhoneNumber')
  final bool requirePhoneNumber;
  @JsonKey(name: 'isPublished')
  final bool isPublished;
  @JsonKey(name: 'hasSideEvents')
  final bool hasSideEvents;
  @JsonKey(name: 'hasWaitlist')
  final bool hasWaitlist;
  @JsonKey(name: 'showGuestCount')
  final bool showGuestCount;
  @JsonKey(name: 'refundable')
  final bool refundable;
  @JsonKey(name: 'nameWithNumber')
  final bool nameWithNumber;
  @JsonKey(name: 'botProtection')
  final bool botProtection;
  @JsonKey(name: 'acceptCrypto')
  final bool? acceptCrypto;
  @JsonKey(name: 'soldCount')
  final int? soldCount;
  @JsonKey(name: 'hasCustomQuestions')
  final bool? hasCustomQuestions;
  @JsonKey(name: 'emailSender')
  final String? emailSender;
  static const fromJsonFactory = _$RegistrationDetailsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RegistrationDetailsDto &&
            (identical(other.visibility, visibility) ||
                const DeepCollectionEquality().equals(
                  other.visibility,
                  visibility,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.requireKYC, requireKYC) ||
                const DeepCollectionEquality().equals(
                  other.requireKYC,
                  requireKYC,
                )) &&
            (identical(other.requireName, requireName) ||
                const DeepCollectionEquality().equals(
                  other.requireName,
                  requireName,
                )) &&
            (identical(other.requireEmail, requireEmail) ||
                const DeepCollectionEquality().equals(
                  other.requireEmail,
                  requireEmail,
                )) &&
            (identical(other.requirePhoneNumber, requirePhoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.requirePhoneNumber,
                  requirePhoneNumber,
                )) &&
            (identical(other.isPublished, isPublished) ||
                const DeepCollectionEquality().equals(
                  other.isPublished,
                  isPublished,
                )) &&
            (identical(other.hasSideEvents, hasSideEvents) ||
                const DeepCollectionEquality().equals(
                  other.hasSideEvents,
                  hasSideEvents,
                )) &&
            (identical(other.hasWaitlist, hasWaitlist) ||
                const DeepCollectionEquality().equals(
                  other.hasWaitlist,
                  hasWaitlist,
                )) &&
            (identical(other.showGuestCount, showGuestCount) ||
                const DeepCollectionEquality().equals(
                  other.showGuestCount,
                  showGuestCount,
                )) &&
            (identical(other.refundable, refundable) ||
                const DeepCollectionEquality().equals(
                  other.refundable,
                  refundable,
                )) &&
            (identical(other.nameWithNumber, nameWithNumber) ||
                const DeepCollectionEquality().equals(
                  other.nameWithNumber,
                  nameWithNumber,
                )) &&
            (identical(other.botProtection, botProtection) ||
                const DeepCollectionEquality().equals(
                  other.botProtection,
                  botProtection,
                )) &&
            (identical(other.acceptCrypto, acceptCrypto) ||
                const DeepCollectionEquality().equals(
                  other.acceptCrypto,
                  acceptCrypto,
                )) &&
            (identical(other.soldCount, soldCount) ||
                const DeepCollectionEquality().equals(
                  other.soldCount,
                  soldCount,
                )) &&
            (identical(other.hasCustomQuestions, hasCustomQuestions) ||
                const DeepCollectionEquality().equals(
                  other.hasCustomQuestions,
                  hasCustomQuestions,
                )) &&
            (identical(other.emailSender, emailSender) ||
                const DeepCollectionEquality().equals(
                  other.emailSender,
                  emailSender,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(visibility) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(requireKYC) ^
      const DeepCollectionEquality().hash(requireName) ^
      const DeepCollectionEquality().hash(requireEmail) ^
      const DeepCollectionEquality().hash(requirePhoneNumber) ^
      const DeepCollectionEquality().hash(isPublished) ^
      const DeepCollectionEquality().hash(hasSideEvents) ^
      const DeepCollectionEquality().hash(hasWaitlist) ^
      const DeepCollectionEquality().hash(showGuestCount) ^
      const DeepCollectionEquality().hash(refundable) ^
      const DeepCollectionEquality().hash(nameWithNumber) ^
      const DeepCollectionEquality().hash(botProtection) ^
      const DeepCollectionEquality().hash(acceptCrypto) ^
      const DeepCollectionEquality().hash(soldCount) ^
      const DeepCollectionEquality().hash(hasCustomQuestions) ^
      const DeepCollectionEquality().hash(emailSender) ^
      runtimeType.hashCode;
}

extension $RegistrationDetailsDtoExtension on RegistrationDetailsDto {
  RegistrationDetailsDto copyWith({
    enums.Visibility? visibility,
    int? maxLimit,
    int? userLimit,
    bool? requireKYC,
    bool? requireName,
    bool? requireEmail,
    bool? requirePhoneNumber,
    bool? isPublished,
    bool? hasSideEvents,
    bool? hasWaitlist,
    bool? showGuestCount,
    bool? refundable,
    bool? nameWithNumber,
    bool? botProtection,
    bool? acceptCrypto,
    int? soldCount,
    bool? hasCustomQuestions,
    String? emailSender,
  }) {
    return RegistrationDetailsDto(
      visibility: visibility ?? this.visibility,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      requireKYC: requireKYC ?? this.requireKYC,
      requireName: requireName ?? this.requireName,
      requireEmail: requireEmail ?? this.requireEmail,
      requirePhoneNumber: requirePhoneNumber ?? this.requirePhoneNumber,
      isPublished: isPublished ?? this.isPublished,
      hasSideEvents: hasSideEvents ?? this.hasSideEvents,
      hasWaitlist: hasWaitlist ?? this.hasWaitlist,
      showGuestCount: showGuestCount ?? this.showGuestCount,
      refundable: refundable ?? this.refundable,
      nameWithNumber: nameWithNumber ?? this.nameWithNumber,
      botProtection: botProtection ?? this.botProtection,
      acceptCrypto: acceptCrypto ?? this.acceptCrypto,
      soldCount: soldCount ?? this.soldCount,
      hasCustomQuestions: hasCustomQuestions ?? this.hasCustomQuestions,
      emailSender: emailSender ?? this.emailSender,
    );
  }

  RegistrationDetailsDto copyWithWrapped({
    Wrapped<enums.Visibility>? visibility,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? requireKYC,
    Wrapped<bool>? requireName,
    Wrapped<bool>? requireEmail,
    Wrapped<bool>? requirePhoneNumber,
    Wrapped<bool>? isPublished,
    Wrapped<bool>? hasSideEvents,
    Wrapped<bool>? hasWaitlist,
    Wrapped<bool>? showGuestCount,
    Wrapped<bool>? refundable,
    Wrapped<bool>? nameWithNumber,
    Wrapped<bool>? botProtection,
    Wrapped<bool?>? acceptCrypto,
    Wrapped<int?>? soldCount,
    Wrapped<bool?>? hasCustomQuestions,
    Wrapped<String?>? emailSender,
  }) {
    return RegistrationDetailsDto(
      visibility: (visibility != null ? visibility.value : this.visibility),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      requireKYC: (requireKYC != null ? requireKYC.value : this.requireKYC),
      requireName: (requireName != null ? requireName.value : this.requireName),
      requireEmail: (requireEmail != null
          ? requireEmail.value
          : this.requireEmail),
      requirePhoneNumber: (requirePhoneNumber != null
          ? requirePhoneNumber.value
          : this.requirePhoneNumber),
      isPublished: (isPublished != null ? isPublished.value : this.isPublished),
      hasSideEvents: (hasSideEvents != null
          ? hasSideEvents.value
          : this.hasSideEvents),
      hasWaitlist: (hasWaitlist != null ? hasWaitlist.value : this.hasWaitlist),
      showGuestCount: (showGuestCount != null
          ? showGuestCount.value
          : this.showGuestCount),
      refundable: (refundable != null ? refundable.value : this.refundable),
      nameWithNumber: (nameWithNumber != null
          ? nameWithNumber.value
          : this.nameWithNumber),
      botProtection: (botProtection != null
          ? botProtection.value
          : this.botProtection),
      acceptCrypto: (acceptCrypto != null
          ? acceptCrypto.value
          : this.acceptCrypto),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      hasCustomQuestions: (hasCustomQuestions != null
          ? hasCustomQuestions.value
          : this.hasCustomQuestions),
      emailSender: (emailSender != null ? emailSender.value : this.emailSender),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiumType {
  const PremiumType({required this.searchable});

  factory PremiumType.fromJson(Map<String, dynamic> json) =>
      _$PremiumTypeFromJson(json);

  static const toJsonFactory = _$PremiumTypeToJson;
  Map<String, dynamic> toJson() => _$PremiumTypeToJson(this);

  @JsonKey(name: 'searchable')
  final bool searchable;
  static const fromJsonFactory = _$PremiumTypeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiumType &&
            (identical(other.searchable, searchable) ||
                const DeepCollectionEquality().equals(
                  other.searchable,
                  searchable,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchable) ^ runtimeType.hashCode;
}

extension $PremiumTypeExtension on PremiumType {
  PremiumType copyWith({bool? searchable}) {
    return PremiumType(searchable: searchable ?? this.searchable);
  }

  PremiumType copyWithWrapped({Wrapped<bool>? searchable}) {
    return PremiumType(
      searchable: (searchable != null ? searchable.value : this.searchable),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventSeoDto {
  const EventSeoDto({this.description, this.tags, this.alternativeTitle});

  factory EventSeoDto.fromJson(Map<String, dynamic> json) =>
      _$EventSeoDtoFromJson(json);

  static const toJsonFactory = _$EventSeoDtoToJson;
  Map<String, dynamic> toJson() => _$EventSeoDtoToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'tags', defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'alternativeTitle')
  final String? alternativeTitle;
  static const fromJsonFactory = _$EventSeoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventSeoDto &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.alternativeTitle, alternativeTitle) ||
                const DeepCollectionEquality().equals(
                  other.alternativeTitle,
                  alternativeTitle,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(alternativeTitle) ^
      runtimeType.hashCode;
}

extension $EventSeoDtoExtension on EventSeoDto {
  EventSeoDto copyWith({
    String? description,
    List<String>? tags,
    String? alternativeTitle,
  }) {
    return EventSeoDto(
      description: description ?? this.description,
      tags: tags ?? this.tags,
      alternativeTitle: alternativeTitle ?? this.alternativeTitle,
    );
  }

  EventSeoDto copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? alternativeTitle,
  }) {
    return EventSeoDto(
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      alternativeTitle: (alternativeTitle != null
          ? alternativeTitle.value
          : this.alternativeTitle),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleDoc {
  const EventUserRoleDoc({
    required this.dataType,
    this.eventId,
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.createdAt,
    this.endTime,
    this.id,
    this.status,
    this.pk,
    this.ts,
  });

  factory EventUserRoleDoc.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleDocFromJson(json);

  static const toJsonFactory = _$EventUserRoleDocToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'createdAt')
  final int? createdAt;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
    name: 'status',
    toJson: roleStatusNullableToJson,
    fromJson: roleStatusNullableFromJson,
  )
  final enums.RoleStatus? status;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  static const fromJsonFactory = _$EventUserRoleDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventUserRoleDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.permissions, permissions) ||
                const DeepCollectionEquality().equals(
                  other.permissions,
                  permissions,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(permissions) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $EventUserRoleDocExtension on EventUserRoleDoc {
  EventUserRoleDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? createdAt,
    int? endTime,
    String? id,
    enums.RoleStatus? status,
    String? pk,
    int? ts,
  }) {
    return EventUserRoleDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      createdAt: createdAt ?? this.createdAt,
      endTime: endTime ?? this.endTime,
      id: id ?? this.id,
      status: status ?? this.status,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventUserRoleDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String?>? eventId,
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? createdAt,
    Wrapped<int?>? endTime,
    Wrapped<String?>? id,
    Wrapped<enums.RoleStatus?>? status,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
  }) {
    return EventUserRoleDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      endTime: (endTime != null ? endTime.value : this.endTime),
      id: (id != null ? id.value : this.id),
      status: (status != null ? status.value : this.status),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfileSummary {
  const EventGuestProfileSummary({
    required this.address,
    required this.profile,
    this.name,
    this.herotag,
  });

  factory EventGuestProfileSummary.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileSummaryFromJson(json);

  static const toJsonFactory = _$EventGuestProfileSummaryToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileSummaryToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'herotag')
  final String? herotag;
  static const fromJsonFactory = _$EventGuestProfileSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestProfileSummary &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(other.herotag, herotag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(herotag) ^
      runtimeType.hashCode;
}

extension $EventGuestProfileSummaryExtension on EventGuestProfileSummary {
  EventGuestProfileSummary copyWith({
    String? address,
    String? profile,
    String? name,
    String? herotag,
  }) {
    return EventGuestProfileSummary(
      address: address ?? this.address,
      profile: profile ?? this.profile,
      name: name ?? this.name,
      herotag: herotag ?? this.herotag,
    );
  }

  EventGuestProfileSummary copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? profile,
    Wrapped<String?>? name,
    Wrapped<String?>? herotag,
  }) {
    return EventGuestProfileSummary(
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
      name: (name != null ? name.value : this.name),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestSummary {
  const EventGuestSummary({required this.count, required this.guests});

  factory EventGuestSummary.fromJson(Map<String, dynamic> json) =>
      _$EventGuestSummaryFromJson(json);

  static const toJsonFactory = _$EventGuestSummaryToJson;
  Map<String, dynamic> toJson() => _$EventGuestSummaryToJson(this);

  @JsonKey(name: 'count')
  final int count;
  @JsonKey(name: 'guests', defaultValue: <EventGuestProfileSummary>[])
  final List<EventGuestProfileSummary> guests;
  static const fromJsonFactory = _$EventGuestSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestSummary &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.guests, guests) ||
                const DeepCollectionEquality().equals(other.guests, guests)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(guests) ^
      runtimeType.hashCode;
}

extension $EventGuestSummaryExtension on EventGuestSummary {
  EventGuestSummary copyWith({
    int? count,
    List<EventGuestProfileSummary>? guests,
  }) {
    return EventGuestSummary(
      count: count ?? this.count,
      guests: guests ?? this.guests,
    );
  }

  EventGuestSummary copyWithWrapped({
    Wrapped<int>? count,
    Wrapped<List<EventGuestProfileSummary>>? guests,
  }) {
    return EventGuestSummary(
      count: (count != null ? count.value : this.count),
      guests: (guests != null ? guests.value : this.guests),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStartPrice {
  const EventStartPrice({required this.price, required this.currency});

  factory EventStartPrice.fromJson(Map<String, dynamic> json) =>
      _$EventStartPriceFromJson(json);

  static const toJsonFactory = _$EventStartPriceToJson;
  Map<String, dynamic> toJson() => _$EventStartPriceToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'currency')
  final String currency;
  static const fromJsonFactory = _$EventStartPriceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventStartPrice &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $EventStartPriceExtension on EventStartPrice {
  EventStartPrice copyWith({double? price, String? currency}) {
    return EventStartPrice(
      price: price ?? this.price,
      currency: currency ?? this.currency,
    );
  }

  EventStartPrice copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<String>? currency,
  }) {
    return EventStartPrice(
      price: (price != null ? price.value : this.price),
      currency: (currency != null ? currency.value : this.currency),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestRegistration {
  const EventGuestRegistration({this.email, this.name, this.phone});

  factory EventGuestRegistration.fromJson(Map<String, dynamic> json) =>
      _$EventGuestRegistrationFromJson(json);

  static const toJsonFactory = _$EventGuestRegistrationToJson;
  Map<String, dynamic> toJson() => _$EventGuestRegistrationToJson(this);

  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  static const fromJsonFactory = _$EventGuestRegistrationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestRegistration &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phone) ^
      runtimeType.hashCode;
}

extension $EventGuestRegistrationExtension on EventGuestRegistration {
  EventGuestRegistration copyWith({
    String? email,
    String? name,
    String? phone,
  }) {
    return EventGuestRegistration(
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
    );
  }

  EventGuestRegistration copyWithWrapped({
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
  }) {
    return EventGuestRegistration(
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestBilling {
  const EventGuestBilling({
    required this.isCompany,
    required this.name,
    this.companyRegistrationNumber,
    this.companyVatNumber,
    required this.email,
    required this.country,
    required this.city,
    required this.address1,
    this.address2,
    this.postalCode,
  });

  factory EventGuestBilling.fromJson(Map<String, dynamic> json) =>
      _$EventGuestBillingFromJson(json);

  static const toJsonFactory = _$EventGuestBillingToJson;
  Map<String, dynamic> toJson() => _$EventGuestBillingToJson(this);

  @JsonKey(name: 'isCompany')
  final bool isCompany;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'companyRegistrationNumber')
  final String? companyRegistrationNumber;
  @JsonKey(name: 'companyVatNumber')
  final String? companyVatNumber;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'address1')
  final String address1;
  @JsonKey(name: 'address2')
  final String? address2;
  @JsonKey(name: 'postalCode')
  final String? postalCode;
  static const fromJsonFactory = _$EventGuestBillingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestBilling &&
            (identical(other.isCompany, isCompany) ||
                const DeepCollectionEquality().equals(
                  other.isCompany,
                  isCompany,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(
                  other.companyRegistrationNumber,
                  companyRegistrationNumber,
                ) ||
                const DeepCollectionEquality().equals(
                  other.companyRegistrationNumber,
                  companyRegistrationNumber,
                )) &&
            (identical(other.companyVatNumber, companyVatNumber) ||
                const DeepCollectionEquality().equals(
                  other.companyVatNumber,
                  companyVatNumber,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.address1, address1) ||
                const DeepCollectionEquality().equals(
                  other.address1,
                  address1,
                )) &&
            (identical(other.address2, address2) ||
                const DeepCollectionEquality().equals(
                  other.address2,
                  address2,
                )) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality().equals(
                  other.postalCode,
                  postalCode,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isCompany) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(companyRegistrationNumber) ^
      const DeepCollectionEquality().hash(companyVatNumber) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(address1) ^
      const DeepCollectionEquality().hash(address2) ^
      const DeepCollectionEquality().hash(postalCode) ^
      runtimeType.hashCode;
}

extension $EventGuestBillingExtension on EventGuestBilling {
  EventGuestBilling copyWith({
    bool? isCompany,
    String? name,
    String? companyRegistrationNumber,
    String? companyVatNumber,
    String? email,
    String? country,
    String? city,
    String? address1,
    String? address2,
    String? postalCode,
  }) {
    return EventGuestBilling(
      isCompany: isCompany ?? this.isCompany,
      name: name ?? this.name,
      companyRegistrationNumber:
          companyRegistrationNumber ?? this.companyRegistrationNumber,
      companyVatNumber: companyVatNumber ?? this.companyVatNumber,
      email: email ?? this.email,
      country: country ?? this.country,
      city: city ?? this.city,
      address1: address1 ?? this.address1,
      address2: address2 ?? this.address2,
      postalCode: postalCode ?? this.postalCode,
    );
  }

  EventGuestBilling copyWithWrapped({
    Wrapped<bool>? isCompany,
    Wrapped<String>? name,
    Wrapped<String?>? companyRegistrationNumber,
    Wrapped<String?>? companyVatNumber,
    Wrapped<String>? email,
    Wrapped<String>? country,
    Wrapped<String>? city,
    Wrapped<String>? address1,
    Wrapped<String?>? address2,
    Wrapped<String?>? postalCode,
  }) {
    return EventGuestBilling(
      isCompany: (isCompany != null ? isCompany.value : this.isCompany),
      name: (name != null ? name.value : this.name),
      companyRegistrationNumber: (companyRegistrationNumber != null
          ? companyRegistrationNumber.value
          : this.companyRegistrationNumber),
      companyVatNumber: (companyVatNumber != null
          ? companyVatNumber.value
          : this.companyVatNumber),
      email: (email != null ? email.value : this.email),
      country: (country != null ? country.value : this.country),
      city: (city != null ? city.value : this.city),
      address1: (address1 != null ? address1.value : this.address1),
      address2: (address2 != null ? address2.value : this.address2),
      postalCode: (postalCode != null ? postalCode.value : this.postalCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestDoc {
  const EventGuestDoc({
    required this.dataType,
    required this.wallet,
    required this.eventId,
    required this.ticket,
    required this.questionnaireFilled,
    this.registration,
    this.billing,
    required this.status,
    required this.createdAt,
    this.invitationId,
    this.metadata,
    this.id,
    this.pk,
    required this.ts,
    this.ttl,
  });

  factory EventGuestDoc.fromJson(Map<String, dynamic> json) =>
      _$EventGuestDocFromJson(json);

  static const toJsonFactory = _$EventGuestDocToJson;
  Map<String, dynamic> toJson() => _$EventGuestDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventGuest);

  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticket')
  final Map<String, dynamic> ticket;
  @JsonKey(name: 'questionnaireFilled')
  final bool questionnaireFilled;
  @JsonKey(name: 'registration')
  final EventGuestRegistration? registration;
  @JsonKey(name: 'billing')
  final EventGuestBilling? billing;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusToJson,
    fromJson: eventGuestStatusFromJson,
  )
  final enums.EventGuestStatus status;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'invitationId')
  final String? invitationId;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int ts;
  @JsonKey(name: 'ttl')
  final int? ttl;
  static const fromJsonFactory = _$EventGuestDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticket, ticket) ||
                const DeepCollectionEquality().equals(other.ticket, ticket)) &&
            (identical(other.questionnaireFilled, questionnaireFilled) ||
                const DeepCollectionEquality().equals(
                  other.questionnaireFilled,
                  questionnaireFilled,
                )) &&
            (identical(other.registration, registration) ||
                const DeepCollectionEquality().equals(
                  other.registration,
                  registration,
                )) &&
            (identical(other.billing, billing) ||
                const DeepCollectionEquality().equals(
                  other.billing,
                  billing,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality().equals(
                  other.invitationId,
                  invitationId,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.ttl, ttl) ||
                const DeepCollectionEquality().equals(other.ttl, ttl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticket) ^
      const DeepCollectionEquality().hash(questionnaireFilled) ^
      const DeepCollectionEquality().hash(registration) ^
      const DeepCollectionEquality().hash(billing) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(ttl) ^
      runtimeType.hashCode;
}

extension $EventGuestDocExtension on EventGuestDoc {
  EventGuestDoc copyWith({
    enums.TicketingDataType? dataType,
    String? wallet,
    String? eventId,
    Map<String, dynamic>? ticket,
    bool? questionnaireFilled,
    EventGuestRegistration? registration,
    EventGuestBilling? billing,
    enums.EventGuestStatus? status,
    int? createdAt,
    String? invitationId,
    Object? metadata,
    String? id,
    String? pk,
    int? ts,
    int? ttl,
  }) {
    return EventGuestDoc(
      dataType: dataType ?? this.dataType,
      wallet: wallet ?? this.wallet,
      eventId: eventId ?? this.eventId,
      ticket: ticket ?? this.ticket,
      questionnaireFilled: questionnaireFilled ?? this.questionnaireFilled,
      registration: registration ?? this.registration,
      billing: billing ?? this.billing,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      invitationId: invitationId ?? this.invitationId,
      metadata: metadata ?? this.metadata,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      ttl: ttl ?? this.ttl,
    );
  }

  EventGuestDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? wallet,
    Wrapped<String>? eventId,
    Wrapped<Map<String, dynamic>>? ticket,
    Wrapped<bool>? questionnaireFilled,
    Wrapped<EventGuestRegistration?>? registration,
    Wrapped<EventGuestBilling?>? billing,
    Wrapped<enums.EventGuestStatus>? status,
    Wrapped<int>? createdAt,
    Wrapped<String?>? invitationId,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<int>? ts,
    Wrapped<int?>? ttl,
  }) {
    return EventGuestDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      wallet: (wallet != null ? wallet.value : this.wallet),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticket: (ticket != null ? ticket.value : this.ticket),
      questionnaireFilled: (questionnaireFilled != null
          ? questionnaireFilled.value
          : this.questionnaireFilled),
      registration: (registration != null
          ? registration.value
          : this.registration),
      billing: (billing != null ? billing.value : this.billing),
      status: (status != null ? status.value : this.status),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      invitationId: (invitationId != null
          ? invitationId.value
          : this.invitationId),
      metadata: (metadata != null ? metadata.value : this.metadata),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      ttl: (ttl != null ? ttl.value : this.ttl),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfile {
  const EventProfile({
    required this.dataType,
    required this.createdAt,
    required this.creatorAddress,
    required this.title,
    required this.startTime,
    required this.endTime,
    this.descriptionUrl,
    required this.location,
    required this.isVirtualEvent,
    this.slug,
    required this.profile,
    required this.category,
    this.subCategory,
    this.background,
    required this.registration,
    required this.premium,
    this.contractAddress,
    this.collection,
    this.seo,
    required this.id,
    this.eventPermissions,
    this.pk,
    this.ts,
    required this.creatorProfile,
    this.guestSummary,
    this.startsFrom,
    this.guestProfile,
  });

  factory EventProfile.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFromJson(json);

  static const toJsonFactory = _$EventProfileToJson;
  Map<String, dynamic> toJson() => _$EventProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventProfile);

  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'creatorAddress')
  final String creatorAddress;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'descriptionUrl')
  final String? descriptionUrl;
  @JsonKey(name: 'location')
  final EventLocationDto location;
  @JsonKey(name: 'isVirtualEvent')
  final bool isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryToJson,
    fromJson: eventCategoryFromJson,
  )
  final enums.EventCategory category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'background')
  final String? background;
  @JsonKey(name: 'registration')
  final RegistrationDetailsDto registration;
  @JsonKey(name: 'premium')
  final PremiumType premium;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'collection')
  final String? collection;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventPermissions')
  final EventUserRoleDoc? eventPermissions;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'creatorProfile')
  final CreatorProfileDoc creatorProfile;
  @JsonKey(name: 'guestSummary')
  final EventGuestSummary? guestSummary;
  @JsonKey(name: 'startsFrom')
  final EventStartPrice? startsFrom;
  @JsonKey(name: 'guestProfile')
  final EventGuestDoc? guestProfile;
  static const fromJsonFactory = _$EventProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfile &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.creatorAddress, creatorAddress) ||
                const DeepCollectionEquality().equals(
                  other.creatorAddress,
                  creatorAddress,
                )) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.descriptionUrl, descriptionUrl) ||
                const DeepCollectionEquality().equals(
                  other.descriptionUrl,
                  descriptionUrl,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.isVirtualEvent, isVirtualEvent) ||
                const DeepCollectionEquality().equals(
                  other.isVirtualEvent,
                  isVirtualEvent,
                )) &&
            (identical(other.slug, slug) ||
                const DeepCollectionEquality().equals(other.slug, slug)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.subCategory, subCategory) ||
                const DeepCollectionEquality().equals(
                  other.subCategory,
                  subCategory,
                )) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality().equals(
                  other.background,
                  background,
                )) &&
            (identical(other.registration, registration) ||
                const DeepCollectionEquality().equals(
                  other.registration,
                  registration,
                )) &&
            (identical(other.premium, premium) ||
                const DeepCollectionEquality().equals(
                  other.premium,
                  premium,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.seo, seo) ||
                const DeepCollectionEquality().equals(other.seo, seo)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.eventPermissions, eventPermissions) ||
                const DeepCollectionEquality().equals(
                  other.eventPermissions,
                  eventPermissions,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.creatorProfile, creatorProfile) ||
                const DeepCollectionEquality().equals(
                  other.creatorProfile,
                  creatorProfile,
                )) &&
            (identical(other.guestSummary, guestSummary) ||
                const DeepCollectionEquality().equals(
                  other.guestSummary,
                  guestSummary,
                )) &&
            (identical(other.startsFrom, startsFrom) ||
                const DeepCollectionEquality().equals(
                  other.startsFrom,
                  startsFrom,
                )) &&
            (identical(other.guestProfile, guestProfile) ||
                const DeepCollectionEquality().equals(
                  other.guestProfile,
                  guestProfile,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(creatorAddress) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(descriptionUrl) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(isVirtualEvent) ^
      const DeepCollectionEquality().hash(slug) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(subCategory) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(registration) ^
      const DeepCollectionEquality().hash(premium) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(seo) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(eventPermissions) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(creatorProfile) ^
      const DeepCollectionEquality().hash(guestSummary) ^
      const DeepCollectionEquality().hash(startsFrom) ^
      const DeepCollectionEquality().hash(guestProfile) ^
      runtimeType.hashCode;
}

extension $EventProfileExtension on EventProfile {
  EventProfile copyWith({
    enums.TicketingDataType? dataType,
    int? createdAt,
    String? creatorAddress,
    String? title,
    int? startTime,
    int? endTime,
    String? descriptionUrl,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    String? profile,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    String? background,
    RegistrationDetailsDto? registration,
    PremiumType? premium,
    String? contractAddress,
    String? collection,
    EventSeoDto? seo,
    String? id,
    EventUserRoleDoc? eventPermissions,
    String? pk,
    int? ts,
    CreatorProfileDoc? creatorProfile,
    EventGuestSummary? guestSummary,
    EventStartPrice? startsFrom,
    EventGuestDoc? guestProfile,
  }) {
    return EventProfile(
      dataType: dataType ?? this.dataType,
      createdAt: createdAt ?? this.createdAt,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      descriptionUrl: descriptionUrl ?? this.descriptionUrl,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      profile: profile ?? this.profile,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      background: background ?? this.background,
      registration: registration ?? this.registration,
      premium: premium ?? this.premium,
      contractAddress: contractAddress ?? this.contractAddress,
      collection: collection ?? this.collection,
      seo: seo ?? this.seo,
      id: id ?? this.id,
      eventPermissions: eventPermissions ?? this.eventPermissions,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      creatorProfile: creatorProfile ?? this.creatorProfile,
      guestSummary: guestSummary ?? this.guestSummary,
      startsFrom: startsFrom ?? this.startsFrom,
      guestProfile: guestProfile ?? this.guestProfile,
    );
  }

  EventProfile copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<int>? createdAt,
    Wrapped<String>? creatorAddress,
    Wrapped<String>? title,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<String?>? descriptionUrl,
    Wrapped<EventLocationDto>? location,
    Wrapped<bool>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<String>? profile,
    Wrapped<enums.EventCategory>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<String?>? background,
    Wrapped<RegistrationDetailsDto>? registration,
    Wrapped<PremiumType>? premium,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? collection,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<String>? id,
    Wrapped<EventUserRoleDoc?>? eventPermissions,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<CreatorProfileDoc>? creatorProfile,
    Wrapped<EventGuestSummary?>? guestSummary,
    Wrapped<EventStartPrice?>? startsFrom,
    Wrapped<EventGuestDoc?>? guestProfile,
  }) {
    return EventProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      descriptionUrl: (descriptionUrl != null
          ? descriptionUrl.value
          : this.descriptionUrl),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      profile: (profile != null ? profile.value : this.profile),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      background: (background != null ? background.value : this.background),
      registration: (registration != null
          ? registration.value
          : this.registration),
      premium: (premium != null ? premium.value : this.premium),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collection: (collection != null ? collection.value : this.collection),
      seo: (seo != null ? seo.value : this.seo),
      id: (id != null ? id.value : this.id),
      eventPermissions: (eventPermissions != null
          ? eventPermissions.value
          : this.eventPermissions),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      guestSummary: (guestSummary != null
          ? guestSummary.value
          : this.guestSummary),
      startsFrom: (startsFrom != null ? startsFrom.value : this.startsFrom),
      guestProfile: (guestProfile != null
          ? guestProfile.value
          : this.guestProfile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorDetailsDto {
  const CreatorDetailsDto({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    required this.joinedDate,
    this.description,
    this.socials,
    this.id,
    this.ts,
    this.listing,
    this.events,
  });

  factory CreatorDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorDetailsDtoFromJson(json);

  static const toJsonFactory = _$CreatorDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorDetailsDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorDetailsDtoDataTypeToJson,
    fromJson: creatorDetailsDtoDataTypeFromJson,
  )
  final enums.CreatorDetailsDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'listing', defaultValue: <MintingListingDto>[])
  final List<MintingListingDto>? listing;
  @JsonKey(name: 'events', defaultValue: <EventProfile>[])
  final List<EventProfile>? events;
  static const fromJsonFactory = _$CreatorDetailsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatorDetailsDto &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                ) ||
                const DeepCollectionEquality().equals(
                  other.ticketingContractAddress,
                  ticketingContractAddress,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.listing, listing) ||
                const DeepCollectionEquality().equals(
                  other.listing,
                  listing,
                )) &&
            (identical(other.events, events) ||
                const DeepCollectionEquality().equals(other.events, events)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(ticketingContractAddress) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(listing) ^
      const DeepCollectionEquality().hash(events) ^
      runtimeType.hashCode;
}

extension $CreatorDetailsDtoExtension on CreatorDetailsDto {
  CreatorDetailsDto copyWith({
    enums.CreatorDetailsDtoDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
    List<MintingListingDto>? listing,
    List<EventProfile>? events,
  }) {
    return CreatorDetailsDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      listing: listing ?? this.listing,
      events: events ?? this.events,
    );
  }

  CreatorDetailsDto copyWithWrapped({
    Wrapped<enums.CreatorDetailsDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<List<MintingListingDto>?>? listing,
    Wrapped<List<EventProfile>?>? events,
  }) {
    return CreatorDetailsDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      listing: (listing != null ? listing.value : this.listing),
      events: (events != null ? events.value : this.events),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EditUserCreatorProfileDto {
  const EditUserCreatorProfileDto({this.description, this.socials, this.name});

  factory EditUserCreatorProfileDto.fromJson(Map<String, dynamic> json) =>
      _$EditUserCreatorProfileDtoFromJson(json);

  static const toJsonFactory = _$EditUserCreatorProfileDtoToJson;
  Map<String, dynamic> toJson() => _$EditUserCreatorProfileDtoToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$EditUserCreatorProfileDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EditUserCreatorProfileDto &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.socials, socials) ||
                const DeepCollectionEquality().equals(
                  other.socials,
                  socials,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(socials) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $EditUserCreatorProfileDtoExtension on EditUserCreatorProfileDto {
  EditUserCreatorProfileDto copyWith({
    String? description,
    SocialsDto? socials,
    String? name,
  }) {
    return EditUserCreatorProfileDto(
      description: description ?? this.description,
      socials: socials ?? this.socials,
      name: name ?? this.name,
    );
  }

  EditUserCreatorProfileDto copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? name,
  }) {
    return EditUserCreatorProfileDto(
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShareholderDto {
  const ShareholderDto({required this.address, required this.share});

  factory ShareholderDto.fromJson(Map<String, dynamic> json) =>
      _$ShareholderDtoFromJson(json);

  static const toJsonFactory = _$ShareholderDtoToJson;
  Map<String, dynamic> toJson() => _$ShareholderDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'share')
  final double share;
  static const fromJsonFactory = _$ShareholderDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShareholderDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.share, share) ||
                const DeepCollectionEquality().equals(other.share, share)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(share) ^
      runtimeType.hashCode;
}

extension $ShareholderDtoExtension on ShareholderDto {
  ShareholderDto copyWith({String? address, double? share}) {
    return ShareholderDto(
      address: address ?? this.address,
      share: share ?? this.share,
    );
  }

  ShareholderDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? share,
  }) {
    return ShareholderDto(
      address: (address != null ? address.value : this.address),
      share: (share != null ? share.value : this.share),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserWallet {
  const Web2UserWallet({
    required this.type,
    required this.address,
    this.index,
    this.signature,
    required this.chain,
    required this.walletClientType,
    this.recoveryMethod,
    this.id,
  });

  factory Web2UserWallet.fromJson(Map<String, dynamic> json) =>
      _$Web2UserWalletFromJson(json);

  static const toJsonFactory = _$Web2UserWalletToJson;
  Map<String, dynamic> toJson() => _$Web2UserWalletToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'index')
  final double? index;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'chain')
  final String chain;
  @JsonKey(
    name: 'walletClientType',
    toJson: walletClientTypeToJson,
    fromJson: walletClientTypeFromJson,
  )
  final enums.WalletClientType walletClientType;
  @JsonKey(name: 'recoveryMethod')
  final String? recoveryMethod;
  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$Web2UserWalletFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Web2UserWallet &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.walletClientType, walletClientType) ||
                const DeepCollectionEquality().equals(
                  other.walletClientType,
                  walletClientType,
                )) &&
            (identical(other.recoveryMethod, recoveryMethod) ||
                const DeepCollectionEquality().equals(
                  other.recoveryMethod,
                  recoveryMethod,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(walletClientType) ^
      const DeepCollectionEquality().hash(recoveryMethod) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $Web2UserWalletExtension on Web2UserWallet {
  Web2UserWallet copyWith({
    enums.LinkedAccountType? type,
    String? address,
    double? index,
    String? signature,
    String? chain,
    enums.WalletClientType? walletClientType,
    String? recoveryMethod,
    String? id,
  }) {
    return Web2UserWallet(
      type: type ?? this.type,
      address: address ?? this.address,
      index: index ?? this.index,
      signature: signature ?? this.signature,
      chain: chain ?? this.chain,
      walletClientType: walletClientType ?? this.walletClientType,
      recoveryMethod: recoveryMethod ?? this.recoveryMethod,
      id: id ?? this.id,
    );
  }

  Web2UserWallet copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? address,
    Wrapped<double?>? index,
    Wrapped<String?>? signature,
    Wrapped<String>? chain,
    Wrapped<enums.WalletClientType>? walletClientType,
    Wrapped<String?>? recoveryMethod,
    Wrapped<String?>? id,
  }) {
    return Web2UserWallet(
      type: (type != null ? type.value : this.type),
      address: (address != null ? address.value : this.address),
      index: (index != null ? index.value : this.index),
      signature: (signature != null ? signature.value : this.signature),
      chain: (chain != null ? chain.value : this.chain),
      walletClientType: (walletClientType != null
          ? walletClientType.value
          : this.walletClientType),
      recoveryMethod: (recoveryMethod != null
          ? recoveryMethod.value
          : this.recoveryMethod),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserAccount {
  const Web2UserAccount({
    required this.type,
    required this.subject,
    this.name,
    this.profilePicture,
    this.email,
    this.username,
  });

  factory Web2UserAccount.fromJson(Map<String, dynamic> json) =>
      _$Web2UserAccountFromJson(json);

  static const toJsonFactory = _$Web2UserAccountToJson;
  Map<String, dynamic> toJson() => _$Web2UserAccountToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'subject')
  final String subject;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'profilePicture')
  final String? profilePicture;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'username')
  final String? username;
  static const fromJsonFactory = _$Web2UserAccountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Web2UserAccount &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(
                  other.subject,
                  subject,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.profilePicture, profilePicture) ||
                const DeepCollectionEquality().equals(
                  other.profilePicture,
                  profilePicture,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(profilePicture) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(username) ^
      runtimeType.hashCode;
}

extension $Web2UserAccountExtension on Web2UserAccount {
  Web2UserAccount copyWith({
    enums.LinkedAccountType? type,
    String? subject,
    String? name,
    String? profilePicture,
    String? email,
    String? username,
  }) {
    return Web2UserAccount(
      type: type ?? this.type,
      subject: subject ?? this.subject,
      name: name ?? this.name,
      profilePicture: profilePicture ?? this.profilePicture,
      email: email ?? this.email,
      username: username ?? this.username,
    );
  }

  Web2UserAccount copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? subject,
    Wrapped<String?>? name,
    Wrapped<String?>? profilePicture,
    Wrapped<String?>? email,
    Wrapped<String?>? username,
  }) {
    return Web2UserAccount(
      type: (type != null ? type.value : this.type),
      subject: (subject != null ? subject.value : this.subject),
      name: (name != null ? name.value : this.name),
      profilePicture: (profilePicture != null
          ? profilePicture.value
          : this.profilePicture),
      email: (email != null ? email.value : this.email),
      username: (username != null ? username.value : this.username),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserDoc {
  const Web2UserDoc({
    required this.createdOn,
    required this.id,
    required this.linkedAccounts,
    required this.shards,
    required this.hasNativeWallet,
    this.wallet,
    required this.salt,
    this.google,
    this.apple,
    required this.pk,
    this.ts,
  });

  factory Web2UserDoc.fromJson(Map<String, dynamic> json) =>
      _$Web2UserDocFromJson(json);

  static const toJsonFactory = _$Web2UserDocToJson;
  Map<String, dynamic> toJson() => _$Web2UserDocToJson(this);

  @JsonKey(name: 'createdOn')
  final double createdOn;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'linkedAccounts', defaultValue: <Object>[])
  final List<Object> linkedAccounts;
  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  @JsonKey(name: 'hasNativeWallet')
  final Object hasNativeWallet;
  @JsonKey(name: 'wallet')
  final Web2UserWallet? wallet;
  @JsonKey(name: 'salt')
  final String salt;
  @JsonKey(name: 'google')
  final Web2UserAccount? google;
  @JsonKey(name: 'apple')
  final Web2UserAccount? apple;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$Web2UserDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Web2UserDoc &&
            (identical(other.createdOn, createdOn) ||
                const DeepCollectionEquality().equals(
                  other.createdOn,
                  createdOn,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.linkedAccounts, linkedAccounts) ||
                const DeepCollectionEquality().equals(
                  other.linkedAccounts,
                  linkedAccounts,
                )) &&
            (identical(other.shards, shards) ||
                const DeepCollectionEquality().equals(other.shards, shards)) &&
            (identical(other.hasNativeWallet, hasNativeWallet) ||
                const DeepCollectionEquality().equals(
                  other.hasNativeWallet,
                  hasNativeWallet,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.salt, salt) ||
                const DeepCollectionEquality().equals(other.salt, salt)) &&
            (identical(other.google, google) ||
                const DeepCollectionEquality().equals(other.google, google)) &&
            (identical(other.apple, apple) ||
                const DeepCollectionEquality().equals(other.apple, apple)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdOn) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(linkedAccounts) ^
      const DeepCollectionEquality().hash(shards) ^
      const DeepCollectionEquality().hash(hasNativeWallet) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(salt) ^
      const DeepCollectionEquality().hash(google) ^
      const DeepCollectionEquality().hash(apple) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $Web2UserDocExtension on Web2UserDoc {
  Web2UserDoc copyWith({
    double? createdOn,
    String? id,
    List<Object>? linkedAccounts,
    List<String>? shards,
    Object? hasNativeWallet,
    Web2UserWallet? wallet,
    String? salt,
    Web2UserAccount? google,
    Web2UserAccount? apple,
    String? pk,
    double? ts,
  }) {
    return Web2UserDoc(
      createdOn: createdOn ?? this.createdOn,
      id: id ?? this.id,
      linkedAccounts: linkedAccounts ?? this.linkedAccounts,
      shards: shards ?? this.shards,
      hasNativeWallet: hasNativeWallet ?? this.hasNativeWallet,
      wallet: wallet ?? this.wallet,
      salt: salt ?? this.salt,
      google: google ?? this.google,
      apple: apple ?? this.apple,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  Web2UserDoc copyWithWrapped({
    Wrapped<double>? createdOn,
    Wrapped<String>? id,
    Wrapped<List<Object>>? linkedAccounts,
    Wrapped<List<String>>? shards,
    Wrapped<Object>? hasNativeWallet,
    Wrapped<Web2UserWallet?>? wallet,
    Wrapped<String>? salt,
    Wrapped<Web2UserAccount?>? google,
    Wrapped<Web2UserAccount?>? apple,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
  }) {
    return Web2UserDoc(
      createdOn: (createdOn != null ? createdOn.value : this.createdOn),
      id: (id != null ? id.value : this.id),
      linkedAccounts: (linkedAccounts != null
          ? linkedAccounts.value
          : this.linkedAccounts),
      shards: (shards != null ? shards.value : this.shards),
      hasNativeWallet: (hasNativeWallet != null
          ? hasNativeWallet.value
          : this.hasNativeWallet),
      wallet: (wallet != null ? wallet.value : this.wallet),
      salt: (salt != null ? salt.value : this.salt),
      google: (google != null ? google.value : this.google),
      apple: (apple != null ? apple.value : this.apple),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuccessWithMessageDto {
  const SuccessWithMessageDto({required this.success, required this.message});

  factory SuccessWithMessageDto.fromJson(Map<String, dynamic> json) =>
      _$SuccessWithMessageDtoFromJson(json);

  static const toJsonFactory = _$SuccessWithMessageDtoToJson;
  Map<String, dynamic> toJson() => _$SuccessWithMessageDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  static const fromJsonFactory = _$SuccessWithMessageDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SuccessWithMessageDto &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(message) ^
      runtimeType.hashCode;
}

extension $SuccessWithMessageDtoExtension on SuccessWithMessageDto {
  SuccessWithMessageDto copyWith({bool? success, String? message}) {
    return SuccessWithMessageDto(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }

  SuccessWithMessageDto copyWithWrapped({
    Wrapped<bool>? success,
    Wrapped<String>? message,
  }) {
    return SuccessWithMessageDto(
      success: (success != null ? success.value : this.success),
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2WalletDto {
  const Web2WalletDto({
    required this.type,
    required this.address,
    required this.chain,
    this.signature,
    this.authToken,
    required this.walletClientType,
    this.index,
    this.recoveryMethod,
  });

  factory Web2WalletDto.fromJson(Map<String, dynamic> json) =>
      _$Web2WalletDtoFromJson(json);

  static const toJsonFactory = _$Web2WalletDtoToJson;
  Map<String, dynamic> toJson() => _$Web2WalletDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'chain')
  final String chain;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'authToken')
  final String? authToken;
  @JsonKey(
    name: 'walletClientType',
    toJson: walletClientTypeToJson,
    fromJson: walletClientTypeFromJson,
  )
  final enums.WalletClientType walletClientType;
  @JsonKey(name: 'index')
  final double? index;
  @JsonKey(name: 'recoveryMethod')
  final String? recoveryMethod;
  static const fromJsonFactory = _$Web2WalletDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Web2WalletDto &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.authToken, authToken) ||
                const DeepCollectionEquality().equals(
                  other.authToken,
                  authToken,
                )) &&
            (identical(other.walletClientType, walletClientType) ||
                const DeepCollectionEquality().equals(
                  other.walletClientType,
                  walletClientType,
                )) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.recoveryMethod, recoveryMethod) ||
                const DeepCollectionEquality().equals(
                  other.recoveryMethod,
                  recoveryMethod,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(authToken) ^
      const DeepCollectionEquality().hash(walletClientType) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(recoveryMethod) ^
      runtimeType.hashCode;
}

extension $Web2WalletDtoExtension on Web2WalletDto {
  Web2WalletDto copyWith({
    enums.LinkedAccountType? type,
    String? address,
    String? chain,
    String? signature,
    String? authToken,
    enums.WalletClientType? walletClientType,
    double? index,
    String? recoveryMethod,
  }) {
    return Web2WalletDto(
      type: type ?? this.type,
      address: address ?? this.address,
      chain: chain ?? this.chain,
      signature: signature ?? this.signature,
      authToken: authToken ?? this.authToken,
      walletClientType: walletClientType ?? this.walletClientType,
      index: index ?? this.index,
      recoveryMethod: recoveryMethod ?? this.recoveryMethod,
    );
  }

  Web2WalletDto copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? address,
    Wrapped<String>? chain,
    Wrapped<String?>? signature,
    Wrapped<String?>? authToken,
    Wrapped<enums.WalletClientType>? walletClientType,
    Wrapped<double?>? index,
    Wrapped<String?>? recoveryMethod,
  }) {
    return Web2WalletDto(
      type: (type != null ? type.value : this.type),
      address: (address != null ? address.value : this.address),
      chain: (chain != null ? chain.value : this.chain),
      signature: (signature != null ? signature.value : this.signature),
      authToken: (authToken != null ? authToken.value : this.authToken),
      walletClientType: (walletClientType != null
          ? walletClientType.value
          : this.walletClientType),
      index: (index != null ? index.value : this.index),
      recoveryMethod: (recoveryMethod != null
          ? recoveryMethod.value
          : this.recoveryMethod),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NativeWalletDto {
  const NativeWalletDto({
    required this.shards,
    required this.wallet,
    required this.isActive,
  });

  factory NativeWalletDto.fromJson(Map<String, dynamic> json) =>
      _$NativeWalletDtoFromJson(json);

  static const toJsonFactory = _$NativeWalletDtoToJson;
  Map<String, dynamic> toJson() => _$NativeWalletDtoToJson(this);

  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  @JsonKey(name: 'wallet')
  final Web2WalletDto wallet;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$NativeWalletDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NativeWalletDto &&
            (identical(other.shards, shards) ||
                const DeepCollectionEquality().equals(other.shards, shards)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(shards) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $NativeWalletDtoExtension on NativeWalletDto {
  NativeWalletDto copyWith({
    List<String>? shards,
    Web2WalletDto? wallet,
    bool? isActive,
  }) {
    return NativeWalletDto(
      shards: shards ?? this.shards,
      wallet: wallet ?? this.wallet,
      isActive: isActive ?? this.isActive,
    );
  }

  NativeWalletDto copyWithWrapped({
    Wrapped<List<String>>? shards,
    Wrapped<Web2WalletDto>? wallet,
    Wrapped<bool>? isActive,
  }) {
    return NativeWalletDto(
      shards: (shards != null ? shards.value : this.shards),
      wallet: (wallet != null ? wallet.value : this.wallet),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SwitchWalletDto {
  const SwitchWalletDto({required this.address});

  factory SwitchWalletDto.fromJson(Map<String, dynamic> json) =>
      _$SwitchWalletDtoFromJson(json);

  static const toJsonFactory = _$SwitchWalletDtoToJson;
  Map<String, dynamic> toJson() => _$SwitchWalletDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$SwitchWalletDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SwitchWalletDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^ runtimeType.hashCode;
}

extension $SwitchWalletDtoExtension on SwitchWalletDto {
  SwitchWalletDto copyWith({String? address}) {
    return SwitchWalletDto(address: address ?? this.address);
  }

  SwitchWalletDto copyWithWrapped({Wrapped<String>? address}) {
    return SwitchWalletDto(
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserShardsDto {
  const Web2UserShardsDto({required this.shards});

  factory Web2UserShardsDto.fromJson(Map<String, dynamic> json) =>
      _$Web2UserShardsDtoFromJson(json);

  static const toJsonFactory = _$Web2UserShardsDtoToJson;
  Map<String, dynamic> toJson() => _$Web2UserShardsDtoToJson(this);

  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  static const fromJsonFactory = _$Web2UserShardsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Web2UserShardsDto &&
            (identical(other.shards, shards) ||
                const DeepCollectionEquality().equals(other.shards, shards)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(shards) ^ runtimeType.hashCode;
}

extension $Web2UserShardsDtoExtension on Web2UserShardsDto {
  Web2UserShardsDto copyWith({List<String>? shards}) {
    return Web2UserShardsDto(shards: shards ?? this.shards);
  }

  Web2UserShardsDto copyWithWrapped({Wrapped<List<String>>? shards}) {
    return Web2UserShardsDto(
      shards: (shards != null ? shards.value : this.shards),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoStakingReward {
  const XoxnoStakingReward({
    required this.tokenIdentifier,
    required this.tokenNonce,
    required this.rewardBalance,
    required this.shareRewardBalance,
    required this.rewardPerEpoch,
    this.rewardPerEpochShort,
    this.rewardPerDayPerNft,
    this.rewardBalanceShort,
    this.usdValue,
  });

  factory XoxnoStakingReward.fromJson(Map<String, dynamic> json) =>
      _$XoxnoStakingRewardFromJson(json);

  static const toJsonFactory = _$XoxnoStakingRewardToJson;
  Map<String, dynamic> toJson() => _$XoxnoStakingRewardToJson(this);

  @JsonKey(name: 'tokenIdentifier')
  final String tokenIdentifier;
  @JsonKey(name: 'tokenNonce')
  final double tokenNonce;
  @JsonKey(name: 'rewardBalance')
  final String rewardBalance;
  @JsonKey(name: 'shareRewardBalance')
  final String shareRewardBalance;
  @JsonKey(name: 'rewardPerEpoch')
  final String rewardPerEpoch;
  @JsonKey(name: 'rewardPerEpochShort')
  final double? rewardPerEpochShort;
  @JsonKey(name: 'rewardPerDayPerNft')
  final double? rewardPerDayPerNft;
  @JsonKey(name: 'rewardBalanceShort')
  final double? rewardBalanceShort;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  static const fromJsonFactory = _$XoxnoStakingRewardFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is XoxnoStakingReward &&
            (identical(other.tokenIdentifier, tokenIdentifier) ||
                const DeepCollectionEquality().equals(
                  other.tokenIdentifier,
                  tokenIdentifier,
                )) &&
            (identical(other.tokenNonce, tokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.tokenNonce,
                  tokenNonce,
                )) &&
            (identical(other.rewardBalance, rewardBalance) ||
                const DeepCollectionEquality().equals(
                  other.rewardBalance,
                  rewardBalance,
                )) &&
            (identical(other.shareRewardBalance, shareRewardBalance) ||
                const DeepCollectionEquality().equals(
                  other.shareRewardBalance,
                  shareRewardBalance,
                )) &&
            (identical(other.rewardPerEpoch, rewardPerEpoch) ||
                const DeepCollectionEquality().equals(
                  other.rewardPerEpoch,
                  rewardPerEpoch,
                )) &&
            (identical(other.rewardPerEpochShort, rewardPerEpochShort) ||
                const DeepCollectionEquality().equals(
                  other.rewardPerEpochShort,
                  rewardPerEpochShort,
                )) &&
            (identical(other.rewardPerDayPerNft, rewardPerDayPerNft) ||
                const DeepCollectionEquality().equals(
                  other.rewardPerDayPerNft,
                  rewardPerDayPerNft,
                )) &&
            (identical(other.rewardBalanceShort, rewardBalanceShort) ||
                const DeepCollectionEquality().equals(
                  other.rewardBalanceShort,
                  rewardBalanceShort,
                )) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokenIdentifier) ^
      const DeepCollectionEquality().hash(tokenNonce) ^
      const DeepCollectionEquality().hash(rewardBalance) ^
      const DeepCollectionEquality().hash(shareRewardBalance) ^
      const DeepCollectionEquality().hash(rewardPerEpoch) ^
      const DeepCollectionEquality().hash(rewardPerEpochShort) ^
      const DeepCollectionEquality().hash(rewardPerDayPerNft) ^
      const DeepCollectionEquality().hash(rewardBalanceShort) ^
      const DeepCollectionEquality().hash(usdValue) ^
      runtimeType.hashCode;
}

extension $XoxnoStakingRewardExtension on XoxnoStakingReward {
  XoxnoStakingReward copyWith({
    String? tokenIdentifier,
    double? tokenNonce,
    String? rewardBalance,
    String? shareRewardBalance,
    String? rewardPerEpoch,
    double? rewardPerEpochShort,
    double? rewardPerDayPerNft,
    double? rewardBalanceShort,
    double? usdValue,
  }) {
    return XoxnoStakingReward(
      tokenIdentifier: tokenIdentifier ?? this.tokenIdentifier,
      tokenNonce: tokenNonce ?? this.tokenNonce,
      rewardBalance: rewardBalance ?? this.rewardBalance,
      shareRewardBalance: shareRewardBalance ?? this.shareRewardBalance,
      rewardPerEpoch: rewardPerEpoch ?? this.rewardPerEpoch,
      rewardPerEpochShort: rewardPerEpochShort ?? this.rewardPerEpochShort,
      rewardPerDayPerNft: rewardPerDayPerNft ?? this.rewardPerDayPerNft,
      rewardBalanceShort: rewardBalanceShort ?? this.rewardBalanceShort,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  XoxnoStakingReward copyWithWrapped({
    Wrapped<String>? tokenIdentifier,
    Wrapped<double>? tokenNonce,
    Wrapped<String>? rewardBalance,
    Wrapped<String>? shareRewardBalance,
    Wrapped<String>? rewardPerEpoch,
    Wrapped<double?>? rewardPerEpochShort,
    Wrapped<double?>? rewardPerDayPerNft,
    Wrapped<double?>? rewardBalanceShort,
    Wrapped<double?>? usdValue,
  }) {
    return XoxnoStakingReward(
      tokenIdentifier: (tokenIdentifier != null
          ? tokenIdentifier.value
          : this.tokenIdentifier),
      tokenNonce: (tokenNonce != null ? tokenNonce.value : this.tokenNonce),
      rewardBalance: (rewardBalance != null
          ? rewardBalance.value
          : this.rewardBalance),
      shareRewardBalance: (shareRewardBalance != null
          ? shareRewardBalance.value
          : this.shareRewardBalance),
      rewardPerEpoch: (rewardPerEpoch != null
          ? rewardPerEpoch.value
          : this.rewardPerEpoch),
      rewardPerEpochShort: (rewardPerEpochShort != null
          ? rewardPerEpochShort.value
          : this.rewardPerEpochShort),
      rewardPerDayPerNft: (rewardPerDayPerNft != null
          ? rewardPerDayPerNft.value
          : this.rewardPerDayPerNft),
      rewardBalanceShort: (rewardBalanceShort != null
          ? rewardBalanceShort.value
          : this.rewardBalanceShort),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingSummary {
  const StakingSummary({
    required this.poolId,
    required this.name,
    this.description,
    required this.stakingEnabled,
    required this.profile,
    required this.collection,
    required this.poolStakedCount,
    required this.userStakedCount,
    required this.delegatorCount,
    required this.rewardDuration,
    required this.poolReward,
    required this.userReward,
    required this.poolType,
    required this.issuingType,
    required this.unBoundPeriod,
    required this.hasUnboundPeriod,
    required this.userUnboundCount,
    required this.maxPoolLimit,
    required this.hasMaxWalletLimit,
    required this.maxWalletLimit,
    required this.startEpoch,
    required this.endEpoch,
    required this.owner,
    required this.currentEpoch,
    required this.isActive,
    required this.daysLeft,
    required this.cutFee,
    required this.percentageFilled,
  });

  factory StakingSummary.fromJson(Map<String, dynamic> json) =>
      _$StakingSummaryFromJson(json);

  static const toJsonFactory = _$StakingSummaryToJson;
  Map<String, dynamic> toJson() => _$StakingSummaryToJson(this);

  @JsonKey(name: 'poolId')
  final double poolId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'stakingEnabled')
  final bool stakingEnabled;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String> collection;
  @JsonKey(name: 'poolStakedCount')
  final double poolStakedCount;
  @JsonKey(name: 'userStakedCount')
  final double userStakedCount;
  @JsonKey(name: 'delegatorCount')
  final double delegatorCount;
  @JsonKey(name: 'rewardDuration')
  final double rewardDuration;
  @JsonKey(name: 'poolReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> poolReward;
  @JsonKey(name: 'userReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> userReward;
  @JsonKey(name: 'poolType')
  final String poolType;
  @JsonKey(name: 'issuingType')
  final String issuingType;
  @JsonKey(name: 'unBoundPeriod')
  final double unBoundPeriod;
  @JsonKey(name: 'hasUnboundPeriod')
  final bool hasUnboundPeriod;
  @JsonKey(name: 'userUnboundCount')
  final double userUnboundCount;
  @JsonKey(name: 'maxPoolLimit')
  final double maxPoolLimit;
  @JsonKey(name: 'hasMaxWalletLimit')
  final bool hasMaxWalletLimit;
  @JsonKey(name: 'maxWalletLimit')
  final double maxWalletLimit;
  @JsonKey(name: 'startEpoch')
  final double startEpoch;
  @JsonKey(name: 'endEpoch')
  final double endEpoch;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'currentEpoch')
  final double currentEpoch;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(name: 'daysLeft')
  final double daysLeft;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'percentageFilled')
  final double percentageFilled;
  static const fromJsonFactory = _$StakingSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingSummary &&
            (identical(other.poolId, poolId) ||
                const DeepCollectionEquality().equals(other.poolId, poolId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.stakingEnabled, stakingEnabled) ||
                const DeepCollectionEquality().equals(
                  other.stakingEnabled,
                  stakingEnabled,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.poolStakedCount, poolStakedCount) ||
                const DeepCollectionEquality().equals(
                  other.poolStakedCount,
                  poolStakedCount,
                )) &&
            (identical(other.userStakedCount, userStakedCount) ||
                const DeepCollectionEquality().equals(
                  other.userStakedCount,
                  userStakedCount,
                )) &&
            (identical(other.delegatorCount, delegatorCount) ||
                const DeepCollectionEquality().equals(
                  other.delegatorCount,
                  delegatorCount,
                )) &&
            (identical(other.rewardDuration, rewardDuration) ||
                const DeepCollectionEquality().equals(
                  other.rewardDuration,
                  rewardDuration,
                )) &&
            (identical(other.poolReward, poolReward) ||
                const DeepCollectionEquality().equals(
                  other.poolReward,
                  poolReward,
                )) &&
            (identical(other.userReward, userReward) ||
                const DeepCollectionEquality().equals(
                  other.userReward,
                  userReward,
                )) &&
            (identical(other.poolType, poolType) ||
                const DeepCollectionEquality().equals(
                  other.poolType,
                  poolType,
                )) &&
            (identical(other.issuingType, issuingType) ||
                const DeepCollectionEquality().equals(
                  other.issuingType,
                  issuingType,
                )) &&
            (identical(other.unBoundPeriod, unBoundPeriod) ||
                const DeepCollectionEquality().equals(
                  other.unBoundPeriod,
                  unBoundPeriod,
                )) &&
            (identical(other.hasUnboundPeriod, hasUnboundPeriod) ||
                const DeepCollectionEquality().equals(
                  other.hasUnboundPeriod,
                  hasUnboundPeriod,
                )) &&
            (identical(other.userUnboundCount, userUnboundCount) ||
                const DeepCollectionEquality().equals(
                  other.userUnboundCount,
                  userUnboundCount,
                )) &&
            (identical(other.maxPoolLimit, maxPoolLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxPoolLimit,
                  maxPoolLimit,
                )) &&
            (identical(other.hasMaxWalletLimit, hasMaxWalletLimit) ||
                const DeepCollectionEquality().equals(
                  other.hasMaxWalletLimit,
                  hasMaxWalletLimit,
                )) &&
            (identical(other.maxWalletLimit, maxWalletLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxWalletLimit,
                  maxWalletLimit,
                )) &&
            (identical(other.startEpoch, startEpoch) ||
                const DeepCollectionEquality().equals(
                  other.startEpoch,
                  startEpoch,
                )) &&
            (identical(other.endEpoch, endEpoch) ||
                const DeepCollectionEquality().equals(
                  other.endEpoch,
                  endEpoch,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.currentEpoch, currentEpoch) ||
                const DeepCollectionEquality().equals(
                  other.currentEpoch,
                  currentEpoch,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.daysLeft, daysLeft) ||
                const DeepCollectionEquality().equals(
                  other.daysLeft,
                  daysLeft,
                )) &&
            (identical(other.cutFee, cutFee) ||
                const DeepCollectionEquality().equals(other.cutFee, cutFee)) &&
            (identical(other.percentageFilled, percentageFilled) ||
                const DeepCollectionEquality().equals(
                  other.percentageFilled,
                  percentageFilled,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(poolId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(stakingEnabled) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(poolStakedCount) ^
      const DeepCollectionEquality().hash(userStakedCount) ^
      const DeepCollectionEquality().hash(delegatorCount) ^
      const DeepCollectionEquality().hash(rewardDuration) ^
      const DeepCollectionEquality().hash(poolReward) ^
      const DeepCollectionEquality().hash(userReward) ^
      const DeepCollectionEquality().hash(poolType) ^
      const DeepCollectionEquality().hash(issuingType) ^
      const DeepCollectionEquality().hash(unBoundPeriod) ^
      const DeepCollectionEquality().hash(hasUnboundPeriod) ^
      const DeepCollectionEquality().hash(userUnboundCount) ^
      const DeepCollectionEquality().hash(maxPoolLimit) ^
      const DeepCollectionEquality().hash(hasMaxWalletLimit) ^
      const DeepCollectionEquality().hash(maxWalletLimit) ^
      const DeepCollectionEquality().hash(startEpoch) ^
      const DeepCollectionEquality().hash(endEpoch) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(currentEpoch) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(daysLeft) ^
      const DeepCollectionEquality().hash(cutFee) ^
      const DeepCollectionEquality().hash(percentageFilled) ^
      runtimeType.hashCode;
}

extension $StakingSummaryExtension on StakingSummary {
  StakingSummary copyWith({
    double? poolId,
    String? name,
    String? description,
    bool? stakingEnabled,
    String? profile,
    List<String>? collection,
    double? poolStakedCount,
    double? userStakedCount,
    double? delegatorCount,
    double? rewardDuration,
    List<XoxnoStakingReward>? poolReward,
    List<XoxnoStakingReward>? userReward,
    String? poolType,
    String? issuingType,
    double? unBoundPeriod,
    bool? hasUnboundPeriod,
    double? userUnboundCount,
    double? maxPoolLimit,
    bool? hasMaxWalletLimit,
    double? maxWalletLimit,
    double? startEpoch,
    double? endEpoch,
    String? owner,
    double? currentEpoch,
    bool? isActive,
    double? daysLeft,
    double? cutFee,
    double? percentageFilled,
  }) {
    return StakingSummary(
      poolId: poolId ?? this.poolId,
      name: name ?? this.name,
      description: description ?? this.description,
      stakingEnabled: stakingEnabled ?? this.stakingEnabled,
      profile: profile ?? this.profile,
      collection: collection ?? this.collection,
      poolStakedCount: poolStakedCount ?? this.poolStakedCount,
      userStakedCount: userStakedCount ?? this.userStakedCount,
      delegatorCount: delegatorCount ?? this.delegatorCount,
      rewardDuration: rewardDuration ?? this.rewardDuration,
      poolReward: poolReward ?? this.poolReward,
      userReward: userReward ?? this.userReward,
      poolType: poolType ?? this.poolType,
      issuingType: issuingType ?? this.issuingType,
      unBoundPeriod: unBoundPeriod ?? this.unBoundPeriod,
      hasUnboundPeriod: hasUnboundPeriod ?? this.hasUnboundPeriod,
      userUnboundCount: userUnboundCount ?? this.userUnboundCount,
      maxPoolLimit: maxPoolLimit ?? this.maxPoolLimit,
      hasMaxWalletLimit: hasMaxWalletLimit ?? this.hasMaxWalletLimit,
      maxWalletLimit: maxWalletLimit ?? this.maxWalletLimit,
      startEpoch: startEpoch ?? this.startEpoch,
      endEpoch: endEpoch ?? this.endEpoch,
      owner: owner ?? this.owner,
      currentEpoch: currentEpoch ?? this.currentEpoch,
      isActive: isActive ?? this.isActive,
      daysLeft: daysLeft ?? this.daysLeft,
      cutFee: cutFee ?? this.cutFee,
      percentageFilled: percentageFilled ?? this.percentageFilled,
    );
  }

  StakingSummary copyWithWrapped({
    Wrapped<double>? poolId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<bool>? stakingEnabled,
    Wrapped<String>? profile,
    Wrapped<List<String>>? collection,
    Wrapped<double>? poolStakedCount,
    Wrapped<double>? userStakedCount,
    Wrapped<double>? delegatorCount,
    Wrapped<double>? rewardDuration,
    Wrapped<List<XoxnoStakingReward>>? poolReward,
    Wrapped<List<XoxnoStakingReward>>? userReward,
    Wrapped<String>? poolType,
    Wrapped<String>? issuingType,
    Wrapped<double>? unBoundPeriod,
    Wrapped<bool>? hasUnboundPeriod,
    Wrapped<double>? userUnboundCount,
    Wrapped<double>? maxPoolLimit,
    Wrapped<bool>? hasMaxWalletLimit,
    Wrapped<double>? maxWalletLimit,
    Wrapped<double>? startEpoch,
    Wrapped<double>? endEpoch,
    Wrapped<String>? owner,
    Wrapped<double>? currentEpoch,
    Wrapped<bool>? isActive,
    Wrapped<double>? daysLeft,
    Wrapped<double>? cutFee,
    Wrapped<double>? percentageFilled,
  }) {
    return StakingSummary(
      poolId: (poolId != null ? poolId.value : this.poolId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      stakingEnabled: (stakingEnabled != null
          ? stakingEnabled.value
          : this.stakingEnabled),
      profile: (profile != null ? profile.value : this.profile),
      collection: (collection != null ? collection.value : this.collection),
      poolStakedCount: (poolStakedCount != null
          ? poolStakedCount.value
          : this.poolStakedCount),
      userStakedCount: (userStakedCount != null
          ? userStakedCount.value
          : this.userStakedCount),
      delegatorCount: (delegatorCount != null
          ? delegatorCount.value
          : this.delegatorCount),
      rewardDuration: (rewardDuration != null
          ? rewardDuration.value
          : this.rewardDuration),
      poolReward: (poolReward != null ? poolReward.value : this.poolReward),
      userReward: (userReward != null ? userReward.value : this.userReward),
      poolType: (poolType != null ? poolType.value : this.poolType),
      issuingType: (issuingType != null ? issuingType.value : this.issuingType),
      unBoundPeriod: (unBoundPeriod != null
          ? unBoundPeriod.value
          : this.unBoundPeriod),
      hasUnboundPeriod: (hasUnboundPeriod != null
          ? hasUnboundPeriod.value
          : this.hasUnboundPeriod),
      userUnboundCount: (userUnboundCount != null
          ? userUnboundCount.value
          : this.userUnboundCount),
      maxPoolLimit: (maxPoolLimit != null
          ? maxPoolLimit.value
          : this.maxPoolLimit),
      hasMaxWalletLimit: (hasMaxWalletLimit != null
          ? hasMaxWalletLimit.value
          : this.hasMaxWalletLimit),
      maxWalletLimit: (maxWalletLimit != null
          ? maxWalletLimit.value
          : this.maxWalletLimit),
      startEpoch: (startEpoch != null ? startEpoch.value : this.startEpoch),
      endEpoch: (endEpoch != null ? endEpoch.value : this.endEpoch),
      owner: (owner != null ? owner.value : this.owner),
      currentEpoch: (currentEpoch != null
          ? currentEpoch.value
          : this.currentEpoch),
      isActive: (isActive != null ? isActive.value : this.isActive),
      daysLeft: (daysLeft != null ? daysLeft.value : this.daysLeft),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      percentageFilled: (percentageFilled != null
          ? percentageFilled.value
          : this.percentageFilled),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingPoolDoc {
  const StakingPoolDoc({
    required this.dataType,
    required this.poolId,
    required this.poolType,
    required this.stakingEnabled,
    required this.whitelistEnabled,
    required this.matchPairEnabled,
    required this.maxStakePerWallet,
    required this.maxStakePerPool,
    required this.issuingType,
    required this.issuingDeadline,
    required this.issuingStart,
    required this.unboundPeriod,
    required this.collection,
    required this.reward,
    required this.cutFee,
    required this.owner,
    this.name,
    this.profile,
    this.totalWhitelisted,
    this.delegatorCount,
    this.poolStakedCount,
    this.pk,
    this.id,
  });

  factory StakingPoolDoc.fromJson(Map<String, dynamic> json) =>
      _$StakingPoolDocFromJson(json);

  static const toJsonFactory = _$StakingPoolDocToJson;
  Map<String, dynamic> toJson() => _$StakingPoolDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: stakingDataTypeToJson,
    fromJson: stakingDataTypeFromJson,
  )
  final enums.StakingDataType dataType;
  @JsonKey(name: 'poolId')
  final double poolId;
  @JsonKey(
    name: 'poolType',
    toJson: stakingPoolTypeStringToJson,
    fromJson: stakingPoolTypeStringFromJson,
  )
  final enums.StakingPoolTypeString poolType;
  @JsonKey(name: 'stakingEnabled')
  final bool stakingEnabled;
  @JsonKey(name: 'whitelistEnabled')
  final bool whitelistEnabled;
  @JsonKey(name: 'matchPairEnabled')
  final bool matchPairEnabled;
  @JsonKey(name: 'maxStakePerWallet')
  final double maxStakePerWallet;
  @JsonKey(name: 'maxStakePerPool')
  final double maxStakePerPool;
  @JsonKey(
    name: 'issuingType',
    toJson: stakingIssuingTypeStringToJson,
    fromJson: stakingIssuingTypeStringFromJson,
  )
  final enums.StakingIssuingTypeString issuingType;
  @JsonKey(name: 'issuingDeadline')
  final double issuingDeadline;
  @JsonKey(name: 'issuingStart')
  final double issuingStart;
  @JsonKey(name: 'unboundPeriod')
  final double unboundPeriod;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String> collection;
  @JsonKey(name: 'reward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> reward;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'totalWhitelisted')
  final double? totalWhitelisted;
  @JsonKey(name: 'delegatorCount')
  final double? delegatorCount;
  @JsonKey(name: 'poolStakedCount')
  final double? poolStakedCount;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$StakingPoolDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingPoolDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.poolId, poolId) ||
                const DeepCollectionEquality().equals(other.poolId, poolId)) &&
            (identical(other.poolType, poolType) ||
                const DeepCollectionEquality().equals(
                  other.poolType,
                  poolType,
                )) &&
            (identical(other.stakingEnabled, stakingEnabled) ||
                const DeepCollectionEquality().equals(
                  other.stakingEnabled,
                  stakingEnabled,
                )) &&
            (identical(other.whitelistEnabled, whitelistEnabled) ||
                const DeepCollectionEquality().equals(
                  other.whitelistEnabled,
                  whitelistEnabled,
                )) &&
            (identical(other.matchPairEnabled, matchPairEnabled) ||
                const DeepCollectionEquality().equals(
                  other.matchPairEnabled,
                  matchPairEnabled,
                )) &&
            (identical(other.maxStakePerWallet, maxStakePerWallet) ||
                const DeepCollectionEquality().equals(
                  other.maxStakePerWallet,
                  maxStakePerWallet,
                )) &&
            (identical(other.maxStakePerPool, maxStakePerPool) ||
                const DeepCollectionEquality().equals(
                  other.maxStakePerPool,
                  maxStakePerPool,
                )) &&
            (identical(other.issuingType, issuingType) ||
                const DeepCollectionEquality().equals(
                  other.issuingType,
                  issuingType,
                )) &&
            (identical(other.issuingDeadline, issuingDeadline) ||
                const DeepCollectionEquality().equals(
                  other.issuingDeadline,
                  issuingDeadline,
                )) &&
            (identical(other.issuingStart, issuingStart) ||
                const DeepCollectionEquality().equals(
                  other.issuingStart,
                  issuingStart,
                )) &&
            (identical(other.unboundPeriod, unboundPeriod) ||
                const DeepCollectionEquality().equals(
                  other.unboundPeriod,
                  unboundPeriod,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.reward, reward) ||
                const DeepCollectionEquality().equals(other.reward, reward)) &&
            (identical(other.cutFee, cutFee) ||
                const DeepCollectionEquality().equals(other.cutFee, cutFee)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.totalWhitelisted, totalWhitelisted) ||
                const DeepCollectionEquality().equals(
                  other.totalWhitelisted,
                  totalWhitelisted,
                )) &&
            (identical(other.delegatorCount, delegatorCount) ||
                const DeepCollectionEquality().equals(
                  other.delegatorCount,
                  delegatorCount,
                )) &&
            (identical(other.poolStakedCount, poolStakedCount) ||
                const DeepCollectionEquality().equals(
                  other.poolStakedCount,
                  poolStakedCount,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(poolId) ^
      const DeepCollectionEquality().hash(poolType) ^
      const DeepCollectionEquality().hash(stakingEnabled) ^
      const DeepCollectionEquality().hash(whitelistEnabled) ^
      const DeepCollectionEquality().hash(matchPairEnabled) ^
      const DeepCollectionEquality().hash(maxStakePerWallet) ^
      const DeepCollectionEquality().hash(maxStakePerPool) ^
      const DeepCollectionEquality().hash(issuingType) ^
      const DeepCollectionEquality().hash(issuingDeadline) ^
      const DeepCollectionEquality().hash(issuingStart) ^
      const DeepCollectionEquality().hash(unboundPeriod) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(reward) ^
      const DeepCollectionEquality().hash(cutFee) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(totalWhitelisted) ^
      const DeepCollectionEquality().hash(delegatorCount) ^
      const DeepCollectionEquality().hash(poolStakedCount) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $StakingPoolDocExtension on StakingPoolDoc {
  StakingPoolDoc copyWith({
    enums.StakingDataType? dataType,
    double? poolId,
    enums.StakingPoolTypeString? poolType,
    bool? stakingEnabled,
    bool? whitelistEnabled,
    bool? matchPairEnabled,
    double? maxStakePerWallet,
    double? maxStakePerPool,
    enums.StakingIssuingTypeString? issuingType,
    double? issuingDeadline,
    double? issuingStart,
    double? unboundPeriod,
    List<String>? collection,
    List<XoxnoStakingReward>? reward,
    double? cutFee,
    String? owner,
    String? name,
    String? profile,
    double? totalWhitelisted,
    double? delegatorCount,
    double? poolStakedCount,
    String? pk,
    String? id,
  }) {
    return StakingPoolDoc(
      dataType: dataType ?? this.dataType,
      poolId: poolId ?? this.poolId,
      poolType: poolType ?? this.poolType,
      stakingEnabled: stakingEnabled ?? this.stakingEnabled,
      whitelistEnabled: whitelistEnabled ?? this.whitelistEnabled,
      matchPairEnabled: matchPairEnabled ?? this.matchPairEnabled,
      maxStakePerWallet: maxStakePerWallet ?? this.maxStakePerWallet,
      maxStakePerPool: maxStakePerPool ?? this.maxStakePerPool,
      issuingType: issuingType ?? this.issuingType,
      issuingDeadline: issuingDeadline ?? this.issuingDeadline,
      issuingStart: issuingStart ?? this.issuingStart,
      unboundPeriod: unboundPeriod ?? this.unboundPeriod,
      collection: collection ?? this.collection,
      reward: reward ?? this.reward,
      cutFee: cutFee ?? this.cutFee,
      owner: owner ?? this.owner,
      name: name ?? this.name,
      profile: profile ?? this.profile,
      totalWhitelisted: totalWhitelisted ?? this.totalWhitelisted,
      delegatorCount: delegatorCount ?? this.delegatorCount,
      poolStakedCount: poolStakedCount ?? this.poolStakedCount,
      pk: pk ?? this.pk,
      id: id ?? this.id,
    );
  }

  StakingPoolDoc copyWithWrapped({
    Wrapped<enums.StakingDataType>? dataType,
    Wrapped<double>? poolId,
    Wrapped<enums.StakingPoolTypeString>? poolType,
    Wrapped<bool>? stakingEnabled,
    Wrapped<bool>? whitelistEnabled,
    Wrapped<bool>? matchPairEnabled,
    Wrapped<double>? maxStakePerWallet,
    Wrapped<double>? maxStakePerPool,
    Wrapped<enums.StakingIssuingTypeString>? issuingType,
    Wrapped<double>? issuingDeadline,
    Wrapped<double>? issuingStart,
    Wrapped<double>? unboundPeriod,
    Wrapped<List<String>>? collection,
    Wrapped<List<XoxnoStakingReward>>? reward,
    Wrapped<double>? cutFee,
    Wrapped<String>? owner,
    Wrapped<String?>? name,
    Wrapped<String?>? profile,
    Wrapped<double?>? totalWhitelisted,
    Wrapped<double?>? delegatorCount,
    Wrapped<double?>? poolStakedCount,
    Wrapped<String?>? pk,
    Wrapped<String?>? id,
  }) {
    return StakingPoolDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      poolId: (poolId != null ? poolId.value : this.poolId),
      poolType: (poolType != null ? poolType.value : this.poolType),
      stakingEnabled: (stakingEnabled != null
          ? stakingEnabled.value
          : this.stakingEnabled),
      whitelistEnabled: (whitelistEnabled != null
          ? whitelistEnabled.value
          : this.whitelistEnabled),
      matchPairEnabled: (matchPairEnabled != null
          ? matchPairEnabled.value
          : this.matchPairEnabled),
      maxStakePerWallet: (maxStakePerWallet != null
          ? maxStakePerWallet.value
          : this.maxStakePerWallet),
      maxStakePerPool: (maxStakePerPool != null
          ? maxStakePerPool.value
          : this.maxStakePerPool),
      issuingType: (issuingType != null ? issuingType.value : this.issuingType),
      issuingDeadline: (issuingDeadline != null
          ? issuingDeadline.value
          : this.issuingDeadline),
      issuingStart: (issuingStart != null
          ? issuingStart.value
          : this.issuingStart),
      unboundPeriod: (unboundPeriod != null
          ? unboundPeriod.value
          : this.unboundPeriod),
      collection: (collection != null ? collection.value : this.collection),
      reward: (reward != null ? reward.value : this.reward),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      owner: (owner != null ? owner.value : this.owner),
      name: (name != null ? name.value : this.name),
      profile: (profile != null ? profile.value : this.profile),
      totalWhitelisted: (totalWhitelisted != null
          ? totalWhitelisted.value
          : this.totalWhitelisted),
      delegatorCount: (delegatorCount != null
          ? delegatorCount.value
          : this.delegatorCount),
      poolStakedCount: (poolStakedCount != null
          ? poolStakedCount.value
          : this.poolStakedCount),
      pk: (pk != null ? pk.value : this.pk),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingEditDto {
  const StakingEditDto({this.name, this.description});

  factory StakingEditDto.fromJson(Map<String, dynamic> json) =>
      _$StakingEditDtoFromJson(json);

  static const toJsonFactory = _$StakingEditDtoToJson;
  Map<String, dynamic> toJson() => _$StakingEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$StakingEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingEditDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $StakingEditDtoExtension on StakingEditDto {
  StakingEditDto copyWith({String? name, String? description}) {
    return StakingEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }

  StakingEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
  }) {
    return StakingEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OwnedCollectionsDto {
  const OwnedCollectionsDto({
    required this.registered,
    required this.availableForRegister,
  });

  factory OwnedCollectionsDto.fromJson(Map<String, dynamic> json) =>
      _$OwnedCollectionsDtoFromJson(json);

  static const toJsonFactory = _$OwnedCollectionsDtoToJson;
  Map<String, dynamic> toJson() => _$OwnedCollectionsDtoToJson(this);

  @JsonKey(name: 'registered', defaultValue: <String>[])
  final List<String> registered;
  @JsonKey(name: 'availableForRegister', defaultValue: <String>[])
  final List<String> availableForRegister;
  static const fromJsonFactory = _$OwnedCollectionsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OwnedCollectionsDto &&
            (identical(other.registered, registered) ||
                const DeepCollectionEquality().equals(
                  other.registered,
                  registered,
                )) &&
            (identical(other.availableForRegister, availableForRegister) ||
                const DeepCollectionEquality().equals(
                  other.availableForRegister,
                  availableForRegister,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(registered) ^
      const DeepCollectionEquality().hash(availableForRegister) ^
      runtimeType.hashCode;
}

extension $OwnedCollectionsDtoExtension on OwnedCollectionsDto {
  OwnedCollectionsDto copyWith({
    List<String>? registered,
    List<String>? availableForRegister,
  }) {
    return OwnedCollectionsDto(
      registered: registered ?? this.registered,
      availableForRegister: availableForRegister ?? this.availableForRegister,
    );
  }

  OwnedCollectionsDto copyWithWrapped({
    Wrapped<List<String>>? registered,
    Wrapped<List<String>>? availableForRegister,
  }) {
    return OwnedCollectionsDto(
      registered: (registered != null ? registered.value : this.registered),
      availableForRegister: (availableForRegister != null
          ? availableForRegister.value
          : this.availableForRegister),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserStakingSummaryDto {
  const UserStakingSummaryDto({
    required this.collection,
    required this.stakedCount,
    required this.name,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.poolIds,
    required this.userReward,
  });

  factory UserStakingSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$UserStakingSummaryDtoFromJson(json);

  static const toJsonFactory = _$UserStakingSummaryDtoToJson;
  Map<String, dynamic> toJson() => _$UserStakingSummaryDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'stakedCount')
  final double stakedCount;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'poolIds', defaultValue: <double>[])
  final List<double> poolIds;
  @JsonKey(name: 'userReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> userReward;
  static const fromJsonFactory = _$UserStakingSummaryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserStakingSummaryDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.stakedCount, stakedCount) ||
                const DeepCollectionEquality().equals(
                  other.stakedCount,
                  stakedCount,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.poolIds, poolIds) ||
                const DeepCollectionEquality().equals(
                  other.poolIds,
                  poolIds,
                )) &&
            (identical(other.userReward, userReward) ||
                const DeepCollectionEquality().equals(
                  other.userReward,
                  userReward,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(stakedCount) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(poolIds) ^
      const DeepCollectionEquality().hash(userReward) ^
      runtimeType.hashCode;
}

extension $UserStakingSummaryDtoExtension on UserStakingSummaryDto {
  UserStakingSummaryDto copyWith({
    String? collection,
    double? stakedCount,
    String? name,
    bool? isVerified,
    String? profile,
    String? banner,
    List<double>? poolIds,
    List<XoxnoStakingReward>? userReward,
  }) {
    return UserStakingSummaryDto(
      collection: collection ?? this.collection,
      stakedCount: stakedCount ?? this.stakedCount,
      name: name ?? this.name,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      poolIds: poolIds ?? this.poolIds,
      userReward: userReward ?? this.userReward,
    );
  }

  UserStakingSummaryDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? stakedCount,
    Wrapped<String>? name,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<List<double>>? poolIds,
    Wrapped<List<XoxnoStakingReward>>? userReward,
  }) {
    return UserStakingSummaryDto(
      collection: (collection != null ? collection.value : this.collection),
      stakedCount: (stakedCount != null ? stakedCount.value : this.stakedCount),
      name: (name != null ? name.value : this.name),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      poolIds: (poolIds != null ? poolIds.value : this.poolIds),
      userReward: (userReward != null ? userReward.value : this.userReward),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingCreatorDoc {
  const StakingCreatorDoc({
    required this.dataType,
    required this.address,
    required this.ownedPools,
    required this.ownedCollections,
    required this.cutFee,
    this.id,
    this.pk,
  });

  factory StakingCreatorDoc.fromJson(Map<String, dynamic> json) =>
      _$StakingCreatorDocFromJson(json);

  static const toJsonFactory = _$StakingCreatorDocToJson;
  Map<String, dynamic> toJson() => _$StakingCreatorDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: stakingDataTypeToJson,
    fromJson: stakingDataTypeFromJson,
  )
  final enums.StakingDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'ownedPools', defaultValue: <double>[])
  final List<double> ownedPools;
  @JsonKey(name: 'ownedCollections', defaultValue: <String>[])
  final List<String> ownedCollections;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$StakingCreatorDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingCreatorDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.ownedPools, ownedPools) ||
                const DeepCollectionEquality().equals(
                  other.ownedPools,
                  ownedPools,
                )) &&
            (identical(other.ownedCollections, ownedCollections) ||
                const DeepCollectionEquality().equals(
                  other.ownedCollections,
                  ownedCollections,
                )) &&
            (identical(other.cutFee, cutFee) ||
                const DeepCollectionEquality().equals(other.cutFee, cutFee)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(ownedPools) ^
      const DeepCollectionEquality().hash(ownedCollections) ^
      const DeepCollectionEquality().hash(cutFee) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $StakingCreatorDocExtension on StakingCreatorDoc {
  StakingCreatorDoc copyWith({
    enums.StakingDataType? dataType,
    String? address,
    List<double>? ownedPools,
    List<String>? ownedCollections,
    double? cutFee,
    String? id,
    String? pk,
  }) {
    return StakingCreatorDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      ownedPools: ownedPools ?? this.ownedPools,
      ownedCollections: ownedCollections ?? this.ownedCollections,
      cutFee: cutFee ?? this.cutFee,
      id: id ?? this.id,
      pk: pk ?? this.pk,
    );
  }

  StakingCreatorDoc copyWithWrapped({
    Wrapped<enums.StakingDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<List<double>>? ownedPools,
    Wrapped<List<String>>? ownedCollections,
    Wrapped<double>? cutFee,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
  }) {
    return StakingCreatorDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      ownedPools: (ownedPools != null ? ownedPools.value : this.ownedPools),
      ownedCollections: (ownedCollections != null
          ? ownedCollections.value
          : this.ownedCollections),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingUserPoolNfts {
  const StakingUserPoolNfts({
    required this.poolInfo,
    required this.nftDocs,
    required this.count,
  });

  factory StakingUserPoolNfts.fromJson(Map<String, dynamic> json) =>
      _$StakingUserPoolNftsFromJson(json);

  static const toJsonFactory = _$StakingUserPoolNftsToJson;
  Map<String, dynamic> toJson() => _$StakingUserPoolNftsToJson(this);

  @JsonKey(name: 'poolInfo')
  final StakingSummary poolInfo;
  @JsonKey(name: 'nftDocs', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated> nftDocs;
  @JsonKey(name: 'count')
  final double count;
  static const fromJsonFactory = _$StakingUserPoolNftsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingUserPoolNfts &&
            (identical(other.poolInfo, poolInfo) ||
                const DeepCollectionEquality().equals(
                  other.poolInfo,
                  poolInfo,
                )) &&
            (identical(other.nftDocs, nftDocs) ||
                const DeepCollectionEquality().equals(
                  other.nftDocs,
                  nftDocs,
                )) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(poolInfo) ^
      const DeepCollectionEquality().hash(nftDocs) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $StakingUserPoolNftsExtension on StakingUserPoolNfts {
  StakingUserPoolNfts copyWith({
    StakingSummary? poolInfo,
    List<NftDocHydrated>? nftDocs,
    double? count,
  }) {
    return StakingUserPoolNfts(
      poolInfo: poolInfo ?? this.poolInfo,
      nftDocs: nftDocs ?? this.nftDocs,
      count: count ?? this.count,
    );
  }

  StakingUserPoolNfts copyWithWrapped({
    Wrapped<StakingSummary>? poolInfo,
    Wrapped<List<NftDocHydrated>>? nftDocs,
    Wrapped<double>? count,
  }) {
    return StakingUserPoolNfts(
      poolInfo: (poolInfo != null ? poolInfo.value : this.poolInfo),
      nftDocs: (nftDocs != null ? nftDocs.value : this.nftDocs),
      count: (count != null ? count.value : this.count),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingExploreDtoHydrated {
  const StakingExploreDtoHydrated({
    required this.collection,
    required this.activePools,
    required this.totalPoolStakedCount,
    required this.totalDelegatorCount,
    required this.rewardTickers,
    required this.collectionInfo,
  });

  factory StakingExploreDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$StakingExploreDtoHydratedFromJson(json);

  static const toJsonFactory = _$StakingExploreDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$StakingExploreDtoHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'activePools')
  final double activePools;
  @JsonKey(name: 'totalPoolStakedCount')
  final double totalPoolStakedCount;
  @JsonKey(name: 'totalDelegatorCount')
  final double totalDelegatorCount;
  @JsonKey(name: 'rewardTickers', defaultValue: <String>[])
  final List<String> rewardTickers;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$StakingExploreDtoHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StakingExploreDtoHydrated &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.activePools, activePools) ||
                const DeepCollectionEquality().equals(
                  other.activePools,
                  activePools,
                )) &&
            (identical(other.totalPoolStakedCount, totalPoolStakedCount) ||
                const DeepCollectionEquality().equals(
                  other.totalPoolStakedCount,
                  totalPoolStakedCount,
                )) &&
            (identical(other.totalDelegatorCount, totalDelegatorCount) ||
                const DeepCollectionEquality().equals(
                  other.totalDelegatorCount,
                  totalDelegatorCount,
                )) &&
            (identical(other.rewardTickers, rewardTickers) ||
                const DeepCollectionEquality().equals(
                  other.rewardTickers,
                  rewardTickers,
                )) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(activePools) ^
      const DeepCollectionEquality().hash(totalPoolStakedCount) ^
      const DeepCollectionEquality().hash(totalDelegatorCount) ^
      const DeepCollectionEquality().hash(rewardTickers) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      runtimeType.hashCode;
}

extension $StakingExploreDtoHydratedExtension on StakingExploreDtoHydrated {
  StakingExploreDtoHydrated copyWith({
    String? collection,
    double? activePools,
    double? totalPoolStakedCount,
    double? totalDelegatorCount,
    List<String>? rewardTickers,
    ShortCollectionDoc? collectionInfo,
  }) {
    return StakingExploreDtoHydrated(
      collection: collection ?? this.collection,
      activePools: activePools ?? this.activePools,
      totalPoolStakedCount: totalPoolStakedCount ?? this.totalPoolStakedCount,
      totalDelegatorCount: totalDelegatorCount ?? this.totalDelegatorCount,
      rewardTickers: rewardTickers ?? this.rewardTickers,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  StakingExploreDtoHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? activePools,
    Wrapped<double>? totalPoolStakedCount,
    Wrapped<double>? totalDelegatorCount,
    Wrapped<List<String>>? rewardTickers,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return StakingExploreDtoHydrated(
      collection: (collection != null ? collection.value : this.collection),
      activePools: (activePools != null ? activePools.value : this.activePools),
      totalPoolStakedCount: (totalPoolStakedCount != null
          ? totalPoolStakedCount.value
          : this.totalPoolStakedCount),
      totalDelegatorCount: (totalDelegatorCount != null
          ? totalDelegatorCount.value
          : this.totalDelegatorCount),
      rewardTickers: (rewardTickers != null
          ? rewardTickers.value
          : this.rewardTickers),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OwnedServicesDto {
  const OwnedServicesDto({
    required this.mintProfiles,
    required this.stakingPools,
    required this.events,
    required this.creatorProfile,
    required this.address,
  });

  factory OwnedServicesDto.fromJson(Map<String, dynamic> json) =>
      _$OwnedServicesDtoFromJson(json);

  static const toJsonFactory = _$OwnedServicesDtoToJson;
  Map<String, dynamic> toJson() => _$OwnedServicesDtoToJson(this);

  @JsonKey(
    name: 'mintProfiles',
    defaultValue: <CollectionMintProfileDocHydrated>[],
  )
  final List<CollectionMintProfileDocHydrated> mintProfiles;
  @JsonKey(name: 'stakingPools', defaultValue: <StakingSummary>[])
  final List<StakingSummary> stakingPools;
  @JsonKey(name: 'events', defaultValue: <EventProfile>[])
  final List<EventProfile> events;
  @JsonKey(name: 'creatorProfile')
  final CreatorProfileDoc creatorProfile;
  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$OwnedServicesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OwnedServicesDto &&
            (identical(other.mintProfiles, mintProfiles) ||
                const DeepCollectionEquality().equals(
                  other.mintProfiles,
                  mintProfiles,
                )) &&
            (identical(other.stakingPools, stakingPools) ||
                const DeepCollectionEquality().equals(
                  other.stakingPools,
                  stakingPools,
                )) &&
            (identical(other.events, events) ||
                const DeepCollectionEquality().equals(other.events, events)) &&
            (identical(other.creatorProfile, creatorProfile) ||
                const DeepCollectionEquality().equals(
                  other.creatorProfile,
                  creatorProfile,
                )) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mintProfiles) ^
      const DeepCollectionEquality().hash(stakingPools) ^
      const DeepCollectionEquality().hash(events) ^
      const DeepCollectionEquality().hash(creatorProfile) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $OwnedServicesDtoExtension on OwnedServicesDto {
  OwnedServicesDto copyWith({
    List<CollectionMintProfileDocHydrated>? mintProfiles,
    List<StakingSummary>? stakingPools,
    List<EventProfile>? events,
    CreatorProfileDoc? creatorProfile,
    String? address,
  }) {
    return OwnedServicesDto(
      mintProfiles: mintProfiles ?? this.mintProfiles,
      stakingPools: stakingPools ?? this.stakingPools,
      events: events ?? this.events,
      creatorProfile: creatorProfile ?? this.creatorProfile,
      address: address ?? this.address,
    );
  }

  OwnedServicesDto copyWithWrapped({
    Wrapped<List<CollectionMintProfileDocHydrated>>? mintProfiles,
    Wrapped<List<StakingSummary>>? stakingPools,
    Wrapped<List<EventProfile>>? events,
    Wrapped<CreatorProfileDoc>? creatorProfile,
    Wrapped<String>? address,
  }) {
    return OwnedServicesDto(
      mintProfiles: (mintProfiles != null
          ? mintProfiles.value
          : this.mintProfiles),
      stakingPools: (stakingPools != null
          ? stakingPools.value
          : this.stakingPools),
      events: (events != null ? events.value : this.events),
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FilterQueryDto {
  const FilterQueryDto({
    required this.name,
    this.top,
    this.skip,
    this.chain,
    this.orderBy,
    this.select,
  });

  factory FilterQueryDto.fromJson(Map<String, dynamic> json) =>
      _$FilterQueryDtoFromJson(json);

  static const toJsonFactory = _$FilterQueryDtoToJson;
  Map<String, dynamic> toJson() => _$FilterQueryDtoToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(
    name: 'chain',
    toJson: activityChainListToJson,
    fromJson: activityChainListFromJson,
  )
  final List<enums.ActivityChain>? chain;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  static const fromJsonFactory = _$FilterQueryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterQueryDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(select) ^
      runtimeType.hashCode;
}

extension $FilterQueryDtoExtension on FilterQueryDto {
  FilterQueryDto copyWith({
    String? name,
    int? top,
    int? skip,
    List<enums.ActivityChain>? chain,
    List<String>? orderBy,
    List<String>? select,
  }) {
    return FilterQueryDto(
      name: name ?? this.name,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      chain: chain ?? this.chain,
      orderBy: orderBy ?? this.orderBy,
      select: select ?? this.select,
    );
  }

  FilterQueryDto copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<List<enums.ActivityChain>?>? chain,
    Wrapped<List<String>?>? orderBy,
    Wrapped<List<String>?>? select,
  }) {
    return FilterQueryDto(
      name: (name != null ? name.value : this.name),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      chain: (chain != null ? chain.value : this.chain),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      select: (select != null ? select.value : this.select),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionDto {
  const CollectionDto({
    required this.collection,
    required this.name,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.type,
    required this.statistics,
    required this.floorPrice,
    this.chain,
  });

  factory CollectionDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionDtoFromJson(json);

  static const toJsonFactory = _$CollectionDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'statistics')
  final StatisticsDto statistics;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(
    name: 'chain',
    toJson: collectionDtoChainNullableToJson,
    fromJson: collectionDtoChainNullableFromJson,
  )
  final enums.CollectionDtoChain? chain;
  static const fromJsonFactory = _$CollectionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality().equals(
                  other.isVisible,
                  isVisible,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality().equals(
                  other.statistics,
                  statistics,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $CollectionDtoExtension on CollectionDto {
  CollectionDto copyWith({
    String? collection,
    String? name,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    String? type,
    StatisticsDto? statistics,
    double? floorPrice,
    enums.CollectionDtoChain? chain,
  }) {
    return CollectionDto(
      collection: collection ?? this.collection,
      name: name ?? this.name,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      type: type ?? this.type,
      statistics: statistics ?? this.statistics,
      floorPrice: floorPrice ?? this.floorPrice,
      chain: chain ?? this.chain,
    );
  }

  CollectionDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? type,
    Wrapped<StatisticsDto>? statistics,
    Wrapped<double>? floorPrice,
    Wrapped<enums.CollectionDtoChain?>? chain,
  }) {
    return CollectionDto(
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      type: (type != null ? type.value : this.type),
      statistics: (statistics != null ? statistics.value : this.statistics),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserDto {
  const UserDto({
    required this.address,
    required this.herotag,
    required this.isVerified,
    required this.profile,
    this.isCreator,
    required this.addressTrimmed,
    this.chain,
  });

  factory UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  static const toJsonFactory = _$UserDtoToJson;
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'isCreator')
  final bool? isCreator;
  @JsonKey(name: 'addressTrimmed')
  final String addressTrimmed;
  @JsonKey(
    name: 'chain',
    toJson: userDtoChainNullableToJson,
    fromJson: userDtoChainNullableFromJson,
  )
  final enums.UserDtoChain? chain;
  static const fromJsonFactory = _$UserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(
                  other.herotag,
                  herotag,
                )) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality().equals(
                  other.isVerified,
                  isVerified,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.isCreator, isCreator) ||
                const DeepCollectionEquality().equals(
                  other.isCreator,
                  isCreator,
                )) &&
            (identical(other.addressTrimmed, addressTrimmed) ||
                const DeepCollectionEquality().equals(
                  other.addressTrimmed,
                  addressTrimmed,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(herotag) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(isCreator) ^
      const DeepCollectionEquality().hash(addressTrimmed) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $UserDtoExtension on UserDto {
  UserDto copyWith({
    String? address,
    String? herotag,
    bool? isVerified,
    String? profile,
    bool? isCreator,
    String? addressTrimmed,
    enums.UserDtoChain? chain,
  }) {
    return UserDto(
      address: address ?? this.address,
      herotag: herotag ?? this.herotag,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      isCreator: isCreator ?? this.isCreator,
      addressTrimmed: addressTrimmed ?? this.addressTrimmed,
      chain: chain ?? this.chain,
    );
  }

  UserDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? herotag,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<bool?>? isCreator,
    Wrapped<String>? addressTrimmed,
    Wrapped<enums.UserDtoChain?>? chain,
  }) {
    return UserDto(
      address: (address != null ? address.value : this.address),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      addressTrimmed: (addressTrimmed != null
          ? addressTrimmed.value
          : this.addressTrimmed),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorDto {
  const CreatorDto({
    required this.address,
    required this.herotag,
    required this.addressTrimmed,
    required this.isCreator,
    required this.contractAddress,
    required this.name,
    required this.creatorTag,
    required this.joinedDate,
    required this.profile,
    this.chain,
  });

  factory CreatorDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorDtoFromJson(json);

  static const toJsonFactory = _$CreatorDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'addressTrimmed')
  final String addressTrimmed;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(
    name: 'chain',
    toJson: creatorDtoChainNullableToJson,
    fromJson: creatorDtoChainNullableFromJson,
  )
  final enums.CreatorDtoChain? chain;
  static const fromJsonFactory = _$CreatorDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatorDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(
                  other.herotag,
                  herotag,
                )) &&
            (identical(other.addressTrimmed, addressTrimmed) ||
                const DeepCollectionEquality().equals(
                  other.addressTrimmed,
                  addressTrimmed,
                )) &&
            (identical(other.isCreator, isCreator) ||
                const DeepCollectionEquality().equals(
                  other.isCreator,
                  isCreator,
                )) &&
            (identical(other.contractAddress, contractAddress) ||
                const DeepCollectionEquality().equals(
                  other.contractAddress,
                  contractAddress,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.creatorTag, creatorTag) ||
                const DeepCollectionEquality().equals(
                  other.creatorTag,
                  creatorTag,
                )) &&
            (identical(other.joinedDate, joinedDate) ||
                const DeepCollectionEquality().equals(
                  other.joinedDate,
                  joinedDate,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(herotag) ^
      const DeepCollectionEquality().hash(addressTrimmed) ^
      const DeepCollectionEquality().hash(isCreator) ^
      const DeepCollectionEquality().hash(contractAddress) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(creatorTag) ^
      const DeepCollectionEquality().hash(joinedDate) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $CreatorDtoExtension on CreatorDto {
  CreatorDto copyWith({
    String? address,
    String? herotag,
    String? addressTrimmed,
    bool? isCreator,
    String? contractAddress,
    String? name,
    String? creatorTag,
    double? joinedDate,
    String? profile,
    enums.CreatorDtoChain? chain,
  }) {
    return CreatorDto(
      address: address ?? this.address,
      herotag: herotag ?? this.herotag,
      addressTrimmed: addressTrimmed ?? this.addressTrimmed,
      isCreator: isCreator ?? this.isCreator,
      contractAddress: contractAddress ?? this.contractAddress,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      chain: chain ?? this.chain,
    );
  }

  CreatorDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? herotag,
    Wrapped<String>? addressTrimmed,
    Wrapped<bool>? isCreator,
    Wrapped<String>? contractAddress,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<double>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<enums.CreatorDtoChain?>? chain,
  }) {
    return CreatorDto(
      address: (address != null ? address.value : this.address),
      herotag: (herotag != null ? herotag.value : this.herotag),
      addressTrimmed: (addressTrimmed != null
          ? addressTrimmed.value
          : this.addressTrimmed),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDto {
  const NftDto({
    required this.identifier,
    required this.name,
    required this.collection,
    required this.onSale,
    required this.url,
    required this.media,
    required this.wasProcessed,
    required this.metadata,
    this.chain,
  });

  factory NftDto.fromJson(Map<String, dynamic> json) => _$NftDtoFromJson(json);

  static const toJsonFactory = _$NftDtoToJson;
  Map<String, dynamic> toJson() => _$NftDtoToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'media')
  final NftMedia media;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'metadata')
  final MetadataDto metadata;
  @JsonKey(
    name: 'chain',
    toJson: nftDtoChainNullableToJson,
    fromJson: nftDtoChainNullableFromJson,
  )
  final enums.NftDtoChain? chain;
  static const fromJsonFactory = _$NftDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftDto &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.onSale, onSale) ||
                const DeepCollectionEquality().equals(other.onSale, onSale)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(onSale) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $NftDtoExtension on NftDto {
  NftDto copyWith({
    String? identifier,
    String? name,
    String? collection,
    bool? onSale,
    String? url,
    NftMedia? media,
    bool? wasProcessed,
    MetadataDto? metadata,
    enums.NftDtoChain? chain,
  }) {
    return NftDto(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      collection: collection ?? this.collection,
      onSale: onSale ?? this.onSale,
      url: url ?? this.url,
      media: media ?? this.media,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      metadata: metadata ?? this.metadata,
      chain: chain ?? this.chain,
    );
  }

  NftDto copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<String>? collection,
    Wrapped<bool>? onSale,
    Wrapped<String>? url,
    Wrapped<NftMedia>? media,
    Wrapped<bool>? wasProcessed,
    Wrapped<MetadataDto>? metadata,
    Wrapped<enums.NftDtoChain?>? chain,
  }) {
    return NftDto(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      collection: (collection != null ? collection.value : this.collection),
      onSale: (onSale != null ? onSale.value : this.onSale),
      url: (url != null ? url.value : this.url),
      media: (media != null ? media.value : this.media),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      metadata: (metadata != null ? metadata.value : this.metadata),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalSearchResourcesDto {
  const GlobalSearchResourcesDto({
    required this.collections,
    required this.users,
    required this.creators,
    required this.nft,
  });

  factory GlobalSearchResourcesDto.fromJson(Map<String, dynamic> json) =>
      _$GlobalSearchResourcesDtoFromJson(json);

  static const toJsonFactory = _$GlobalSearchResourcesDtoToJson;
  Map<String, dynamic> toJson() => _$GlobalSearchResourcesDtoToJson(this);

  @JsonKey(name: 'collections', defaultValue: <CollectionDto>[])
  final List<CollectionDto> collections;
  @JsonKey(name: 'users', defaultValue: <UserDto>[])
  final List<UserDto> users;
  @JsonKey(name: 'creators', defaultValue: <CreatorDto>[])
  final List<CreatorDto> creators;
  @JsonKey(name: 'nft', defaultValue: <NftDto>[])
  final List<NftDto> nft;
  static const fromJsonFactory = _$GlobalSearchResourcesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalSearchResourcesDto &&
            (identical(other.collections, collections) ||
                const DeepCollectionEquality().equals(
                  other.collections,
                  collections,
                )) &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)) &&
            (identical(other.creators, creators) ||
                const DeepCollectionEquality().equals(
                  other.creators,
                  creators,
                )) &&
            (identical(other.nft, nft) ||
                const DeepCollectionEquality().equals(other.nft, nft)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collections) ^
      const DeepCollectionEquality().hash(users) ^
      const DeepCollectionEquality().hash(creators) ^
      const DeepCollectionEquality().hash(nft) ^
      runtimeType.hashCode;
}

extension $GlobalSearchResourcesDtoExtension on GlobalSearchResourcesDto {
  GlobalSearchResourcesDto copyWith({
    List<CollectionDto>? collections,
    List<UserDto>? users,
    List<CreatorDto>? creators,
    List<NftDto>? nft,
  }) {
    return GlobalSearchResourcesDto(
      collections: collections ?? this.collections,
      users: users ?? this.users,
      creators: creators ?? this.creators,
      nft: nft ?? this.nft,
    );
  }

  GlobalSearchResourcesDto copyWithWrapped({
    Wrapped<List<CollectionDto>>? collections,
    Wrapped<List<UserDto>>? users,
    Wrapped<List<CreatorDto>>? creators,
    Wrapped<List<NftDto>>? nft,
  }) {
    return GlobalSearchResourcesDto(
      collections: (collections != null ? collections.value : this.collections),
      users: (users != null ? users.value : this.users),
      creators: (creators != null ? creators.value : this.creators),
      nft: (nft != null ? nft.value : this.nft),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalSearchResourcesPaginated {
  const GlobalSearchResourcesPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory GlobalSearchResourcesPaginated.fromJson(Map<String, dynamic> json) =>
      _$GlobalSearchResourcesPaginatedFromJson(json);

  static const toJsonFactory = _$GlobalSearchResourcesPaginatedToJson;
  Map<String, dynamic> toJson() => _$GlobalSearchResourcesPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources')
  final GlobalSearchResourcesDto resources;
  static const fromJsonFactory = _$GlobalSearchResourcesPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalSearchResourcesPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $GlobalSearchResourcesPaginatedExtension
    on GlobalSearchResourcesPaginated {
  GlobalSearchResourcesPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    GlobalSearchResourcesDto? resources,
  }) {
    return GlobalSearchResourcesPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  GlobalSearchResourcesPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<GlobalSearchResourcesDto>? resources,
  }) {
    return GlobalSearchResourcesPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationDoc {
  const NotificationDoc({
    required this.dataType,
    required this.txHash,
    required this.source,
    required this.activityType,
    required this.owner,
    this.message,
    required this.asset,
    required this.activity,
    required this.isRead,
    required this.timestamp,
    this.id,
    this.pk,
    this.ts,
  });

  factory NotificationDoc.fromJson(Map<String, dynamic> json) =>
      _$NotificationDocFromJson(json);

  static const toJsonFactory = _$NotificationDocToJson;
  Map<String, dynamic> toJson() => _$NotificationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: notificationDocDataTypeToJson,
    fromJson: notificationDocDataTypeDataTypeFromJson,
  )
  final enums.NotificationDocDataType dataType;
  static enums.NotificationDocDataType notificationDocDataTypeDataTypeFromJson(
    Object? value,
  ) => notificationDocDataTypeFromJson(
    value,
    enums.NotificationDocDataType.notification,
  );

  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'source')
  final String source;
  @JsonKey(
    name: 'activityType',
    toJson: notificationDocActivityTypeToJson,
    fromJson: notificationDocActivityTypeFromJson,
  )
  final enums.NotificationDocActivityType activityType;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'message')
  final String? message;
  @JsonKey(name: 'asset')
  final Object asset;
  @JsonKey(name: 'activity')
  final Object activity;
  @JsonKey(name: 'isRead', defaultValue: false)
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$NotificationDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.activityType, activityType) ||
                const DeepCollectionEquality().equals(
                  other.activityType,
                  activityType,
                )) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.activity, activity) ||
                const DeepCollectionEquality().equals(
                  other.activity,
                  activity,
                )) &&
            (identical(other.isRead, isRead) ||
                const DeepCollectionEquality().equals(other.isRead, isRead)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(activityType) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(activity) ^
      const DeepCollectionEquality().hash(isRead) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $NotificationDocExtension on NotificationDoc {
  NotificationDoc copyWith({
    enums.NotificationDocDataType? dataType,
    String? txHash,
    String? source,
    enums.NotificationDocActivityType? activityType,
    String? owner,
    String? message,
    Object? asset,
    Object? activity,
    bool? isRead,
    double? timestamp,
    String? id,
    String? pk,
    double? ts,
  }) {
    return NotificationDoc(
      dataType: dataType ?? this.dataType,
      txHash: txHash ?? this.txHash,
      source: source ?? this.source,
      activityType: activityType ?? this.activityType,
      owner: owner ?? this.owner,
      message: message ?? this.message,
      asset: asset ?? this.asset,
      activity: activity ?? this.activity,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  NotificationDoc copyWithWrapped({
    Wrapped<enums.NotificationDocDataType>? dataType,
    Wrapped<String>? txHash,
    Wrapped<String>? source,
    Wrapped<enums.NotificationDocActivityType>? activityType,
    Wrapped<String>? owner,
    Wrapped<String?>? message,
    Wrapped<Object>? asset,
    Wrapped<Object>? activity,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return NotificationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      txHash: (txHash != null ? txHash.value : this.txHash),
      source: (source != null ? source.value : this.source),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      owner: (owner != null ? owner.value : this.owner),
      message: (message != null ? message.value : this.message),
      asset: (asset != null ? asset.value : this.asset),
      activity: (activity != null ? activity.value : this.activity),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationPaginated {
  const NotificationPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NotificationPaginated.fromJson(Map<String, dynamic> json) =>
      _$NotificationPaginatedFromJson(json);

  static const toJsonFactory = _$NotificationPaginatedToJson;
  Map<String, dynamic> toJson() => _$NotificationPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NotificationDoc>[])
  final List<NotificationDoc> resources;
  static const fromJsonFactory = _$NotificationPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $NotificationPaginatedExtension on NotificationPaginated {
  NotificationPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NotificationDoc>? resources,
  }) {
    return NotificationPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NotificationPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NotificationDoc>>? resources,
  }) {
    return NotificationPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationCountResponse {
  const PushNotificationCountResponse({required this.count});

  factory PushNotificationCountResponse.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationCountResponseFromJson(json);

  static const toJsonFactory = _$PushNotificationCountResponseToJson;
  Map<String, dynamic> toJson() => _$PushNotificationCountResponseToJson(this);

  @JsonKey(name: 'count')
  final double count;
  static const fromJsonFactory = _$PushNotificationCountResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PushNotificationCountResponse &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^ runtimeType.hashCode;
}

extension $PushNotificationCountResponseExtension
    on PushNotificationCountResponse {
  PushNotificationCountResponse copyWith({double? count}) {
    return PushNotificationCountResponse(count: count ?? this.count);
  }

  PushNotificationCountResponse copyWithWrapped({Wrapped<double>? count}) {
    return PushNotificationCountResponse(
      count: (count != null ? count.value : this.count),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MobileDeviceRegistrationDto {
  const MobileDeviceRegistrationDto({
    required this.deviceUUID,
    required this.platform,
    required this.pushChannel,
    required this.appVersion,
    this.deviceModel,
    this.osVersion,
  });

  factory MobileDeviceRegistrationDto.fromJson(Map<String, dynamic> json) =>
      _$MobileDeviceRegistrationDtoFromJson(json);

  static const toJsonFactory = _$MobileDeviceRegistrationDtoToJson;
  Map<String, dynamic> toJson() => _$MobileDeviceRegistrationDtoToJson(this);

  @JsonKey(name: 'deviceUUID')
  final String deviceUUID;
  @JsonKey(
    name: 'platform',
    toJson: devicePlatformToJson,
    fromJson: devicePlatformFromJson,
  )
  final enums.DevicePlatform platform;
  @JsonKey(name: 'pushChannel')
  final String pushChannel;
  @JsonKey(name: 'appVersion')
  final String appVersion;
  @JsonKey(name: 'deviceModel')
  final String? deviceModel;
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  static const fromJsonFactory = _$MobileDeviceRegistrationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MobileDeviceRegistrationDto &&
            (identical(other.deviceUUID, deviceUUID) ||
                const DeepCollectionEquality().equals(
                  other.deviceUUID,
                  deviceUUID,
                )) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality().equals(
                  other.platform,
                  platform,
                )) &&
            (identical(other.pushChannel, pushChannel) ||
                const DeepCollectionEquality().equals(
                  other.pushChannel,
                  pushChannel,
                )) &&
            (identical(other.appVersion, appVersion) ||
                const DeepCollectionEquality().equals(
                  other.appVersion,
                  appVersion,
                )) &&
            (identical(other.deviceModel, deviceModel) ||
                const DeepCollectionEquality().equals(
                  other.deviceModel,
                  deviceModel,
                )) &&
            (identical(other.osVersion, osVersion) ||
                const DeepCollectionEquality().equals(
                  other.osVersion,
                  osVersion,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceUUID) ^
      const DeepCollectionEquality().hash(platform) ^
      const DeepCollectionEquality().hash(pushChannel) ^
      const DeepCollectionEquality().hash(appVersion) ^
      const DeepCollectionEquality().hash(deviceModel) ^
      const DeepCollectionEquality().hash(osVersion) ^
      runtimeType.hashCode;
}

extension $MobileDeviceRegistrationDtoExtension on MobileDeviceRegistrationDto {
  MobileDeviceRegistrationDto copyWith({
    String? deviceUUID,
    enums.DevicePlatform? platform,
    String? pushChannel,
    String? appVersion,
    String? deviceModel,
    String? osVersion,
  }) {
    return MobileDeviceRegistrationDto(
      deviceUUID: deviceUUID ?? this.deviceUUID,
      platform: platform ?? this.platform,
      pushChannel: pushChannel ?? this.pushChannel,
      appVersion: appVersion ?? this.appVersion,
      deviceModel: deviceModel ?? this.deviceModel,
      osVersion: osVersion ?? this.osVersion,
    );
  }

  MobileDeviceRegistrationDto copyWithWrapped({
    Wrapped<String>? deviceUUID,
    Wrapped<enums.DevicePlatform>? platform,
    Wrapped<String>? pushChannel,
    Wrapped<String>? appVersion,
    Wrapped<String?>? deviceModel,
    Wrapped<String?>? osVersion,
  }) {
    return MobileDeviceRegistrationDto(
      deviceUUID: (deviceUUID != null ? deviceUUID.value : this.deviceUUID),
      platform: (platform != null ? platform.value : this.platform),
      pushChannel: (pushChannel != null ? pushChannel.value : this.pushChannel),
      appVersion: (appVersion != null ? appVersion.value : this.appVersion),
      deviceModel: (deviceModel != null ? deviceModel.value : this.deviceModel),
      osVersion: (osVersion != null ? osVersion.value : this.osVersion),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MobileDeviceDoc {
  const MobileDeviceDoc({
    required this.dataType,
    required this.deviceUUID,
    required this.installationId,
    required this.platform,
    required this.pushChannel,
    required this.web2UserId,
    required this.linkedAddresses,
    required this.appVersion,
    this.deviceModel,
    this.osVersion,
    required this.registeredAt,
    required this.lastActiveAt,
    required this.isActive,
    this.id,
    this.pk,
    this.ts,
  });

  factory MobileDeviceDoc.fromJson(Map<String, dynamic> json) =>
      _$MobileDeviceDocFromJson(json);

  static const toJsonFactory = _$MobileDeviceDocToJson;
  Map<String, dynamic> toJson() => _$MobileDeviceDocToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'deviceUUID')
  final String deviceUUID;
  @JsonKey(name: 'installationId')
  final String installationId;
  @JsonKey(
    name: 'platform',
    toJson: devicePlatformToJson,
    fromJson: devicePlatformFromJson,
  )
  final enums.DevicePlatform platform;
  @JsonKey(name: 'pushChannel')
  final String pushChannel;
  @JsonKey(name: 'web2UserId')
  final String web2UserId;
  @JsonKey(name: 'linkedAddresses', defaultValue: <String>[])
  final List<String> linkedAddresses;
  @JsonKey(name: 'appVersion')
  final String appVersion;
  @JsonKey(name: 'deviceModel')
  final String? deviceModel;
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  @JsonKey(name: 'registeredAt')
  final double registeredAt;
  @JsonKey(name: 'lastActiveAt')
  final double lastActiveAt;
  @JsonKey(name: 'isActive')
  final Object isActive;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$MobileDeviceDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MobileDeviceDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.deviceUUID, deviceUUID) ||
                const DeepCollectionEquality().equals(
                  other.deviceUUID,
                  deviceUUID,
                )) &&
            (identical(other.installationId, installationId) ||
                const DeepCollectionEquality().equals(
                  other.installationId,
                  installationId,
                )) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality().equals(
                  other.platform,
                  platform,
                )) &&
            (identical(other.pushChannel, pushChannel) ||
                const DeepCollectionEquality().equals(
                  other.pushChannel,
                  pushChannel,
                )) &&
            (identical(other.web2UserId, web2UserId) ||
                const DeepCollectionEquality().equals(
                  other.web2UserId,
                  web2UserId,
                )) &&
            (identical(other.linkedAddresses, linkedAddresses) ||
                const DeepCollectionEquality().equals(
                  other.linkedAddresses,
                  linkedAddresses,
                )) &&
            (identical(other.appVersion, appVersion) ||
                const DeepCollectionEquality().equals(
                  other.appVersion,
                  appVersion,
                )) &&
            (identical(other.deviceModel, deviceModel) ||
                const DeepCollectionEquality().equals(
                  other.deviceModel,
                  deviceModel,
                )) &&
            (identical(other.osVersion, osVersion) ||
                const DeepCollectionEquality().equals(
                  other.osVersion,
                  osVersion,
                )) &&
            (identical(other.registeredAt, registeredAt) ||
                const DeepCollectionEquality().equals(
                  other.registeredAt,
                  registeredAt,
                )) &&
            (identical(other.lastActiveAt, lastActiveAt) ||
                const DeepCollectionEquality().equals(
                  other.lastActiveAt,
                  lastActiveAt,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(deviceUUID) ^
      const DeepCollectionEquality().hash(installationId) ^
      const DeepCollectionEquality().hash(platform) ^
      const DeepCollectionEquality().hash(pushChannel) ^
      const DeepCollectionEquality().hash(web2UserId) ^
      const DeepCollectionEquality().hash(linkedAddresses) ^
      const DeepCollectionEquality().hash(appVersion) ^
      const DeepCollectionEquality().hash(deviceModel) ^
      const DeepCollectionEquality().hash(osVersion) ^
      const DeepCollectionEquality().hash(registeredAt) ^
      const DeepCollectionEquality().hash(lastActiveAt) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $MobileDeviceDocExtension on MobileDeviceDoc {
  MobileDeviceDoc copyWith({
    Object? dataType,
    String? deviceUUID,
    String? installationId,
    enums.DevicePlatform? platform,
    String? pushChannel,
    String? web2UserId,
    List<String>? linkedAddresses,
    String? appVersion,
    String? deviceModel,
    String? osVersion,
    double? registeredAt,
    double? lastActiveAt,
    Object? isActive,
    String? id,
    String? pk,
    double? ts,
  }) {
    return MobileDeviceDoc(
      dataType: dataType ?? this.dataType,
      deviceUUID: deviceUUID ?? this.deviceUUID,
      installationId: installationId ?? this.installationId,
      platform: platform ?? this.platform,
      pushChannel: pushChannel ?? this.pushChannel,
      web2UserId: web2UserId ?? this.web2UserId,
      linkedAddresses: linkedAddresses ?? this.linkedAddresses,
      appVersion: appVersion ?? this.appVersion,
      deviceModel: deviceModel ?? this.deviceModel,
      osVersion: osVersion ?? this.osVersion,
      registeredAt: registeredAt ?? this.registeredAt,
      lastActiveAt: lastActiveAt ?? this.lastActiveAt,
      isActive: isActive ?? this.isActive,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  MobileDeviceDoc copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? deviceUUID,
    Wrapped<String>? installationId,
    Wrapped<enums.DevicePlatform>? platform,
    Wrapped<String>? pushChannel,
    Wrapped<String>? web2UserId,
    Wrapped<List<String>>? linkedAddresses,
    Wrapped<String>? appVersion,
    Wrapped<String?>? deviceModel,
    Wrapped<String?>? osVersion,
    Wrapped<double>? registeredAt,
    Wrapped<double>? lastActiveAt,
    Wrapped<Object>? isActive,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return MobileDeviceDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      deviceUUID: (deviceUUID != null ? deviceUUID.value : this.deviceUUID),
      installationId: (installationId != null
          ? installationId.value
          : this.installationId),
      platform: (platform != null ? platform.value : this.platform),
      pushChannel: (pushChannel != null ? pushChannel.value : this.pushChannel),
      web2UserId: (web2UserId != null ? web2UserId.value : this.web2UserId),
      linkedAddresses: (linkedAddresses != null
          ? linkedAddresses.value
          : this.linkedAddresses),
      appVersion: (appVersion != null ? appVersion.value : this.appVersion),
      deviceModel: (deviceModel != null ? deviceModel.value : this.deviceModel),
      osVersion: (osVersion != null ? osVersion.value : this.osVersion),
      registeredAt: (registeredAt != null
          ? registeredAt.value
          : this.registeredAt),
      lastActiveAt: (lastActiveAt != null
          ? lastActiveAt.value
          : this.lastActiveAt),
      isActive: (isActive != null ? isActive.value : this.isActive),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationEventDto {
  const PushNotificationEventDto({
    this.eventId,
    this.eventTitle,
    this.eventProfile,
    this.creatorAddress,
    this.creatorName,
  });

  factory PushNotificationEventDto.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationEventDtoFromJson(json);

  static const toJsonFactory = _$PushNotificationEventDtoToJson;
  Map<String, dynamic> toJson() => _$PushNotificationEventDtoToJson(this);

  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'eventTitle')
  final String? eventTitle;
  @JsonKey(name: 'eventProfile')
  final String? eventProfile;
  @JsonKey(name: 'creatorAddress')
  final String? creatorAddress;
  @JsonKey(name: 'creatorName')
  final String? creatorName;
  static const fromJsonFactory = _$PushNotificationEventDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PushNotificationEventDto &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.eventTitle, eventTitle) ||
                const DeepCollectionEquality().equals(
                  other.eventTitle,
                  eventTitle,
                )) &&
            (identical(other.eventProfile, eventProfile) ||
                const DeepCollectionEquality().equals(
                  other.eventProfile,
                  eventProfile,
                )) &&
            (identical(other.creatorAddress, creatorAddress) ||
                const DeepCollectionEquality().equals(
                  other.creatorAddress,
                  creatorAddress,
                )) &&
            (identical(other.creatorName, creatorName) ||
                const DeepCollectionEquality().equals(
                  other.creatorName,
                  creatorName,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(eventTitle) ^
      const DeepCollectionEquality().hash(eventProfile) ^
      const DeepCollectionEquality().hash(creatorAddress) ^
      const DeepCollectionEquality().hash(creatorName) ^
      runtimeType.hashCode;
}

extension $PushNotificationEventDtoExtension on PushNotificationEventDto {
  PushNotificationEventDto copyWith({
    String? eventId,
    String? eventTitle,
    String? eventProfile,
    String? creatorAddress,
    String? creatorName,
  }) {
    return PushNotificationEventDto(
      eventId: eventId ?? this.eventId,
      eventTitle: eventTitle ?? this.eventTitle,
      eventProfile: eventProfile ?? this.eventProfile,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      creatorName: creatorName ?? this.creatorName,
    );
  }

  PushNotificationEventDto copyWithWrapped({
    Wrapped<String?>? eventId,
    Wrapped<String?>? eventTitle,
    Wrapped<String?>? eventProfile,
    Wrapped<String?>? creatorAddress,
    Wrapped<String?>? creatorName,
  }) {
    return PushNotificationEventDto(
      eventId: (eventId != null ? eventId.value : this.eventId),
      eventTitle: (eventTitle != null ? eventTitle.value : this.eventTitle),
      eventProfile: (eventProfile != null
          ? eventProfile.value
          : this.eventProfile),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationTargetingDto {
  const PushNotificationTargetingDto({
    required this.type,
    this.tagExpression,
    this.targetUsers,
    this.targetAddresses,
    this.recipientCount,
  });

  factory PushNotificationTargetingDto.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationTargetingDtoFromJson(json);

  static const toJsonFactory = _$PushNotificationTargetingDtoToJson;
  Map<String, dynamic> toJson() => _$PushNotificationTargetingDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: pushNotificationTypeToJson,
    fromJson: pushNotificationTypeFromJson,
  )
  final enums.PushNotificationType type;
  @JsonKey(name: 'tagExpression')
  final String? tagExpression;
  @JsonKey(name: 'targetUsers', defaultValue: <String>[])
  final List<String>? targetUsers;
  @JsonKey(name: 'targetAddresses', defaultValue: <String>[])
  final List<String>? targetAddresses;
  @JsonKey(name: 'recipientCount')
  final double? recipientCount;
  static const fromJsonFactory = _$PushNotificationTargetingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PushNotificationTargetingDto &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.tagExpression, tagExpression) ||
                const DeepCollectionEquality().equals(
                  other.tagExpression,
                  tagExpression,
                )) &&
            (identical(other.targetUsers, targetUsers) ||
                const DeepCollectionEquality().equals(
                  other.targetUsers,
                  targetUsers,
                )) &&
            (identical(other.targetAddresses, targetAddresses) ||
                const DeepCollectionEquality().equals(
                  other.targetAddresses,
                  targetAddresses,
                )) &&
            (identical(other.recipientCount, recipientCount) ||
                const DeepCollectionEquality().equals(
                  other.recipientCount,
                  recipientCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(tagExpression) ^
      const DeepCollectionEquality().hash(targetUsers) ^
      const DeepCollectionEquality().hash(targetAddresses) ^
      const DeepCollectionEquality().hash(recipientCount) ^
      runtimeType.hashCode;
}

extension $PushNotificationTargetingDtoExtension
    on PushNotificationTargetingDto {
  PushNotificationTargetingDto copyWith({
    enums.PushNotificationType? type,
    String? tagExpression,
    List<String>? targetUsers,
    List<String>? targetAddresses,
    double? recipientCount,
  }) {
    return PushNotificationTargetingDto(
      type: type ?? this.type,
      tagExpression: tagExpression ?? this.tagExpression,
      targetUsers: targetUsers ?? this.targetUsers,
      targetAddresses: targetAddresses ?? this.targetAddresses,
      recipientCount: recipientCount ?? this.recipientCount,
    );
  }

  PushNotificationTargetingDto copyWithWrapped({
    Wrapped<enums.PushNotificationType>? type,
    Wrapped<String?>? tagExpression,
    Wrapped<List<String>?>? targetUsers,
    Wrapped<List<String>?>? targetAddresses,
    Wrapped<double?>? recipientCount,
  }) {
    return PushNotificationTargetingDto(
      type: (type != null ? type.value : this.type),
      tagExpression: (tagExpression != null
          ? tagExpression.value
          : this.tagExpression),
      targetUsers: (targetUsers != null ? targetUsers.value : this.targetUsers),
      targetAddresses: (targetAddresses != null
          ? targetAddresses.value
          : this.targetAddresses),
      recipientCount: (recipientCount != null
          ? recipientCount.value
          : this.recipientCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationDoc {
  const PushNotificationDoc({
    required this.dataType,
    required this.title,
    required this.message,
    this.imageUrl,
    required this.notificationType,
    required this.status,
    required this.owner,
    required this.senderAddress,
    this.senderName,
    this.event,
    required this.targeting,
    required this.isRead,
    required this.timestamp,
    this.deliveredAt,
    this.clickedAt,
    this.sound,
    this.badge,
    this.appMetadata,
    this.id,
    this.pk,
    this.ts,
  });

  factory PushNotificationDoc.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationDocFromJson(json);

  static const toJsonFactory = _$PushNotificationDocToJson;
  Map<String, dynamic> toJson() => _$PushNotificationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: notificationDataTypeToJson,
    fromJson: notificationDataTypeFromJson,
  )
  final enums.NotificationDataType dataType;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(
    name: 'notificationType',
    toJson: pushNotificationTypeToJson,
    fromJson: pushNotificationTypeFromJson,
  )
  final enums.PushNotificationType notificationType;
  @JsonKey(
    name: 'status',
    toJson: pushNotificationStatusToJson,
    fromJson: pushNotificationStatusFromJson,
  )
  final enums.PushNotificationStatus status;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'senderAddress')
  final String senderAddress;
  @JsonKey(name: 'senderName')
  final String? senderName;
  @JsonKey(name: 'event')
  final PushNotificationEventDto? event;
  @JsonKey(name: 'targeting')
  final PushNotificationTargetingDto targeting;
  @JsonKey(name: 'isRead', defaultValue: false)
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'deliveredAt')
  final double? deliveredAt;
  @JsonKey(name: 'clickedAt')
  final double? clickedAt;
  @JsonKey(name: 'sound')
  final String? sound;
  @JsonKey(name: 'badge')
  final double? badge;
  @JsonKey(name: 'appMetadata')
  final Object? appMetadata;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$PushNotificationDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PushNotificationDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality().equals(
                  other.imageUrl,
                  imageUrl,
                )) &&
            (identical(other.notificationType, notificationType) ||
                const DeepCollectionEquality().equals(
                  other.notificationType,
                  notificationType,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.senderAddress, senderAddress) ||
                const DeepCollectionEquality().equals(
                  other.senderAddress,
                  senderAddress,
                )) &&
            (identical(other.senderName, senderName) ||
                const DeepCollectionEquality().equals(
                  other.senderName,
                  senderName,
                )) &&
            (identical(other.event, event) ||
                const DeepCollectionEquality().equals(other.event, event)) &&
            (identical(other.targeting, targeting) ||
                const DeepCollectionEquality().equals(
                  other.targeting,
                  targeting,
                )) &&
            (identical(other.isRead, isRead) ||
                const DeepCollectionEquality().equals(other.isRead, isRead)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.deliveredAt, deliveredAt) ||
                const DeepCollectionEquality().equals(
                  other.deliveredAt,
                  deliveredAt,
                )) &&
            (identical(other.clickedAt, clickedAt) ||
                const DeepCollectionEquality().equals(
                  other.clickedAt,
                  clickedAt,
                )) &&
            (identical(other.sound, sound) ||
                const DeepCollectionEquality().equals(other.sound, sound)) &&
            (identical(other.badge, badge) ||
                const DeepCollectionEquality().equals(other.badge, badge)) &&
            (identical(other.appMetadata, appMetadata) ||
                const DeepCollectionEquality().equals(
                  other.appMetadata,
                  appMetadata,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(notificationType) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(senderAddress) ^
      const DeepCollectionEquality().hash(senderName) ^
      const DeepCollectionEquality().hash(event) ^
      const DeepCollectionEquality().hash(targeting) ^
      const DeepCollectionEquality().hash(isRead) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(deliveredAt) ^
      const DeepCollectionEquality().hash(clickedAt) ^
      const DeepCollectionEquality().hash(sound) ^
      const DeepCollectionEquality().hash(badge) ^
      const DeepCollectionEquality().hash(appMetadata) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $PushNotificationDocExtension on PushNotificationDoc {
  PushNotificationDoc copyWith({
    enums.NotificationDataType? dataType,
    String? title,
    String? message,
    String? imageUrl,
    enums.PushNotificationType? notificationType,
    enums.PushNotificationStatus? status,
    String? owner,
    String? senderAddress,
    String? senderName,
    PushNotificationEventDto? event,
    PushNotificationTargetingDto? targeting,
    bool? isRead,
    double? timestamp,
    double? deliveredAt,
    double? clickedAt,
    String? sound,
    double? badge,
    Object? appMetadata,
    String? id,
    String? pk,
    double? ts,
  }) {
    return PushNotificationDoc(
      dataType: dataType ?? this.dataType,
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      notificationType: notificationType ?? this.notificationType,
      status: status ?? this.status,
      owner: owner ?? this.owner,
      senderAddress: senderAddress ?? this.senderAddress,
      senderName: senderName ?? this.senderName,
      event: event ?? this.event,
      targeting: targeting ?? this.targeting,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      deliveredAt: deliveredAt ?? this.deliveredAt,
      clickedAt: clickedAt ?? this.clickedAt,
      sound: sound ?? this.sound,
      badge: badge ?? this.badge,
      appMetadata: appMetadata ?? this.appMetadata,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  PushNotificationDoc copyWithWrapped({
    Wrapped<enums.NotificationDataType>? dataType,
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<enums.PushNotificationType>? notificationType,
    Wrapped<enums.PushNotificationStatus>? status,
    Wrapped<String>? owner,
    Wrapped<String>? senderAddress,
    Wrapped<String?>? senderName,
    Wrapped<PushNotificationEventDto?>? event,
    Wrapped<PushNotificationTargetingDto>? targeting,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<double?>? deliveredAt,
    Wrapped<double?>? clickedAt,
    Wrapped<String?>? sound,
    Wrapped<double?>? badge,
    Wrapped<Object?>? appMetadata,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return PushNotificationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      notificationType: (notificationType != null
          ? notificationType.value
          : this.notificationType),
      status: (status != null ? status.value : this.status),
      owner: (owner != null ? owner.value : this.owner),
      senderAddress: (senderAddress != null
          ? senderAddress.value
          : this.senderAddress),
      senderName: (senderName != null ? senderName.value : this.senderName),
      event: (event != null ? event.value : this.event),
      targeting: (targeting != null ? targeting.value : this.targeting),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      deliveredAt: (deliveredAt != null ? deliveredAt.value : this.deliveredAt),
      clickedAt: (clickedAt != null ? clickedAt.value : this.clickedAt),
      sound: (sound != null ? sound.value : this.sound),
      badge: (badge != null ? badge.value : this.badge),
      appMetadata: (appMetadata != null ? appMetadata.value : this.appMetadata),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationResponse {
  const PushNotificationResponse({
    required this.resources,
    required this.hasMoreResults,
  });

  factory PushNotificationResponse.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationResponseFromJson(json);

  static const toJsonFactory = _$PushNotificationResponseToJson;
  Map<String, dynamic> toJson() => _$PushNotificationResponseToJson(this);

  @JsonKey(name: 'resources', defaultValue: <PushNotificationDoc>[])
  final List<PushNotificationDoc> resources;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  static const fromJsonFactory = _$PushNotificationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PushNotificationResponse &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resources) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      runtimeType.hashCode;
}

extension $PushNotificationResponseExtension on PushNotificationResponse {
  PushNotificationResponse copyWith({
    List<PushNotificationDoc>? resources,
    bool? hasMoreResults,
  }) {
    return PushNotificationResponse(
      resources: resources ?? this.resources,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
    );
  }

  PushNotificationResponse copyWithWrapped({
    Wrapped<List<PushNotificationDoc>>? resources,
    Wrapped<bool>? hasMoreResults,
  }) {
    return PushNotificationResponse(
      resources: (resources != null ? resources.value : this.resources),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationSuccessResponseDto {
  const NotificationSuccessResponseDto({
    required this.success,
    required this.message,
  });

  factory NotificationSuccessResponseDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationSuccessResponseDtoFromJson(json);

  static const toJsonFactory = _$NotificationSuccessResponseDtoToJson;
  Map<String, dynamic> toJson() => _$NotificationSuccessResponseDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  static const fromJsonFactory = _$NotificationSuccessResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationSuccessResponseDto &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(message) ^
      runtimeType.hashCode;
}

extension $NotificationSuccessResponseDtoExtension
    on NotificationSuccessResponseDto {
  NotificationSuccessResponseDto copyWith({bool? success, String? message}) {
    return NotificationSuccessResponseDto(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }

  NotificationSuccessResponseDto copyWithWrapped({
    Wrapped<bool>? success,
    Wrapped<String>? message,
  }) {
    return NotificationSuccessResponseDto(
      success: (success != null ? success.value : this.success),
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventNotificationDto {
  const EventNotificationDto({
    required this.title,
    required this.message,
    this.imageUrl,
    this.eventId,
    this.targetUsers,
    this.targetAddresses,
    this.metadata,
  });

  factory EventNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$EventNotificationDtoFromJson(json);

  static const toJsonFactory = _$EventNotificationDtoToJson;
  Map<String, dynamic> toJson() => _$EventNotificationDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'targetUsers', defaultValue: <String>[])
  final List<String>? targetUsers;
  @JsonKey(name: 'targetAddresses', defaultValue: <String>[])
  final List<String>? targetAddresses;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  static const fromJsonFactory = _$EventNotificationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventNotificationDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality().equals(
                  other.imageUrl,
                  imageUrl,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.targetUsers, targetUsers) ||
                const DeepCollectionEquality().equals(
                  other.targetUsers,
                  targetUsers,
                )) &&
            (identical(other.targetAddresses, targetAddresses) ||
                const DeepCollectionEquality().equals(
                  other.targetAddresses,
                  targetAddresses,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(targetUsers) ^
      const DeepCollectionEquality().hash(targetAddresses) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $EventNotificationDtoExtension on EventNotificationDto {
  EventNotificationDto copyWith({
    String? title,
    String? message,
    String? imageUrl,
    String? eventId,
    List<String>? targetUsers,
    List<String>? targetAddresses,
    Object? metadata,
  }) {
    return EventNotificationDto(
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      eventId: eventId ?? this.eventId,
      targetUsers: targetUsers ?? this.targetUsers,
      targetAddresses: targetAddresses ?? this.targetAddresses,
      metadata: metadata ?? this.metadata,
    );
  }

  EventNotificationDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<String?>? eventId,
    Wrapped<List<String>?>? targetUsers,
    Wrapped<List<String>?>? targetAddresses,
    Wrapped<Object?>? metadata,
  }) {
    return EventNotificationDto(
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      eventId: (eventId != null ? eventId.value : this.eventId),
      targetUsers: (targetUsers != null ? targetUsers.value : this.targetUsers),
      targetAddresses: (targetAddresses != null
          ? targetAddresses.value
          : this.targetAddresses),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorMarketingNotificationDto {
  const CreatorMarketingNotificationDto({
    required this.title,
    required this.message,
    this.imageUrl,
    required this.creatorAddress,
    this.metadata,
  });

  factory CreatorMarketingNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorMarketingNotificationDtoFromJson(json);

  static const toJsonFactory = _$CreatorMarketingNotificationDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CreatorMarketingNotificationDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(name: 'creatorAddress')
  final String creatorAddress;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  static const fromJsonFactory = _$CreatorMarketingNotificationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatorMarketingNotificationDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality().equals(
                  other.imageUrl,
                  imageUrl,
                )) &&
            (identical(other.creatorAddress, creatorAddress) ||
                const DeepCollectionEquality().equals(
                  other.creatorAddress,
                  creatorAddress,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(creatorAddress) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $CreatorMarketingNotificationDtoExtension
    on CreatorMarketingNotificationDto {
  CreatorMarketingNotificationDto copyWith({
    String? title,
    String? message,
    String? imageUrl,
    String? creatorAddress,
    Object? metadata,
  }) {
    return CreatorMarketingNotificationDto(
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      metadata: metadata ?? this.metadata,
    );
  }

  CreatorMarketingNotificationDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<String>? creatorAddress,
    Wrapped<Object?>? metadata,
  }) {
    return CreatorMarketingNotificationDto(
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityDataDto {
  const ActivityDataDto({this.collection, this.identifier});

  factory ActivityDataDto.fromJson(Map<String, dynamic> json) =>
      _$ActivityDataDtoFromJson(json);

  static const toJsonFactory = _$ActivityDataDtoToJson;
  Map<String, dynamic> toJson() => _$ActivityDataDtoToJson(this);

  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  static const fromJsonFactory = _$ActivityDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityDataDto &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $ActivityDataDtoExtension on ActivityDataDto {
  ActivityDataDto copyWith({
    List<String>? collection,
    List<String>? identifier,
  }) {
    return ActivityDataDto(
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
    );
  }

  ActivityDataDto copyWithWrapped({
    Wrapped<List<String>?>? collection,
    Wrapped<List<String>?>? identifier,
  }) {
    return ActivityDataDto(
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityFilterCriteriaDto {
  const NftActivityFilterCriteriaDto({
    this.txHash,
    this.activityAddress,
    this.from,
    this.to,
    this.activityType,
    this.source,
    this.range,
    this.activityData,
  });

  factory NftActivityFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$NftActivityFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$NftActivityFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$NftActivityFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'txHash', defaultValue: <String>[])
  final List<String>? txHash;
  @JsonKey(name: 'activityAddress', defaultValue: <String>[])
  final List<String>? activityAddress;
  @JsonKey(name: 'from', defaultValue: <String>[])
  final List<String>? from;
  @JsonKey(name: 'to', defaultValue: <String>[])
  final List<String>? to;
  @JsonKey(
    name: 'activityType',
    toJson: nftActivityTypeListToJson,
    fromJson: nftActivityTypeListFromJson,
  )
  final List<enums.NftActivityType>? activityType;
  @JsonKey(
    name: 'source',
    toJson: nftActivityEventSourceListToJson,
    fromJson: nftActivityEventSourceListFromJson,
  )
  final List<enums.NftActivityEventSource>? source;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'activityData')
  final ActivityDataDto? activityData;
  static const fromJsonFactory = _$NftActivityFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityFilterCriteriaDto &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.activityAddress, activityAddress) ||
                const DeepCollectionEquality().equals(
                  other.activityAddress,
                  activityAddress,
                )) &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)) &&
            (identical(other.activityType, activityType) ||
                const DeepCollectionEquality().equals(
                  other.activityType,
                  activityType,
                )) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.activityData, activityData) ||
                const DeepCollectionEquality().equals(
                  other.activityData,
                  activityData,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(activityAddress) ^
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to) ^
      const DeepCollectionEquality().hash(activityType) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(activityData) ^
      runtimeType.hashCode;
}

extension $NftActivityFilterCriteriaDtoExtension
    on NftActivityFilterCriteriaDto {
  NftActivityFilterCriteriaDto copyWith({
    List<String>? txHash,
    List<String>? activityAddress,
    List<String>? from,
    List<String>? to,
    List<enums.NftActivityType>? activityType,
    List<enums.NftActivityEventSource>? source,
    List<RangeFilter>? range,
    ActivityDataDto? activityData,
  }) {
    return NftActivityFilterCriteriaDto(
      txHash: txHash ?? this.txHash,
      activityAddress: activityAddress ?? this.activityAddress,
      from: from ?? this.from,
      to: to ?? this.to,
      activityType: activityType ?? this.activityType,
      source: source ?? this.source,
      range: range ?? this.range,
      activityData: activityData ?? this.activityData,
    );
  }

  NftActivityFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? txHash,
    Wrapped<List<String>?>? activityAddress,
    Wrapped<List<String>?>? from,
    Wrapped<List<String>?>? to,
    Wrapped<List<enums.NftActivityType>?>? activityType,
    Wrapped<List<enums.NftActivityEventSource>?>? source,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<ActivityDataDto?>? activityData,
  }) {
    return NftActivityFilterCriteriaDto(
      txHash: (txHash != null ? txHash.value : this.txHash),
      activityAddress: (activityAddress != null
          ? activityAddress.value
          : this.activityAddress),
      from: (from != null ? from.value : this.from),
      to: (to != null ? to.value : this.to),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      source: (source != null ? source.value : this.source),
      range: (range != null ? range.value : this.range),
      activityData: (activityData != null
          ? activityData.value
          : this.activityData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityFilter {
  const NftActivityFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory NftActivityFilter.fromJson(Map<String, dynamic> json) =>
      _$NftActivityFilterFromJson(json);

  static const toJsonFactory = _$NftActivityFilterToJson;
  Map<String, dynamic> toJson() => _$NftActivityFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftActivityFilterCriteriaDto? filters;
  static const fromJsonFactory = _$NftActivityFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $NftActivityFilterExtension on NftActivityFilter {
  NftActivityFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftActivityFilterCriteriaDto? filters,
  }) {
    return NftActivityFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  NftActivityFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftActivityFilterCriteriaDto?>? filters,
  }) {
    return NftActivityFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortNftDoc {
  const ShortNftDoc({
    required this.identifier,
    required this.collection,
    required this.name,
    required this.url,
    required this.wasProcessed,
    this.media,
    this.metadata,
  });

  factory ShortNftDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortNftDocFromJson(json);

  static const toJsonFactory = _$ShortNftDocToJson;
  Map<String, dynamic> toJson() => _$ShortNftDocToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'metadata')
  final NftMetadata? metadata;
  static const fromJsonFactory = _$ShortNftDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortNftDoc &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.wasProcessed, wasProcessed) ||
                const DeepCollectionEquality().equals(
                  other.wasProcessed,
                  wasProcessed,
                )) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(wasProcessed) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $ShortNftDocExtension on ShortNftDoc {
  ShortNftDoc copyWith({
    String? identifier,
    String? collection,
    String? name,
    String? url,
    bool? wasProcessed,
    NftMedia? media,
    NftMetadata? metadata,
  }) {
    return ShortNftDoc(
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      name: name ?? this.name,
      url: url ?? this.url,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      metadata: metadata ?? this.metadata,
    );
  }

  ShortNftDoc copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<String>? url,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftMetadata?>? metadata,
  }) {
    return ShortNftDoc(
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      url: (url != null ? url.value : this.url),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDataHydrated {
  const NftActivityDataHydrated({
    required this.collection,
    this.identifier,
    required this.price,
    required this.paymentToken,
    required this.quantity,
    required this.scId,
    required this.usdValue,
    required this.egldValue,
    this.auctionType,
    this.deadline,
    this.originalPayment,
    this.originalTokenAmount,
    this.originalTokenAmountShort,
    this.originalTokenEgldValue,
    this.originalTokenUsdValue,
    this.originalTokenIdentifier,
    required this.nftInfo,
    required this.collectionInfo,
  });

  factory NftActivityDataHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityDataHydratedFromJson(json);

  static const toJsonFactory = _$NftActivityDataHydratedToJson;
  Map<String, dynamic> toJson() => _$NftActivityDataHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'identifier')
  final String? identifier;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'scId')
  final double scId;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(
    name: 'auctionType',
    toJson: nftActivityDataHydratedAuctionTypeNullableToJson,
    fromJson: nftActivityDataHydratedAuctionTypeNullableFromJson,
  )
  final enums.NftActivityDataHydratedAuctionType? auctionType;
  @JsonKey(name: 'deadline')
  final double? deadline;
  @JsonKey(name: 'originalPayment')
  final NftActivityDataHydrated$OriginalPayment? originalPayment;
  @JsonKey(name: 'originalTokenAmount')
  final String? originalTokenAmount;
  @JsonKey(name: 'originalTokenAmountShort')
  final double? originalTokenAmountShort;
  @JsonKey(name: 'originalTokenEgldValue')
  final double? originalTokenEgldValue;
  @JsonKey(name: 'originalTokenUsdValue')
  final double? originalTokenUsdValue;
  @JsonKey(name: 'originalTokenIdentifier')
  final String? originalTokenIdentifier;
  @JsonKey(name: 'nftInfo')
  final ShortNftDoc nftInfo;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$NftActivityDataHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityDataHydrated &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality().equals(
                  other.collection,
                  collection,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.scId, scId) ||
                const DeepCollectionEquality().equals(other.scId, scId)) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.egldValue, egldValue) ||
                const DeepCollectionEquality().equals(
                  other.egldValue,
                  egldValue,
                )) &&
            (identical(other.auctionType, auctionType) ||
                const DeepCollectionEquality().equals(
                  other.auctionType,
                  auctionType,
                )) &&
            (identical(other.deadline, deadline) ||
                const DeepCollectionEquality().equals(
                  other.deadline,
                  deadline,
                )) &&
            (identical(other.originalPayment, originalPayment) ||
                const DeepCollectionEquality().equals(
                  other.originalPayment,
                  originalPayment,
                )) &&
            (identical(other.originalTokenAmount, originalTokenAmount) ||
                const DeepCollectionEquality().equals(
                  other.originalTokenAmount,
                  originalTokenAmount,
                )) &&
            (identical(
                  other.originalTokenAmountShort,
                  originalTokenAmountShort,
                ) ||
                const DeepCollectionEquality().equals(
                  other.originalTokenAmountShort,
                  originalTokenAmountShort,
                )) &&
            (identical(other.originalTokenEgldValue, originalTokenEgldValue) ||
                const DeepCollectionEquality().equals(
                  other.originalTokenEgldValue,
                  originalTokenEgldValue,
                )) &&
            (identical(other.originalTokenUsdValue, originalTokenUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.originalTokenUsdValue,
                  originalTokenUsdValue,
                )) &&
            (identical(
                  other.originalTokenIdentifier,
                  originalTokenIdentifier,
                ) ||
                const DeepCollectionEquality().equals(
                  other.originalTokenIdentifier,
                  originalTokenIdentifier,
                )) &&
            (identical(other.nftInfo, nftInfo) ||
                const DeepCollectionEquality().equals(
                  other.nftInfo,
                  nftInfo,
                )) &&
            (identical(other.collectionInfo, collectionInfo) ||
                const DeepCollectionEquality().equals(
                  other.collectionInfo,
                  collectionInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(scId) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(egldValue) ^
      const DeepCollectionEquality().hash(auctionType) ^
      const DeepCollectionEquality().hash(deadline) ^
      const DeepCollectionEquality().hash(originalPayment) ^
      const DeepCollectionEquality().hash(originalTokenAmount) ^
      const DeepCollectionEquality().hash(originalTokenAmountShort) ^
      const DeepCollectionEquality().hash(originalTokenEgldValue) ^
      const DeepCollectionEquality().hash(originalTokenUsdValue) ^
      const DeepCollectionEquality().hash(originalTokenIdentifier) ^
      const DeepCollectionEquality().hash(nftInfo) ^
      const DeepCollectionEquality().hash(collectionInfo) ^
      runtimeType.hashCode;
}

extension $NftActivityDataHydratedExtension on NftActivityDataHydrated {
  NftActivityDataHydrated copyWith({
    String? collection,
    String? identifier,
    double? price,
    String? paymentToken,
    double? quantity,
    double? scId,
    double? usdValue,
    double? egldValue,
    enums.NftActivityDataHydratedAuctionType? auctionType,
    double? deadline,
    NftActivityDataHydrated$OriginalPayment? originalPayment,
    String? originalTokenAmount,
    double? originalTokenAmountShort,
    double? originalTokenEgldValue,
    double? originalTokenUsdValue,
    String? originalTokenIdentifier,
    ShortNftDoc? nftInfo,
    ShortCollectionDoc? collectionInfo,
  }) {
    return NftActivityDataHydrated(
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
      price: price ?? this.price,
      paymentToken: paymentToken ?? this.paymentToken,
      quantity: quantity ?? this.quantity,
      scId: scId ?? this.scId,
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      auctionType: auctionType ?? this.auctionType,
      deadline: deadline ?? this.deadline,
      originalPayment: originalPayment ?? this.originalPayment,
      originalTokenAmount: originalTokenAmount ?? this.originalTokenAmount,
      originalTokenAmountShort:
          originalTokenAmountShort ?? this.originalTokenAmountShort,
      originalTokenEgldValue:
          originalTokenEgldValue ?? this.originalTokenEgldValue,
      originalTokenUsdValue:
          originalTokenUsdValue ?? this.originalTokenUsdValue,
      originalTokenIdentifier:
          originalTokenIdentifier ?? this.originalTokenIdentifier,
      nftInfo: nftInfo ?? this.nftInfo,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  NftActivityDataHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String?>? identifier,
    Wrapped<double>? price,
    Wrapped<String>? paymentToken,
    Wrapped<double>? quantity,
    Wrapped<double>? scId,
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<enums.NftActivityDataHydratedAuctionType?>? auctionType,
    Wrapped<double?>? deadline,
    Wrapped<NftActivityDataHydrated$OriginalPayment?>? originalPayment,
    Wrapped<String?>? originalTokenAmount,
    Wrapped<double?>? originalTokenAmountShort,
    Wrapped<double?>? originalTokenEgldValue,
    Wrapped<double?>? originalTokenUsdValue,
    Wrapped<String?>? originalTokenIdentifier,
    Wrapped<ShortNftDoc>? nftInfo,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return NftActivityDataHydrated(
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
      price: (price != null ? price.value : this.price),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      quantity: (quantity != null ? quantity.value : this.quantity),
      scId: (scId != null ? scId.value : this.scId),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      deadline: (deadline != null ? deadline.value : this.deadline),
      originalPayment: (originalPayment != null
          ? originalPayment.value
          : this.originalPayment),
      originalTokenAmount: (originalTokenAmount != null
          ? originalTokenAmount.value
          : this.originalTokenAmount),
      originalTokenAmountShort: (originalTokenAmountShort != null
          ? originalTokenAmountShort.value
          : this.originalTokenAmountShort),
      originalTokenEgldValue: (originalTokenEgldValue != null
          ? originalTokenEgldValue.value
          : this.originalTokenEgldValue),
      originalTokenUsdValue: (originalTokenUsdValue != null
          ? originalTokenUsdValue.value
          : this.originalTokenUsdValue),
      originalTokenIdentifier: (originalTokenIdentifier != null
          ? originalTokenIdentifier.value
          : this.originalTokenIdentifier),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDocHydrated {
  const NftActivityDocHydrated({
    required this.timestamp,
    required this.txHash,
    required this.eventIdentifier,
    this.eventOrder,
    required this.chain,
    required this.source,
    required this.activityType,
    required this.id,
    required this.pk,
    required this.ts,
    required this.from,
    required this.to,
    required this.activityData,
  });

  factory NftActivityDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityDocHydratedFromJson(json);

  static const toJsonFactory = _$NftActivityDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftActivityDocHydratedToJson(this);

  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'eventIdentifier')
  final String eventIdentifier;
  @JsonKey(name: 'eventOrder')
  final double? eventOrder;
  @JsonKey(
    name: 'chain',
    toJson: nftActivityDocHydratedChainToJson,
    fromJson: nftActivityDocHydratedChainFromJson,
  )
  final enums.NftActivityDocHydratedChain chain;
  @JsonKey(
    name: 'source',
    toJson: nftActivityDocHydratedSourceToJson,
    fromJson: nftActivityDocHydratedSourceFromJson,
  )
  final enums.NftActivityDocHydratedSource source;
  @JsonKey(
    name: 'activityType',
    toJson: nftActivityDocHydratedActivityTypeToJson,
    fromJson: nftActivityDocHydratedActivityTypeFromJson,
  )
  final enums.NftActivityDocHydratedActivityType activityType;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'from')
  final OwnerDto from;
  @JsonKey(name: 'to')
  final OwnerDto to;
  @JsonKey(name: 'activityData')
  final NftActivityDataHydrated activityData;
  static const fromJsonFactory = _$NftActivityDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityDocHydrated &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.eventIdentifier, eventIdentifier) ||
                const DeepCollectionEquality().equals(
                  other.eventIdentifier,
                  eventIdentifier,
                )) &&
            (identical(other.eventOrder, eventOrder) ||
                const DeepCollectionEquality().equals(
                  other.eventOrder,
                  eventOrder,
                )) &&
            (identical(other.chain, chain) ||
                const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.activityType, activityType) ||
                const DeepCollectionEquality().equals(
                  other.activityType,
                  activityType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)) &&
            (identical(other.activityData, activityData) ||
                const DeepCollectionEquality().equals(
                  other.activityData,
                  activityData,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(eventIdentifier) ^
      const DeepCollectionEquality().hash(eventOrder) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(activityType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to) ^
      const DeepCollectionEquality().hash(activityData) ^
      runtimeType.hashCode;
}

extension $NftActivityDocHydratedExtension on NftActivityDocHydrated {
  NftActivityDocHydrated copyWith({
    double? timestamp,
    String? txHash,
    String? eventIdentifier,
    double? eventOrder,
    enums.NftActivityDocHydratedChain? chain,
    enums.NftActivityDocHydratedSource? source,
    enums.NftActivityDocHydratedActivityType? activityType,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? from,
    OwnerDto? to,
    NftActivityDataHydrated? activityData,
  }) {
    return NftActivityDocHydrated(
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      eventIdentifier: eventIdentifier ?? this.eventIdentifier,
      eventOrder: eventOrder ?? this.eventOrder,
      chain: chain ?? this.chain,
      source: source ?? this.source,
      activityType: activityType ?? this.activityType,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      from: from ?? this.from,
      to: to ?? this.to,
      activityData: activityData ?? this.activityData,
    );
  }

  NftActivityDocHydrated copyWithWrapped({
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? eventIdentifier,
    Wrapped<double?>? eventOrder,
    Wrapped<enums.NftActivityDocHydratedChain>? chain,
    Wrapped<enums.NftActivityDocHydratedSource>? source,
    Wrapped<enums.NftActivityDocHydratedActivityType>? activityType,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? from,
    Wrapped<OwnerDto>? to,
    Wrapped<NftActivityDataHydrated>? activityData,
  }) {
    return NftActivityDocHydrated(
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      eventIdentifier: (eventIdentifier != null
          ? eventIdentifier.value
          : this.eventIdentifier),
      eventOrder: (eventOrder != null ? eventOrder.value : this.eventOrder),
      chain: (chain != null ? chain.value : this.chain),
      source: (source != null ? source.value : this.source),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      from: (from != null ? from.value : this.from),
      to: (to != null ? to.value : this.to),
      activityData: (activityData != null
          ? activityData.value
          : this.activityData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityPaginated {
  const NftActivityPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftActivityPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityPaginatedFromJson(json);

  static const toJsonFactory = _$NftActivityPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftActivityPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftActivityDocHydrated>[])
  final List<NftActivityDocHydrated> resources;
  static const fromJsonFactory = _$NftActivityPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $NftActivityPaginatedExtension on NftActivityPaginated {
  NftActivityPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftActivityDocHydrated>? resources,
  }) {
    return NftActivityPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftActivityPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftActivityDocHydrated>>? resources,
  }) {
    return NftActivityPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VolumeGraph {
  const VolumeGraph({
    required this.marketplace,
    required this.timestamp,
    required this.totalEgldVolume,
    required this.totalUsdVolume,
    required this.totalTrades,
    required this.floorPrice,
    required this.athPrice,
    required this.avgPrice,
  });

  factory VolumeGraph.fromJson(Map<String, dynamic> json) =>
      _$VolumeGraphFromJson(json);

  static const toJsonFactory = _$VolumeGraphToJson;
  Map<String, dynamic> toJson() => _$VolumeGraphToJson(this);

  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp', defaultValue: <List<Object?>>[])
  final List<List<Object?>> timestamp;
  @JsonKey(name: 'totalEgldVolume', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalEgldVolume;
  @JsonKey(name: 'totalUsdVolume', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalUsdVolume;
  @JsonKey(name: 'totalTrades', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalTrades;
  @JsonKey(name: 'floorPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> floorPrice;
  @JsonKey(name: 'athPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> athPrice;
  @JsonKey(name: 'avgPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgPrice;
  static const fromJsonFactory = _$VolumeGraphFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VolumeGraph &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.totalEgldVolume, totalEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalEgldVolume,
                  totalEgldVolume,
                )) &&
            (identical(other.totalUsdVolume, totalUsdVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalUsdVolume,
                  totalUsdVolume,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.athPrice, athPrice) ||
                const DeepCollectionEquality().equals(
                  other.athPrice,
                  athPrice,
                )) &&
            (identical(other.avgPrice, avgPrice) ||
                const DeepCollectionEquality().equals(
                  other.avgPrice,
                  avgPrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(totalEgldVolume) ^
      const DeepCollectionEquality().hash(totalUsdVolume) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(athPrice) ^
      const DeepCollectionEquality().hash(avgPrice) ^
      runtimeType.hashCode;
}

extension $VolumeGraphExtension on VolumeGraph {
  VolumeGraph copyWith({
    String? marketplace,
    List<List<Object?>>? timestamp,
    List<List<Object?>>? totalEgldVolume,
    List<List<Object?>>? totalUsdVolume,
    List<List<Object?>>? totalTrades,
    List<List<Object?>>? floorPrice,
    List<List<Object?>>? athPrice,
    List<List<Object?>>? avgPrice,
  }) {
    return VolumeGraph(
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      totalUsdVolume: totalUsdVolume ?? this.totalUsdVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      floorPrice: floorPrice ?? this.floorPrice,
      athPrice: athPrice ?? this.athPrice,
      avgPrice: avgPrice ?? this.avgPrice,
    );
  }

  VolumeGraph copyWithWrapped({
    Wrapped<String>? marketplace,
    Wrapped<List<List<Object?>>>? timestamp,
    Wrapped<List<List<Object?>>>? totalEgldVolume,
    Wrapped<List<List<Object?>>>? totalUsdVolume,
    Wrapped<List<List<Object?>>>? totalTrades,
    Wrapped<List<List<Object?>>>? floorPrice,
    Wrapped<List<List<Object?>>>? athPrice,
    Wrapped<List<List<Object?>>>? avgPrice,
  }) {
    return VolumeGraph(
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      totalUsdVolume: (totalUsdVolume != null
          ? totalUsdVolume.value
          : this.totalUsdVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      athPrice: (athPrice != null ? athPrice.value : this.athPrice),
      avgPrice: (avgPrice != null ? avgPrice.value : this.avgPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsVolumeDto {
  const AnalyticsVolumeDto({
    required this.marketplace,
    required this.timestamp,
    required this.totalEgldVolume,
    required this.totalUsdVolume,
    required this.totalTrades,
    required this.floorPrice,
    required this.athPrice,
    required this.avgPrice,
  });

  factory AnalyticsVolumeDto.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsVolumeDtoFromJson(json);

  static const toJsonFactory = _$AnalyticsVolumeDtoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsVolumeDtoToJson(this);

  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp', defaultValue: <String>[])
  final List<String> timestamp;
  @JsonKey(name: 'totalEgldVolume', defaultValue: <String>[])
  final List<String> totalEgldVolume;
  @JsonKey(name: 'totalUsdVolume', defaultValue: <String>[])
  final List<String> totalUsdVolume;
  @JsonKey(name: 'totalTrades', defaultValue: <String>[])
  final List<String> totalTrades;
  @JsonKey(name: 'floorPrice', defaultValue: <String>[])
  final List<String> floorPrice;
  @JsonKey(name: 'athPrice', defaultValue: <String>[])
  final List<String> athPrice;
  @JsonKey(name: 'avgPrice', defaultValue: <String>[])
  final List<String> avgPrice;
  static const fromJsonFactory = _$AnalyticsVolumeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsVolumeDto &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.totalEgldVolume, totalEgldVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalEgldVolume,
                  totalEgldVolume,
                )) &&
            (identical(other.totalUsdVolume, totalUsdVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalUsdVolume,
                  totalUsdVolume,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )) &&
            (identical(other.floorPrice, floorPrice) ||
                const DeepCollectionEquality().equals(
                  other.floorPrice,
                  floorPrice,
                )) &&
            (identical(other.athPrice, athPrice) ||
                const DeepCollectionEquality().equals(
                  other.athPrice,
                  athPrice,
                )) &&
            (identical(other.avgPrice, avgPrice) ||
                const DeepCollectionEquality().equals(
                  other.avgPrice,
                  avgPrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(totalEgldVolume) ^
      const DeepCollectionEquality().hash(totalUsdVolume) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      const DeepCollectionEquality().hash(floorPrice) ^
      const DeepCollectionEquality().hash(athPrice) ^
      const DeepCollectionEquality().hash(avgPrice) ^
      runtimeType.hashCode;
}

extension $AnalyticsVolumeDtoExtension on AnalyticsVolumeDto {
  AnalyticsVolumeDto copyWith({
    String? marketplace,
    List<String>? timestamp,
    List<String>? totalEgldVolume,
    List<String>? totalUsdVolume,
    List<String>? totalTrades,
    List<String>? floorPrice,
    List<String>? athPrice,
    List<String>? avgPrice,
  }) {
    return AnalyticsVolumeDto(
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      totalUsdVolume: totalUsdVolume ?? this.totalUsdVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      floorPrice: floorPrice ?? this.floorPrice,
      athPrice: athPrice ?? this.athPrice,
      avgPrice: avgPrice ?? this.avgPrice,
    );
  }

  AnalyticsVolumeDto copyWithWrapped({
    Wrapped<String>? marketplace,
    Wrapped<List<String>>? timestamp,
    Wrapped<List<String>>? totalEgldVolume,
    Wrapped<List<String>>? totalUsdVolume,
    Wrapped<List<String>>? totalTrades,
    Wrapped<List<String>>? floorPrice,
    Wrapped<List<String>>? athPrice,
    Wrapped<List<String>>? avgPrice,
  }) {
    return AnalyticsVolumeDto(
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      totalUsdVolume: (totalUsdVolume != null
          ? totalUsdVolume.value
          : this.totalUsdVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      athPrice: (athPrice != null ? athPrice.value : this.athPrice),
      avgPrice: (avgPrice != null ? avgPrice.value : this.avgPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionDetailsDto {
  const TransactionDetailsDto({
    required this.price,
    required this.txHash,
    required this.timestamp,
    required this.identifier,
  });

  factory TransactionDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$TransactionDetailsDtoFromJson(json);

  static const toJsonFactory = _$TransactionDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$TransactionDetailsDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$TransactionDetailsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionDetailsDto &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $TransactionDetailsDtoExtension on TransactionDetailsDto {
  TransactionDetailsDto copyWith({
    double? price,
    String? txHash,
    double? timestamp,
    String? identifier,
  }) {
    return TransactionDetailsDto(
      price: price ?? this.price,
      txHash: txHash ?? this.txHash,
      timestamp: timestamp ?? this.timestamp,
      identifier: identifier ?? this.identifier,
    );
  }

  TransactionDetailsDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<String>? txHash,
    Wrapped<double>? timestamp,
    Wrapped<String>? identifier,
  }) {
    return TransactionDetailsDto(
      price: (price != null ? price.value : this.price),
      txHash: (txHash != null ? txHash.value : this.txHash),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AveragePriceDto {
  const AveragePriceDto({required this.price});

  factory AveragePriceDto.fromJson(Map<String, dynamic> json) =>
      _$AveragePriceDtoFromJson(json);

  static const toJsonFactory = _$AveragePriceDtoToJson;
  Map<String, dynamic> toJson() => _$AveragePriceDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  static const fromJsonFactory = _$AveragePriceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AveragePriceDto &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^ runtimeType.hashCode;
}

extension $AveragePriceDtoExtension on AveragePriceDto {
  AveragePriceDto copyWith({double? price}) {
    return AveragePriceDto(price: price ?? this.price);
  }

  AveragePriceDto copyWithWrapped({Wrapped<double>? price}) {
    return AveragePriceDto(price: (price != null ? price.value : this.price));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsDto {
  const AnalyticsDto({
    required this.count,
    required this.volume,
    required this.min,
    required this.max,
    required this.avg,
  });

  factory AnalyticsDto.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsDtoFromJson(json);

  static const toJsonFactory = _$AnalyticsDtoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsDtoToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'volume')
  final double volume;
  @JsonKey(name: 'min')
  final TransactionDetailsDto min;
  @JsonKey(name: 'max')
  final TransactionDetailsDto max;
  @JsonKey(name: 'avg')
  final AveragePriceDto avg;
  static const fromJsonFactory = _$AnalyticsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsDto &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.volume, volume) ||
                const DeepCollectionEquality().equals(other.volume, volume)) &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)) &&
            (identical(other.avg, avg) ||
                const DeepCollectionEquality().equals(other.avg, avg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(volume) ^
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max) ^
      const DeepCollectionEquality().hash(avg) ^
      runtimeType.hashCode;
}

extension $AnalyticsDtoExtension on AnalyticsDto {
  AnalyticsDto copyWith({
    double? count,
    double? volume,
    TransactionDetailsDto? min,
    TransactionDetailsDto? max,
    AveragePriceDto? avg,
  }) {
    return AnalyticsDto(
      count: count ?? this.count,
      volume: volume ?? this.volume,
      min: min ?? this.min,
      max: max ?? this.max,
      avg: avg ?? this.avg,
    );
  }

  AnalyticsDto copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<double>? volume,
    Wrapped<TransactionDetailsDto>? min,
    Wrapped<TransactionDetailsDto>? max,
    Wrapped<AveragePriceDto>? avg,
  }) {
    return AnalyticsDto(
      count: (count != null ? count.value : this.count),
      volume: (volume != null ? volume.value : this.volume),
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
      avg: (avg != null ? avg.value : this.avg),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAnalyticsDto {
  const UserAnalyticsDto({required this.purchase, required this.sale});

  factory UserAnalyticsDto.fromJson(Map<String, dynamic> json) =>
      _$UserAnalyticsDtoFromJson(json);

  static const toJsonFactory = _$UserAnalyticsDtoToJson;
  Map<String, dynamic> toJson() => _$UserAnalyticsDtoToJson(this);

  @JsonKey(name: 'Purchase')
  final AnalyticsDto purchase;
  @JsonKey(name: 'Sale')
  final AnalyticsDto sale;
  static const fromJsonFactory = _$UserAnalyticsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserAnalyticsDto &&
            (identical(other.purchase, purchase) ||
                const DeepCollectionEquality().equals(
                  other.purchase,
                  purchase,
                )) &&
            (identical(other.sale, sale) ||
                const DeepCollectionEquality().equals(other.sale, sale)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(purchase) ^
      const DeepCollectionEquality().hash(sale) ^
      runtimeType.hashCode;
}

extension $UserAnalyticsDtoExtension on UserAnalyticsDto {
  UserAnalyticsDto copyWith({AnalyticsDto? purchase, AnalyticsDto? sale}) {
    return UserAnalyticsDto(
      purchase: purchase ?? this.purchase,
      sale: sale ?? this.sale,
    );
  }

  UserAnalyticsDto copyWithWrapped({
    Wrapped<AnalyticsDto>? purchase,
    Wrapped<AnalyticsDto>? sale,
  }) {
    return UserAnalyticsDto(
      purchase: (purchase != null ? purchase.value : this.purchase),
      sale: (sale != null ? sale.value : this.sale),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AllTimeHighDto {
  const AllTimeHighDto({
    required this.price,
    required this.timestamp,
    required this.txHash,
    required this.identifier,
  });

  factory AllTimeHighDto.fromJson(Map<String, dynamic> json) =>
      _$AllTimeHighDtoFromJson(json);

  static const toJsonFactory = _$AllTimeHighDtoToJson;
  Map<String, dynamic> toJson() => _$AllTimeHighDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$AllTimeHighDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AllTimeHighDto &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(identifier) ^
      runtimeType.hashCode;
}

extension $AllTimeHighDtoExtension on AllTimeHighDto {
  AllTimeHighDto copyWith({
    double? price,
    double? timestamp,
    String? txHash,
    String? identifier,
  }) {
    return AllTimeHighDto(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      identifier: identifier ?? this.identifier,
    );
  }

  AllTimeHighDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? identifier,
  }) {
    return AllTimeHighDto(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingStatsDto {
  const TradingStatsDto({
    required this.totalVolume,
    required this.totalTrades,
    required this.averagePrice,
    required this.allTimeHigh,
    required this.day,
    required this.week,
    required this.month,
    required this.quarter,
    required this.halfYear,
    required this.year,
  });

  factory TradingStatsDto.fromJson(Map<String, dynamic> json) =>
      _$TradingStatsDtoFromJson(json);

  static const toJsonFactory = _$TradingStatsDtoToJson;
  Map<String, dynamic> toJson() => _$TradingStatsDtoToJson(this);

  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'averagePrice')
  final double averagePrice;
  @JsonKey(name: 'allTimeHigh')
  final AllTimeHighDto allTimeHigh;
  @JsonKey(name: 'day')
  final Object day;
  @JsonKey(name: 'week')
  final Object week;
  @JsonKey(name: 'month')
  final Object month;
  @JsonKey(name: 'quarter')
  final Object quarter;
  @JsonKey(name: 'halfYear')
  final Object halfYear;
  @JsonKey(name: 'year')
  final Object year;
  static const fromJsonFactory = _$TradingStatsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TradingStatsDto &&
            (identical(other.totalVolume, totalVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalVolume,
                  totalVolume,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )) &&
            (identical(other.averagePrice, averagePrice) ||
                const DeepCollectionEquality().equals(
                  other.averagePrice,
                  averagePrice,
                )) &&
            (identical(other.allTimeHigh, allTimeHigh) ||
                const DeepCollectionEquality().equals(
                  other.allTimeHigh,
                  allTimeHigh,
                )) &&
            (identical(other.day, day) ||
                const DeepCollectionEquality().equals(other.day, day)) &&
            (identical(other.week, week) ||
                const DeepCollectionEquality().equals(other.week, week)) &&
            (identical(other.month, month) ||
                const DeepCollectionEquality().equals(other.month, month)) &&
            (identical(other.quarter, quarter) ||
                const DeepCollectionEquality().equals(
                  other.quarter,
                  quarter,
                )) &&
            (identical(other.halfYear, halfYear) ||
                const DeepCollectionEquality().equals(
                  other.halfYear,
                  halfYear,
                )) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalVolume) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      const DeepCollectionEquality().hash(averagePrice) ^
      const DeepCollectionEquality().hash(allTimeHigh) ^
      const DeepCollectionEquality().hash(day) ^
      const DeepCollectionEquality().hash(week) ^
      const DeepCollectionEquality().hash(month) ^
      const DeepCollectionEquality().hash(quarter) ^
      const DeepCollectionEquality().hash(halfYear) ^
      const DeepCollectionEquality().hash(year) ^
      runtimeType.hashCode;
}

extension $TradingStatsDtoExtension on TradingStatsDto {
  TradingStatsDto copyWith({
    double? totalVolume,
    double? totalTrades,
    double? averagePrice,
    AllTimeHighDto? allTimeHigh,
    Object? day,
    Object? week,
    Object? month,
    Object? quarter,
    Object? halfYear,
    Object? year,
  }) {
    return TradingStatsDto(
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      averagePrice: averagePrice ?? this.averagePrice,
      allTimeHigh: allTimeHigh ?? this.allTimeHigh,
      day: day ?? this.day,
      week: week ?? this.week,
      month: month ?? this.month,
      quarter: quarter ?? this.quarter,
      halfYear: halfYear ?? this.halfYear,
      year: year ?? this.year,
    );
  }

  TradingStatsDto copyWithWrapped({
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double>? averagePrice,
    Wrapped<AllTimeHighDto>? allTimeHigh,
    Wrapped<Object>? day,
    Wrapped<Object>? week,
    Wrapped<Object>? month,
    Wrapped<Object>? quarter,
    Wrapped<Object>? halfYear,
    Wrapped<Object>? year,
  }) {
    return TradingStatsDto(
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
      allTimeHigh: (allTimeHigh != null ? allTimeHigh.value : this.allTimeHigh),
      day: (day != null ? day.value : this.day),
      week: (week != null ? week.value : this.week),
      month: (month != null ? month.value : this.month),
      quarter: (quarter != null ? quarter.value : this.quarter),
      halfYear: (halfYear != null ? halfYear.value : this.halfYear),
      year: (year != null ? year.value : this.year),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalAnalyticsOverviewResponseDto {
  const GlobalAnalyticsOverviewResponseDto({
    required this.userCount,
    required this.listingsCount,
    required this.tradingStats,
  });

  factory GlobalAnalyticsOverviewResponseDto.fromJson(
    Map<String, dynamic> json,
  ) => _$GlobalAnalyticsOverviewResponseDtoFromJson(json);

  static const toJsonFactory = _$GlobalAnalyticsOverviewResponseDtoToJson;
  Map<String, dynamic> toJson() =>
      _$GlobalAnalyticsOverviewResponseDtoToJson(this);

  @JsonKey(name: 'userCount')
  final double userCount;
  @JsonKey(name: 'listingsCount')
  final double listingsCount;
  @JsonKey(name: 'tradingStats')
  final TradingStatsDto tradingStats;
  static const fromJsonFactory = _$GlobalAnalyticsOverviewResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalAnalyticsOverviewResponseDto &&
            (identical(other.userCount, userCount) ||
                const DeepCollectionEquality().equals(
                  other.userCount,
                  userCount,
                )) &&
            (identical(other.listingsCount, listingsCount) ||
                const DeepCollectionEquality().equals(
                  other.listingsCount,
                  listingsCount,
                )) &&
            (identical(other.tradingStats, tradingStats) ||
                const DeepCollectionEquality().equals(
                  other.tradingStats,
                  tradingStats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userCount) ^
      const DeepCollectionEquality().hash(listingsCount) ^
      const DeepCollectionEquality().hash(tradingStats) ^
      runtimeType.hashCode;
}

extension $GlobalAnalyticsOverviewResponseDtoExtension
    on GlobalAnalyticsOverviewResponseDto {
  GlobalAnalyticsOverviewResponseDto copyWith({
    double? userCount,
    double? listingsCount,
    TradingStatsDto? tradingStats,
  }) {
    return GlobalAnalyticsOverviewResponseDto(
      userCount: userCount ?? this.userCount,
      listingsCount: listingsCount ?? this.listingsCount,
      tradingStats: tradingStats ?? this.tradingStats,
    );
  }

  GlobalAnalyticsOverviewResponseDto copyWithWrapped({
    Wrapped<double>? userCount,
    Wrapped<double>? listingsCount,
    Wrapped<TradingStatsDto>? tradingStats,
  }) {
    return GlobalAnalyticsOverviewResponseDto(
      userCount: (userCount != null ? userCount.value : this.userCount),
      listingsCount: (listingsCount != null
          ? listingsCount.value
          : this.listingsCount),
      tradingStats: (tradingStats != null
          ? tradingStats.value
          : this.tradingStats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PriceDataDto {
  const PriceDataDto({
    required this.price,
    required this.timestamp,
    required this.identifier,
    required this.txHash,
    required this.usdValue,
    this.nftInfo,
  });

  factory PriceDataDto.fromJson(Map<String, dynamic> json) =>
      _$PriceDataDtoFromJson(json);

  static const toJsonFactory = _$PriceDataDtoToJson;
  Map<String, dynamic> toJson() => _$PriceDataDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'nftInfo')
  final ShortNftDoc? nftInfo;
  static const fromJsonFactory = _$PriceDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PriceDataDto &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.usdValue, usdValue) ||
                const DeepCollectionEquality().equals(
                  other.usdValue,
                  usdValue,
                )) &&
            (identical(other.nftInfo, nftInfo) ||
                const DeepCollectionEquality().equals(other.nftInfo, nftInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(usdValue) ^
      const DeepCollectionEquality().hash(nftInfo) ^
      runtimeType.hashCode;
}

extension $PriceDataDtoExtension on PriceDataDto {
  PriceDataDto copyWith({
    double? price,
    double? timestamp,
    String? identifier,
    String? txHash,
    double? usdValue,
    ShortNftDoc? nftInfo,
  }) {
    return PriceDataDto(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      identifier: identifier ?? this.identifier,
      txHash: txHash ?? this.txHash,
      usdValue: usdValue ?? this.usdValue,
      nftInfo: nftInfo ?? this.nftInfo,
    );
  }

  PriceDataDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? identifier,
    Wrapped<String>? txHash,
    Wrapped<double>? usdValue,
    Wrapped<ShortNftDoc?>? nftInfo,
  }) {
    return PriceDataDto(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      identifier: (identifier != null ? identifier.value : this.identifier),
      txHash: (txHash != null ? txHash.value : this.txHash),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserStatsDto {
  const UserStatsDto({
    required this.wallet,
    required this.totalVolume,
    required this.totalTrades,
    required this.totalCollections,
    required this.totalNfts,
    required this.totalPartners,
    required this.buyerVolume,
    required this.buyerTrades,
    required this.buyerNfts,
    required this.buyerCollections,
    required this.buyerPartners,
    required this.buyerMaxPriceData,
    required this.buyerMinPriceData,
    required this.sellerVolume,
    required this.sellerTrades,
    required this.sellerNfts,
    required this.sellerCollections,
    required this.sellerPartners,
    required this.sellerMaxPriceData,
    required this.sellerMinPriceData,
  });

  factory UserStatsDto.fromJson(Map<String, dynamic> json) =>
      _$UserStatsDtoFromJson(json);

  static const toJsonFactory = _$UserStatsDtoToJson;
  Map<String, dynamic> toJson() => _$UserStatsDtoToJson(this);

  @JsonKey(name: 'wallet')
  final WalletDto wallet;
  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'totalCollections')
  final double totalCollections;
  @JsonKey(name: 'totalNfts')
  final double totalNfts;
  @JsonKey(name: 'totalPartners')
  final double totalPartners;
  @JsonKey(name: 'buyerVolume')
  final double buyerVolume;
  @JsonKey(name: 'buyerTrades')
  final double buyerTrades;
  @JsonKey(name: 'buyerNfts')
  final double buyerNfts;
  @JsonKey(name: 'buyerCollections')
  final double buyerCollections;
  @JsonKey(name: 'buyerPartners')
  final double buyerPartners;
  @JsonKey(name: 'buyerMaxPriceData')
  final PriceDataDto buyerMaxPriceData;
  @JsonKey(name: 'buyerMinPriceData')
  final PriceDataDto buyerMinPriceData;
  @JsonKey(name: 'sellerVolume')
  final double sellerVolume;
  @JsonKey(name: 'sellerTrades')
  final double sellerTrades;
  @JsonKey(name: 'sellerNfts')
  final double sellerNfts;
  @JsonKey(name: 'sellerCollections')
  final double sellerCollections;
  @JsonKey(name: 'sellerPartners')
  final double sellerPartners;
  @JsonKey(name: 'sellerMaxPriceData')
  final PriceDataDto sellerMaxPriceData;
  @JsonKey(name: 'sellerMinPriceData')
  final PriceDataDto sellerMinPriceData;
  static const fromJsonFactory = _$UserStatsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserStatsDto &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.totalVolume, totalVolume) ||
                const DeepCollectionEquality().equals(
                  other.totalVolume,
                  totalVolume,
                )) &&
            (identical(other.totalTrades, totalTrades) ||
                const DeepCollectionEquality().equals(
                  other.totalTrades,
                  totalTrades,
                )) &&
            (identical(other.totalCollections, totalCollections) ||
                const DeepCollectionEquality().equals(
                  other.totalCollections,
                  totalCollections,
                )) &&
            (identical(other.totalNfts, totalNfts) ||
                const DeepCollectionEquality().equals(
                  other.totalNfts,
                  totalNfts,
                )) &&
            (identical(other.totalPartners, totalPartners) ||
                const DeepCollectionEquality().equals(
                  other.totalPartners,
                  totalPartners,
                )) &&
            (identical(other.buyerVolume, buyerVolume) ||
                const DeepCollectionEquality().equals(
                  other.buyerVolume,
                  buyerVolume,
                )) &&
            (identical(other.buyerTrades, buyerTrades) ||
                const DeepCollectionEquality().equals(
                  other.buyerTrades,
                  buyerTrades,
                )) &&
            (identical(other.buyerNfts, buyerNfts) ||
                const DeepCollectionEquality().equals(
                  other.buyerNfts,
                  buyerNfts,
                )) &&
            (identical(other.buyerCollections, buyerCollections) ||
                const DeepCollectionEquality().equals(
                  other.buyerCollections,
                  buyerCollections,
                )) &&
            (identical(other.buyerPartners, buyerPartners) ||
                const DeepCollectionEquality().equals(
                  other.buyerPartners,
                  buyerPartners,
                )) &&
            (identical(other.buyerMaxPriceData, buyerMaxPriceData) ||
                const DeepCollectionEquality().equals(
                  other.buyerMaxPriceData,
                  buyerMaxPriceData,
                )) &&
            (identical(other.buyerMinPriceData, buyerMinPriceData) ||
                const DeepCollectionEquality().equals(
                  other.buyerMinPriceData,
                  buyerMinPriceData,
                )) &&
            (identical(other.sellerVolume, sellerVolume) ||
                const DeepCollectionEquality().equals(
                  other.sellerVolume,
                  sellerVolume,
                )) &&
            (identical(other.sellerTrades, sellerTrades) ||
                const DeepCollectionEquality().equals(
                  other.sellerTrades,
                  sellerTrades,
                )) &&
            (identical(other.sellerNfts, sellerNfts) ||
                const DeepCollectionEquality().equals(
                  other.sellerNfts,
                  sellerNfts,
                )) &&
            (identical(other.sellerCollections, sellerCollections) ||
                const DeepCollectionEquality().equals(
                  other.sellerCollections,
                  sellerCollections,
                )) &&
            (identical(other.sellerPartners, sellerPartners) ||
                const DeepCollectionEquality().equals(
                  other.sellerPartners,
                  sellerPartners,
                )) &&
            (identical(other.sellerMaxPriceData, sellerMaxPriceData) ||
                const DeepCollectionEquality().equals(
                  other.sellerMaxPriceData,
                  sellerMaxPriceData,
                )) &&
            (identical(other.sellerMinPriceData, sellerMinPriceData) ||
                const DeepCollectionEquality().equals(
                  other.sellerMinPriceData,
                  sellerMinPriceData,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(totalVolume) ^
      const DeepCollectionEquality().hash(totalTrades) ^
      const DeepCollectionEquality().hash(totalCollections) ^
      const DeepCollectionEquality().hash(totalNfts) ^
      const DeepCollectionEquality().hash(totalPartners) ^
      const DeepCollectionEquality().hash(buyerVolume) ^
      const DeepCollectionEquality().hash(buyerTrades) ^
      const DeepCollectionEquality().hash(buyerNfts) ^
      const DeepCollectionEquality().hash(buyerCollections) ^
      const DeepCollectionEquality().hash(buyerPartners) ^
      const DeepCollectionEquality().hash(buyerMaxPriceData) ^
      const DeepCollectionEquality().hash(buyerMinPriceData) ^
      const DeepCollectionEquality().hash(sellerVolume) ^
      const DeepCollectionEquality().hash(sellerTrades) ^
      const DeepCollectionEquality().hash(sellerNfts) ^
      const DeepCollectionEquality().hash(sellerCollections) ^
      const DeepCollectionEquality().hash(sellerPartners) ^
      const DeepCollectionEquality().hash(sellerMaxPriceData) ^
      const DeepCollectionEquality().hash(sellerMinPriceData) ^
      runtimeType.hashCode;
}

extension $UserStatsDtoExtension on UserStatsDto {
  UserStatsDto copyWith({
    WalletDto? wallet,
    double? totalVolume,
    double? totalTrades,
    double? totalCollections,
    double? totalNfts,
    double? totalPartners,
    double? buyerVolume,
    double? buyerTrades,
    double? buyerNfts,
    double? buyerCollections,
    double? buyerPartners,
    PriceDataDto? buyerMaxPriceData,
    PriceDataDto? buyerMinPriceData,
    double? sellerVolume,
    double? sellerTrades,
    double? sellerNfts,
    double? sellerCollections,
    double? sellerPartners,
    PriceDataDto? sellerMaxPriceData,
    PriceDataDto? sellerMinPriceData,
  }) {
    return UserStatsDto(
      wallet: wallet ?? this.wallet,
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      totalCollections: totalCollections ?? this.totalCollections,
      totalNfts: totalNfts ?? this.totalNfts,
      totalPartners: totalPartners ?? this.totalPartners,
      buyerVolume: buyerVolume ?? this.buyerVolume,
      buyerTrades: buyerTrades ?? this.buyerTrades,
      buyerNfts: buyerNfts ?? this.buyerNfts,
      buyerCollections: buyerCollections ?? this.buyerCollections,
      buyerPartners: buyerPartners ?? this.buyerPartners,
      buyerMaxPriceData: buyerMaxPriceData ?? this.buyerMaxPriceData,
      buyerMinPriceData: buyerMinPriceData ?? this.buyerMinPriceData,
      sellerVolume: sellerVolume ?? this.sellerVolume,
      sellerTrades: sellerTrades ?? this.sellerTrades,
      sellerNfts: sellerNfts ?? this.sellerNfts,
      sellerCollections: sellerCollections ?? this.sellerCollections,
      sellerPartners: sellerPartners ?? this.sellerPartners,
      sellerMaxPriceData: sellerMaxPriceData ?? this.sellerMaxPriceData,
      sellerMinPriceData: sellerMinPriceData ?? this.sellerMinPriceData,
    );
  }

  UserStatsDto copyWithWrapped({
    Wrapped<WalletDto>? wallet,
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double>? totalCollections,
    Wrapped<double>? totalNfts,
    Wrapped<double>? totalPartners,
    Wrapped<double>? buyerVolume,
    Wrapped<double>? buyerTrades,
    Wrapped<double>? buyerNfts,
    Wrapped<double>? buyerCollections,
    Wrapped<double>? buyerPartners,
    Wrapped<PriceDataDto>? buyerMaxPriceData,
    Wrapped<PriceDataDto>? buyerMinPriceData,
    Wrapped<double>? sellerVolume,
    Wrapped<double>? sellerTrades,
    Wrapped<double>? sellerNfts,
    Wrapped<double>? sellerCollections,
    Wrapped<double>? sellerPartners,
    Wrapped<PriceDataDto>? sellerMaxPriceData,
    Wrapped<PriceDataDto>? sellerMinPriceData,
  }) {
    return UserStatsDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      totalCollections: (totalCollections != null
          ? totalCollections.value
          : this.totalCollections),
      totalNfts: (totalNfts != null ? totalNfts.value : this.totalNfts),
      totalPartners: (totalPartners != null
          ? totalPartners.value
          : this.totalPartners),
      buyerVolume: (buyerVolume != null ? buyerVolume.value : this.buyerVolume),
      buyerTrades: (buyerTrades != null ? buyerTrades.value : this.buyerTrades),
      buyerNfts: (buyerNfts != null ? buyerNfts.value : this.buyerNfts),
      buyerCollections: (buyerCollections != null
          ? buyerCollections.value
          : this.buyerCollections),
      buyerPartners: (buyerPartners != null
          ? buyerPartners.value
          : this.buyerPartners),
      buyerMaxPriceData: (buyerMaxPriceData != null
          ? buyerMaxPriceData.value
          : this.buyerMaxPriceData),
      buyerMinPriceData: (buyerMinPriceData != null
          ? buyerMinPriceData.value
          : this.buyerMinPriceData),
      sellerVolume: (sellerVolume != null
          ? sellerVolume.value
          : this.sellerVolume),
      sellerTrades: (sellerTrades != null
          ? sellerTrades.value
          : this.sellerTrades),
      sellerNfts: (sellerNfts != null ? sellerNfts.value : this.sellerNfts),
      sellerCollections: (sellerCollections != null
          ? sellerCollections.value
          : this.sellerCollections),
      sellerPartners: (sellerPartners != null
          ? sellerPartners.value
          : this.sellerPartners),
      sellerMaxPriceData: (sellerMaxPriceData != null
          ? sellerMaxPriceData.value
          : this.sellerMaxPriceData),
      sellerMinPriceData: (sellerMinPriceData != null
          ? sellerMinPriceData.value
          : this.sellerMinPriceData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AirdropDtoHydrated {
  const AirdropDtoHydrated({
    required this.tokenAllocation,
    required this.totalScore,
    required this.rank,
    required this.wallet,
    this.signature,
    this.isClaimed,
    this.amount,
  });

  factory AirdropDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$AirdropDtoHydratedFromJson(json);

  static const toJsonFactory = _$AirdropDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$AirdropDtoHydratedToJson(this);

  @JsonKey(name: 'tokenAllocation')
  final double tokenAllocation;
  @JsonKey(name: 'totalScore')
  final double totalScore;
  @JsonKey(name: 'rank')
  final double rank;
  @JsonKey(name: 'wallet')
  final Object wallet;
  @JsonKey(name: 'signature')
  final Object? signature;
  @JsonKey(name: 'isClaimed')
  final bool? isClaimed;
  @JsonKey(name: 'amount')
  final String? amount;
  static const fromJsonFactory = _$AirdropDtoHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AirdropDtoHydrated &&
            (identical(other.tokenAllocation, tokenAllocation) ||
                const DeepCollectionEquality().equals(
                  other.tokenAllocation,
                  tokenAllocation,
                )) &&
            (identical(other.totalScore, totalScore) ||
                const DeepCollectionEquality().equals(
                  other.totalScore,
                  totalScore,
                )) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.isClaimed, isClaimed) ||
                const DeepCollectionEquality().equals(
                  other.isClaimed,
                  isClaimed,
                )) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokenAllocation) ^
      const DeepCollectionEquality().hash(totalScore) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(isClaimed) ^
      const DeepCollectionEquality().hash(amount) ^
      runtimeType.hashCode;
}

extension $AirdropDtoHydratedExtension on AirdropDtoHydrated {
  AirdropDtoHydrated copyWith({
    double? tokenAllocation,
    double? totalScore,
    double? rank,
    Object? wallet,
    Object? signature,
    bool? isClaimed,
    String? amount,
  }) {
    return AirdropDtoHydrated(
      tokenAllocation: tokenAllocation ?? this.tokenAllocation,
      totalScore: totalScore ?? this.totalScore,
      rank: rank ?? this.rank,
      wallet: wallet ?? this.wallet,
      signature: signature ?? this.signature,
      isClaimed: isClaimed ?? this.isClaimed,
      amount: amount ?? this.amount,
    );
  }

  AirdropDtoHydrated copyWithWrapped({
    Wrapped<double>? tokenAllocation,
    Wrapped<double>? totalScore,
    Wrapped<double>? rank,
    Wrapped<Object>? wallet,
    Wrapped<Object?>? signature,
    Wrapped<bool?>? isClaimed,
    Wrapped<String?>? amount,
  }) {
    return AirdropDtoHydrated(
      tokenAllocation: (tokenAllocation != null
          ? tokenAllocation.value
          : this.tokenAllocation),
      totalScore: (totalScore != null ? totalScore.value : this.totalScore),
      rank: (rank != null ? rank.value : this.rank),
      wallet: (wallet != null ? wallet.value : this.wallet),
      signature: (signature != null ? signature.value : this.signature),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingTokenPriceDto {
  const LendingTokenPriceDto({required this.price});

  factory LendingTokenPriceDto.fromJson(Map<String, dynamic> json) =>
      _$LendingTokenPriceDtoFromJson(json);

  static const toJsonFactory = _$LendingTokenPriceDtoToJson;
  Map<String, dynamic> toJson() => _$LendingTokenPriceDtoToJson(this);

  @JsonKey(name: 'price')
  final String price;
  static const fromJsonFactory = _$LendingTokenPriceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LendingTokenPriceDto &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^ runtimeType.hashCode;
}

extension $LendingTokenPriceDtoExtension on LendingTokenPriceDto {
  LendingTokenPriceDto copyWith({String? price}) {
    return LendingTokenPriceDto(price: price ?? this.price);
  }

  LendingTokenPriceDto copyWithWrapped({Wrapped<String>? price}) {
    return LendingTokenPriceDto(
      price: (price != null ? price.value : this.price),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginRequestDto {
  const LoginRequestDto({
    this.address,
    required this.loginToken,
    this.signature,
    this.data,
    this.service,
  });

  factory LoginRequestDto.fromJson(Map<String, dynamic> json) =>
      _$LoginRequestDtoFromJson(json);

  static const toJsonFactory = _$LoginRequestDtoToJson;
  Map<String, dynamic> toJson() => _$LoginRequestDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'loginToken')
  final String loginToken;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'data')
  final Object? data;
  @JsonKey(
    name: 'service',
    toJson: loginRequestDtoServiceNullableToJson,
    fromJson: loginRequestDtoServiceServiceNullableFromJson,
  )
  final enums.LoginRequestDtoService? service;
  static enums.LoginRequestDtoService?
  loginRequestDtoServiceServiceNullableFromJson(Object? value) =>
      loginRequestDtoServiceNullableFromJson(
        value,
        enums.LoginRequestDtoService.xoxno,
      );

  static const fromJsonFactory = _$LoginRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LoginRequestDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.loginToken, loginToken) ||
                const DeepCollectionEquality().equals(
                  other.loginToken,
                  loginToken,
                )) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.service, service) ||
                const DeepCollectionEquality().equals(other.service, service)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(loginToken) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(service) ^
      runtimeType.hashCode;
}

extension $LoginRequestDtoExtension on LoginRequestDto {
  LoginRequestDto copyWith({
    String? address,
    String? loginToken,
    String? signature,
    Object? data,
    enums.LoginRequestDtoService? service,
  }) {
    return LoginRequestDto(
      address: address ?? this.address,
      loginToken: loginToken ?? this.loginToken,
      signature: signature ?? this.signature,
      data: data ?? this.data,
      service: service ?? this.service,
    );
  }

  LoginRequestDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String>? loginToken,
    Wrapped<String?>? signature,
    Wrapped<Object?>? data,
    Wrapped<enums.LoginRequestDtoService?>? service,
  }) {
    return LoginRequestDto(
      address: (address != null ? address.value : this.address),
      loginToken: (loginToken != null ? loginToken.value : this.loginToken),
      signature: (signature != null ? signature.value : this.signature),
      data: (data != null ? data.value : this.data),
      service: (service != null ? service.value : this.service),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginAccessDto {
  const LoginAccessDto({required this.accessToken, required this.expires});

  factory LoginAccessDto.fromJson(Map<String, dynamic> json) =>
      _$LoginAccessDtoFromJson(json);

  static const toJsonFactory = _$LoginAccessDtoToJson;
  Map<String, dynamic> toJson() => _$LoginAccessDtoToJson(this);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'expires')
  final double expires;
  static const fromJsonFactory = _$LoginAccessDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LoginAccessDto &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality().equals(
                  other.accessToken,
                  accessToken,
                )) &&
            (identical(other.expires, expires) ||
                const DeepCollectionEquality().equals(other.expires, expires)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(expires) ^
      runtimeType.hashCode;
}

extension $LoginAccessDtoExtension on LoginAccessDto {
  LoginAccessDto copyWith({String? accessToken, double? expires}) {
    return LoginAccessDto(
      accessToken: accessToken ?? this.accessToken,
      expires: expires ?? this.expires,
    );
  }

  LoginAccessDto copyWithWrapped({
    Wrapped<String>? accessToken,
    Wrapped<double>? expires,
  }) {
    return LoginAccessDto(
      accessToken: (accessToken != null ? accessToken.value : this.accessToken),
      expires: (expires != null ? expires.value : this.expires),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionLog {
  const TransactionLog({
    this.id,
    required this.address,
    required this.events,
    required this.timestamp,
    required this.txHash,
  });

  factory TransactionLog.fromJson(Map<String, dynamic> json) =>
      _$TransactionLogFromJson(json);

  static const toJsonFactory = _$TransactionLogToJson;
  Map<String, dynamic> toJson() => _$TransactionLogToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'events', defaultValue: <List<Object?>>[])
  final List<List<Object?>> events;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  static const fromJsonFactory = _$TransactionLogFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionLog &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.events, events) ||
                const DeepCollectionEquality().equals(other.events, events)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(events) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(txHash) ^
      runtimeType.hashCode;
}

extension $TransactionLogExtension on TransactionLog {
  TransactionLog copyWith({
    String? id,
    String? address,
    List<List<Object?>>? events,
    double? timestamp,
    String? txHash,
  }) {
    return TransactionLog(
      id: id ?? this.id,
      address: address ?? this.address,
      events: events ?? this.events,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
    );
  }

  TransactionLog copyWithWrapped({
    Wrapped<String?>? id,
    Wrapped<String>? address,
    Wrapped<List<List<Object?>>>? events,
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
  }) {
    return TransactionLog(
      id: (id != null ? id.value : this.id),
      address: (address != null ? address.value : this.address),
      events: (events != null ? events.value : this.events),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionDetailed {
  const TransactionDetailed({
    required this.txHash,
    this.gasLimit,
    this.gasPrice,
    this.gasUsed,
    this.miniBlockHash,
    this.nonce,
    required this.receiver,
    required this.receiverShard,
    this.round,
    required this.sender,
    required this.senderShard,
    this.signature,
    required this.status,
    required this.$value,
    this.fee,
    required this.timestamp,
    this.data,
    this.function,
    this.action,
    this.scamInfo,
    this.type,
    this.originalTxHash,
    this.pendingResults,
    required this.results,
    this.price,
    this.logs,
    required this.operations,
  });

  factory TransactionDetailed.fromJson(Map<String, dynamic> json) =>
      _$TransactionDetailedFromJson(json);

  static const toJsonFactory = _$TransactionDetailedToJson;
  Map<String, dynamic> toJson() => _$TransactionDetailedToJson(this);

  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'gasLimit')
  final double? gasLimit;
  @JsonKey(name: 'gasPrice')
  final double? gasPrice;
  @JsonKey(name: 'gasUsed')
  final double? gasUsed;
  @JsonKey(name: 'miniBlockHash')
  final String? miniBlockHash;
  @JsonKey(name: 'nonce')
  final double? nonce;
  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverShard')
  final double receiverShard;
  @JsonKey(name: 'round')
  final double? round;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderShard')
  final double senderShard;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'fee')
  final String? fee;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'data')
  final String? data;
  @JsonKey(name: 'function')
  final String? function;
  @JsonKey(name: 'action')
  final Object? action;
  @JsonKey(name: 'scamInfo')
  final Object? scamInfo;
  @JsonKey(
    name: 'type',
    toJson: transactionTypeNullableToJson,
    fromJson: transactionTypeNullableFromJson,
  )
  final enums.TransactionType? type;
  @JsonKey(name: 'originalTxHash')
  final String? originalTxHash;
  @JsonKey(name: 'pendingResults')
  final bool? pendingResults;
  @JsonKey(name: 'results', defaultValue: <List<Object?>>[])
  final List<List<Object?>> results;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'logs')
  final TransactionLog? logs;
  @JsonKey(name: 'operations', defaultValue: <List<Object?>>[])
  final List<List<Object?>> operations;
  static const fromJsonFactory = _$TransactionDetailedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionDetailed &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.gasLimit, gasLimit) ||
                const DeepCollectionEquality().equals(
                  other.gasLimit,
                  gasLimit,
                )) &&
            (identical(other.gasPrice, gasPrice) ||
                const DeepCollectionEquality().equals(
                  other.gasPrice,
                  gasPrice,
                )) &&
            (identical(other.gasUsed, gasUsed) ||
                const DeepCollectionEquality().equals(
                  other.gasUsed,
                  gasUsed,
                )) &&
            (identical(other.miniBlockHash, miniBlockHash) ||
                const DeepCollectionEquality().equals(
                  other.miniBlockHash,
                  miniBlockHash,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )) &&
            (identical(other.receiverShard, receiverShard) ||
                const DeepCollectionEquality().equals(
                  other.receiverShard,
                  receiverShard,
                )) &&
            (identical(other.round, round) ||
                const DeepCollectionEquality().equals(other.round, round)) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.senderShard, senderShard) ||
                const DeepCollectionEquality().equals(
                  other.senderShard,
                  senderShard,
                )) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.fee, fee) ||
                const DeepCollectionEquality().equals(other.fee, fee)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.function, function) ||
                const DeepCollectionEquality().equals(
                  other.function,
                  function,
                )) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.scamInfo, scamInfo) ||
                const DeepCollectionEquality().equals(
                  other.scamInfo,
                  scamInfo,
                )) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.originalTxHash, originalTxHash) ||
                const DeepCollectionEquality().equals(
                  other.originalTxHash,
                  originalTxHash,
                )) &&
            (identical(other.pendingResults, pendingResults) ||
                const DeepCollectionEquality().equals(
                  other.pendingResults,
                  pendingResults,
                )) &&
            (identical(other.results, results) ||
                const DeepCollectionEquality().equals(
                  other.results,
                  results,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.logs, logs) ||
                const DeepCollectionEquality().equals(other.logs, logs)) &&
            (identical(other.operations, operations) ||
                const DeepCollectionEquality().equals(
                  other.operations,
                  operations,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(gasLimit) ^
      const DeepCollectionEquality().hash(gasPrice) ^
      const DeepCollectionEquality().hash(gasUsed) ^
      const DeepCollectionEquality().hash(miniBlockHash) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(receiver) ^
      const DeepCollectionEquality().hash(receiverShard) ^
      const DeepCollectionEquality().hash(round) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(senderShard) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(fee) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(function) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(scamInfo) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(originalTxHash) ^
      const DeepCollectionEquality().hash(pendingResults) ^
      const DeepCollectionEquality().hash(results) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(logs) ^
      const DeepCollectionEquality().hash(operations) ^
      runtimeType.hashCode;
}

extension $TransactionDetailedExtension on TransactionDetailed {
  TransactionDetailed copyWith({
    String? txHash,
    double? gasLimit,
    double? gasPrice,
    double? gasUsed,
    String? miniBlockHash,
    double? nonce,
    String? receiver,
    double? receiverShard,
    double? round,
    String? sender,
    double? senderShard,
    String? signature,
    String? status,
    String? $value,
    String? fee,
    double? timestamp,
    String? data,
    String? function,
    Object? action,
    Object? scamInfo,
    enums.TransactionType? type,
    String? originalTxHash,
    bool? pendingResults,
    List<List<Object?>>? results,
    double? price,
    TransactionLog? logs,
    List<List<Object?>>? operations,
  }) {
    return TransactionDetailed(
      txHash: txHash ?? this.txHash,
      gasLimit: gasLimit ?? this.gasLimit,
      gasPrice: gasPrice ?? this.gasPrice,
      gasUsed: gasUsed ?? this.gasUsed,
      miniBlockHash: miniBlockHash ?? this.miniBlockHash,
      nonce: nonce ?? this.nonce,
      receiver: receiver ?? this.receiver,
      receiverShard: receiverShard ?? this.receiverShard,
      round: round ?? this.round,
      sender: sender ?? this.sender,
      senderShard: senderShard ?? this.senderShard,
      signature: signature ?? this.signature,
      status: status ?? this.status,
      $value: $value ?? this.$value,
      fee: fee ?? this.fee,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
      function: function ?? this.function,
      action: action ?? this.action,
      scamInfo: scamInfo ?? this.scamInfo,
      type: type ?? this.type,
      originalTxHash: originalTxHash ?? this.originalTxHash,
      pendingResults: pendingResults ?? this.pendingResults,
      results: results ?? this.results,
      price: price ?? this.price,
      logs: logs ?? this.logs,
      operations: operations ?? this.operations,
    );
  }

  TransactionDetailed copyWithWrapped({
    Wrapped<String>? txHash,
    Wrapped<double?>? gasLimit,
    Wrapped<double?>? gasPrice,
    Wrapped<double?>? gasUsed,
    Wrapped<String?>? miniBlockHash,
    Wrapped<double?>? nonce,
    Wrapped<String>? receiver,
    Wrapped<double>? receiverShard,
    Wrapped<double?>? round,
    Wrapped<String>? sender,
    Wrapped<double>? senderShard,
    Wrapped<String?>? signature,
    Wrapped<String>? status,
    Wrapped<String>? $value,
    Wrapped<String?>? fee,
    Wrapped<double>? timestamp,
    Wrapped<String?>? data,
    Wrapped<String?>? function,
    Wrapped<Object?>? action,
    Wrapped<Object?>? scamInfo,
    Wrapped<enums.TransactionType?>? type,
    Wrapped<String?>? originalTxHash,
    Wrapped<bool?>? pendingResults,
    Wrapped<List<List<Object?>>>? results,
    Wrapped<double?>? price,
    Wrapped<TransactionLog?>? logs,
    Wrapped<List<List<Object?>>>? operations,
  }) {
    return TransactionDetailed(
      txHash: (txHash != null ? txHash.value : this.txHash),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
      gasPrice: (gasPrice != null ? gasPrice.value : this.gasPrice),
      gasUsed: (gasUsed != null ? gasUsed.value : this.gasUsed),
      miniBlockHash: (miniBlockHash != null
          ? miniBlockHash.value
          : this.miniBlockHash),
      nonce: (nonce != null ? nonce.value : this.nonce),
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverShard: (receiverShard != null
          ? receiverShard.value
          : this.receiverShard),
      round: (round != null ? round.value : this.round),
      sender: (sender != null ? sender.value : this.sender),
      senderShard: (senderShard != null ? senderShard.value : this.senderShard),
      signature: (signature != null ? signature.value : this.signature),
      status: (status != null ? status.value : this.status),
      $value: ($value != null ? $value.value : this.$value),
      fee: (fee != null ? fee.value : this.fee),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      data: (data != null ? data.value : this.data),
      function: (function != null ? function.value : this.function),
      action: (action != null ? action.value : this.action),
      scamInfo: (scamInfo != null ? scamInfo.value : this.scamInfo),
      type: (type != null ? type.value : this.type),
      originalTxHash: (originalTxHash != null
          ? originalTxHash.value
          : this.originalTxHash),
      pendingResults: (pendingResults != null
          ? pendingResults.value
          : this.pendingResults),
      results: (results != null ? results.value : this.results),
      price: (price != null ? price.value : this.price),
      logs: (logs != null ? logs.value : this.logs),
      operations: (operations != null ? operations.value : this.operations),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionProcessStatus {
  const TransactionProcessStatus({required this.reason, required this.status});

  factory TransactionProcessStatus.fromJson(Map<String, dynamic> json) =>
      _$TransactionProcessStatusFromJson(json);

  static const toJsonFactory = _$TransactionProcessStatusToJson;
  Map<String, dynamic> toJson() => _$TransactionProcessStatusToJson(this);

  @JsonKey(name: 'reason')
  final Object reason;
  @JsonKey(
    name: 'status',
    toJson: transactionStatusToJson,
    fromJson: transactionStatusFromJson,
  )
  final enums.TransactionStatus status;
  static const fromJsonFactory = _$TransactionProcessStatusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionProcessStatus &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $TransactionProcessStatusExtension on TransactionProcessStatus {
  TransactionProcessStatus copyWith({
    Object? reason,
    enums.TransactionStatus? status,
  }) {
    return TransactionProcessStatus(
      reason: reason ?? this.reason,
      status: status ?? this.status,
    );
  }

  TransactionProcessStatus copyWithWrapped({
    Wrapped<Object>? reason,
    Wrapped<enums.TransactionStatus>? status,
  }) {
    return TransactionProcessStatus(
      reason: (reason != null ? reason.value : this.reason),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionCreate {
  const TransactionCreate({
    required this.chainID,
    this.data,
    required this.gasLimit,
    required this.gasPrice,
    required this.nonce,
    required this.receiver,
    this.receiverUsername,
    required this.sender,
    this.senderUsername,
    required this.signature,
    required this.$value,
    required this.version,
    this.options,
    this.guardian,
    this.guardianSignature,
  });

  factory TransactionCreate.fromJson(Map<String, dynamic> json) =>
      _$TransactionCreateFromJson(json);

  static const toJsonFactory = _$TransactionCreateToJson;
  Map<String, dynamic> toJson() => _$TransactionCreateToJson(this);

  @JsonKey(name: 'chainID')
  final String chainID;
  @JsonKey(name: 'data')
  final Object? data;
  @JsonKey(name: 'gasLimit')
  final double gasLimit;
  @JsonKey(name: 'gasPrice')
  final double gasPrice;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverUsername')
  final String? receiverUsername;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderUsername')
  final String? senderUsername;
  @JsonKey(name: 'signature')
  final String signature;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'version')
  final double version;
  @JsonKey(name: 'options')
  final double? options;
  @JsonKey(name: 'guardian')
  final String? guardian;
  @JsonKey(name: 'guardianSignature')
  final String? guardianSignature;
  static const fromJsonFactory = _$TransactionCreateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionCreate &&
            (identical(other.chainID, chainID) ||
                const DeepCollectionEquality().equals(
                  other.chainID,
                  chainID,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.gasLimit, gasLimit) ||
                const DeepCollectionEquality().equals(
                  other.gasLimit,
                  gasLimit,
                )) &&
            (identical(other.gasPrice, gasPrice) ||
                const DeepCollectionEquality().equals(
                  other.gasPrice,
                  gasPrice,
                )) &&
            (identical(other.nonce, nonce) ||
                const DeepCollectionEquality().equals(other.nonce, nonce)) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )) &&
            (identical(other.receiverUsername, receiverUsername) ||
                const DeepCollectionEquality().equals(
                  other.receiverUsername,
                  receiverUsername,
                )) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.senderUsername, senderUsername) ||
                const DeepCollectionEquality().equals(
                  other.senderUsername,
                  senderUsername,
                )) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(
                  other.version,
                  version,
                )) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(
                  other.options,
                  options,
                )) &&
            (identical(other.guardian, guardian) ||
                const DeepCollectionEquality().equals(
                  other.guardian,
                  guardian,
                )) &&
            (identical(other.guardianSignature, guardianSignature) ||
                const DeepCollectionEquality().equals(
                  other.guardianSignature,
                  guardianSignature,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chainID) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(gasLimit) ^
      const DeepCollectionEquality().hash(gasPrice) ^
      const DeepCollectionEquality().hash(nonce) ^
      const DeepCollectionEquality().hash(receiver) ^
      const DeepCollectionEquality().hash(receiverUsername) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(senderUsername) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(guardian) ^
      const DeepCollectionEquality().hash(guardianSignature) ^
      runtimeType.hashCode;
}

extension $TransactionCreateExtension on TransactionCreate {
  TransactionCreate copyWith({
    String? chainID,
    Object? data,
    double? gasLimit,
    double? gasPrice,
    double? nonce,
    String? receiver,
    String? receiverUsername,
    String? sender,
    String? senderUsername,
    String? signature,
    String? $value,
    double? version,
    double? options,
    String? guardian,
    String? guardianSignature,
  }) {
    return TransactionCreate(
      chainID: chainID ?? this.chainID,
      data: data ?? this.data,
      gasLimit: gasLimit ?? this.gasLimit,
      gasPrice: gasPrice ?? this.gasPrice,
      nonce: nonce ?? this.nonce,
      receiver: receiver ?? this.receiver,
      receiverUsername: receiverUsername ?? this.receiverUsername,
      sender: sender ?? this.sender,
      senderUsername: senderUsername ?? this.senderUsername,
      signature: signature ?? this.signature,
      $value: $value ?? this.$value,
      version: version ?? this.version,
      options: options ?? this.options,
      guardian: guardian ?? this.guardian,
      guardianSignature: guardianSignature ?? this.guardianSignature,
    );
  }

  TransactionCreate copyWithWrapped({
    Wrapped<String>? chainID,
    Wrapped<Object?>? data,
    Wrapped<double>? gasLimit,
    Wrapped<double>? gasPrice,
    Wrapped<double>? nonce,
    Wrapped<String>? receiver,
    Wrapped<String?>? receiverUsername,
    Wrapped<String>? sender,
    Wrapped<String?>? senderUsername,
    Wrapped<String>? signature,
    Wrapped<String>? $value,
    Wrapped<double>? version,
    Wrapped<double?>? options,
    Wrapped<String?>? guardian,
    Wrapped<String?>? guardianSignature,
  }) {
    return TransactionCreate(
      chainID: (chainID != null ? chainID.value : this.chainID),
      data: (data != null ? data.value : this.data),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
      gasPrice: (gasPrice != null ? gasPrice.value : this.gasPrice),
      nonce: (nonce != null ? nonce.value : this.nonce),
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverUsername: (receiverUsername != null
          ? receiverUsername.value
          : this.receiverUsername),
      sender: (sender != null ? sender.value : this.sender),
      senderUsername: (senderUsername != null
          ? senderUsername.value
          : this.senderUsername),
      signature: (signature != null ? signature.value : this.signature),
      $value: ($value != null ? $value.value : this.$value),
      version: (version != null ? version.value : this.version),
      options: (options != null ? options.value : this.options),
      guardian: (guardian != null ? guardian.value : this.guardian),
      guardianSignature: (guardianSignature != null
          ? guardianSignature.value
          : this.guardianSignature),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionSendResult {
  const TransactionSendResult({
    required this.receiver,
    required this.receiverShard,
    required this.sender,
    required this.senderShard,
    required this.status,
    required this.txHash,
  });

  factory TransactionSendResult.fromJson(Map<String, dynamic> json) =>
      _$TransactionSendResultFromJson(json);

  static const toJsonFactory = _$TransactionSendResultToJson;
  Map<String, dynamic> toJson() => _$TransactionSendResultToJson(this);

  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverShard')
  final double receiverShard;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderShard')
  final double senderShard;
  @JsonKey(
    name: 'status',
    toJson: transactionStatusToJson,
    fromJson: transactionStatusFromJson,
  )
  final enums.TransactionStatus status;
  @JsonKey(name: 'txHash')
  final String txHash;
  static const fromJsonFactory = _$TransactionSendResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransactionSendResult &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )) &&
            (identical(other.receiverShard, receiverShard) ||
                const DeepCollectionEquality().equals(
                  other.receiverShard,
                  receiverShard,
                )) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.senderShard, senderShard) ||
                const DeepCollectionEquality().equals(
                  other.senderShard,
                  senderShard,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(receiver) ^
      const DeepCollectionEquality().hash(receiverShard) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(senderShard) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(txHash) ^
      runtimeType.hashCode;
}

extension $TransactionSendResultExtension on TransactionSendResult {
  TransactionSendResult copyWith({
    String? receiver,
    double? receiverShard,
    String? sender,
    double? senderShard,
    enums.TransactionStatus? status,
    String? txHash,
  }) {
    return TransactionSendResult(
      receiver: receiver ?? this.receiver,
      receiverShard: receiverShard ?? this.receiverShard,
      sender: sender ?? this.sender,
      senderShard: senderShard ?? this.senderShard,
      status: status ?? this.status,
      txHash: txHash ?? this.txHash,
    );
  }

  TransactionSendResult copyWithWrapped({
    Wrapped<String>? receiver,
    Wrapped<double>? receiverShard,
    Wrapped<String>? sender,
    Wrapped<double>? senderShard,
    Wrapped<enums.TransactionStatus>? status,
    Wrapped<String>? txHash,
  }) {
    return TransactionSendResult(
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverShard: (receiverShard != null
          ? receiverShard.value
          : this.receiverShard),
      sender: (sender != null ? sender.value : this.sender),
      senderShard: (senderShard != null ? senderShard.value : this.senderShard),
      status: (status != null ? status.value : this.status),
      txHash: (txHash != null ? txHash.value : this.txHash),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageReplyDto {
  const ChatMessageReplyDto({
    required this.sender,
    required this.content,
    required this.timestamp,
    required this.id,
  });

  factory ChatMessageReplyDto.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageReplyDtoFromJson(json);

  static const toJsonFactory = _$ChatMessageReplyDtoToJson;
  Map<String, dynamic> toJson() => _$ChatMessageReplyDtoToJson(this);

  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'content')
  final ChatMessageReplyDto content;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'id')
  final String id;
  static const fromJsonFactory = _$ChatMessageReplyDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChatMessageReplyDto &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $ChatMessageReplyDtoExtension on ChatMessageReplyDto {
  ChatMessageReplyDto copyWith({
    String? sender,
    ChatMessageReplyDto? content,
    double? timestamp,
    String? id,
  }) {
    return ChatMessageReplyDto(
      sender: sender ?? this.sender,
      content: content ?? this.content,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
    );
  }

  ChatMessageReplyDto copyWithWrapped({
    Wrapped<String>? sender,
    Wrapped<ChatMessageReplyDto>? content,
    Wrapped<double>? timestamp,
    Wrapped<String>? id,
  }) {
    return ChatMessageReplyDto(
      sender: (sender != null ? sender.value : this.sender),
      content: (content != null ? content.value : this.content),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageContentDto {
  const ChatMessageContentDto({
    required this.type,
    required this.$value,
    this.replyTo,
  });

  factory ChatMessageContentDto.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageContentDtoFromJson(json);

  static const toJsonFactory = _$ChatMessageContentDtoToJson;
  Map<String, dynamic> toJson() => _$ChatMessageContentDtoToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'replyTo')
  final ChatMessageReplyDto? replyTo;
  static const fromJsonFactory = _$ChatMessageContentDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChatMessageContentDto &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.replyTo, replyTo) ||
                const DeepCollectionEquality().equals(other.replyTo, replyTo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(replyTo) ^
      runtimeType.hashCode;
}

extension $ChatMessageContentDtoExtension on ChatMessageContentDto {
  ChatMessageContentDto copyWith({
    String? type,
    String? $value,
    ChatMessageReplyDto? replyTo,
  }) {
    return ChatMessageContentDto(
      type: type ?? this.type,
      $value: $value ?? this.$value,
      replyTo: replyTo ?? this.replyTo,
    );
  }

  ChatMessageContentDto copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? $value,
    Wrapped<ChatMessageReplyDto?>? replyTo,
  }) {
    return ChatMessageContentDto(
      type: (type != null ? type.value : this.type),
      $value: ($value != null ? $value.value : this.$value),
      replyTo: (replyTo != null ? replyTo.value : this.replyTo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SendChatMessageDto {
  const SendChatMessageDto({
    required this.sender,
    required this.content,
    required this.receiver,
  });

  factory SendChatMessageDto.fromJson(Map<String, dynamic> json) =>
      _$SendChatMessageDtoFromJson(json);

  static const toJsonFactory = _$SendChatMessageDtoToJson;
  Map<String, dynamic> toJson() => _$SendChatMessageDtoToJson(this);

  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'content')
  final ChatMessageContentDto content;
  @JsonKey(name: 'receiver')
  final String receiver;
  static const fromJsonFactory = _$SendChatMessageDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SendChatMessageDto &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(receiver) ^
      runtimeType.hashCode;
}

extension $SendChatMessageDtoExtension on SendChatMessageDto {
  SendChatMessageDto copyWith({
    String? sender,
    ChatMessageContentDto? content,
    String? receiver,
  }) {
    return SendChatMessageDto(
      sender: sender ?? this.sender,
      content: content ?? this.content,
      receiver: receiver ?? this.receiver,
    );
  }

  SendChatMessageDto copyWithWrapped({
    Wrapped<String>? sender,
    Wrapped<ChatMessageContentDto>? content,
    Wrapped<String>? receiver,
  }) {
    return SendChatMessageDto(
      sender: (sender != null ? sender.value : this.sender),
      content: (content != null ? content.value : this.content),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MessageDto {
  const MessageDto({
    required this.content,
    required this.isRead,
    required this.timestamp,
    required this.sender,
    required this.isDeletedFor,
  });

  factory MessageDto.fromJson(Map<String, dynamic> json) =>
      _$MessageDtoFromJson(json);

  static const toJsonFactory = _$MessageDtoToJson;
  Map<String, dynamic> toJson() => _$MessageDtoToJson(this);

  @JsonKey(name: 'content')
  final ChatMessageContentDto content;
  @JsonKey(name: 'isRead')
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'isDeletedFor', defaultValue: <String>[])
  final List<String> isDeletedFor;
  static const fromJsonFactory = _$MessageDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MessageDto &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.isRead, isRead) ||
                const DeepCollectionEquality().equals(other.isRead, isRead)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.isDeletedFor, isDeletedFor) ||
                const DeepCollectionEquality().equals(
                  other.isDeletedFor,
                  isDeletedFor,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(isRead) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(isDeletedFor) ^
      runtimeType.hashCode;
}

extension $MessageDtoExtension on MessageDto {
  MessageDto copyWith({
    ChatMessageContentDto? content,
    bool? isRead,
    double? timestamp,
    String? sender,
    List<String>? isDeletedFor,
  }) {
    return MessageDto(
      content: content ?? this.content,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      sender: sender ?? this.sender,
      isDeletedFor: isDeletedFor ?? this.isDeletedFor,
    );
  }

  MessageDto copyWithWrapped({
    Wrapped<ChatMessageContentDto>? content,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<String>? sender,
    Wrapped<List<String>>? isDeletedFor,
  }) {
    return MessageDto(
      content: (content != null ? content.value : this.content),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      sender: (sender != null ? sender.value : this.sender),
      isDeletedFor: (isDeletedFor != null
          ? isDeletedFor.value
          : this.isDeletedFor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageDocHydrated {
  const ChatMessageDocHydrated({
    required this.dataType,
    required this.chatId,
    required this.isGroupChat,
    required this.message,
    required this.pk,
    required this.id,
    required this.ttl,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory ChatMessageDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageDocHydratedFromJson(json);

  static const toJsonFactory = _$ChatMessageDocHydratedToJson;
  Map<String, dynamic> toJson() => _$ChatMessageDocHydratedToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'chatId')
  final String chatId;
  @JsonKey(name: 'isGroupChat')
  final bool isGroupChat;
  @JsonKey(name: 'message')
  final MessageDto message;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'ttl')
  final double ttl;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$ChatMessageDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChatMessageDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.chatId, chatId) ||
                const DeepCollectionEquality().equals(other.chatId, chatId)) &&
            (identical(other.isGroupChat, isGroupChat) ||
                const DeepCollectionEquality().equals(
                  other.isGroupChat,
                  isGroupChat,
                )) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ttl, ttl) ||
                const DeepCollectionEquality().equals(other.ttl, ttl)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(chatId) ^
      const DeepCollectionEquality().hash(isGroupChat) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ttl) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(receiver) ^
      runtimeType.hashCode;
}

extension $ChatMessageDocHydratedExtension on ChatMessageDocHydrated {
  ChatMessageDocHydrated copyWith({
    Object? dataType,
    String? chatId,
    bool? isGroupChat,
    MessageDto? message,
    String? pk,
    String? id,
    double? ttl,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return ChatMessageDocHydrated(
      dataType: dataType ?? this.dataType,
      chatId: chatId ?? this.chatId,
      isGroupChat: isGroupChat ?? this.isGroupChat,
      message: message ?? this.message,
      pk: pk ?? this.pk,
      id: id ?? this.id,
      ttl: ttl ?? this.ttl,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  ChatMessageDocHydrated copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? chatId,
    Wrapped<bool>? isGroupChat,
    Wrapped<MessageDto>? message,
    Wrapped<String>? pk,
    Wrapped<String>? id,
    Wrapped<double>? ttl,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return ChatMessageDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      chatId: (chatId != null ? chatId.value : this.chatId),
      isGroupChat: (isGroupChat != null ? isGroupChat.value : this.isGroupChat),
      message: (message != null ? message.value : this.message),
      pk: (pk != null ? pk.value : this.pk),
      id: (id != null ? id.value : this.id),
      ttl: (ttl != null ? ttl.value : this.ttl),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserConversationDocHydrated {
  const UserConversationDocHydrated({
    required this.dataType,
    this.chatName,
    required this.isGroupChat,
    required this.chatId,
    required this.message,
    this.deleteTimestamp,
    this.unreadCount,
    required this.id,
    required this.pk,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory UserConversationDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$UserConversationDocHydratedFromJson(json);

  static const toJsonFactory = _$UserConversationDocHydratedToJson;
  Map<String, dynamic> toJson() => _$UserConversationDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userConversationDocHydratedDataTypeToJson,
    fromJson: userConversationDocHydratedDataTypeDataTypeFromJson,
  )
  final enums.UserConversationDocHydratedDataType dataType;
  static enums.UserConversationDocHydratedDataType
  userConversationDocHydratedDataTypeDataTypeFromJson(Object? value) =>
      userConversationDocHydratedDataTypeFromJson(
        value,
        enums.UserConversationDocHydratedDataType.conversation,
      );

  @JsonKey(name: 'chatName')
  final Object? chatName;
  @JsonKey(name: 'isGroupChat')
  final bool isGroupChat;
  @JsonKey(name: 'chatId')
  final String chatId;
  @JsonKey(name: 'message')
  final MessageDto message;
  @JsonKey(name: 'deleteTimestamp')
  final Object? deleteTimestamp;
  @JsonKey(name: 'unreadCount')
  final Object? unreadCount;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$UserConversationDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserConversationDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.chatName, chatName) ||
                const DeepCollectionEquality().equals(
                  other.chatName,
                  chatName,
                )) &&
            (identical(other.isGroupChat, isGroupChat) ||
                const DeepCollectionEquality().equals(
                  other.isGroupChat,
                  isGroupChat,
                )) &&
            (identical(other.chatId, chatId) ||
                const DeepCollectionEquality().equals(other.chatId, chatId)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.deleteTimestamp, deleteTimestamp) ||
                const DeepCollectionEquality().equals(
                  other.deleteTimestamp,
                  deleteTimestamp,
                )) &&
            (identical(other.unreadCount, unreadCount) ||
                const DeepCollectionEquality().equals(
                  other.unreadCount,
                  unreadCount,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(chatName) ^
      const DeepCollectionEquality().hash(isGroupChat) ^
      const DeepCollectionEquality().hash(chatId) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(deleteTimestamp) ^
      const DeepCollectionEquality().hash(unreadCount) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(receiver) ^
      runtimeType.hashCode;
}

extension $UserConversationDocHydratedExtension on UserConversationDocHydrated {
  UserConversationDocHydrated copyWith({
    enums.UserConversationDocHydratedDataType? dataType,
    Object? chatName,
    bool? isGroupChat,
    String? chatId,
    MessageDto? message,
    Object? deleteTimestamp,
    Object? unreadCount,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return UserConversationDocHydrated(
      dataType: dataType ?? this.dataType,
      chatName: chatName ?? this.chatName,
      isGroupChat: isGroupChat ?? this.isGroupChat,
      chatId: chatId ?? this.chatId,
      message: message ?? this.message,
      deleteTimestamp: deleteTimestamp ?? this.deleteTimestamp,
      unreadCount: unreadCount ?? this.unreadCount,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  UserConversationDocHydrated copyWithWrapped({
    Wrapped<enums.UserConversationDocHydratedDataType>? dataType,
    Wrapped<Object?>? chatName,
    Wrapped<bool>? isGroupChat,
    Wrapped<String>? chatId,
    Wrapped<MessageDto>? message,
    Wrapped<Object?>? deleteTimestamp,
    Wrapped<Object?>? unreadCount,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return UserConversationDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      chatName: (chatName != null ? chatName.value : this.chatName),
      isGroupChat: (isGroupChat != null ? isGroupChat.value : this.isGroupChat),
      chatId: (chatId != null ? chatId.value : this.chatId),
      message: (message != null ? message.value : this.message),
      deleteTimestamp: (deleteTimestamp != null
          ? deleteTimestamp.value
          : this.deleteTimestamp),
      unreadCount: (unreadCount != null ? unreadCount.value : this.unreadCount),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserConversationPaginated {
  const UserConversationPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory UserConversationPaginated.fromJson(Map<String, dynamic> json) =>
      _$UserConversationPaginatedFromJson(json);

  static const toJsonFactory = _$UserConversationPaginatedToJson;
  Map<String, dynamic> toJson() => _$UserConversationPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <UserConversationDocHydrated>[])
  final List<UserConversationDocHydrated> resources;
  static const fromJsonFactory = _$UserConversationPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserConversationPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $UserConversationPaginatedExtension on UserConversationPaginated {
  UserConversationPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<UserConversationDocHydrated>? resources,
  }) {
    return UserConversationPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  UserConversationPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<UserConversationDocHydrated>>? resources,
  }) {
    return UserConversationPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessagePaginated {
  const ChatMessagePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
    required this.receiver,
  });

  factory ChatMessagePaginated.fromJson(Map<String, dynamic> json) =>
      _$ChatMessagePaginatedFromJson(json);

  static const toJsonFactory = _$ChatMessagePaginatedToJson;
  Map<String, dynamic> toJson() => _$ChatMessagePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <ChatMessageDocHydrated>[])
  final List<ChatMessageDocHydrated> resources;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$ChatMessagePaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChatMessagePaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      const DeepCollectionEquality().hash(receiver) ^
      runtimeType.hashCode;
}

extension $ChatMessagePaginatedExtension on ChatMessagePaginated {
  ChatMessagePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<ChatMessageDocHydrated>? resources,
    OwnerDto? receiver,
  }) {
    return ChatMessagePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
      receiver: receiver ?? this.receiver,
    );
  }

  ChatMessagePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<ChatMessageDocHydrated>>? resources,
    Wrapped<OwnerDto>? receiver,
  }) {
    return ChatMessagePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UnreadMessageCountByChatIdDto {
  const UnreadMessageCountByChatIdDto({
    required this.unreadCount,
    required this.chatId,
  });

  factory UnreadMessageCountByChatIdDto.fromJson(Map<String, dynamic> json) =>
      _$UnreadMessageCountByChatIdDtoFromJson(json);

  static const toJsonFactory = _$UnreadMessageCountByChatIdDtoToJson;
  Map<String, dynamic> toJson() => _$UnreadMessageCountByChatIdDtoToJson(this);

  @JsonKey(name: 'unreadCount')
  final double unreadCount;
  @JsonKey(name: 'chatId')
  final String chatId;
  static const fromJsonFactory = _$UnreadMessageCountByChatIdDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UnreadMessageCountByChatIdDto &&
            (identical(other.unreadCount, unreadCount) ||
                const DeepCollectionEquality().equals(
                  other.unreadCount,
                  unreadCount,
                )) &&
            (identical(other.chatId, chatId) ||
                const DeepCollectionEquality().equals(other.chatId, chatId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(unreadCount) ^
      const DeepCollectionEquality().hash(chatId) ^
      runtimeType.hashCode;
}

extension $UnreadMessageCountByChatIdDtoExtension
    on UnreadMessageCountByChatIdDto {
  UnreadMessageCountByChatIdDto copyWith({
    double? unreadCount,
    String? chatId,
  }) {
    return UnreadMessageCountByChatIdDto(
      unreadCount: unreadCount ?? this.unreadCount,
      chatId: chatId ?? this.chatId,
    );
  }

  UnreadMessageCountByChatIdDto copyWithWrapped({
    Wrapped<double>? unreadCount,
    Wrapped<String>? chatId,
  }) {
    return UnreadMessageCountByChatIdDto(
      unreadCount: (unreadCount != null ? unreadCount.value : this.unreadCount),
      chatId: (chatId != null ? chatId.value : this.chatId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalConversationSummaryDto {
  const GlobalConversationSummaryDto({
    required this.totalUnreadChats,
    required this.totalUnreadMessages,
    required this.unreadMessageCountByChatId,
  });

  factory GlobalConversationSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$GlobalConversationSummaryDtoFromJson(json);

  static const toJsonFactory = _$GlobalConversationSummaryDtoToJson;
  Map<String, dynamic> toJson() => _$GlobalConversationSummaryDtoToJson(this);

  @JsonKey(name: 'totalUnreadChats')
  final double totalUnreadChats;
  @JsonKey(name: 'totalUnreadMessages')
  final double totalUnreadMessages;
  @JsonKey(
    name: 'unreadMessageCountByChatId',
    defaultValue: <UnreadMessageCountByChatIdDto>[],
  )
  final List<UnreadMessageCountByChatIdDto> unreadMessageCountByChatId;
  static const fromJsonFactory = _$GlobalConversationSummaryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GlobalConversationSummaryDto &&
            (identical(other.totalUnreadChats, totalUnreadChats) ||
                const DeepCollectionEquality().equals(
                  other.totalUnreadChats,
                  totalUnreadChats,
                )) &&
            (identical(other.totalUnreadMessages, totalUnreadMessages) ||
                const DeepCollectionEquality().equals(
                  other.totalUnreadMessages,
                  totalUnreadMessages,
                )) &&
            (identical(
                  other.unreadMessageCountByChatId,
                  unreadMessageCountByChatId,
                ) ||
                const DeepCollectionEquality().equals(
                  other.unreadMessageCountByChatId,
                  unreadMessageCountByChatId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalUnreadChats) ^
      const DeepCollectionEquality().hash(totalUnreadMessages) ^
      const DeepCollectionEquality().hash(unreadMessageCountByChatId) ^
      runtimeType.hashCode;
}

extension $GlobalConversationSummaryDtoExtension
    on GlobalConversationSummaryDto {
  GlobalConversationSummaryDto copyWith({
    double? totalUnreadChats,
    double? totalUnreadMessages,
    List<UnreadMessageCountByChatIdDto>? unreadMessageCountByChatId,
  }) {
    return GlobalConversationSummaryDto(
      totalUnreadChats: totalUnreadChats ?? this.totalUnreadChats,
      totalUnreadMessages: totalUnreadMessages ?? this.totalUnreadMessages,
      unreadMessageCountByChatId:
          unreadMessageCountByChatId ?? this.unreadMessageCountByChatId,
    );
  }

  GlobalConversationSummaryDto copyWithWrapped({
    Wrapped<double>? totalUnreadChats,
    Wrapped<double>? totalUnreadMessages,
    Wrapped<List<UnreadMessageCountByChatIdDto>>? unreadMessageCountByChatId,
  }) {
    return GlobalConversationSummaryDto(
      totalUnreadChats: (totalUnreadChats != null
          ? totalUnreadChats.value
          : this.totalUnreadChats),
      totalUnreadMessages: (totalUnreadMessages != null
          ? totalUnreadMessages.value
          : this.totalUnreadMessages),
      unreadMessageCountByChatId: (unreadMessageCountByChatId != null
          ? unreadMessageCountByChatId.value
          : this.unreadMessageCountByChatId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBlockDocHydrated {
  const UserBlockDocHydrated({
    required this.dataType,
    required this.timestamp,
    required this.id,
    required this.pk,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory UserBlockDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$UserBlockDocHydratedFromJson(json);

  static const toJsonFactory = _$UserBlockDocHydratedToJson;
  Map<String, dynamic> toJson() => _$UserBlockDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userBlockDocHydratedDataTypeToJson,
    fromJson: userBlockDocHydratedDataTypeDataTypeFromJson,
  )
  final enums.UserBlockDocHydratedDataType dataType;
  static enums.UserBlockDocHydratedDataType
  userBlockDocHydratedDataTypeDataTypeFromJson(Object? value) =>
      userBlockDocHydratedDataTypeFromJson(
        value,
        enums.UserBlockDocHydratedDataType.blockeduser,
      );

  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$UserBlockDocHydratedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserBlockDocHydrated &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.sender, sender) ||
                const DeepCollectionEquality().equals(other.sender, sender)) &&
            (identical(other.receiver, receiver) ||
                const DeepCollectionEquality().equals(
                  other.receiver,
                  receiver,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(sender) ^
      const DeepCollectionEquality().hash(receiver) ^
      runtimeType.hashCode;
}

extension $UserBlockDocHydratedExtension on UserBlockDocHydrated {
  UserBlockDocHydrated copyWith({
    enums.UserBlockDocHydratedDataType? dataType,
    Object? timestamp,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return UserBlockDocHydrated(
      dataType: dataType ?? this.dataType,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  UserBlockDocHydrated copyWithWrapped({
    Wrapped<enums.UserBlockDocHydratedDataType>? dataType,
    Wrapped<Object>? timestamp,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return UserBlockDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBlockPaginated {
  const UserBlockPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory UserBlockPaginated.fromJson(Map<String, dynamic> json) =>
      _$UserBlockPaginatedFromJson(json);

  static const toJsonFactory = _$UserBlockPaginatedToJson;
  Map<String, dynamic> toJson() => _$UserBlockPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <UserBlockDocHydrated>[])
  final List<UserBlockDocHydrated> resources;
  static const fromJsonFactory = _$UserBlockPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserBlockPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $UserBlockPaginatedExtension on UserBlockPaginated {
  UserBlockPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<UserBlockDocHydrated>? resources,
  }) {
    return UserBlockPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  UserBlockPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<UserBlockDocHydrated>>? resources,
  }) {
    return UserBlockPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WebSocketTokenDto {
  const WebSocketTokenDto({required this.token});

  factory WebSocketTokenDto.fromJson(Map<String, dynamic> json) =>
      _$WebSocketTokenDtoFromJson(json);

  static const toJsonFactory = _$WebSocketTokenDtoToJson;
  Map<String, dynamic> toJson() => _$WebSocketTokenDtoToJson(this);

  @JsonKey(name: 'token')
  final String token;
  static const fromJsonFactory = _$WebSocketTokenDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WebSocketTokenDto &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^ runtimeType.hashCode;
}

extension $WebSocketTokenDtoExtension on WebSocketTokenDto {
  WebSocketTokenDto copyWith({String? token}) {
    return WebSocketTokenDto(token: token ?? this.token);
  }

  WebSocketTokenDto copyWithWrapped({Wrapped<String>? token}) {
    return WebSocketTokenDto(token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class RegistrationDetailsCreateDto {
  const RegistrationDetailsCreateDto({
    required this.visibility,
    required this.maxLimit,
    required this.userLimit,
    required this.requireKYC,
    required this.requireName,
    required this.requireEmail,
    required this.requirePhoneNumber,
    required this.isPublished,
    required this.hasSideEvents,
    required this.hasWaitlist,
    required this.showGuestCount,
    required this.refundable,
    required this.nameWithNumber,
    required this.botProtection,
  });

  factory RegistrationDetailsCreateDto.fromJson(Map<String, dynamic> json) =>
      _$RegistrationDetailsCreateDtoFromJson(json);

  static const toJsonFactory = _$RegistrationDetailsCreateDtoToJson;
  Map<String, dynamic> toJson() => _$RegistrationDetailsCreateDtoToJson(this);

  @JsonKey(
    name: 'visibility',
    toJson: visibilityToJson,
    fromJson: visibilityFromJson,
  )
  final enums.Visibility visibility;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'requireKYC')
  final bool requireKYC;
  @JsonKey(name: 'requireName')
  final bool requireName;
  @JsonKey(name: 'requireEmail')
  final bool requireEmail;
  @JsonKey(name: 'requirePhoneNumber')
  final bool requirePhoneNumber;
  @JsonKey(name: 'isPublished')
  final bool isPublished;
  @JsonKey(name: 'hasSideEvents')
  final bool hasSideEvents;
  @JsonKey(name: 'hasWaitlist')
  final bool hasWaitlist;
  @JsonKey(name: 'showGuestCount')
  final bool showGuestCount;
  @JsonKey(name: 'refundable')
  final bool refundable;
  @JsonKey(name: 'nameWithNumber')
  final bool nameWithNumber;
  @JsonKey(name: 'botProtection')
  final bool botProtection;
  static const fromJsonFactory = _$RegistrationDetailsCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RegistrationDetailsCreateDto &&
            (identical(other.visibility, visibility) ||
                const DeepCollectionEquality().equals(
                  other.visibility,
                  visibility,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.requireKYC, requireKYC) ||
                const DeepCollectionEquality().equals(
                  other.requireKYC,
                  requireKYC,
                )) &&
            (identical(other.requireName, requireName) ||
                const DeepCollectionEquality().equals(
                  other.requireName,
                  requireName,
                )) &&
            (identical(other.requireEmail, requireEmail) ||
                const DeepCollectionEquality().equals(
                  other.requireEmail,
                  requireEmail,
                )) &&
            (identical(other.requirePhoneNumber, requirePhoneNumber) ||
                const DeepCollectionEquality().equals(
                  other.requirePhoneNumber,
                  requirePhoneNumber,
                )) &&
            (identical(other.isPublished, isPublished) ||
                const DeepCollectionEquality().equals(
                  other.isPublished,
                  isPublished,
                )) &&
            (identical(other.hasSideEvents, hasSideEvents) ||
                const DeepCollectionEquality().equals(
                  other.hasSideEvents,
                  hasSideEvents,
                )) &&
            (identical(other.hasWaitlist, hasWaitlist) ||
                const DeepCollectionEquality().equals(
                  other.hasWaitlist,
                  hasWaitlist,
                )) &&
            (identical(other.showGuestCount, showGuestCount) ||
                const DeepCollectionEquality().equals(
                  other.showGuestCount,
                  showGuestCount,
                )) &&
            (identical(other.refundable, refundable) ||
                const DeepCollectionEquality().equals(
                  other.refundable,
                  refundable,
                )) &&
            (identical(other.nameWithNumber, nameWithNumber) ||
                const DeepCollectionEquality().equals(
                  other.nameWithNumber,
                  nameWithNumber,
                )) &&
            (identical(other.botProtection, botProtection) ||
                const DeepCollectionEquality().equals(
                  other.botProtection,
                  botProtection,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(visibility) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(requireKYC) ^
      const DeepCollectionEquality().hash(requireName) ^
      const DeepCollectionEquality().hash(requireEmail) ^
      const DeepCollectionEquality().hash(requirePhoneNumber) ^
      const DeepCollectionEquality().hash(isPublished) ^
      const DeepCollectionEquality().hash(hasSideEvents) ^
      const DeepCollectionEquality().hash(hasWaitlist) ^
      const DeepCollectionEquality().hash(showGuestCount) ^
      const DeepCollectionEquality().hash(refundable) ^
      const DeepCollectionEquality().hash(nameWithNumber) ^
      const DeepCollectionEquality().hash(botProtection) ^
      runtimeType.hashCode;
}

extension $RegistrationDetailsCreateDtoExtension
    on RegistrationDetailsCreateDto {
  RegistrationDetailsCreateDto copyWith({
    enums.Visibility? visibility,
    int? maxLimit,
    int? userLimit,
    bool? requireKYC,
    bool? requireName,
    bool? requireEmail,
    bool? requirePhoneNumber,
    bool? isPublished,
    bool? hasSideEvents,
    bool? hasWaitlist,
    bool? showGuestCount,
    bool? refundable,
    bool? nameWithNumber,
    bool? botProtection,
  }) {
    return RegistrationDetailsCreateDto(
      visibility: visibility ?? this.visibility,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      requireKYC: requireKYC ?? this.requireKYC,
      requireName: requireName ?? this.requireName,
      requireEmail: requireEmail ?? this.requireEmail,
      requirePhoneNumber: requirePhoneNumber ?? this.requirePhoneNumber,
      isPublished: isPublished ?? this.isPublished,
      hasSideEvents: hasSideEvents ?? this.hasSideEvents,
      hasWaitlist: hasWaitlist ?? this.hasWaitlist,
      showGuestCount: showGuestCount ?? this.showGuestCount,
      refundable: refundable ?? this.refundable,
      nameWithNumber: nameWithNumber ?? this.nameWithNumber,
      botProtection: botProtection ?? this.botProtection,
    );
  }

  RegistrationDetailsCreateDto copyWithWrapped({
    Wrapped<enums.Visibility>? visibility,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? requireKYC,
    Wrapped<bool>? requireName,
    Wrapped<bool>? requireEmail,
    Wrapped<bool>? requirePhoneNumber,
    Wrapped<bool>? isPublished,
    Wrapped<bool>? hasSideEvents,
    Wrapped<bool>? hasWaitlist,
    Wrapped<bool>? showGuestCount,
    Wrapped<bool>? refundable,
    Wrapped<bool>? nameWithNumber,
    Wrapped<bool>? botProtection,
  }) {
    return RegistrationDetailsCreateDto(
      visibility: (visibility != null ? visibility.value : this.visibility),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      requireKYC: (requireKYC != null ? requireKYC.value : this.requireKYC),
      requireName: (requireName != null ? requireName.value : this.requireName),
      requireEmail: (requireEmail != null
          ? requireEmail.value
          : this.requireEmail),
      requirePhoneNumber: (requirePhoneNumber != null
          ? requirePhoneNumber.value
          : this.requirePhoneNumber),
      isPublished: (isPublished != null ? isPublished.value : this.isPublished),
      hasSideEvents: (hasSideEvents != null
          ? hasSideEvents.value
          : this.hasSideEvents),
      hasWaitlist: (hasWaitlist != null ? hasWaitlist.value : this.hasWaitlist),
      showGuestCount: (showGuestCount != null
          ? showGuestCount.value
          : this.showGuestCount),
      refundable: (refundable != null ? refundable.value : this.refundable),
      nameWithNumber: (nameWithNumber != null
          ? nameWithNumber.value
          : this.nameWithNumber),
      botProtection: (botProtection != null
          ? botProtection.value
          : this.botProtection),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileCreateDto {
  const EventProfileCreateDto({
    required this.title,
    required this.startTime,
    required this.endTime,
    required this.location,
    required this.isVirtualEvent,
    this.slug,
    required this.category,
    this.subCategory,
    this.seo,
    required this.registration,
  });

  factory EventProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileCreateDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'location')
  final EventLocationDto location;
  @JsonKey(name: 'isVirtualEvent')
  final bool isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryToJson,
    fromJson: eventCategoryFromJson,
  )
  final enums.EventCategory category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'registration')
  final RegistrationDetailsCreateDto registration;
  static const fromJsonFactory = _$EventProfileCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfileCreateDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.isVirtualEvent, isVirtualEvent) ||
                const DeepCollectionEquality().equals(
                  other.isVirtualEvent,
                  isVirtualEvent,
                )) &&
            (identical(other.slug, slug) ||
                const DeepCollectionEquality().equals(other.slug, slug)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.subCategory, subCategory) ||
                const DeepCollectionEquality().equals(
                  other.subCategory,
                  subCategory,
                )) &&
            (identical(other.seo, seo) ||
                const DeepCollectionEquality().equals(other.seo, seo)) &&
            (identical(other.registration, registration) ||
                const DeepCollectionEquality().equals(
                  other.registration,
                  registration,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(isVirtualEvent) ^
      const DeepCollectionEquality().hash(slug) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(subCategory) ^
      const DeepCollectionEquality().hash(seo) ^
      const DeepCollectionEquality().hash(registration) ^
      runtimeType.hashCode;
}

extension $EventProfileCreateDtoExtension on EventProfileCreateDto {
  EventProfileCreateDto copyWith({
    String? title,
    int? startTime,
    int? endTime,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    EventSeoDto? seo,
    RegistrationDetailsCreateDto? registration,
  }) {
    return EventProfileCreateDto(
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      seo: seo ?? this.seo,
      registration: registration ?? this.registration,
    );
  }

  EventProfileCreateDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<EventLocationDto>? location,
    Wrapped<bool>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<enums.EventCategory>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<RegistrationDetailsCreateDto>? registration,
  }) {
    return EventProfileCreateDto(
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      seo: (seo != null ? seo.value : this.seo),
      registration: (registration != null
          ? registration.value
          : this.registration),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileFilterCriteriaDto {
  const EventProfileFilterCriteriaDto({
    this.searchText,
    this.area,
    this.range,
    this.category,
    this.subCategory,
  });

  factory EventProfileFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventProfileFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'area', defaultValue: <String>[])
  final List<String>? area;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'subCategory', defaultValue: <String>[])
  final List<String>? subCategory;
  static const fromJsonFactory = _$EventProfileFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfileFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.area, area) ||
                const DeepCollectionEquality().equals(other.area, area)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.subCategory, subCategory) ||
                const DeepCollectionEquality().equals(
                  other.subCategory,
                  subCategory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(area) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(subCategory) ^
      runtimeType.hashCode;
}

extension $EventProfileFilterCriteriaDtoExtension
    on EventProfileFilterCriteriaDto {
  EventProfileFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? area,
    List<RangeFilter>? range,
    List<String>? category,
    List<String>? subCategory,
  }) {
    return EventProfileFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      area: area ?? this.area,
      range: range ?? this.range,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
    );
  }

  EventProfileFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? area,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<List<String>?>? category,
    Wrapped<List<String>?>? subCategory,
  }) {
    return EventProfileFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      area: (area != null ? area.value : this.area),
      range: (range != null ? range.value : this.range),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventExtraProperties {
  const EventExtraProperties({
    this.creatorProfile,
    this.guestSummary,
    this.startsFrom,
  });

  factory EventExtraProperties.fromJson(Map<String, dynamic> json) =>
      _$EventExtraPropertiesFromJson(json);

  static const toJsonFactory = _$EventExtraPropertiesToJson;
  Map<String, dynamic> toJson() => _$EventExtraPropertiesToJson(this);

  @JsonKey(name: 'creatorProfile')
  final bool? creatorProfile;
  @JsonKey(name: 'guestSummary')
  final bool? guestSummary;
  @JsonKey(name: 'startsFrom')
  final bool? startsFrom;
  static const fromJsonFactory = _$EventExtraPropertiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventExtraProperties &&
            (identical(other.creatorProfile, creatorProfile) ||
                const DeepCollectionEquality().equals(
                  other.creatorProfile,
                  creatorProfile,
                )) &&
            (identical(other.guestSummary, guestSummary) ||
                const DeepCollectionEquality().equals(
                  other.guestSummary,
                  guestSummary,
                )) &&
            (identical(other.startsFrom, startsFrom) ||
                const DeepCollectionEquality().equals(
                  other.startsFrom,
                  startsFrom,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(creatorProfile) ^
      const DeepCollectionEquality().hash(guestSummary) ^
      const DeepCollectionEquality().hash(startsFrom) ^
      runtimeType.hashCode;
}

extension $EventExtraPropertiesExtension on EventExtraProperties {
  EventExtraProperties copyWith({
    bool? creatorProfile,
    bool? guestSummary,
    bool? startsFrom,
  }) {
    return EventExtraProperties(
      creatorProfile: creatorProfile ?? this.creatorProfile,
      guestSummary: guestSummary ?? this.guestSummary,
      startsFrom: startsFrom ?? this.startsFrom,
    );
  }

  EventExtraProperties copyWithWrapped({
    Wrapped<bool?>? creatorProfile,
    Wrapped<bool?>? guestSummary,
    Wrapped<bool?>? startsFrom,
  }) {
    return EventExtraProperties(
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      guestSummary: (guestSummary != null
          ? guestSummary.value
          : this.guestSummary),
      startsFrom: (startsFrom != null ? startsFrom.value : this.startsFrom),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileFilter {
  const EventProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
    this.extraProperties,
  });

  factory EventProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFilterFromJson(json);

  static const toJsonFactory = _$EventProfileFilterToJson;
  Map<String, dynamic> toJson() => _$EventProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventProfileFilterCriteriaDto filters;
  @JsonKey(name: 'extraProperties')
  final EventExtraProperties? extraProperties;
  static const fromJsonFactory = _$EventProfileFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfileFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(
                  other.filters,
                  filters,
                )) &&
            (identical(other.extraProperties, extraProperties) ||
                const DeepCollectionEquality().equals(
                  other.extraProperties,
                  extraProperties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      const DeepCollectionEquality().hash(extraProperties) ^
      runtimeType.hashCode;
}

extension $EventProfileFilterExtension on EventProfileFilter {
  EventProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventProfileFilterCriteriaDto? filters,
    EventExtraProperties? extraProperties,
  }) {
    return EventProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  EventProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventProfileFilterCriteriaDto>? filters,
    Wrapped<EventExtraProperties?>? extraProperties,
  }) {
    return EventProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileQuery {
  const EventProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$EventProfileQueryFromJson(json);

  static const toJsonFactory = _$EventProfileQueryToJson;
  Map<String, dynamic> toJson() => _$EventProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventProfile>[])
  final List<EventProfile> resources;
  static const fromJsonFactory = _$EventProfileQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfileQuery &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventProfileQueryExtension on EventProfileQuery {
  EventProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventProfile>? resources,
  }) {
    return EventProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventProfile>>? resources,
  }) {
    return EventProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileEditDto {
  const EventProfileEditDto({
    this.title,
    this.startTime,
    this.endTime,
    this.location,
    this.isVirtualEvent,
    this.slug,
    this.category,
    this.subCategory,
    this.seo,
    this.registration,
  });

  factory EventProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileEditDtoToJson(this);

  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'startTime')
  final int? startTime;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'location')
  final EventLocationDto? location;
  @JsonKey(name: 'isVirtualEvent')
  final bool? isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryNullableToJson,
    fromJson: eventCategoryNullableFromJson,
  )
  final enums.EventCategory? category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'registration')
  final RegistrationDetailsCreateDto? registration;
  static const fromJsonFactory = _$EventProfileEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventProfileEditDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality().equals(
                  other.location,
                  location,
                )) &&
            (identical(other.isVirtualEvent, isVirtualEvent) ||
                const DeepCollectionEquality().equals(
                  other.isVirtualEvent,
                  isVirtualEvent,
                )) &&
            (identical(other.slug, slug) ||
                const DeepCollectionEquality().equals(other.slug, slug)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.subCategory, subCategory) ||
                const DeepCollectionEquality().equals(
                  other.subCategory,
                  subCategory,
                )) &&
            (identical(other.seo, seo) ||
                const DeepCollectionEquality().equals(other.seo, seo)) &&
            (identical(other.registration, registration) ||
                const DeepCollectionEquality().equals(
                  other.registration,
                  registration,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(isVirtualEvent) ^
      const DeepCollectionEquality().hash(slug) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(subCategory) ^
      const DeepCollectionEquality().hash(seo) ^
      const DeepCollectionEquality().hash(registration) ^
      runtimeType.hashCode;
}

extension $EventProfileEditDtoExtension on EventProfileEditDto {
  EventProfileEditDto copyWith({
    String? title,
    int? startTime,
    int? endTime,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    EventSeoDto? seo,
    RegistrationDetailsCreateDto? registration,
  }) {
    return EventProfileEditDto(
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      seo: seo ?? this.seo,
      registration: registration ?? this.registration,
    );
  }

  EventProfileEditDto copyWithWrapped({
    Wrapped<String?>? title,
    Wrapped<int?>? startTime,
    Wrapped<int?>? endTime,
    Wrapped<EventLocationDto?>? location,
    Wrapped<bool?>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<enums.EventCategory?>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<RegistrationDetailsCreateDto?>? registration,
  }) {
    return EventProfileEditDto(
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      seo: (seo != null ? seo.value : this.seo),
      registration: (registration != null
          ? registration.value
          : this.registration),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketSelectionDto {
  const TicketSelectionDto({
    required this.ticketProfileId,
    required this.ticketStageId,
    required this.quantity,
    this.price,
    this.name,
    this.description,
    this.currency,
  });

  factory TicketSelectionDto.fromJson(Map<String, dynamic> json) =>
      _$TicketSelectionDtoFromJson(json);

  static const toJsonFactory = _$TicketSelectionDtoToJson;
  Map<String, dynamic> toJson() => _$TicketSelectionDtoToJson(this);

  @JsonKey(name: 'ticketProfileId')
  final String ticketProfileId;
  @JsonKey(name: 'ticketStageId')
  final String ticketStageId;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$TicketSelectionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketSelectionDto &&
            (identical(other.ticketProfileId, ticketProfileId) ||
                const DeepCollectionEquality().equals(
                  other.ticketProfileId,
                  ticketProfileId,
                )) &&
            (identical(other.ticketStageId, ticketStageId) ||
                const DeepCollectionEquality().equals(
                  other.ticketStageId,
                  ticketStageId,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ticketProfileId) ^
      const DeepCollectionEquality().hash(ticketStageId) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $TicketSelectionDtoExtension on TicketSelectionDto {
  TicketSelectionDto copyWith({
    String? ticketProfileId,
    String? ticketStageId,
    int? quantity,
    double? price,
    String? name,
    String? description,
    String? currency,
  }) {
    return TicketSelectionDto(
      ticketProfileId: ticketProfileId ?? this.ticketProfileId,
      ticketStageId: ticketStageId ?? this.ticketStageId,
      quantity: quantity ?? this.quantity,
      price: price ?? this.price,
      name: name ?? this.name,
      description: description ?? this.description,
      currency: currency ?? this.currency,
    );
  }

  TicketSelectionDto copyWithWrapped({
    Wrapped<String>? ticketProfileId,
    Wrapped<String>? ticketStageId,
    Wrapped<int>? quantity,
    Wrapped<double?>? price,
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? currency,
  }) {
    return TicketSelectionDto(
      ticketProfileId: (ticketProfileId != null
          ? ticketProfileId.value
          : this.ticketProfileId),
      ticketStageId: (ticketStageId != null
          ? ticketStageId.value
          : this.ticketStageId),
      quantity: (quantity != null ? quantity.value : this.quantity),
      price: (price != null ? price.value : this.price),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      currency: (currency != null ? currency.value : this.currency),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionAnswerDto {
  const EventQuestionAnswerDto({
    required this.questionId,
    required this.answer,
  });

  factory EventQuestionAnswerDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionAnswerDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionAnswerDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionAnswerDtoToJson(this);

  @JsonKey(name: 'questionId')
  final String questionId;
  @JsonKey(name: 'answer')
  final Object answer;
  static const fromJsonFactory = _$EventQuestionAnswerDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventQuestionAnswerDto &&
            (identical(other.questionId, questionId) ||
                const DeepCollectionEquality().equals(
                  other.questionId,
                  questionId,
                )) &&
            (identical(other.answer, answer) ||
                const DeepCollectionEquality().equals(other.answer, answer)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(questionId) ^
      const DeepCollectionEquality().hash(answer) ^
      runtimeType.hashCode;
}

extension $EventQuestionAnswerDtoExtension on EventQuestionAnswerDto {
  EventQuestionAnswerDto copyWith({String? questionId, Object? answer}) {
    return EventQuestionAnswerDto(
      questionId: questionId ?? this.questionId,
      answer: answer ?? this.answer,
    );
  }

  EventQuestionAnswerDto copyWithWrapped({
    Wrapped<String>? questionId,
    Wrapped<Object>? answer,
  }) {
    return EventQuestionAnswerDto(
      questionId: (questionId != null ? questionId.value : this.questionId),
      answer: (answer != null ? answer.value : this.answer),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CallbackUrl {
  const CallbackUrl({
    required this.success,
    required this.error,
    required this.successClose,
    required this.errorClose,
  });

  factory CallbackUrl.fromJson(Map<String, dynamic> json) =>
      _$CallbackUrlFromJson(json);

  static const toJsonFactory = _$CallbackUrlToJson;
  Map<String, dynamic> toJson() => _$CallbackUrlToJson(this);

  @JsonKey(name: 'success')
  final String success;
  @JsonKey(name: 'error')
  final String error;
  @JsonKey(name: 'successClose')
  final String successClose;
  @JsonKey(name: 'errorClose')
  final String errorClose;
  static const fromJsonFactory = _$CallbackUrlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CallbackUrl &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.successClose, successClose) ||
                const DeepCollectionEquality().equals(
                  other.successClose,
                  successClose,
                )) &&
            (identical(other.errorClose, errorClose) ||
                const DeepCollectionEquality().equals(
                  other.errorClose,
                  errorClose,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(successClose) ^
      const DeepCollectionEquality().hash(errorClose) ^
      runtimeType.hashCode;
}

extension $CallbackUrlExtension on CallbackUrl {
  CallbackUrl copyWith({
    String? success,
    String? error,
    String? successClose,
    String? errorClose,
  }) {
    return CallbackUrl(
      success: success ?? this.success,
      error: error ?? this.error,
      successClose: successClose ?? this.successClose,
      errorClose: errorClose ?? this.errorClose,
    );
  }

  CallbackUrl copyWithWrapped({
    Wrapped<String>? success,
    Wrapped<String>? error,
    Wrapped<String>? successClose,
    Wrapped<String>? errorClose,
  }) {
    return CallbackUrl(
      success: (success != null ? success.value : this.success),
      error: (error != null ? error.value : this.error),
      successClose: (successClose != null
          ? successClose.value
          : this.successClose),
      errorClose: (errorClose != null ? errorClose.value : this.errorClose),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestRegistrationDto {
  const EventGuestRegistrationDto({
    this.email,
    this.name,
    this.phone,
    this.ticketSelections,
    this.voucherCode,
    this.referralCode,
    this.payWithCrypto,
    this.currency,
    this.questionAnswers,
    this.callbackUrl,
  });

  factory EventGuestRegistrationDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestRegistrationDtoFromJson(json);

  static const toJsonFactory = _$EventGuestRegistrationDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestRegistrationDtoToJson(this);

  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'ticketSelections', defaultValue: <TicketSelectionDto>[])
  final List<TicketSelectionDto>? ticketSelections;
  @JsonKey(name: 'voucherCode')
  final String? voucherCode;
  @JsonKey(name: 'referralCode')
  final String? referralCode;
  @JsonKey(name: 'payWithCrypto', defaultValue: false)
  final bool? payWithCrypto;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'questionAnswers', defaultValue: <EventQuestionAnswerDto>[])
  final List<EventQuestionAnswerDto>? questionAnswers;
  @JsonKey(name: 'callbackUrl')
  final CallbackUrl? callbackUrl;
  static const fromJsonFactory = _$EventGuestRegistrationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestRegistrationDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.ticketSelections, ticketSelections) ||
                const DeepCollectionEquality().equals(
                  other.ticketSelections,
                  ticketSelections,
                )) &&
            (identical(other.voucherCode, voucherCode) ||
                const DeepCollectionEquality().equals(
                  other.voucherCode,
                  voucherCode,
                )) &&
            (identical(other.referralCode, referralCode) ||
                const DeepCollectionEquality().equals(
                  other.referralCode,
                  referralCode,
                )) &&
            (identical(other.payWithCrypto, payWithCrypto) ||
                const DeepCollectionEquality().equals(
                  other.payWithCrypto,
                  payWithCrypto,
                )) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )) &&
            (identical(other.questionAnswers, questionAnswers) ||
                const DeepCollectionEquality().equals(
                  other.questionAnswers,
                  questionAnswers,
                )) &&
            (identical(other.callbackUrl, callbackUrl) ||
                const DeepCollectionEquality().equals(
                  other.callbackUrl,
                  callbackUrl,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(ticketSelections) ^
      const DeepCollectionEquality().hash(voucherCode) ^
      const DeepCollectionEquality().hash(referralCode) ^
      const DeepCollectionEquality().hash(payWithCrypto) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(questionAnswers) ^
      const DeepCollectionEquality().hash(callbackUrl) ^
      runtimeType.hashCode;
}

extension $EventGuestRegistrationDtoExtension on EventGuestRegistrationDto {
  EventGuestRegistrationDto copyWith({
    String? email,
    String? name,
    String? phone,
    List<TicketSelectionDto>? ticketSelections,
    String? voucherCode,
    String? referralCode,
    bool? payWithCrypto,
    String? currency,
    List<EventQuestionAnswerDto>? questionAnswers,
    CallbackUrl? callbackUrl,
  }) {
    return EventGuestRegistrationDto(
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      ticketSelections: ticketSelections ?? this.ticketSelections,
      voucherCode: voucherCode ?? this.voucherCode,
      referralCode: referralCode ?? this.referralCode,
      payWithCrypto: payWithCrypto ?? this.payWithCrypto,
      currency: currency ?? this.currency,
      questionAnswers: questionAnswers ?? this.questionAnswers,
      callbackUrl: callbackUrl ?? this.callbackUrl,
    );
  }

  EventGuestRegistrationDto copyWithWrapped({
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
    Wrapped<List<TicketSelectionDto>?>? ticketSelections,
    Wrapped<String?>? voucherCode,
    Wrapped<String?>? referralCode,
    Wrapped<bool?>? payWithCrypto,
    Wrapped<String?>? currency,
    Wrapped<List<EventQuestionAnswerDto>?>? questionAnswers,
    Wrapped<CallbackUrl?>? callbackUrl,
  }) {
    return EventGuestRegistrationDto(
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      ticketSelections: (ticketSelections != null
          ? ticketSelections.value
          : this.ticketSelections),
      voucherCode: (voucherCode != null ? voucherCode.value : this.voucherCode),
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      payWithCrypto: (payWithCrypto != null
          ? payWithCrypto.value
          : this.payWithCrypto),
      currency: (currency != null ? currency.value : this.currency),
      questionAnswers: (questionAnswers != null
          ? questionAnswers.value
          : this.questionAnswers),
      callbackUrl: (callbackUrl != null ? callbackUrl.value : this.callbackUrl),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwispayPaymentFormData {
  const TwispayPaymentFormData({
    required this.base64JsonRequest,
    required this.base64Checksum,
  });

  factory TwispayPaymentFormData.fromJson(Map<String, dynamic> json) =>
      _$TwispayPaymentFormDataFromJson(json);

  static const toJsonFactory = _$TwispayPaymentFormDataToJson;
  Map<String, dynamic> toJson() => _$TwispayPaymentFormDataToJson(this);

  @JsonKey(name: 'base64JsonRequest')
  final String base64JsonRequest;
  @JsonKey(name: 'base64Checksum')
  final Object base64Checksum;
  static const fromJsonFactory = _$TwispayPaymentFormDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwispayPaymentFormData &&
            (identical(other.base64JsonRequest, base64JsonRequest) ||
                const DeepCollectionEquality().equals(
                  other.base64JsonRequest,
                  base64JsonRequest,
                )) &&
            (identical(other.base64Checksum, base64Checksum) ||
                const DeepCollectionEquality().equals(
                  other.base64Checksum,
                  base64Checksum,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(base64JsonRequest) ^
      const DeepCollectionEquality().hash(base64Checksum) ^
      runtimeType.hashCode;
}

extension $TwispayPaymentFormDataExtension on TwispayPaymentFormData {
  TwispayPaymentFormData copyWith({
    String? base64JsonRequest,
    Object? base64Checksum,
  }) {
    return TwispayPaymentFormData(
      base64JsonRequest: base64JsonRequest ?? this.base64JsonRequest,
      base64Checksum: base64Checksum ?? this.base64Checksum,
    );
  }

  TwispayPaymentFormData copyWithWrapped({
    Wrapped<String>? base64JsonRequest,
    Wrapped<Object>? base64Checksum,
  }) {
    return TwispayPaymentFormData(
      base64JsonRequest: (base64JsonRequest != null
          ? base64JsonRequest.value
          : this.base64JsonRequest),
      base64Checksum: (base64Checksum != null
          ? base64Checksum.value
          : this.base64Checksum),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StripePaymentFormData {
  const StripePaymentFormData({
    required this.sessionId,
    required this.publicKey,
  });

  factory StripePaymentFormData.fromJson(Map<String, dynamic> json) =>
      _$StripePaymentFormDataFromJson(json);

  static const toJsonFactory = _$StripePaymentFormDataToJson;
  Map<String, dynamic> toJson() => _$StripePaymentFormDataToJson(this);

  @JsonKey(name: 'sessionId')
  final String sessionId;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  static const fromJsonFactory = _$StripePaymentFormDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StripePaymentFormData &&
            (identical(other.sessionId, sessionId) ||
                const DeepCollectionEquality().equals(
                  other.sessionId,
                  sessionId,
                )) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality().equals(
                  other.publicKey,
                  publicKey,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sessionId) ^
      const DeepCollectionEquality().hash(publicKey) ^
      runtimeType.hashCode;
}

extension $StripePaymentFormDataExtension on StripePaymentFormData {
  StripePaymentFormData copyWith({String? sessionId, String? publicKey}) {
    return StripePaymentFormData(
      sessionId: sessionId ?? this.sessionId,
      publicKey: publicKey ?? this.publicKey,
    );
  }

  StripePaymentFormData copyWithWrapped({
    Wrapped<String>? sessionId,
    Wrapped<String>? publicKey,
  }) {
    return StripePaymentFormData(
      sessionId: (sessionId != null ? sessionId.value : this.sessionId),
      publicKey: (publicKey != null ? publicKey.value : this.publicKey),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FiatPaymentForm {
  const FiatPaymentForm({required this.type, required this.data});

  factory FiatPaymentForm.fromJson(Map<String, dynamic> json) =>
      _$FiatPaymentFormFromJson(json);

  static const toJsonFactory = _$FiatPaymentFormToJson;
  Map<String, dynamic> toJson() => _$FiatPaymentFormToJson(this);

  @JsonKey(
    name: 'type',
    toJson: paymentProviderToJson,
    fromJson: paymentProviderFromJson,
  )
  final enums.PaymentProvider type;
  @JsonKey(name: 'data')
  final dynamic data;
  static const fromJsonFactory = _$FiatPaymentFormFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FiatPaymentForm &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FiatPaymentFormExtension on FiatPaymentForm {
  FiatPaymentForm copyWith({enums.PaymentProvider? type, dynamic data}) {
    return FiatPaymentForm(type: type ?? this.type, data: data ?? this.data);
  }

  FiatPaymentForm copyWithWrapped({
    Wrapped<enums.PaymentProvider>? type,
    Wrapped<dynamic>? data,
  }) {
    return FiatPaymentForm(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CryptoPaymentResult {
  const CryptoPaymentResult({required this.signature, required this.data});

  factory CryptoPaymentResult.fromJson(Map<String, dynamic> json) =>
      _$CryptoPaymentResultFromJson(json);

  static const toJsonFactory = _$CryptoPaymentResultToJson;
  Map<String, dynamic> toJson() => _$CryptoPaymentResultToJson(this);

  @JsonKey(name: 'signature')
  final String signature;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$CryptoPaymentResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CryptoPaymentResult &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality().equals(
                  other.signature,
                  signature,
                )) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $CryptoPaymentResultExtension on CryptoPaymentResult {
  CryptoPaymentResult copyWith({String? signature, String? data}) {
    return CryptoPaymentResult(
      signature: signature ?? this.signature,
      data: data ?? this.data,
    );
  }

  CryptoPaymentResult copyWithWrapped({
    Wrapped<String>? signature,
    Wrapped<String>? data,
  }) {
    return CryptoPaymentResult(
      signature: (signature != null ? signature.value : this.signature),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationResponseDto {
  const EventRegistrationResponseDto({
    required this.guestDoc,
    this.fiatPaymentForm,
    this.cryptoPayment,
  });

  factory EventRegistrationResponseDto.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationResponseDtoFromJson(json);

  static const toJsonFactory = _$EventRegistrationResponseDtoToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationResponseDtoToJson(this);

  @JsonKey(name: 'guestDoc')
  final EventGuestDoc guestDoc;
  @JsonKey(name: 'fiatPaymentForm')
  final FiatPaymentForm? fiatPaymentForm;
  @JsonKey(name: 'cryptoPayment')
  final CryptoPaymentResult? cryptoPayment;
  static const fromJsonFactory = _$EventRegistrationResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationResponseDto &&
            (identical(other.guestDoc, guestDoc) ||
                const DeepCollectionEquality().equals(
                  other.guestDoc,
                  guestDoc,
                )) &&
            (identical(other.fiatPaymentForm, fiatPaymentForm) ||
                const DeepCollectionEquality().equals(
                  other.fiatPaymentForm,
                  fiatPaymentForm,
                )) &&
            (identical(other.cryptoPayment, cryptoPayment) ||
                const DeepCollectionEquality().equals(
                  other.cryptoPayment,
                  cryptoPayment,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(guestDoc) ^
      const DeepCollectionEquality().hash(fiatPaymentForm) ^
      const DeepCollectionEquality().hash(cryptoPayment) ^
      runtimeType.hashCode;
}

extension $EventRegistrationResponseDtoExtension
    on EventRegistrationResponseDto {
  EventRegistrationResponseDto copyWith({
    EventGuestDoc? guestDoc,
    FiatPaymentForm? fiatPaymentForm,
    CryptoPaymentResult? cryptoPayment,
  }) {
    return EventRegistrationResponseDto(
      guestDoc: guestDoc ?? this.guestDoc,
      fiatPaymentForm: fiatPaymentForm ?? this.fiatPaymentForm,
      cryptoPayment: cryptoPayment ?? this.cryptoPayment,
    );
  }

  EventRegistrationResponseDto copyWithWrapped({
    Wrapped<EventGuestDoc>? guestDoc,
    Wrapped<FiatPaymentForm?>? fiatPaymentForm,
    Wrapped<CryptoPaymentResult?>? cryptoPayment,
  }) {
    return EventRegistrationResponseDto(
      guestDoc: (guestDoc != null ? guestDoc.value : this.guestDoc),
      fiatPaymentForm: (fiatPaymentForm != null
          ? fiatPaymentForm.value
          : this.fiatPaymentForm),
      cryptoPayment: (cryptoPayment != null
          ? cryptoPayment.value
          : this.cryptoPayment),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileCreateDto {
  const EventTicketProfileCreateDto({
    required this.name,
    required this.description,
    this.royalties,
    this.badgeColor,
    this.characteristics,
    this.maxLimit,
    required this.userLimit,
  });

  factory EventTicketProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventTicketProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileCreateDtoToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  static const fromJsonFactory = _$EventTicketProfileCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventTicketProfileCreateDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.badgeColor, badgeColor) ||
                const DeepCollectionEquality().equals(
                  other.badgeColor,
                  badgeColor,
                )) &&
            (identical(other.characteristics, characteristics) ||
                const DeepCollectionEquality().equals(
                  other.characteristics,
                  characteristics,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(badgeColor) ^
      const DeepCollectionEquality().hash(characteristics) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      runtimeType.hashCode;
}

extension $EventTicketProfileCreateDtoExtension on EventTicketProfileCreateDto {
  EventTicketProfileCreateDto copyWith({
    String? name,
    String? description,
    double? royalties,
    String? badgeColor,
    Object? characteristics,
    int? maxLimit,
    int? userLimit,
  }) {
    return EventTicketProfileCreateDto(
      name: name ?? this.name,
      description: description ?? this.description,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
    );
  }

  EventTicketProfileCreateDto copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<int?>? maxLimit,
    Wrapped<int>? userLimit,
  }) {
    return EventTicketProfileCreateDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileDoc {
  const EventTicketProfileDoc({
    required this.dataType,
    required this.eventId,
    required this.name,
    required this.description,
    required this.profile,
    this.royalties,
    this.badgeColor,
    this.characteristics,
    this.maxLimit,
    required this.userLimit,
    required this.soldCount,
    required this.createdAt,
    required this.id,
    required this.pk,
    required this.ts,
  });

  factory EventTicketProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileDocFromJson(json);

  static const toJsonFactory = _$EventTicketProfileDocToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'soldCount')
  final int soldCount;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final int ts;
  static const fromJsonFactory = _$EventTicketProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventTicketProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.badgeColor, badgeColor) ||
                const DeepCollectionEquality().equals(
                  other.badgeColor,
                  badgeColor,
                )) &&
            (identical(other.characteristics, characteristics) ||
                const DeepCollectionEquality().equals(
                  other.characteristics,
                  characteristics,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.soldCount, soldCount) ||
                const DeepCollectionEquality().equals(
                  other.soldCount,
                  soldCount,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(badgeColor) ^
      const DeepCollectionEquality().hash(characteristics) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(soldCount) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $EventTicketProfileDocExtension on EventTicketProfileDoc {
  EventTicketProfileDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? description,
    String? profile,
    double? royalties,
    String? badgeColor,
    Object? characteristics,
    int? maxLimit,
    int? userLimit,
    int? soldCount,
    int? createdAt,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventTicketProfileDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      description: description ?? this.description,
      profile: profile ?? this.profile,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      soldCount: soldCount ?? this.soldCount,
      createdAt: createdAt ?? this.createdAt,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventTicketProfileDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<String>? profile,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<int?>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<int>? soldCount,
    Wrapped<int>? createdAt,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<int>? ts,
  }) {
    return EventTicketProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      profile: (profile != null ? profile.value : this.profile),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileEditDto {
  const EventTicketProfileEditDto({
    this.name,
    this.description,
    this.royalties,
    this.badgeColor,
    this.characteristics,
    this.maxLimit,
    this.userLimit,
  });

  factory EventTicketProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventTicketProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int? userLimit;
  static const fromJsonFactory = _$EventTicketProfileEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventTicketProfileEditDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.badgeColor, badgeColor) ||
                const DeepCollectionEquality().equals(
                  other.badgeColor,
                  badgeColor,
                )) &&
            (identical(other.characteristics, characteristics) ||
                const DeepCollectionEquality().equals(
                  other.characteristics,
                  characteristics,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(badgeColor) ^
      const DeepCollectionEquality().hash(characteristics) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      runtimeType.hashCode;
}

extension $EventTicketProfileEditDtoExtension on EventTicketProfileEditDto {
  EventTicketProfileEditDto copyWith({
    String? name,
    String? description,
    double? royalties,
    String? badgeColor,
    Object? characteristics,
    int? maxLimit,
    int? userLimit,
  }) {
    return EventTicketProfileEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
    );
  }

  EventTicketProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<int?>? maxLimit,
    Wrapped<int?>? userLimit,
  }) {
    return EventTicketProfileEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileCreateDto {
  const EventStageProfileCreateDto({
    required this.ticketId,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.maxLimit,
    required this.userLimit,
    required this.isEnabled,
    required this.isWhitelist,
    required this.requiredApproval,
    required this.prices,
  });

  factory EventStageProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventStageProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileCreateDtoToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'isEnabled')
  final bool isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  static const fromJsonFactory = _$EventStageProfileCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventStageProfileCreateDto &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.isEnabled, isEnabled) ||
                const DeepCollectionEquality().equals(
                  other.isEnabled,
                  isEnabled,
                )) &&
            (identical(other.isWhitelist, isWhitelist) ||
                const DeepCollectionEquality().equals(
                  other.isWhitelist,
                  isWhitelist,
                )) &&
            (identical(other.requiredApproval, requiredApproval) ||
                const DeepCollectionEquality().equals(
                  other.requiredApproval,
                  requiredApproval,
                )) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(isEnabled) ^
      const DeepCollectionEquality().hash(isWhitelist) ^
      const DeepCollectionEquality().hash(requiredApproval) ^
      const DeepCollectionEquality().hash(prices) ^
      runtimeType.hashCode;
}

extension $EventStageProfileCreateDtoExtension on EventStageProfileCreateDto {
  EventStageProfileCreateDto copyWith({
    String? ticketId,
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
  }) {
    return EventStageProfileCreateDto(
      ticketId: ticketId ?? this.ticketId,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
    );
  }

  EventStageProfileCreateDto copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<String>? name,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? isEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<bool>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
  }) {
    return EventStageProfileCreateDto(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileDoc {
  const EventStageProfileDoc({
    required this.dataType,
    required this.eventId,
    required this.ticketId,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.maxLimit,
    required this.userLimit,
    required this.isEnabled,
    required this.isWhitelist,
    required this.requiredApproval,
    required this.prices,
    required this.soldCount,
    required this.id,
    required this.pk,
    required this.ts,
  });

  factory EventStageProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileDocFromJson(json);

  static const toJsonFactory = _$EventStageProfileDocToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventTicketStage,
  );

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'isEnabled')
  final bool isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'soldCount')
  final int soldCount;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final int ts;
  static const fromJsonFactory = _$EventStageProfileDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventStageProfileDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.isEnabled, isEnabled) ||
                const DeepCollectionEquality().equals(
                  other.isEnabled,
                  isEnabled,
                )) &&
            (identical(other.isWhitelist, isWhitelist) ||
                const DeepCollectionEquality().equals(
                  other.isWhitelist,
                  isWhitelist,
                )) &&
            (identical(other.requiredApproval, requiredApproval) ||
                const DeepCollectionEquality().equals(
                  other.requiredApproval,
                  requiredApproval,
                )) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)) &&
            (identical(other.soldCount, soldCount) ||
                const DeepCollectionEquality().equals(
                  other.soldCount,
                  soldCount,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(isEnabled) ^
      const DeepCollectionEquality().hash(isWhitelist) ^
      const DeepCollectionEquality().hash(requiredApproval) ^
      const DeepCollectionEquality().hash(prices) ^
      const DeepCollectionEquality().hash(soldCount) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $EventStageProfileDocExtension on EventStageProfileDoc {
  EventStageProfileDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? ticketId,
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
    int? soldCount,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventStageProfileDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      ticketId: ticketId ?? this.ticketId,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
      soldCount: soldCount ?? this.soldCount,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventStageProfileDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String>? ticketId,
    Wrapped<String>? name,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? isEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<bool>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<int>? soldCount,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<int>? ts,
  }) {
    return EventStageProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileEditDto {
  const EventStageProfileEditDto({
    this.name,
    this.startTime,
    this.endTime,
    this.maxLimit,
    this.userLimit,
    this.isEnabled,
    this.isWhitelist,
    this.requiredApproval,
    this.prices,
  });

  factory EventStageProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventStageProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'startTime')
  final int? startTime;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int? userLimit;
  @JsonKey(name: 'isEnabled')
  final bool? isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool? isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool? requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment>? prices;
  static const fromJsonFactory = _$EventStageProfileEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventStageProfileEditDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality().equals(
                  other.maxLimit,
                  maxLimit,
                )) &&
            (identical(other.userLimit, userLimit) ||
                const DeepCollectionEquality().equals(
                  other.userLimit,
                  userLimit,
                )) &&
            (identical(other.isEnabled, isEnabled) ||
                const DeepCollectionEquality().equals(
                  other.isEnabled,
                  isEnabled,
                )) &&
            (identical(other.isWhitelist, isWhitelist) ||
                const DeepCollectionEquality().equals(
                  other.isWhitelist,
                  isWhitelist,
                )) &&
            (identical(other.requiredApproval, requiredApproval) ||
                const DeepCollectionEquality().equals(
                  other.requiredApproval,
                  requiredApproval,
                )) &&
            (identical(other.prices, prices) ||
                const DeepCollectionEquality().equals(other.prices, prices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(userLimit) ^
      const DeepCollectionEquality().hash(isEnabled) ^
      const DeepCollectionEquality().hash(isWhitelist) ^
      const DeepCollectionEquality().hash(requiredApproval) ^
      const DeepCollectionEquality().hash(prices) ^
      runtimeType.hashCode;
}

extension $EventStageProfileEditDtoExtension on EventStageProfileEditDto {
  EventStageProfileEditDto copyWith({
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
  }) {
    return EventStageProfileEditDto(
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
    );
  }

  EventStageProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<int?>? startTime,
    Wrapped<int?>? endTime,
    Wrapped<int?>? maxLimit,
    Wrapped<int?>? userLimit,
    Wrapped<bool?>? isEnabled,
    Wrapped<bool?>? isWhitelist,
    Wrapped<bool?>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>?>? prices,
  }) {
    return EventStageProfileEditDto(
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketCalculationRequestDto {
  const TicketCalculationRequestDto({
    this.referralCode,
    this.discountCode,
    required this.ticketSelections,
  });

  factory TicketCalculationRequestDto.fromJson(Map<String, dynamic> json) =>
      _$TicketCalculationRequestDtoFromJson(json);

  static const toJsonFactory = _$TicketCalculationRequestDtoToJson;
  Map<String, dynamic> toJson() => _$TicketCalculationRequestDtoToJson(this);

  @JsonKey(name: 'referralCode')
  final String? referralCode;
  @JsonKey(name: 'discountCode')
  final String? discountCode;
  @JsonKey(name: 'ticketSelections', defaultValue: <TicketSelectionDto>[])
  final List<TicketSelectionDto> ticketSelections;
  static const fromJsonFactory = _$TicketCalculationRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketCalculationRequestDto &&
            (identical(other.referralCode, referralCode) ||
                const DeepCollectionEquality().equals(
                  other.referralCode,
                  referralCode,
                )) &&
            (identical(other.discountCode, discountCode) ||
                const DeepCollectionEquality().equals(
                  other.discountCode,
                  discountCode,
                )) &&
            (identical(other.ticketSelections, ticketSelections) ||
                const DeepCollectionEquality().equals(
                  other.ticketSelections,
                  ticketSelections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(referralCode) ^
      const DeepCollectionEquality().hash(discountCode) ^
      const DeepCollectionEquality().hash(ticketSelections) ^
      runtimeType.hashCode;
}

extension $TicketCalculationRequestDtoExtension on TicketCalculationRequestDto {
  TicketCalculationRequestDto copyWith({
    String? referralCode,
    String? discountCode,
    List<TicketSelectionDto>? ticketSelections,
  }) {
    return TicketCalculationRequestDto(
      referralCode: referralCode ?? this.referralCode,
      discountCode: discountCode ?? this.discountCode,
      ticketSelections: ticketSelections ?? this.ticketSelections,
    );
  }

  TicketCalculationRequestDto copyWithWrapped({
    Wrapped<String?>? referralCode,
    Wrapped<String?>? discountCode,
    Wrapped<List<TicketSelectionDto>>? ticketSelections,
  }) {
    return TicketCalculationRequestDto(
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      discountCode: (discountCode != null
          ? discountCode.value
          : this.discountCode),
      ticketSelections: (ticketSelections != null
          ? ticketSelections.value
          : this.ticketSelections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StagePrice {
  const StagePrice({
    required this.stageId,
    required this.stageName,
    required this.ticketId,
    required this.ticketType,
    required this.currency,
    required this.normalPrice,
    required this.discountedPrice,
    required this.quantity,
  });

  factory StagePrice.fromJson(Map<String, dynamic> json) =>
      _$StagePriceFromJson(json);

  static const toJsonFactory = _$StagePriceToJson;
  Map<String, dynamic> toJson() => _$StagePriceToJson(this);

  @JsonKey(name: 'stageId')
  final String stageId;
  @JsonKey(name: 'stageName')
  final String stageName;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'ticketType')
  final String ticketType;
  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'normalPrice')
  final double normalPrice;
  @JsonKey(name: 'discountedPrice')
  final double discountedPrice;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory = _$StagePriceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StagePrice &&
            (identical(other.stageId, stageId) ||
                const DeepCollectionEquality().equals(
                  other.stageId,
                  stageId,
                )) &&
            (identical(other.stageName, stageName) ||
                const DeepCollectionEquality().equals(
                  other.stageName,
                  stageName,
                )) &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.ticketType, ticketType) ||
                const DeepCollectionEquality().equals(
                  other.ticketType,
                  ticketType,
                )) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )) &&
            (identical(other.normalPrice, normalPrice) ||
                const DeepCollectionEquality().equals(
                  other.normalPrice,
                  normalPrice,
                )) &&
            (identical(other.discountedPrice, discountedPrice) ||
                const DeepCollectionEquality().equals(
                  other.discountedPrice,
                  discountedPrice,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stageId) ^
      const DeepCollectionEquality().hash(stageName) ^
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(ticketType) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(normalPrice) ^
      const DeepCollectionEquality().hash(discountedPrice) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $StagePriceExtension on StagePrice {
  StagePrice copyWith({
    String? stageId,
    String? stageName,
    String? ticketId,
    String? ticketType,
    String? currency,
    double? normalPrice,
    double? discountedPrice,
    int? quantity,
  }) {
    return StagePrice(
      stageId: stageId ?? this.stageId,
      stageName: stageName ?? this.stageName,
      ticketId: ticketId ?? this.ticketId,
      ticketType: ticketType ?? this.ticketType,
      currency: currency ?? this.currency,
      normalPrice: normalPrice ?? this.normalPrice,
      discountedPrice: discountedPrice ?? this.discountedPrice,
      quantity: quantity ?? this.quantity,
    );
  }

  StagePrice copyWithWrapped({
    Wrapped<String>? stageId,
    Wrapped<String>? stageName,
    Wrapped<String>? ticketId,
    Wrapped<String>? ticketType,
    Wrapped<String>? currency,
    Wrapped<double>? normalPrice,
    Wrapped<double>? discountedPrice,
    Wrapped<int>? quantity,
  }) {
    return StagePrice(
      stageId: (stageId != null ? stageId.value : this.stageId),
      stageName: (stageName != null ? stageName.value : this.stageName),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      ticketType: (ticketType != null ? ticketType.value : this.ticketType),
      currency: (currency != null ? currency.value : this.currency),
      normalPrice: (normalPrice != null ? normalPrice.value : this.normalPrice),
      discountedPrice: (discountedPrice != null
          ? discountedPrice.value
          : this.discountedPrice),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketPricesResponse {
  const TicketPricesResponse({
    required this.currency,
    required this.stagePrices,
    this.vat,
  });

  factory TicketPricesResponse.fromJson(Map<String, dynamic> json) =>
      _$TicketPricesResponseFromJson(json);

  static const toJsonFactory = _$TicketPricesResponseToJson;
  Map<String, dynamic> toJson() => _$TicketPricesResponseToJson(this);

  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'stagePrices', defaultValue: <StagePrice>[])
  final List<StagePrice> stagePrices;
  @JsonKey(name: 'vat')
  final double? vat;
  static const fromJsonFactory = _$TicketPricesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketPricesResponse &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )) &&
            (identical(other.stagePrices, stagePrices) ||
                const DeepCollectionEquality().equals(
                  other.stagePrices,
                  stagePrices,
                )) &&
            (identical(other.vat, vat) ||
                const DeepCollectionEquality().equals(other.vat, vat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(stagePrices) ^
      const DeepCollectionEquality().hash(vat) ^
      runtimeType.hashCode;
}

extension $TicketPricesResponseExtension on TicketPricesResponse {
  TicketPricesResponse copyWith({
    String? currency,
    List<StagePrice>? stagePrices,
    double? vat,
  }) {
    return TicketPricesResponse(
      currency: currency ?? this.currency,
      stagePrices: stagePrices ?? this.stagePrices,
      vat: vat ?? this.vat,
    );
  }

  TicketPricesResponse copyWithWrapped({
    Wrapped<String>? currency,
    Wrapped<List<StagePrice>>? stagePrices,
    Wrapped<double?>? vat,
  }) {
    return TicketPricesResponse(
      currency: (currency != null ? currency.value : this.currency),
      stagePrices: (stagePrices != null ? stagePrices.value : this.stagePrices),
      vat: (vat != null ? vat.value : this.vat),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DiscountCodeValidationResponse {
  const DiscountCodeValidationResponse({
    required this.isValid,
    required this.discountType,
    required this.discountAmount,
    this.discountMaxAmount,
  });

  factory DiscountCodeValidationResponse.fromJson(Map<String, dynamic> json) =>
      _$DiscountCodeValidationResponseFromJson(json);

  static const toJsonFactory = _$DiscountCodeValidationResponseToJson;
  Map<String, dynamic> toJson() => _$DiscountCodeValidationResponseToJson(this);

  @JsonKey(name: 'isValid')
  final bool isValid;
  @JsonKey(name: 'discountType')
  final String discountType;
  @JsonKey(name: 'discountAmount')
  final double discountAmount;
  @JsonKey(name: 'discountMaxAmount')
  final double? discountMaxAmount;
  static const fromJsonFactory = _$DiscountCodeValidationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DiscountCodeValidationResponse &&
            (identical(other.isValid, isValid) ||
                const DeepCollectionEquality().equals(
                  other.isValid,
                  isValid,
                )) &&
            (identical(other.discountType, discountType) ||
                const DeepCollectionEquality().equals(
                  other.discountType,
                  discountType,
                )) &&
            (identical(other.discountAmount, discountAmount) ||
                const DeepCollectionEquality().equals(
                  other.discountAmount,
                  discountAmount,
                )) &&
            (identical(other.discountMaxAmount, discountMaxAmount) ||
                const DeepCollectionEquality().equals(
                  other.discountMaxAmount,
                  discountMaxAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isValid) ^
      const DeepCollectionEquality().hash(discountType) ^
      const DeepCollectionEquality().hash(discountAmount) ^
      const DeepCollectionEquality().hash(discountMaxAmount) ^
      runtimeType.hashCode;
}

extension $DiscountCodeValidationResponseExtension
    on DiscountCodeValidationResponse {
  DiscountCodeValidationResponse copyWith({
    bool? isValid,
    String? discountType,
    double? discountAmount,
    double? discountMaxAmount,
  }) {
    return DiscountCodeValidationResponse(
      isValid: isValid ?? this.isValid,
      discountType: discountType ?? this.discountType,
      discountAmount: discountAmount ?? this.discountAmount,
      discountMaxAmount: discountMaxAmount ?? this.discountMaxAmount,
    );
  }

  DiscountCodeValidationResponse copyWithWrapped({
    Wrapped<bool>? isValid,
    Wrapped<String>? discountType,
    Wrapped<double>? discountAmount,
    Wrapped<double?>? discountMaxAmount,
  }) {
    return DiscountCodeValidationResponse(
      isValid: (isValid != null ? isValid.value : this.isValid),
      discountType: (discountType != null
          ? discountType.value
          : this.discountType),
      discountAmount: (discountAmount != null
          ? discountAmount.value
          : this.discountAmount),
      discountMaxAmount: (discountMaxAmount != null
          ? discountMaxAmount.value
          : this.discountMaxAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Ticket {
  const Ticket({required this.ticketId, required this.quantity});

  factory Ticket.fromJson(Map<String, dynamic> json) => _$TicketFromJson(json);

  static const toJsonFactory = _$TicketToJson;
  Map<String, dynamic> toJson() => _$TicketToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory = _$TicketFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Ticket &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $TicketExtension on Ticket {
  Ticket copyWith({String? ticketId, int? quantity}) {
    return Ticket(
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
    );
  }

  Ticket copyWithWrapped({Wrapped<String>? ticketId, Wrapped<int>? quantity}) {
    return Ticket(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationCreateDto {
  const EventInvitationCreateDto({
    this.name,
    this.email,
    required this.startTime,
    required this.endTime,
    required this.tickets,
  });

  factory EventInvitationCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationCreateDtoFromJson(json);

  static const toJsonFactory = _$EventInvitationCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventInvitationCreateDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'tickets', defaultValue: <Ticket>[])
  final List<Ticket> tickets;
  static const fromJsonFactory = _$EventInvitationCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitationCreateDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.tickets, tickets) ||
                const DeepCollectionEquality().equals(other.tickets, tickets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(tickets) ^
      runtimeType.hashCode;
}

extension $EventInvitationCreateDtoExtension on EventInvitationCreateDto {
  EventInvitationCreateDto copyWith({
    String? name,
    String? email,
    int? startTime,
    int? endTime,
    List<Ticket>? tickets,
  }) {
    return EventInvitationCreateDto(
      name: name ?? this.name,
      email: email ?? this.email,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      tickets: tickets ?? this.tickets,
    );
  }

  EventInvitationCreateDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<List<Ticket>>? tickets,
  }) {
    return EventInvitationCreateDto(
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      tickets: (tickets != null ? tickets.value : this.tickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketProfileSummary {
  const TicketProfileSummary({
    required this.name,
    required this.description,
    required this.profile,
    this.badgeColor,
    this.characteristics,
    this.ticketId,
    this.quantity,
  });

  factory TicketProfileSummary.fromJson(Map<String, dynamic> json) =>
      _$TicketProfileSummaryFromJson(json);

  static const toJsonFactory = _$TicketProfileSummaryToJson;
  Map<String, dynamic> toJson() => _$TicketProfileSummaryToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'ticketId')
  final String? ticketId;
  @JsonKey(name: 'quantity')
  final int? quantity;
  static const fromJsonFactory = _$TicketProfileSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketProfileSummary &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.badgeColor, badgeColor) ||
                const DeepCollectionEquality().equals(
                  other.badgeColor,
                  badgeColor,
                )) &&
            (identical(other.characteristics, characteristics) ||
                const DeepCollectionEquality().equals(
                  other.characteristics,
                  characteristics,
                )) &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(badgeColor) ^
      const DeepCollectionEquality().hash(characteristics) ^
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $TicketProfileSummaryExtension on TicketProfileSummary {
  TicketProfileSummary copyWith({
    String? name,
    String? description,
    String? profile,
    String? badgeColor,
    Object? characteristics,
    String? ticketId,
    int? quantity,
  }) {
    return TicketProfileSummary(
      name: name ?? this.name,
      description: description ?? this.description,
      profile: profile ?? this.profile,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
    );
  }

  TicketProfileSummary copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<String>? profile,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<String?>? ticketId,
    Wrapped<int?>? quantity,
  }) {
    return TicketProfileSummary(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      profile: (profile != null ? profile.value : this.profile),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationDoc {
  const EventInvitationDoc({
    required this.dataType,
    required this.eventId,
    this.name,
    this.email,
    this.phone,
    required this.tickets,
    required this.startTime,
    required this.endTime,
    required this.createdAt,
    required this.isClaimed,
    required this.isUsed,
    required this.status,
    required this.claimedAt,
    this.claimedBy,
    this.txHash,
    required this.id,
    this.pk,
    required this.ts,
  });

  factory EventInvitationDoc.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationDocFromJson(json);

  static const toJsonFactory = _$EventInvitationDocToJson;
  Map<String, dynamic> toJson() => _$EventInvitationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) =>
      ticketingDataTypeFromJson(value, enums.TicketingDataType.eventInvitation);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'tickets', defaultValue: <TicketProfileSummary>[])
  final List<TicketProfileSummary> tickets;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isClaimed')
  final bool isClaimed;
  @JsonKey(name: 'isUsed')
  final bool isUsed;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusToJson,
    fromJson: eventInvitationStatusStatusFromJson,
  )
  final enums.EventInvitationStatus status;
  static enums.EventInvitationStatus eventInvitationStatusStatusFromJson(
    Object? value,
  ) =>
      eventInvitationStatusFromJson(value, enums.EventInvitationStatus.pending);

  @JsonKey(name: 'claimedAt')
  final int claimedAt;
  @JsonKey(name: 'claimedBy')
  final String? claimedBy;
  @JsonKey(name: 'txHash')
  final String? txHash;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int ts;
  static const fromJsonFactory = _$EventInvitationDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitationDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.tickets, tickets) ||
                const DeepCollectionEquality().equals(
                  other.tickets,
                  tickets,
                )) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.isClaimed, isClaimed) ||
                const DeepCollectionEquality().equals(
                  other.isClaimed,
                  isClaimed,
                )) &&
            (identical(other.isUsed, isUsed) ||
                const DeepCollectionEquality().equals(other.isUsed, isUsed)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.claimedAt, claimedAt) ||
                const DeepCollectionEquality().equals(
                  other.claimedAt,
                  claimedAt,
                )) &&
            (identical(other.claimedBy, claimedBy) ||
                const DeepCollectionEquality().equals(
                  other.claimedBy,
                  claimedBy,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(tickets) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isClaimed) ^
      const DeepCollectionEquality().hash(isUsed) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(claimedAt) ^
      const DeepCollectionEquality().hash(claimedBy) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      runtimeType.hashCode;
}

extension $EventInvitationDocExtension on EventInvitationDoc {
  EventInvitationDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? email,
    String? phone,
    List<TicketProfileSummary>? tickets,
    int? startTime,
    int? endTime,
    int? createdAt,
    bool? isClaimed,
    bool? isUsed,
    enums.EventInvitationStatus? status,
    int? claimedAt,
    String? claimedBy,
    String? txHash,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventInvitationDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      tickets: tickets ?? this.tickets,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      createdAt: createdAt ?? this.createdAt,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      status: status ?? this.status,
      claimedAt: claimedAt ?? this.claimedAt,
      claimedBy: claimedBy ?? this.claimedBy,
      txHash: txHash ?? this.txHash,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventInvitationDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<List<TicketProfileSummary>>? tickets,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isClaimed,
    Wrapped<bool>? isUsed,
    Wrapped<enums.EventInvitationStatus>? status,
    Wrapped<int>? claimedAt,
    Wrapped<String?>? claimedBy,
    Wrapped<String?>? txHash,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int>? ts,
  }) {
    return EventInvitationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      tickets: (tickets != null ? tickets.value : this.tickets),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      status: (status != null ? status.value : this.status),
      claimedAt: (claimedAt != null ? claimedAt.value : this.claimedAt),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      txHash: (txHash != null ? txHash.value : this.txHash),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationFilterCriteriaDto {
  const EventInvitationFilterCriteriaDto({
    this.searchText,
    this.claimedBy,
    this.eventId,
    this.email,
    this.status,
    this.isClaimed,
    this.isUsed,
    this.range,
  });

  factory EventInvitationFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$EventInvitationFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventInvitationFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$EventInvitationFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'claimedBy', defaultValue: <String>[])
  final List<String>? claimedBy;
  @JsonKey(name: 'eventId', defaultValue: <String>[])
  final List<String>? eventId;
  @JsonKey(name: 'email', defaultValue: <String>[])
  final List<String>? email;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusListToJson,
    fromJson: eventInvitationStatusListFromJson,
  )
  final List<enums.EventInvitationStatus>? status;
  @JsonKey(name: 'isClaimed')
  final bool? isClaimed;
  @JsonKey(name: 'isUsed')
  final bool? isUsed;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventInvitationFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitationFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.claimedBy, claimedBy) ||
                const DeepCollectionEquality().equals(
                  other.claimedBy,
                  claimedBy,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.isClaimed, isClaimed) ||
                const DeepCollectionEquality().equals(
                  other.isClaimed,
                  isClaimed,
                )) &&
            (identical(other.isUsed, isUsed) ||
                const DeepCollectionEquality().equals(other.isUsed, isUsed)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(claimedBy) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(isClaimed) ^
      const DeepCollectionEquality().hash(isUsed) ^
      const DeepCollectionEquality().hash(range) ^
      runtimeType.hashCode;
}

extension $EventInvitationFilterCriteriaDtoExtension
    on EventInvitationFilterCriteriaDto {
  EventInvitationFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? claimedBy,
    List<String>? eventId,
    List<String>? email,
    List<enums.EventInvitationStatus>? status,
    bool? isClaimed,
    bool? isUsed,
    List<RangeFilter>? range,
  }) {
    return EventInvitationFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      claimedBy: claimedBy ?? this.claimedBy,
      eventId: eventId ?? this.eventId,
      email: email ?? this.email,
      status: status ?? this.status,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      range: range ?? this.range,
    );
  }

  EventInvitationFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? claimedBy,
    Wrapped<List<String>?>? eventId,
    Wrapped<List<String>?>? email,
    Wrapped<List<enums.EventInvitationStatus>?>? status,
    Wrapped<bool?>? isClaimed,
    Wrapped<bool?>? isUsed,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventInvitationFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      eventId: (eventId != null ? eventId.value : this.eventId),
      email: (email != null ? email.value : this.email),
      status: (status != null ? status.value : this.status),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationFilter {
  const EventInvitationFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventInvitationFilter.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationFilterFromJson(json);

  static const toJsonFactory = _$EventInvitationFilterToJson;
  Map<String, dynamic> toJson() => _$EventInvitationFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventInvitationFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventInvitationFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitationFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EventInvitationFilterExtension on EventInvitationFilter {
  EventInvitationFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventInvitationFilterCriteriaDto? filters,
  }) {
    return EventInvitationFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventInvitationFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventInvitationFilterCriteriaDto>? filters,
  }) {
    return EventInvitationFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitation {
  const EventInvitation({
    required this.dataType,
    required this.eventId,
    this.name,
    this.email,
    this.phone,
    required this.tickets,
    required this.startTime,
    required this.endTime,
    required this.createdAt,
    required this.isClaimed,
    required this.isUsed,
    required this.status,
    required this.claimedAt,
    this.claimedBy,
    this.txHash,
    required this.id,
    this.pk,
    required this.ts,
    this.profile,
    this.herotag,
  });

  factory EventInvitation.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationFromJson(json);

  static const toJsonFactory = _$EventInvitationToJson;
  Map<String, dynamic> toJson() => _$EventInvitationToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) =>
      ticketingDataTypeFromJson(value, enums.TicketingDataType.eventInvitation);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'tickets', defaultValue: <TicketProfileSummary>[])
  final List<TicketProfileSummary> tickets;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isClaimed')
  final bool isClaimed;
  @JsonKey(name: 'isUsed')
  final bool isUsed;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusToJson,
    fromJson: eventInvitationStatusStatusFromJson,
  )
  final enums.EventInvitationStatus status;
  static enums.EventInvitationStatus eventInvitationStatusStatusFromJson(
    Object? value,
  ) =>
      eventInvitationStatusFromJson(value, enums.EventInvitationStatus.pending);

  @JsonKey(name: 'claimedAt')
  final int claimedAt;
  @JsonKey(name: 'claimedBy')
  final String? claimedBy;
  @JsonKey(name: 'txHash')
  final String? txHash;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int ts;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'herotag')
  final String? herotag;
  static const fromJsonFactory = _$EventInvitationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitation &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.tickets, tickets) ||
                const DeepCollectionEquality().equals(
                  other.tickets,
                  tickets,
                )) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.isClaimed, isClaimed) ||
                const DeepCollectionEquality().equals(
                  other.isClaimed,
                  isClaimed,
                )) &&
            (identical(other.isUsed, isUsed) ||
                const DeepCollectionEquality().equals(other.isUsed, isUsed)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.claimedAt, claimedAt) ||
                const DeepCollectionEquality().equals(
                  other.claimedAt,
                  claimedAt,
                )) &&
            (identical(other.claimedBy, claimedBy) ||
                const DeepCollectionEquality().equals(
                  other.claimedBy,
                  claimedBy,
                )) &&
            (identical(other.txHash, txHash) ||
                const DeepCollectionEquality().equals(other.txHash, txHash)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(other.herotag, herotag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(tickets) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isClaimed) ^
      const DeepCollectionEquality().hash(isUsed) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(claimedAt) ^
      const DeepCollectionEquality().hash(claimedBy) ^
      const DeepCollectionEquality().hash(txHash) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(herotag) ^
      runtimeType.hashCode;
}

extension $EventInvitationExtension on EventInvitation {
  EventInvitation copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? email,
    String? phone,
    List<TicketProfileSummary>? tickets,
    int? startTime,
    int? endTime,
    int? createdAt,
    bool? isClaimed,
    bool? isUsed,
    enums.EventInvitationStatus? status,
    int? claimedAt,
    String? claimedBy,
    String? txHash,
    String? id,
    String? pk,
    int? ts,
    String? profile,
    String? herotag,
  }) {
    return EventInvitation(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      tickets: tickets ?? this.tickets,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      createdAt: createdAt ?? this.createdAt,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      status: status ?? this.status,
      claimedAt: claimedAt ?? this.claimedAt,
      claimedBy: claimedBy ?? this.claimedBy,
      txHash: txHash ?? this.txHash,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventInvitation copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<List<TicketProfileSummary>>? tickets,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isClaimed,
    Wrapped<bool>? isUsed,
    Wrapped<enums.EventInvitationStatus>? status,
    Wrapped<int>? claimedAt,
    Wrapped<String?>? claimedBy,
    Wrapped<String?>? txHash,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int>? ts,
    Wrapped<String?>? profile,
    Wrapped<String?>? herotag,
  }) {
    return EventInvitation(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      tickets: (tickets != null ? tickets.value : this.tickets),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      status: (status != null ? status.value : this.status),
      claimedAt: (claimedAt != null ? claimedAt.value : this.claimedAt),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      txHash: (txHash != null ? txHash.value : this.txHash),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationQuery {
  const EventInvitationQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventInvitationQuery.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationQueryFromJson(json);

  static const toJsonFactory = _$EventInvitationQueryToJson;
  Map<String, dynamic> toJson() => _$EventInvitationQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventInvitation>[])
  final List<EventInvitation> resources;
  static const fromJsonFactory = _$EventInvitationQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInvitationQuery &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventInvitationQueryExtension on EventInvitationQuery {
  EventInvitationQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventInvitation>? resources,
  }) {
    return EventInvitationQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventInvitationQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventInvitation>>? resources,
  }) {
    return EventInvitationQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherFilterCriteriaDto {
  const EventVoucherFilterCriteriaDto({
    this.searchText,
    this.code,
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.isActive,
    this.ownerId,
    this.range,
  });

  factory EventVoucherFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'code', defaultValue: <String>[])
  final List<String>? code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeListToJson,
    fromJson: voucherTypeListFromJson,
  )
  final List<enums.VoucherType>? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final double? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final double? maxUsesPerUser;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventVoucherFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.maxDiscountAmount, maxDiscountAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxDiscountAmount,
                  maxDiscountAmount,
                )) &&
            (identical(other.maxUses, maxUses) ||
                const DeepCollectionEquality().equals(
                  other.maxUses,
                  maxUses,
                )) &&
            (identical(other.maxUsesPerUser, maxUsesPerUser) ||
                const DeepCollectionEquality().equals(
                  other.maxUsesPerUser,
                  maxUsesPerUser,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(maxDiscountAmount) ^
      const DeepCollectionEquality().hash(maxUses) ^
      const DeepCollectionEquality().hash(maxUsesPerUser) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(range) ^
      runtimeType.hashCode;
}

extension $EventVoucherFilterCriteriaDtoExtension
    on EventVoucherFilterCriteriaDto {
  EventVoucherFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? code,
    List<enums.VoucherType>? type,
    double? amount,
    double? maxDiscountAmount,
    double? maxUses,
    double? maxUsesPerUser,
    bool? isActive,
    String? ownerId,
    List<RangeFilter>? range,
  }) {
    return EventVoucherFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      range: range ?? this.range,
    );
  }

  EventVoucherFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? code,
    Wrapped<List<enums.VoucherType>?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<double?>? maxUses,
    Wrapped<double?>? maxUsesPerUser,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventVoucherFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherFilter {
  const EventVoucherFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventVoucherFilter.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherFilterFromJson(json);

  static const toJsonFactory = _$EventVoucherFilterToJson;
  Map<String, dynamic> toJson() => _$EventVoucherFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventVoucherFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventVoucherFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EventVoucherFilterExtension on EventVoucherFilter {
  EventVoucherFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventVoucherFilterCriteriaDto? filters,
  }) {
    return EventVoucherFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventVoucherFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventVoucherFilterCriteriaDto>? filters,
  }) {
    return EventVoucherFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherDoc {
  const EventVoucherDoc({
    required this.dataType,
    required this.id,
    required this.code,
    required this.type,
    required this.amount,
    this.maxDiscountAmount,
    required this.maxUses,
    required this.maxUsesPerUser,
    required this.usedCount,
    required this.eventId,
    required this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    required this.startDate,
    required this.endDate,
    required this.isActive,
    this.ownerId,
    required this.createdAt,
    required this.createdBy,
    required this.pk,
  });

  factory EventVoucherDoc.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherDocFromJson(json);

  static const toJsonFactory = _$EventVoucherDocToJson;
  Map<String, dynamic> toJson() => _$EventVoucherDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventVoucher);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'code')
  final String code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeToJson,
    fromJson: voucherTypeFromJson,
  )
  final enums.VoucherType type;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int maxUsesPerUser;
  @JsonKey(name: 'usedCount')
  final int usedCount;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String> ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int startDate;
  @JsonKey(name: 'endDate')
  final int endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'createdBy')
  final String createdBy;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventVoucherDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.maxDiscountAmount, maxDiscountAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxDiscountAmount,
                  maxDiscountAmount,
                )) &&
            (identical(other.maxUses, maxUses) ||
                const DeepCollectionEquality().equals(
                  other.maxUses,
                  maxUses,
                )) &&
            (identical(other.maxUsesPerUser, maxUsesPerUser) ||
                const DeepCollectionEquality().equals(
                  other.maxUsesPerUser,
                  maxUsesPerUser,
                )) &&
            (identical(other.usedCount, usedCount) ||
                const DeepCollectionEquality().equals(
                  other.usedCount,
                  usedCount,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticketTypeIds, ticketTypeIds) ||
                const DeepCollectionEquality().equals(
                  other.ticketTypeIds,
                  ticketTypeIds,
                )) &&
            (identical(other.stageIds, stageIds) ||
                const DeepCollectionEquality().equals(
                  other.stageIds,
                  stageIds,
                )) &&
            (identical(other.minTicketCount, minTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.minTicketCount,
                  minTicketCount,
                )) &&
            (identical(other.maxTicketCount, maxTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.maxTicketCount,
                  maxTicketCount,
                )) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality().equals(
                  other.startDate,
                  startDate,
                )) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(
                  other.endDate,
                  endDate,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(maxDiscountAmount) ^
      const DeepCollectionEquality().hash(maxUses) ^
      const DeepCollectionEquality().hash(maxUsesPerUser) ^
      const DeepCollectionEquality().hash(usedCount) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticketTypeIds) ^
      const DeepCollectionEquality().hash(stageIds) ^
      const DeepCollectionEquality().hash(minTicketCount) ^
      const DeepCollectionEquality().hash(maxTicketCount) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $EventVoucherDocExtension on EventVoucherDoc {
  EventVoucherDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? code,
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    int? usedCount,
    String? eventId,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    int? createdAt,
    String? createdBy,
    String? pk,
  }) {
    return EventVoucherDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      usedCount: usedCount ?? this.usedCount,
      eventId: eventId ?? this.eventId,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      createdAt: createdAt ?? this.createdAt,
      createdBy: createdBy ?? this.createdBy,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? code,
    Wrapped<enums.VoucherType>? type,
    Wrapped<double>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int>? maxUses,
    Wrapped<int>? maxUsesPerUser,
    Wrapped<int>? usedCount,
    Wrapped<String>? eventId,
    Wrapped<List<String>>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int>? startDate,
    Wrapped<int>? endDate,
    Wrapped<bool>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<int>? createdAt,
    Wrapped<String>? createdBy,
    Wrapped<String>? pk,
  }) {
    return EventVoucherDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      usedCount: (usedCount != null ? usedCount.value : this.usedCount),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherQuery {
  const EventVoucherQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventVoucherQuery.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherQueryFromJson(json);

  static const toJsonFactory = _$EventVoucherQueryToJson;
  Map<String, dynamic> toJson() => _$EventVoucherQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventVoucherDoc>[])
  final List<EventVoucherDoc> resources;
  static const fromJsonFactory = _$EventVoucherQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherQuery &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventVoucherQueryExtension on EventVoucherQuery {
  EventVoucherQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventVoucherDoc>? resources,
  }) {
    return EventVoucherQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventVoucherQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventVoucherDoc>>? resources,
  }) {
    return EventVoucherQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionDoc {
  const EventQuestionDoc({
    required this.dataType,
    required this.id,
    required this.eventId,
    required this.title,
    required this.required,
    required this.answerType,
    required this.requireTime,
    this.answers,
    required this.createdAt,
    required this.pk,
  });

  factory EventQuestionDoc.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionDocFromJson(json);

  static const toJsonFactory = _$EventQuestionDocToJson;
  Map<String, dynamic> toJson() => _$EventQuestionDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventQuestion);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'required')
  final bool required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeToJson,
    fromJson: eventQuestionAnswerTypeFromJson,
  )
  final enums.EventQuestionAnswerType answerType;
  @JsonKey(name: 'requireTime')
  final bool requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventQuestionDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventQuestionDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality().equals(
                  other.required,
                  required,
                )) &&
            (identical(other.answerType, answerType) ||
                const DeepCollectionEquality().equals(
                  other.answerType,
                  answerType,
                )) &&
            (identical(other.requireTime, requireTime) ||
                const DeepCollectionEquality().equals(
                  other.requireTime,
                  requireTime,
                )) &&
            (identical(other.answers, answers) ||
                const DeepCollectionEquality().equals(
                  other.answers,
                  answers,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(answerType) ^
      const DeepCollectionEquality().hash(requireTime) ^
      const DeepCollectionEquality().hash(answers) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $EventQuestionDocExtension on EventQuestionDoc {
  EventQuestionDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? eventId,
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
    int? createdAt,
    String? pk,
  }) {
    return EventQuestionDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      eventId: eventId ?? this.eventId,
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
      createdAt: createdAt ?? this.createdAt,
      pk: pk ?? this.pk,
    );
  }

  EventQuestionDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? eventId,
    Wrapped<String>? title,
    Wrapped<bool>? required,
    Wrapped<enums.EventQuestionAnswerType>? answerType,
    Wrapped<bool>? requireTime,
    Wrapped<List<String>?>? answers,
    Wrapped<int>? createdAt,
    Wrapped<String>? pk,
  }) {
    return EventQuestionDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      eventId: (eventId != null ? eventId.value : this.eventId),
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionCreateDto {
  const EventQuestionCreateDto({
    required this.title,
    required this.required,
    required this.answerType,
    required this.requireTime,
    this.answers,
  });

  factory EventQuestionCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionCreateDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionCreateDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'required')
  final bool required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeToJson,
    fromJson: eventQuestionAnswerTypeFromJson,
  )
  final enums.EventQuestionAnswerType answerType;
  @JsonKey(name: 'requireTime')
  final bool requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  static const fromJsonFactory = _$EventQuestionCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventQuestionCreateDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality().equals(
                  other.required,
                  required,
                )) &&
            (identical(other.answerType, answerType) ||
                const DeepCollectionEquality().equals(
                  other.answerType,
                  answerType,
                )) &&
            (identical(other.requireTime, requireTime) ||
                const DeepCollectionEquality().equals(
                  other.requireTime,
                  requireTime,
                )) &&
            (identical(other.answers, answers) ||
                const DeepCollectionEquality().equals(other.answers, answers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(answerType) ^
      const DeepCollectionEquality().hash(requireTime) ^
      const DeepCollectionEquality().hash(answers) ^
      runtimeType.hashCode;
}

extension $EventQuestionCreateDtoExtension on EventQuestionCreateDto {
  EventQuestionCreateDto copyWith({
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
  }) {
    return EventQuestionCreateDto(
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
    );
  }

  EventQuestionCreateDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<bool>? required,
    Wrapped<enums.EventQuestionAnswerType>? answerType,
    Wrapped<bool>? requireTime,
    Wrapped<List<String>?>? answers,
  }) {
    return EventQuestionCreateDto(
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionEditDto {
  const EventQuestionEditDto({
    this.title,
    this.required,
    this.answerType,
    this.requireTime,
    this.answers,
  });

  factory EventQuestionEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionEditDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionEditDtoToJson(this);

  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'required')
  final bool? required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeNullableToJson,
    fromJson: eventQuestionAnswerTypeNullableFromJson,
  )
  final enums.EventQuestionAnswerType? answerType;
  @JsonKey(name: 'requireTime')
  final bool? requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  static const fromJsonFactory = _$EventQuestionEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventQuestionEditDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality().equals(
                  other.required,
                  required,
                )) &&
            (identical(other.answerType, answerType) ||
                const DeepCollectionEquality().equals(
                  other.answerType,
                  answerType,
                )) &&
            (identical(other.requireTime, requireTime) ||
                const DeepCollectionEquality().equals(
                  other.requireTime,
                  requireTime,
                )) &&
            (identical(other.answers, answers) ||
                const DeepCollectionEquality().equals(other.answers, answers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(answerType) ^
      const DeepCollectionEquality().hash(requireTime) ^
      const DeepCollectionEquality().hash(answers) ^
      runtimeType.hashCode;
}

extension $EventQuestionEditDtoExtension on EventQuestionEditDto {
  EventQuestionEditDto copyWith({
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
  }) {
    return EventQuestionEditDto(
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
    );
  }

  EventQuestionEditDto copyWithWrapped({
    Wrapped<String?>? title,
    Wrapped<bool?>? required,
    Wrapped<enums.EventQuestionAnswerType?>? answerType,
    Wrapped<bool?>? requireTime,
    Wrapped<List<String>?>? answers,
  }) {
    return EventQuestionEditDto(
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestFilterCriteriaDto {
  const EventGuestFilterCriteriaDto({
    this.searchText,
    this.wallet,
    this.eventId,
    this.status,
    this.questionnaireFilled,
    this.range,
  });

  factory EventGuestFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventGuestFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'wallet', defaultValue: <String>[])
  final List<String>? wallet;
  @JsonKey(name: 'eventId', defaultValue: <String>[])
  final List<String>? eventId;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusListToJson,
    fromJson: eventGuestStatusListFromJson,
  )
  final List<enums.EventGuestStatus>? status;
  @JsonKey(name: 'questionnaireFilled')
  final bool? questionnaireFilled;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventGuestFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.questionnaireFilled, questionnaireFilled) ||
                const DeepCollectionEquality().equals(
                  other.questionnaireFilled,
                  questionnaireFilled,
                )) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(questionnaireFilled) ^
      const DeepCollectionEquality().hash(range) ^
      runtimeType.hashCode;
}

extension $EventGuestFilterCriteriaDtoExtension on EventGuestFilterCriteriaDto {
  EventGuestFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? wallet,
    List<String>? eventId,
    List<enums.EventGuestStatus>? status,
    bool? questionnaireFilled,
    List<RangeFilter>? range,
  }) {
    return EventGuestFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      wallet: wallet ?? this.wallet,
      eventId: eventId ?? this.eventId,
      status: status ?? this.status,
      questionnaireFilled: questionnaireFilled ?? this.questionnaireFilled,
      range: range ?? this.range,
    );
  }

  EventGuestFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? wallet,
    Wrapped<List<String>?>? eventId,
    Wrapped<List<enums.EventGuestStatus>?>? status,
    Wrapped<bool?>? questionnaireFilled,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventGuestFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      wallet: (wallet != null ? wallet.value : this.wallet),
      eventId: (eventId != null ? eventId.value : this.eventId),
      status: (status != null ? status.value : this.status),
      questionnaireFilled: (questionnaireFilled != null
          ? questionnaireFilled.value
          : this.questionnaireFilled),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestFilter {
  const EventGuestFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventGuestFilter.fromJson(Map<String, dynamic> json) =>
      _$EventGuestFilterFromJson(json);

  static const toJsonFactory = _$EventGuestFilterToJson;
  Map<String, dynamic> toJson() => _$EventGuestFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventGuestFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventGuestFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EventGuestFilterExtension on EventGuestFilter {
  EventGuestFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventGuestFilterCriteriaDto? filters,
  }) {
    return EventGuestFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventGuestFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventGuestFilterCriteriaDto>? filters,
  }) {
    return EventGuestFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfile {
  const EventGuestProfile({
    required this.dataType,
    required this.wallet,
    required this.eventId,
    required this.ticket,
    required this.questionnaireFilled,
    this.registration,
    this.billing,
    required this.status,
    required this.createdAt,
    this.invitationId,
    this.metadata,
    this.id,
    this.pk,
    required this.ts,
    this.ttl,
    required this.profile,
    required this.herotag,
  });

  factory EventGuestProfile.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileFromJson(json);

  static const toJsonFactory = _$EventGuestProfileToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventGuest);

  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticket')
  final Map<String, dynamic> ticket;
  @JsonKey(name: 'questionnaireFilled')
  final bool questionnaireFilled;
  @JsonKey(name: 'registration')
  final EventGuestRegistration? registration;
  @JsonKey(name: 'billing')
  final EventGuestBilling? billing;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusToJson,
    fromJson: eventGuestStatusFromJson,
  )
  final enums.EventGuestStatus status;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'invitationId')
  final String? invitationId;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int ts;
  @JsonKey(name: 'ttl')
  final int? ttl;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'herotag')
  final String herotag;
  static const fromJsonFactory = _$EventGuestProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestProfile &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticket, ticket) ||
                const DeepCollectionEquality().equals(other.ticket, ticket)) &&
            (identical(other.questionnaireFilled, questionnaireFilled) ||
                const DeepCollectionEquality().equals(
                  other.questionnaireFilled,
                  questionnaireFilled,
                )) &&
            (identical(other.registration, registration) ||
                const DeepCollectionEquality().equals(
                  other.registration,
                  registration,
                )) &&
            (identical(other.billing, billing) ||
                const DeepCollectionEquality().equals(
                  other.billing,
                  billing,
                )) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality().equals(
                  other.invitationId,
                  invitationId,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.ttl, ttl) ||
                const DeepCollectionEquality().equals(other.ttl, ttl)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(other.herotag, herotag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticket) ^
      const DeepCollectionEquality().hash(questionnaireFilled) ^
      const DeepCollectionEquality().hash(registration) ^
      const DeepCollectionEquality().hash(billing) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(ttl) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(herotag) ^
      runtimeType.hashCode;
}

extension $EventGuestProfileExtension on EventGuestProfile {
  EventGuestProfile copyWith({
    enums.TicketingDataType? dataType,
    String? wallet,
    String? eventId,
    Map<String, dynamic>? ticket,
    bool? questionnaireFilled,
    EventGuestRegistration? registration,
    EventGuestBilling? billing,
    enums.EventGuestStatus? status,
    int? createdAt,
    String? invitationId,
    Object? metadata,
    String? id,
    String? pk,
    int? ts,
    int? ttl,
    String? profile,
    String? herotag,
  }) {
    return EventGuestProfile(
      dataType: dataType ?? this.dataType,
      wallet: wallet ?? this.wallet,
      eventId: eventId ?? this.eventId,
      ticket: ticket ?? this.ticket,
      questionnaireFilled: questionnaireFilled ?? this.questionnaireFilled,
      registration: registration ?? this.registration,
      billing: billing ?? this.billing,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      invitationId: invitationId ?? this.invitationId,
      metadata: metadata ?? this.metadata,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      ttl: ttl ?? this.ttl,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventGuestProfile copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? wallet,
    Wrapped<String>? eventId,
    Wrapped<Map<String, dynamic>>? ticket,
    Wrapped<bool>? questionnaireFilled,
    Wrapped<EventGuestRegistration?>? registration,
    Wrapped<EventGuestBilling?>? billing,
    Wrapped<enums.EventGuestStatus>? status,
    Wrapped<int>? createdAt,
    Wrapped<String?>? invitationId,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<int>? ts,
    Wrapped<int?>? ttl,
    Wrapped<String>? profile,
    Wrapped<String>? herotag,
  }) {
    return EventGuestProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      wallet: (wallet != null ? wallet.value : this.wallet),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticket: (ticket != null ? ticket.value : this.ticket),
      questionnaireFilled: (questionnaireFilled != null
          ? questionnaireFilled.value
          : this.questionnaireFilled),
      registration: (registration != null
          ? registration.value
          : this.registration),
      billing: (billing != null ? billing.value : this.billing),
      status: (status != null ? status.value : this.status),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      invitationId: (invitationId != null
          ? invitationId.value
          : this.invitationId),
      metadata: (metadata != null ? metadata.value : this.metadata),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      ttl: (ttl != null ? ttl.value : this.ttl),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfileQuery {
  const EventGuestProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventGuestProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileQueryFromJson(json);

  static const toJsonFactory = _$EventGuestProfileQueryToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventGuestProfile>[])
  final List<EventGuestProfile> resources;
  static const fromJsonFactory = _$EventGuestProfileQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestProfileQuery &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventGuestProfileQueryExtension on EventGuestProfileQuery {
  EventGuestProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventGuestProfile>? resources,
  }) {
    return EventGuestProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventGuestProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventGuestProfile>>? resources,
  }) {
    return EventGuestProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestExport {
  const EventGuestExport({
    required this.wallet,
    this.email,
    this.name,
    this.phone,
    required this.status,
  });

  factory EventGuestExport.fromJson(Map<String, dynamic> json) =>
      _$EventGuestExportFromJson(json);

  static const toJsonFactory = _$EventGuestExportToJson;
  Map<String, dynamic> toJson() => _$EventGuestExportToJson(this);

  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusToJson,
    fromJson: eventGuestStatusFromJson,
  )
  final enums.EventGuestStatus status;
  static const fromJsonFactory = _$EventGuestExportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestExport &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $EventGuestExportExtension on EventGuestExport {
  EventGuestExport copyWith({
    String? wallet,
    String? email,
    String? name,
    String? phone,
    enums.EventGuestStatus? status,
  }) {
    return EventGuestExport(
      wallet: wallet ?? this.wallet,
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      status: status ?? this.status,
    );
  }

  EventGuestExport copyWithWrapped({
    Wrapped<String>? wallet,
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
    Wrapped<enums.EventGuestStatus>? status,
  }) {
    return EventGuestExport(
      wallet: (wallet != null ? wallet.value : this.wallet),
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleCreateDto {
  const EventUserRoleCreateDto({
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.endTime,
  });

  factory EventUserRoleCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleCreateDtoFromJson(json);

  static const toJsonFactory = _$EventUserRoleCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleCreateDtoToJson(this);

  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'endTime')
  final int? endTime;
  static const fromJsonFactory = _$EventUserRoleCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventUserRoleCreateDto &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.permissions, permissions) ||
                const DeepCollectionEquality().equals(
                  other.permissions,
                  permissions,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(other.endTime, endTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(permissions) ^
      const DeepCollectionEquality().hash(endTime) ^
      runtimeType.hashCode;
}

extension $EventUserRoleCreateDtoExtension on EventUserRoleCreateDto {
  EventUserRoleCreateDto copyWith({
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? endTime,
  }) {
    return EventUserRoleCreateDto(
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      endTime: endTime ?? this.endTime,
    );
  }

  EventUserRoleCreateDto copyWithWrapped({
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? endTime,
  }) {
    return EventUserRoleCreateDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      endTime: (endTime != null ? endTime.value : this.endTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRole {
  const EventUserRole({
    required this.dataType,
    this.eventId,
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.createdAt,
    this.endTime,
    this.id,
    this.status,
    this.pk,
    this.ts,
    required this.profile,
    required this.herotag,
  });

  factory EventUserRole.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleFromJson(json);

  static const toJsonFactory = _$EventUserRoleToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'createdAt')
  final int? createdAt;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
    name: 'status',
    toJson: roleStatusNullableToJson,
    fromJson: roleStatusNullableFromJson,
  )
  final enums.RoleStatus? status;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'herotag')
  final String herotag;
  static const fromJsonFactory = _$EventUserRoleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventUserRole &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.permissions, permissions) ||
                const DeepCollectionEquality().equals(
                  other.permissions,
                  permissions,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(
                  other.endTime,
                  endTime,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.ts, ts) ||
                const DeepCollectionEquality().equals(other.ts, ts)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(
                  other.profile,
                  profile,
                )) &&
            (identical(other.herotag, herotag) ||
                const DeepCollectionEquality().equals(other.herotag, herotag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(permissions) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(ts) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(herotag) ^
      runtimeType.hashCode;
}

extension $EventUserRoleExtension on EventUserRole {
  EventUserRole copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? createdAt,
    int? endTime,
    String? id,
    enums.RoleStatus? status,
    String? pk,
    int? ts,
    String? profile,
    String? herotag,
  }) {
    return EventUserRole(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      createdAt: createdAt ?? this.createdAt,
      endTime: endTime ?? this.endTime,
      id: id ?? this.id,
      status: status ?? this.status,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventUserRole copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String?>? eventId,
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? createdAt,
    Wrapped<int?>? endTime,
    Wrapped<String?>? id,
    Wrapped<enums.RoleStatus?>? status,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<String>? profile,
    Wrapped<String>? herotag,
  }) {
    return EventUserRole(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      endTime: (endTime != null ? endTime.value : this.endTime),
      id: (id != null ? id.value : this.id),
      status: (status != null ? status.value : this.status),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleEditDto {
  const EventUserRoleEditDto({
    this.wallet,
    this.name,
    this.email,
    this.role,
    this.permissions,
    this.endTime,
  });

  factory EventUserRoleEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleEditDtoFromJson(json);

  static const toJsonFactory = _$EventUserRoleEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleEditDtoToJson(this);

  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles>? role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission>? permissions;
  @JsonKey(name: 'endTime')
  final int? endTime;
  static const fromJsonFactory = _$EventUserRoleEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventUserRoleEditDto &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.permissions, permissions) ||
                const DeepCollectionEquality().equals(
                  other.permissions,
                  permissions,
                )) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(other.endTime, endTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(permissions) ^
      const DeepCollectionEquality().hash(endTime) ^
      runtimeType.hashCode;
}

extension $EventUserRoleEditDtoExtension on EventUserRoleEditDto {
  EventUserRoleEditDto copyWith({
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? endTime,
  }) {
    return EventUserRoleEditDto(
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      endTime: endTime ?? this.endTime,
    );
  }

  EventUserRoleEditDto copyWithWrapped({
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>?>? role,
    Wrapped<List<enums.EventUserRolePermission>?>? permissions,
    Wrapped<int?>? endTime,
  }) {
    return EventUserRoleEditDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      endTime: (endTime != null ? endTime.value : this.endTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BageQRData {
  const BageQRData({required this.type, required this.data});

  factory BageQRData.fromJson(Map<String, dynamic> json) =>
      _$BageQRDataFromJson(json);

  static const toJsonFactory = _$BageQRDataToJson;
  Map<String, dynamic> toJson() => _$BageQRDataToJson(this);

  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$BageQRDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BageQRData &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BageQRDataExtension on BageQRData {
  BageQRData copyWith({enums.EventTicketQrType? type, String? data}) {
    return BageQRData(type: type ?? this.type, data: data ?? this.data);
  }

  BageQRData copyWithWrapped({
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<String>? data,
  }) {
    return BageQRData(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class QRBody {
  const QRBody({required this.type, required this.data});

  factory QRBody.fromJson(Map<String, dynamic> json) => _$QRBodyFromJson(json);

  static const toJsonFactory = _$QRBodyToJson;
  Map<String, dynamic> toJson() => _$QRBodyToJson(this);

  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$QRBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QRBody &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $QRBodyExtension on QRBody {
  QRBody copyWith({enums.EventTicketQrType? type, String? data}) {
    return QRBody(type: type ?? this.type, data: data ?? this.data);
  }

  QRBody copyWithWrapped({
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<String>? data,
  }) {
    return QRBody(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketsType {
  const TicketsType({required this.ticketId, required this.quantity});

  factory TicketsType.fromJson(Map<String, dynamic> json) =>
      _$TicketsTypeFromJson(json);

  static const toJsonFactory = _$TicketsTypeToJson;
  Map<String, dynamic> toJson() => _$TicketsTypeToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'quantity')
  final double quantity;
  static const fromJsonFactory = _$TicketsTypeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketsType &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $TicketsTypeExtension on TicketsType {
  TicketsType copyWith({String? ticketId, double? quantity}) {
    return TicketsType(
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
    );
  }

  TicketsType copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<double>? quantity,
  }) {
    return TicketsType(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventCheckInQR {
  const EventCheckInQR({required this.qr, this.tickets});

  factory EventCheckInQR.fromJson(Map<String, dynamic> json) =>
      _$EventCheckInQRFromJson(json);

  static const toJsonFactory = _$EventCheckInQRToJson;
  Map<String, dynamic> toJson() => _$EventCheckInQRToJson(this);

  @JsonKey(name: 'qr')
  final QRBody qr;
  @JsonKey(name: 'tickets', defaultValue: <TicketsType>[])
  final List<TicketsType>? tickets;
  static const fromJsonFactory = _$EventCheckInQRFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventCheckInQR &&
            (identical(other.qr, qr) ||
                const DeepCollectionEquality().equals(other.qr, qr)) &&
            (identical(other.tickets, tickets) ||
                const DeepCollectionEquality().equals(other.tickets, tickets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(qr) ^
      const DeepCollectionEquality().hash(tickets) ^
      runtimeType.hashCode;
}

extension $EventCheckInQRExtension on EventCheckInQR {
  EventCheckInQR copyWith({QRBody? qr, List<TicketsType>? tickets}) {
    return EventCheckInQR(qr: qr ?? this.qr, tickets: tickets ?? this.tickets);
  }

  EventCheckInQR copyWithWrapped({
    Wrapped<QRBody>? qr,
    Wrapped<List<TicketsType>?>? tickets,
  }) {
    return EventCheckInQR(
      qr: (qr != null ? qr.value : this.qr),
      tickets: (tickets != null ? tickets.value : this.tickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketSelection {
  const TicketSelection({
    required this.identifier,
    required this.ticketId,
    required this.quantity,
    this.ticketProfile,
  });

  factory TicketSelection.fromJson(Map<String, dynamic> json) =>
      _$TicketSelectionFromJson(json);

  static const toJsonFactory = _$TicketSelectionToJson;
  Map<String, dynamic> toJson() => _$TicketSelectionToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'ticketProfile')
  final TicketProfileSummary? ticketProfile;
  static const fromJsonFactory = _$TicketSelectionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketSelection &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality().equals(
                  other.identifier,
                  identifier,
                )) &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.ticketProfile, ticketProfile) ||
                const DeepCollectionEquality().equals(
                  other.ticketProfile,
                  ticketProfile,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(ticketProfile) ^
      runtimeType.hashCode;
}

extension $TicketSelectionExtension on TicketSelection {
  TicketSelection copyWith({
    String? identifier,
    String? ticketId,
    double? quantity,
    TicketProfileSummary? ticketProfile,
  }) {
    return TicketSelection(
      identifier: identifier ?? this.identifier,
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
      ticketProfile: ticketProfile ?? this.ticketProfile,
    );
  }

  TicketSelection copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? ticketId,
    Wrapped<double>? quantity,
    Wrapped<TicketProfileSummary?>? ticketProfile,
  }) {
    return TicketSelection(
      identifier: (identifier != null ? identifier.value : this.identifier),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
      ticketProfile: (ticketProfile != null
          ? ticketProfile.value
          : this.ticketProfile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketValidationResult {
  const TicketValidationResult({
    required this.status,
    required this.type,
    required this.message,
    this.guest,
    this.invitation,
    this.nfts,
    this.availableTickets,
  });

  factory TicketValidationResult.fromJson(Map<String, dynamic> json) =>
      _$TicketValidationResultFromJson(json);

  static const toJsonFactory = _$TicketValidationResultToJson;
  Map<String, dynamic> toJson() => _$TicketValidationResultToJson(this);

  @JsonKey(
    name: 'status',
    toJson: eventScanStatusToJson,
    fromJson: eventScanStatusFromJson,
  )
  final enums.EventScanStatus status;
  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(
    name: 'message',
    toJson: eventScanMessageToJson,
    fromJson: eventScanMessageFromJson,
  )
  final enums.EventScanMessage message;
  @JsonKey(name: 'guest')
  final EventGuestProfile? guest;
  @JsonKey(name: 'invitation')
  final EventInvitation? invitation;
  @JsonKey(name: 'nfts', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated>? nfts;
  @JsonKey(name: 'availableTickets', defaultValue: <TicketSelection>[])
  final List<TicketSelection>? availableTickets;
  static const fromJsonFactory = _$TicketValidationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TicketValidationResult &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.guest, guest) ||
                const DeepCollectionEquality().equals(other.guest, guest)) &&
            (identical(other.invitation, invitation) ||
                const DeepCollectionEquality().equals(
                  other.invitation,
                  invitation,
                )) &&
            (identical(other.nfts, nfts) ||
                const DeepCollectionEquality().equals(other.nfts, nfts)) &&
            (identical(other.availableTickets, availableTickets) ||
                const DeepCollectionEquality().equals(
                  other.availableTickets,
                  availableTickets,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(guest) ^
      const DeepCollectionEquality().hash(invitation) ^
      const DeepCollectionEquality().hash(nfts) ^
      const DeepCollectionEquality().hash(availableTickets) ^
      runtimeType.hashCode;
}

extension $TicketValidationResultExtension on TicketValidationResult {
  TicketValidationResult copyWith({
    enums.EventScanStatus? status,
    enums.EventTicketQrType? type,
    enums.EventScanMessage? message,
    EventGuestProfile? guest,
    EventInvitation? invitation,
    List<NftDocHydrated>? nfts,
    List<TicketSelection>? availableTickets,
  }) {
    return TicketValidationResult(
      status: status ?? this.status,
      type: type ?? this.type,
      message: message ?? this.message,
      guest: guest ?? this.guest,
      invitation: invitation ?? this.invitation,
      nfts: nfts ?? this.nfts,
      availableTickets: availableTickets ?? this.availableTickets,
    );
  }

  TicketValidationResult copyWithWrapped({
    Wrapped<enums.EventScanStatus>? status,
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<enums.EventScanMessage>? message,
    Wrapped<EventGuestProfile?>? guest,
    Wrapped<EventInvitation?>? invitation,
    Wrapped<List<NftDocHydrated>?>? nfts,
    Wrapped<List<TicketSelection>?>? availableTickets,
  }) {
    return TicketValidationResult(
      status: (status != null ? status.value : this.status),
      type: (type != null ? type.value : this.type),
      message: (message != null ? message.value : this.message),
      guest: (guest != null ? guest.value : this.guest),
      invitation: (invitation != null ? invitation.value : this.invitation),
      nfts: (nfts != null ? nfts.value : this.nfts),
      availableTickets: (availableTickets != null
          ? availableTickets.value
          : this.availableTickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherCreateDto {
  const EventVoucherCreateDto({
    this.code,
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.eventId,
    this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    this.startDate,
    this.endDate,
    this.isActive,
    this.ownerId,
    this.pk,
  });

  factory EventVoucherCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherCreateDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherCreateDtoToJson(this);

  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeNullableToJson,
    fromJson: voucherTypeNullableFromJson,
  )
  final enums.VoucherType? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int? maxUsesPerUser;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String>? ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int? startDate;
  @JsonKey(name: 'endDate')
  final int? endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$EventVoucherCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherCreateDto &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.maxDiscountAmount, maxDiscountAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxDiscountAmount,
                  maxDiscountAmount,
                )) &&
            (identical(other.maxUses, maxUses) ||
                const DeepCollectionEquality().equals(
                  other.maxUses,
                  maxUses,
                )) &&
            (identical(other.maxUsesPerUser, maxUsesPerUser) ||
                const DeepCollectionEquality().equals(
                  other.maxUsesPerUser,
                  maxUsesPerUser,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.ticketTypeIds, ticketTypeIds) ||
                const DeepCollectionEquality().equals(
                  other.ticketTypeIds,
                  ticketTypeIds,
                )) &&
            (identical(other.stageIds, stageIds) ||
                const DeepCollectionEquality().equals(
                  other.stageIds,
                  stageIds,
                )) &&
            (identical(other.minTicketCount, minTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.minTicketCount,
                  minTicketCount,
                )) &&
            (identical(other.maxTicketCount, maxTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.maxTicketCount,
                  maxTicketCount,
                )) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality().equals(
                  other.startDate,
                  startDate,
                )) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(
                  other.endDate,
                  endDate,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(maxDiscountAmount) ^
      const DeepCollectionEquality().hash(maxUses) ^
      const DeepCollectionEquality().hash(maxUsesPerUser) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(ticketTypeIds) ^
      const DeepCollectionEquality().hash(stageIds) ^
      const DeepCollectionEquality().hash(minTicketCount) ^
      const DeepCollectionEquality().hash(maxTicketCount) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $EventVoucherCreateDtoExtension on EventVoucherCreateDto {
  EventVoucherCreateDto copyWith({
    String? code,
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    String? eventId,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    String? pk,
  }) {
    return EventVoucherCreateDto(
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      eventId: eventId ?? this.eventId,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherCreateDto copyWithWrapped({
    Wrapped<String?>? code,
    Wrapped<enums.VoucherType?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int?>? maxUses,
    Wrapped<int?>? maxUsesPerUser,
    Wrapped<String?>? eventId,
    Wrapped<List<String>?>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int?>? startDate,
    Wrapped<int?>? endDate,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? pk,
  }) {
    return EventVoucherCreateDto(
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherEditDto {
  const EventVoucherEditDto({
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    this.startDate,
    this.endDate,
    this.isActive,
    this.ownerId,
    this.pk,
  });

  factory EventVoucherEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherEditDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherEditDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: voucherTypeNullableToJson,
    fromJson: voucherTypeNullableFromJson,
  )
  final enums.VoucherType? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int? maxUsesPerUser;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String>? ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int? startDate;
  @JsonKey(name: 'endDate')
  final int? endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$EventVoucherEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventVoucherEditDto &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.maxDiscountAmount, maxDiscountAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxDiscountAmount,
                  maxDiscountAmount,
                )) &&
            (identical(other.maxUses, maxUses) ||
                const DeepCollectionEquality().equals(
                  other.maxUses,
                  maxUses,
                )) &&
            (identical(other.maxUsesPerUser, maxUsesPerUser) ||
                const DeepCollectionEquality().equals(
                  other.maxUsesPerUser,
                  maxUsesPerUser,
                )) &&
            (identical(other.ticketTypeIds, ticketTypeIds) ||
                const DeepCollectionEquality().equals(
                  other.ticketTypeIds,
                  ticketTypeIds,
                )) &&
            (identical(other.stageIds, stageIds) ||
                const DeepCollectionEquality().equals(
                  other.stageIds,
                  stageIds,
                )) &&
            (identical(other.minTicketCount, minTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.minTicketCount,
                  minTicketCount,
                )) &&
            (identical(other.maxTicketCount, maxTicketCount) ||
                const DeepCollectionEquality().equals(
                  other.maxTicketCount,
                  maxTicketCount,
                )) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality().equals(
                  other.startDate,
                  startDate,
                )) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(
                  other.endDate,
                  endDate,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(maxDiscountAmount) ^
      const DeepCollectionEquality().hash(maxUses) ^
      const DeepCollectionEquality().hash(maxUsesPerUser) ^
      const DeepCollectionEquality().hash(ticketTypeIds) ^
      const DeepCollectionEquality().hash(stageIds) ^
      const DeepCollectionEquality().hash(minTicketCount) ^
      const DeepCollectionEquality().hash(maxTicketCount) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $EventVoucherEditDtoExtension on EventVoucherEditDto {
  EventVoucherEditDto copyWith({
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    String? pk,
  }) {
    return EventVoucherEditDto(
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherEditDto copyWithWrapped({
    Wrapped<enums.VoucherType?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int?>? maxUses,
    Wrapped<int?>? maxUsesPerUser,
    Wrapped<List<String>?>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int?>? startDate,
    Wrapped<int?>? endDate,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? pk,
  }) {
    return EventVoucherEditDto(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ManualCheckInDto {
  const ManualCheckInDto({
    required this.invitationIdOrAddress,
    this.selectedTickets,
  });

  factory ManualCheckInDto.fromJson(Map<String, dynamic> json) =>
      _$ManualCheckInDtoFromJson(json);

  static const toJsonFactory = _$ManualCheckInDtoToJson;
  Map<String, dynamic> toJson() => _$ManualCheckInDtoToJson(this);

  @JsonKey(name: 'invitationIdOrAddress')
  final String invitationIdOrAddress;
  @JsonKey(name: 'selectedTickets', defaultValue: <TicketsType>[])
  final List<TicketsType>? selectedTickets;
  static const fromJsonFactory = _$ManualCheckInDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ManualCheckInDto &&
            (identical(other.invitationIdOrAddress, invitationIdOrAddress) ||
                const DeepCollectionEquality().equals(
                  other.invitationIdOrAddress,
                  invitationIdOrAddress,
                )) &&
            (identical(other.selectedTickets, selectedTickets) ||
                const DeepCollectionEquality().equals(
                  other.selectedTickets,
                  selectedTickets,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationIdOrAddress) ^
      const DeepCollectionEquality().hash(selectedTickets) ^
      runtimeType.hashCode;
}

extension $ManualCheckInDtoExtension on ManualCheckInDto {
  ManualCheckInDto copyWith({
    String? invitationIdOrAddress,
    List<TicketsType>? selectedTickets,
  }) {
    return ManualCheckInDto(
      invitationIdOrAddress:
          invitationIdOrAddress ?? this.invitationIdOrAddress,
      selectedTickets: selectedTickets ?? this.selectedTickets,
    );
  }

  ManualCheckInDto copyWithWrapped({
    Wrapped<String>? invitationIdOrAddress,
    Wrapped<List<TicketsType>?>? selectedTickets,
  }) {
    return ManualCheckInDto(
      invitationIdOrAddress: (invitationIdOrAddress != null
          ? invitationIdOrAddress.value
          : this.invitationIdOrAddress),
      selectedTickets: (selectedTickets != null
          ? selectedTickets.value
          : this.selectedTickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestAnswerDoc {
  const EventGuestAnswerDoc({
    required this.dataType,
    required this.id,
    required this.wallet,
    required this.questionId,
    required this.eventId,
    required this.answer,
    required this.createdAt,
    this.ttl,
  });

  factory EventGuestAnswerDoc.fromJson(Map<String, dynamic> json) =>
      _$EventGuestAnswerDocFromJson(json);

  static const toJsonFactory = _$EventGuestAnswerDocToJson;
  Map<String, dynamic> toJson() => _$EventGuestAnswerDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventQuestionAnswer,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'questionId')
  final String questionId;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'answer')
  final Object answer;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'ttl')
  final int? ttl;
  static const fromJsonFactory = _$EventGuestAnswerDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestAnswerDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.questionId, questionId) ||
                const DeepCollectionEquality().equals(
                  other.questionId,
                  questionId,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.answer, answer) ||
                const DeepCollectionEquality().equals(other.answer, answer)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.ttl, ttl) ||
                const DeepCollectionEquality().equals(other.ttl, ttl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(questionId) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(answer) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(ttl) ^
      runtimeType.hashCode;
}

extension $EventGuestAnswerDocExtension on EventGuestAnswerDoc {
  EventGuestAnswerDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? wallet,
    String? questionId,
    String? eventId,
    Object? answer,
    int? createdAt,
    int? ttl,
  }) {
    return EventGuestAnswerDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      wallet: wallet ?? this.wallet,
      questionId: questionId ?? this.questionId,
      eventId: eventId ?? this.eventId,
      answer: answer ?? this.answer,
      createdAt: createdAt ?? this.createdAt,
      ttl: ttl ?? this.ttl,
    );
  }

  EventGuestAnswerDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? wallet,
    Wrapped<String>? questionId,
    Wrapped<String>? eventId,
    Wrapped<Object>? answer,
    Wrapped<int>? createdAt,
    Wrapped<int?>? ttl,
  }) {
    return EventGuestAnswerDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      wallet: (wallet != null ? wallet.value : this.wallet),
      questionId: (questionId != null ? questionId.value : this.questionId),
      eventId: (eventId != null ? eventId.value : this.eventId),
      answer: (answer != null ? answer.value : this.answer),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      ttl: (ttl != null ? ttl.value : this.ttl),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnsweredQuestionWithDetails {
  const AnsweredQuestionWithDetails({this.answer, this.question});

  factory AnsweredQuestionWithDetails.fromJson(Map<String, dynamic> json) =>
      _$AnsweredQuestionWithDetailsFromJson(json);

  static const toJsonFactory = _$AnsweredQuestionWithDetailsToJson;
  Map<String, dynamic> toJson() => _$AnsweredQuestionWithDetailsToJson(this);

  @JsonKey(name: 'answer')
  final EventGuestAnswerDoc? answer;
  @JsonKey(name: 'question')
  final EventQuestionDoc? question;
  static const fromJsonFactory = _$AnsweredQuestionWithDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnsweredQuestionWithDetails &&
            (identical(other.answer, answer) ||
                const DeepCollectionEquality().equals(other.answer, answer)) &&
            (identical(other.question, question) ||
                const DeepCollectionEquality().equals(
                  other.question,
                  question,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(answer) ^
      const DeepCollectionEquality().hash(question) ^
      runtimeType.hashCode;
}

extension $AnsweredQuestionWithDetailsExtension on AnsweredQuestionWithDetails {
  AnsweredQuestionWithDetails copyWith({
    EventGuestAnswerDoc? answer,
    EventQuestionDoc? question,
  }) {
    return AnsweredQuestionWithDetails(
      answer: answer ?? this.answer,
      question: question ?? this.question,
    );
  }

  AnsweredQuestionWithDetails copyWithWrapped({
    Wrapped<EventGuestAnswerDoc?>? answer,
    Wrapped<EventQuestionDoc?>? question,
  }) {
    return AnsweredQuestionWithDetails(
      answer: (answer != null ? answer.value : this.answer),
      question: (question != null ? question.value : this.question),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestApproveDto {
  const EventGuestApproveDto({this.address, required this.isApproved});

  factory EventGuestApproveDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestApproveDtoFromJson(json);

  static const toJsonFactory = _$EventGuestApproveDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestApproveDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'isApproved')
  final bool isApproved;
  static const fromJsonFactory = _$EventGuestApproveDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestApproveDto &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(
                  other.address,
                  address,
                )) &&
            (identical(other.isApproved, isApproved) ||
                const DeepCollectionEquality().equals(
                  other.isApproved,
                  isApproved,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(isApproved) ^
      runtimeType.hashCode;
}

extension $EventGuestApproveDtoExtension on EventGuestApproveDto {
  EventGuestApproveDto copyWith({String? address, bool? isApproved}) {
    return EventGuestApproveDto(
      address: address ?? this.address,
      isApproved: isApproved ?? this.isApproved,
    );
  }

  EventGuestApproveDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<bool>? isApproved,
  }) {
    return EventGuestApproveDto(
      address: (address != null ? address.value : this.address),
      isApproved: (isApproved != null ? isApproved.value : this.isApproved),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventLocationCities {
  const EventLocationCities({required this.city, required this.eventCount});

  factory EventLocationCities.fromJson(Map<String, dynamic> json) =>
      _$EventLocationCitiesFromJson(json);

  static const toJsonFactory = _$EventLocationCitiesToJson;
  Map<String, dynamic> toJson() => _$EventLocationCitiesToJson(this);

  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'eventCount')
  final double eventCount;
  static const fromJsonFactory = _$EventLocationCitiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventLocationCities &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.eventCount, eventCount) ||
                const DeepCollectionEquality().equals(
                  other.eventCount,
                  eventCount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(eventCount) ^
      runtimeType.hashCode;
}

extension $EventLocationCitiesExtension on EventLocationCities {
  EventLocationCities copyWith({String? city, double? eventCount}) {
    return EventLocationCities(
      city: city ?? this.city,
      eventCount: eventCount ?? this.eventCount,
    );
  }

  EventLocationCities copyWithWrapped({
    Wrapped<String>? city,
    Wrapped<double>? eventCount,
  }) {
    return EventLocationCities(
      city: (city != null ? city.value : this.city),
      eventCount: (eventCount != null ? eventCount.value : this.eventCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventCountGroupedByCountry {
  const EventCountGroupedByCountry({
    required this.country,
    required this.eventCount,
    required this.cities,
  });

  factory EventCountGroupedByCountry.fromJson(Map<String, dynamic> json) =>
      _$EventCountGroupedByCountryFromJson(json);

  static const toJsonFactory = _$EventCountGroupedByCountryToJson;
  Map<String, dynamic> toJson() => _$EventCountGroupedByCountryToJson(this);

  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'eventCount')
  final double eventCount;
  @JsonKey(name: 'cities', defaultValue: <EventLocationCities>[])
  final List<EventLocationCities> cities;
  static const fromJsonFactory = _$EventCountGroupedByCountryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventCountGroupedByCountry &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.eventCount, eventCount) ||
                const DeepCollectionEquality().equals(
                  other.eventCount,
                  eventCount,
                )) &&
            (identical(other.cities, cities) ||
                const DeepCollectionEquality().equals(other.cities, cities)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(eventCount) ^
      const DeepCollectionEquality().hash(cities) ^
      runtimeType.hashCode;
}

extension $EventCountGroupedByCountryExtension on EventCountGroupedByCountry {
  EventCountGroupedByCountry copyWith({
    String? country,
    double? eventCount,
    List<EventLocationCities>? cities,
  }) {
    return EventCountGroupedByCountry(
      country: country ?? this.country,
      eventCount: eventCount ?? this.eventCount,
      cities: cities ?? this.cities,
    );
  }

  EventCountGroupedByCountry copyWithWrapped({
    Wrapped<String>? country,
    Wrapped<double>? eventCount,
    Wrapped<List<EventLocationCities>>? cities,
  }) {
    return EventCountGroupedByCountry(
      country: (country != null ? country.value : this.country),
      eventCount: (eventCount != null ? eventCount.value : this.eventCount),
      cities: (cities != null ? cities.value : this.cities),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortVoucherDoc {
  const ShortVoucherDoc({
    required this.type,
    required this.amount,
    this.maxDiscountAmount,
  });

  factory ShortVoucherDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortVoucherDocFromJson(json);

  static const toJsonFactory = _$ShortVoucherDocToJson;
  Map<String, dynamic> toJson() => _$ShortVoucherDocToJson(this);

  @JsonKey(
    name: 'type',
    toJson: voucherTypeToJson,
    fromJson: voucherTypeFromJson,
  )
  final enums.VoucherType type;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  static const fromJsonFactory = _$ShortVoucherDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShortVoucherDoc &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.maxDiscountAmount, maxDiscountAmount) ||
                const DeepCollectionEquality().equals(
                  other.maxDiscountAmount,
                  maxDiscountAmount,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(maxDiscountAmount) ^
      runtimeType.hashCode;
}

extension $ShortVoucherDocExtension on ShortVoucherDoc {
  ShortVoucherDoc copyWith({
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
  }) {
    return ShortVoucherDoc(
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
    );
  }

  ShortVoucherDoc copyWithWrapped({
    Wrapped<enums.VoucherType>? type,
    Wrapped<double>? amount,
    Wrapped<double?>? maxDiscountAmount,
  }) {
    return ShortVoucherDoc(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RewardDetails {
  const RewardDetails({
    required this.rewardType,
    required this.conditionType,
    required this.condition,
    this.currency,
    this.voucherInfo,
  });

  factory RewardDetails.fromJson(Map<String, dynamic> json) =>
      _$RewardDetailsFromJson(json);

  static const toJsonFactory = _$RewardDetailsToJson;
  Map<String, dynamic> toJson() => _$RewardDetailsToJson(this);

  @JsonKey(
    name: 'rewardType',
    toJson: eventReferralEnumToJson,
    fromJson: eventReferralEnumFromJson,
  )
  final enums.EventReferralEnum rewardType;
  @JsonKey(
    name: 'conditionType',
    toJson: referralConditionTypeToJson,
    fromJson: referralConditionTypeFromJson,
  )
  final enums.ReferralConditionType conditionType;
  @JsonKey(name: 'condition')
  final double condition;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'voucherInfo')
  final ShortVoucherDoc? voucherInfo;
  static const fromJsonFactory = _$RewardDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RewardDetails &&
            (identical(other.rewardType, rewardType) ||
                const DeepCollectionEquality().equals(
                  other.rewardType,
                  rewardType,
                )) &&
            (identical(other.conditionType, conditionType) ||
                const DeepCollectionEquality().equals(
                  other.conditionType,
                  conditionType,
                )) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality().equals(
                  other.condition,
                  condition,
                )) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality().equals(
                  other.currency,
                  currency,
                )) &&
            (identical(other.voucherInfo, voucherInfo) ||
                const DeepCollectionEquality().equals(
                  other.voucherInfo,
                  voucherInfo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rewardType) ^
      const DeepCollectionEquality().hash(conditionType) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(voucherInfo) ^
      runtimeType.hashCode;
}

extension $RewardDetailsExtension on RewardDetails {
  RewardDetails copyWith({
    enums.EventReferralEnum? rewardType,
    enums.ReferralConditionType? conditionType,
    double? condition,
    String? currency,
    ShortVoucherDoc? voucherInfo,
  }) {
    return RewardDetails(
      rewardType: rewardType ?? this.rewardType,
      conditionType: conditionType ?? this.conditionType,
      condition: condition ?? this.condition,
      currency: currency ?? this.currency,
      voucherInfo: voucherInfo ?? this.voucherInfo,
    );
  }

  RewardDetails copyWithWrapped({
    Wrapped<enums.EventReferralEnum>? rewardType,
    Wrapped<enums.ReferralConditionType>? conditionType,
    Wrapped<double>? condition,
    Wrapped<String?>? currency,
    Wrapped<ShortVoucherDoc?>? voucherInfo,
  }) {
    return RewardDetails(
      rewardType: (rewardType != null ? rewardType.value : this.rewardType),
      conditionType: (conditionType != null
          ? conditionType.value
          : this.conditionType),
      condition: (condition != null ? condition.value : this.condition),
      currency: (currency != null ? currency.value : this.currency),
      voucherInfo: (voucherInfo != null ? voucherInfo.value : this.voucherInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigCreateDto {
  const EventReferralConfigCreateDto({
    this.appliedVoucher,
    this.rewardDetails,
    required this.isSelfService,
    required this.isActive,
  });

  factory EventReferralConfigCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigCreateDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigCreateDtoToJson(this);

  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isSelfService')
  final bool isSelfService;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$EventReferralConfigCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigCreateDto &&
            (identical(other.appliedVoucher, appliedVoucher) ||
                const DeepCollectionEquality().equals(
                  other.appliedVoucher,
                  appliedVoucher,
                )) &&
            (identical(other.rewardDetails, rewardDetails) ||
                const DeepCollectionEquality().equals(
                  other.rewardDetails,
                  rewardDetails,
                )) &&
            (identical(other.isSelfService, isSelfService) ||
                const DeepCollectionEquality().equals(
                  other.isSelfService,
                  isSelfService,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(appliedVoucher) ^
      const DeepCollectionEquality().hash(rewardDetails) ^
      const DeepCollectionEquality().hash(isSelfService) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigCreateDtoExtension
    on EventReferralConfigCreateDto {
  EventReferralConfigCreateDto copyWith({
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isSelfService,
    bool? isActive,
  }) {
    return EventReferralConfigCreateDto(
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isSelfService: isSelfService ?? this.isSelfService,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralConfigCreateDto copyWithWrapped({
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool>? isSelfService,
    Wrapped<bool>? isActive,
  }) {
    return EventReferralConfigCreateDto(
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigDoc {
  const EventReferralConfigDoc({
    required this.dataType,
    required this.id,
    required this.eventId,
    this.appliedVoucher,
    this.rewardDetails,
    required this.isSelfService,
    required this.isActive,
    required this.createdAt,
    required this.createdBy,
    required this.pk,
  });

  factory EventReferralConfigDoc.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigDocFromJson(json);

  static const toJsonFactory = _$EventReferralConfigDocToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventReferralConfig,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isSelfService')
  final bool isSelfService;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'createdBy')
  final String createdBy;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventReferralConfigDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.appliedVoucher, appliedVoucher) ||
                const DeepCollectionEquality().equals(
                  other.appliedVoucher,
                  appliedVoucher,
                )) &&
            (identical(other.rewardDetails, rewardDetails) ||
                const DeepCollectionEquality().equals(
                  other.rewardDetails,
                  rewardDetails,
                )) &&
            (identical(other.isSelfService, isSelfService) ||
                const DeepCollectionEquality().equals(
                  other.isSelfService,
                  isSelfService,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality().equals(
                  other.createdBy,
                  createdBy,
                )) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(appliedVoucher) ^
      const DeepCollectionEquality().hash(rewardDetails) ^
      const DeepCollectionEquality().hash(isSelfService) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(pk) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigDocExtension on EventReferralConfigDoc {
  EventReferralConfigDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? eventId,
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isSelfService,
    bool? isActive,
    int? createdAt,
    String? createdBy,
    String? pk,
  }) {
    return EventReferralConfigDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      eventId: eventId ?? this.eventId,
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isSelfService: isSelfService ?? this.isSelfService,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      createdBy: createdBy ?? this.createdBy,
      pk: pk ?? this.pk,
    );
  }

  EventReferralConfigDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? eventId,
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool>? isSelfService,
    Wrapped<bool>? isActive,
    Wrapped<int>? createdAt,
    Wrapped<String>? createdBy,
    Wrapped<String>? pk,
  }) {
    return EventReferralConfigDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      eventId: (eventId != null ? eventId.value : this.eventId),
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      isActive: (isActive != null ? isActive.value : this.isActive),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigEditDto {
  const EventReferralConfigEditDto({
    this.appliedVoucher,
    this.rewardDetails,
    this.isSelfService,
    this.isActive,
  });

  factory EventReferralConfigEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigEditDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigEditDtoToJson(this);

  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isSelfService')
  final bool? isSelfService;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  static const fromJsonFactory = _$EventReferralConfigEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigEditDto &&
            (identical(other.appliedVoucher, appliedVoucher) ||
                const DeepCollectionEquality().equals(
                  other.appliedVoucher,
                  appliedVoucher,
                )) &&
            (identical(other.rewardDetails, rewardDetails) ||
                const DeepCollectionEquality().equals(
                  other.rewardDetails,
                  rewardDetails,
                )) &&
            (identical(other.isSelfService, isSelfService) ||
                const DeepCollectionEquality().equals(
                  other.isSelfService,
                  isSelfService,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(appliedVoucher) ^
      const DeepCollectionEquality().hash(rewardDetails) ^
      const DeepCollectionEquality().hash(isSelfService) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigEditDtoExtension on EventReferralConfigEditDto {
  EventReferralConfigEditDto copyWith({
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isSelfService,
    bool? isActive,
  }) {
    return EventReferralConfigEditDto(
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isSelfService: isSelfService ?? this.isSelfService,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralConfigEditDto copyWithWrapped({
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool?>? isSelfService,
    Wrapped<bool?>? isActive,
  }) {
    return EventReferralConfigEditDto(
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigFilterCriteriaDto {
  const EventReferralConfigFilterCriteriaDto({
    this.searchText,
    this.ownerId,
    this.isActive,
    this.isSelfService,
    this.createdAt,
  });

  factory EventReferralConfigFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$EventReferralConfigFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$EventReferralConfigFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'isSelfService')
  final bool? isSelfService;
  @JsonKey(name: 'createdAt', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? createdAt;
  static const fromJsonFactory = _$EventReferralConfigFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.isSelfService, isSelfService) ||
                const DeepCollectionEquality().equals(
                  other.isSelfService,
                  isSelfService,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(isSelfService) ^
      const DeepCollectionEquality().hash(createdAt) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigFilterCriteriaDtoExtension
    on EventReferralConfigFilterCriteriaDto {
  EventReferralConfigFilterCriteriaDto copyWith({
    String? searchText,
    String? ownerId,
    bool? isActive,
    bool? isSelfService,
    List<RangeFilter>? createdAt,
  }) {
    return EventReferralConfigFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      ownerId: ownerId ?? this.ownerId,
      isActive: isActive ?? this.isActive,
      isSelfService: isSelfService ?? this.isSelfService,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  EventReferralConfigFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<String?>? ownerId,
    Wrapped<bool?>? isActive,
    Wrapped<bool?>? isSelfService,
    Wrapped<List<RangeFilter>?>? createdAt,
  }) {
    return EventReferralConfigFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigFilter {
  const EventReferralConfigFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventReferralConfigFilter.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigFilterFromJson(json);

  static const toJsonFactory = _$EventReferralConfigFilterToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventReferralConfigFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventReferralConfigFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigFilterExtension on EventReferralConfigFilter {
  EventReferralConfigFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventReferralConfigFilterCriteriaDto? filters,
  }) {
    return EventReferralConfigFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventReferralConfigFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventReferralConfigFilterCriteriaDto>? filters,
  }) {
    return EventReferralConfigFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigPaginated {
  const EventReferralConfigPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventReferralConfigPaginated.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigPaginatedFromJson(json);

  static const toJsonFactory = _$EventReferralConfigPaginatedToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventReferralConfigDoc>[])
  final List<EventReferralConfigDoc> resources;
  static const fromJsonFactory = _$EventReferralConfigPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralConfigPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventReferralConfigPaginatedExtension
    on EventReferralConfigPaginated {
  EventReferralConfigPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventReferralConfigDoc>? resources,
  }) {
    return EventReferralConfigPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventReferralConfigPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventReferralConfigDoc>>? resources,
  }) {
    return EventReferralConfigPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralCreateDto {
  const EventReferralCreateDto({
    required this.referralCode,
    required this.referralConfigId,
  });

  factory EventReferralCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralCreateDtoFromJson(json);

  static const toJsonFactory = _$EventReferralCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralCreateDtoToJson(this);

  @JsonKey(name: 'referralCode')
  final String referralCode;
  @JsonKey(name: 'referralConfigId')
  final String referralConfigId;
  static const fromJsonFactory = _$EventReferralCreateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralCreateDto &&
            (identical(other.referralCode, referralCode) ||
                const DeepCollectionEquality().equals(
                  other.referralCode,
                  referralCode,
                )) &&
            (identical(other.referralConfigId, referralConfigId) ||
                const DeepCollectionEquality().equals(
                  other.referralConfigId,
                  referralConfigId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(referralCode) ^
      const DeepCollectionEquality().hash(referralConfigId) ^
      runtimeType.hashCode;
}

extension $EventReferralCreateDtoExtension on EventReferralCreateDto {
  EventReferralCreateDto copyWith({
    String? referralCode,
    String? referralConfigId,
  }) {
    return EventReferralCreateDto(
      referralCode: referralCode ?? this.referralCode,
      referralConfigId: referralConfigId ?? this.referralConfigId,
    );
  }

  EventReferralCreateDto copyWithWrapped({
    Wrapped<String>? referralCode,
    Wrapped<String>? referralConfigId,
  }) {
    return EventReferralCreateDto(
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralDoc {
  const EventReferralDoc({
    required this.dataType,
    required this.id,
    required this.pk,
    required this.referralCode,
    this.ownerId,
    required this.eventId,
    required this.referralConfigId,
    required this.successfulReferrals,
    required this.createdAt,
    required this.isActive,
  });

  factory EventReferralDoc.fromJson(Map<String, dynamic> json) =>
      _$EventReferralDocFromJson(json);

  static const toJsonFactory = _$EventReferralDocToJson;
  Map<String, dynamic> toJson() => _$EventReferralDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventReferralCode,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: 'referralCode')
  final String referralCode;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'referralConfigId')
  final String referralConfigId;
  @JsonKey(name: 'successfulReferrals')
  final int successfulReferrals;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$EventReferralDocFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralDoc &&
            (identical(other.dataType, dataType) ||
                const DeepCollectionEquality().equals(
                  other.dataType,
                  dataType,
                )) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pk, pk) ||
                const DeepCollectionEquality().equals(other.pk, pk)) &&
            (identical(other.referralCode, referralCode) ||
                const DeepCollectionEquality().equals(
                  other.referralCode,
                  referralCode,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality().equals(
                  other.eventId,
                  eventId,
                )) &&
            (identical(other.referralConfigId, referralConfigId) ||
                const DeepCollectionEquality().equals(
                  other.referralConfigId,
                  referralConfigId,
                )) &&
            (identical(other.successfulReferrals, successfulReferrals) ||
                const DeepCollectionEquality().equals(
                  other.successfulReferrals,
                  successfulReferrals,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pk) ^
      const DeepCollectionEquality().hash(referralCode) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(referralConfigId) ^
      const DeepCollectionEquality().hash(successfulReferrals) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $EventReferralDocExtension on EventReferralDoc {
  EventReferralDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? pk,
    String? referralCode,
    String? ownerId,
    String? eventId,
    String? referralConfigId,
    int? successfulReferrals,
    int? createdAt,
    bool? isActive,
  }) {
    return EventReferralDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      referralCode: referralCode ?? this.referralCode,
      ownerId: ownerId ?? this.ownerId,
      eventId: eventId ?? this.eventId,
      referralConfigId: referralConfigId ?? this.referralConfigId,
      successfulReferrals: successfulReferrals ?? this.successfulReferrals,
      createdAt: createdAt ?? this.createdAt,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<String>? referralCode,
    Wrapped<String?>? ownerId,
    Wrapped<String>? eventId,
    Wrapped<String>? referralConfigId,
    Wrapped<int>? successfulReferrals,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isActive,
  }) {
    return EventReferralDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      eventId: (eventId != null ? eventId.value : this.eventId),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
      successfulReferrals: (successfulReferrals != null
          ? successfulReferrals.value
          : this.successfulReferrals),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralEditDto {
  const EventReferralEditDto({this.isActive});

  factory EventReferralEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralEditDtoFromJson(json);

  static const toJsonFactory = _$EventReferralEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralEditDtoToJson(this);

  @JsonKey(name: 'isActive')
  final bool? isActive;
  static const fromJsonFactory = _$EventReferralEditDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralEditDto &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isActive) ^ runtimeType.hashCode;
}

extension $EventReferralEditDtoExtension on EventReferralEditDto {
  EventReferralEditDto copyWith({bool? isActive}) {
    return EventReferralEditDto(isActive: isActive ?? this.isActive);
  }

  EventReferralEditDto copyWithWrapped({Wrapped<bool?>? isActive}) {
    return EventReferralEditDto(
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralFilterCriteriaDto {
  const EventReferralFilterCriteriaDto({
    this.searchText,
    this.referralCode,
    this.ownerId,
    this.referralConfigId,
    this.isActive,
    this.minSuccessfulReferrals,
    this.maxSuccessfulReferrals,
    this.conditionType,
    this.createdAt,
  });

  factory EventReferralFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventReferralFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'referralCode', defaultValue: <String>[])
  final List<String>? referralCode;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'referralConfigId')
  final String? referralConfigId;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'minSuccessfulReferrals')
  final double? minSuccessfulReferrals;
  @JsonKey(name: 'maxSuccessfulReferrals')
  final double? maxSuccessfulReferrals;
  @JsonKey(
    name: 'conditionType',
    toJson: referralConditionTypeListToJson,
    fromJson: referralConditionTypeListFromJson,
  )
  final List<enums.ReferralConditionType>? conditionType;
  @JsonKey(name: 'createdAt', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? createdAt;
  static const fromJsonFactory = _$EventReferralFilterCriteriaDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralFilterCriteriaDto &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality().equals(
                  other.searchText,
                  searchText,
                )) &&
            (identical(other.referralCode, referralCode) ||
                const DeepCollectionEquality().equals(
                  other.referralCode,
                  referralCode,
                )) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(
                  other.ownerId,
                  ownerId,
                )) &&
            (identical(other.referralConfigId, referralConfigId) ||
                const DeepCollectionEquality().equals(
                  other.referralConfigId,
                  referralConfigId,
                )) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality().equals(
                  other.isActive,
                  isActive,
                )) &&
            (identical(other.minSuccessfulReferrals, minSuccessfulReferrals) ||
                const DeepCollectionEquality().equals(
                  other.minSuccessfulReferrals,
                  minSuccessfulReferrals,
                )) &&
            (identical(other.maxSuccessfulReferrals, maxSuccessfulReferrals) ||
                const DeepCollectionEquality().equals(
                  other.maxSuccessfulReferrals,
                  maxSuccessfulReferrals,
                )) &&
            (identical(other.conditionType, conditionType) ||
                const DeepCollectionEquality().equals(
                  other.conditionType,
                  conditionType,
                )) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(referralCode) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(referralConfigId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(minSuccessfulReferrals) ^
      const DeepCollectionEquality().hash(maxSuccessfulReferrals) ^
      const DeepCollectionEquality().hash(conditionType) ^
      const DeepCollectionEquality().hash(createdAt) ^
      runtimeType.hashCode;
}

extension $EventReferralFilterCriteriaDtoExtension
    on EventReferralFilterCriteriaDto {
  EventReferralFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? referralCode,
    String? ownerId,
    String? referralConfigId,
    bool? isActive,
    double? minSuccessfulReferrals,
    double? maxSuccessfulReferrals,
    List<enums.ReferralConditionType>? conditionType,
    List<RangeFilter>? createdAt,
  }) {
    return EventReferralFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      referralCode: referralCode ?? this.referralCode,
      ownerId: ownerId ?? this.ownerId,
      referralConfigId: referralConfigId ?? this.referralConfigId,
      isActive: isActive ?? this.isActive,
      minSuccessfulReferrals:
          minSuccessfulReferrals ?? this.minSuccessfulReferrals,
      maxSuccessfulReferrals:
          maxSuccessfulReferrals ?? this.maxSuccessfulReferrals,
      conditionType: conditionType ?? this.conditionType,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  EventReferralFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? referralCode,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? referralConfigId,
    Wrapped<bool?>? isActive,
    Wrapped<double?>? minSuccessfulReferrals,
    Wrapped<double?>? maxSuccessfulReferrals,
    Wrapped<List<enums.ReferralConditionType>?>? conditionType,
    Wrapped<List<RangeFilter>?>? createdAt,
  }) {
    return EventReferralFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      minSuccessfulReferrals: (minSuccessfulReferrals != null
          ? minSuccessfulReferrals.value
          : this.minSuccessfulReferrals),
      maxSuccessfulReferrals: (maxSuccessfulReferrals != null
          ? maxSuccessfulReferrals.value
          : this.maxSuccessfulReferrals),
      conditionType: (conditionType != null
          ? conditionType.value
          : this.conditionType),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralFilter {
  const EventReferralFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventReferralFilter.fromJson(Map<String, dynamic> json) =>
      _$EventReferralFilterFromJson(json);

  static const toJsonFactory = _$EventReferralFilterToJson;
  Map<String, dynamic> toJson() => _$EventReferralFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventReferralFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventReferralFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralFilter &&
            (identical(other.select, select) ||
                const DeepCollectionEquality().equals(other.select, select)) &&
            (identical(other.orderBy, orderBy) ||
                const DeepCollectionEquality().equals(
                  other.orderBy,
                  orderBy,
                )) &&
            (identical(other.includeCount, includeCount) ||
                const DeepCollectionEquality().equals(
                  other.includeCount,
                  includeCount,
                )) &&
            (identical(other.strictSelect, strictSelect) ||
                const DeepCollectionEquality().equals(
                  other.strictSelect,
                  strictSelect,
                )) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.skip, skip) ||
                const DeepCollectionEquality().equals(other.skip, skip)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(select) ^
      const DeepCollectionEquality().hash(orderBy) ^
      const DeepCollectionEquality().hash(includeCount) ^
      const DeepCollectionEquality().hash(strictSelect) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(skip) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EventReferralFilterExtension on EventReferralFilter {
  EventReferralFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventReferralFilterCriteriaDto? filters,
  }) {
    return EventReferralFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventReferralFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventReferralFilterCriteriaDto>? filters,
  }) {
    return EventReferralFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralPaginated {
  const EventReferralPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventReferralPaginated.fromJson(Map<String, dynamic> json) =>
      _$EventReferralPaginatedFromJson(json);

  static const toJsonFactory = _$EventReferralPaginatedToJson;
  Map<String, dynamic> toJson() => _$EventReferralPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventReferralDoc>[])
  final List<EventReferralDoc> resources;
  static const fromJsonFactory = _$EventReferralPaginatedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventReferralPaginated &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.hasMoreResults, hasMoreResults) ||
                const DeepCollectionEquality().equals(
                  other.hasMoreResults,
                  hasMoreResults,
                )) &&
            (identical(other.resources, resources) ||
                const DeepCollectionEquality().equals(
                  other.resources,
                  resources,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(hasMoreResults) ^
      const DeepCollectionEquality().hash(resources) ^
      runtimeType.hashCode;
}

extension $EventReferralPaginatedExtension on EventReferralPaginated {
  EventReferralPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventReferralDoc>? resources,
  }) {
    return EventReferralPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventReferralPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventReferralDoc>>? resources,
  }) {
    return EventReferralPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftSaleInfo {
  const NftSaleInfo({
    required this.auctionId,
    required this.seller,
    required this.minBid,
    required this.maxBid,
    this.currentBid,
    required this.startTime,
    required this.deadline,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.auctionType,
    required this.timestamp,
    required this.minBidShort,
    this.minBidUsdValue,
    required this.maxBidShort,
    this.maxBidUsdValue,
    this.currentBidShort,
    required this.quantity,
    required this.marketplace,
    this.royalties,
    this.currentWinner,
  });

  factory NftSaleInfo.fromJson(Map<String, dynamic> json) =>
      _$NftSaleInfoFromJson(json);

  static const toJsonFactory = _$NftSaleInfoToJson;
  Map<String, dynamic> toJson() => _$NftSaleInfoToJson(this);

  @JsonKey(name: 'auctionId')
  final double auctionId;
  @JsonKey(name: 'seller')
  final String seller;
  @JsonKey(name: 'minBid')
  final String minBid;
  @JsonKey(name: 'maxBid')
  final String maxBid;
  @JsonKey(name: 'currentBid')
  final String? currentBid;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'deadline')
  final double deadline;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(
    name: 'auctionType',
    toJson: xoxnoAuctionTypeStringToJson,
    fromJson: xoxnoAuctionTypeStringFromJson,
  )
  final enums.XoxnoAuctionTypeString auctionType;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'minBidUsdValue')
  final double? minBidUsdValue;
  @JsonKey(name: 'maxBidShort')
  final double maxBidShort;
  @JsonKey(name: 'maxBidUsdValue')
  final double? maxBidUsdValue;
  @JsonKey(name: 'currentBidShort')
  final double? currentBidShort;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(
    name: 'marketplace',
    toJson: marketplacesOnSaleNamesToJson,
    fromJson: marketplacesOnSaleNamesFromJson,
  )
  final enums.MarketplacesOnSaleNames marketplace;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'currentWinner')
  final String? currentWinner;
  static const fromJsonFactory = _$NftSaleInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftSaleInfo &&
            (identical(other.auctionId, auctionId) ||
                const DeepCollectionEquality().equals(
                  other.auctionId,
                  auctionId,
                )) &&
            (identical(other.seller, seller) ||
                const DeepCollectionEquality().equals(other.seller, seller)) &&
            (identical(other.minBid, minBid) ||
                const DeepCollectionEquality().equals(other.minBid, minBid)) &&
            (identical(other.maxBid, maxBid) ||
                const DeepCollectionEquality().equals(other.maxBid, maxBid)) &&
            (identical(other.currentBid, currentBid) ||
                const DeepCollectionEquality().equals(
                  other.currentBid,
                  currentBid,
                )) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )) &&
            (identical(other.deadline, deadline) ||
                const DeepCollectionEquality().equals(
                  other.deadline,
                  deadline,
                )) &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.paymentTokenNonce, paymentTokenNonce) ||
                const DeepCollectionEquality().equals(
                  other.paymentTokenNonce,
                  paymentTokenNonce,
                )) &&
            (identical(other.auctionType, auctionType) ||
                const DeepCollectionEquality().equals(
                  other.auctionType,
                  auctionType,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.minBidShort, minBidShort) ||
                const DeepCollectionEquality().equals(
                  other.minBidShort,
                  minBidShort,
                )) &&
            (identical(other.minBidUsdValue, minBidUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.minBidUsdValue,
                  minBidUsdValue,
                )) &&
            (identical(other.maxBidShort, maxBidShort) ||
                const DeepCollectionEquality().equals(
                  other.maxBidShort,
                  maxBidShort,
                )) &&
            (identical(other.maxBidUsdValue, maxBidUsdValue) ||
                const DeepCollectionEquality().equals(
                  other.maxBidUsdValue,
                  maxBidUsdValue,
                )) &&
            (identical(other.currentBidShort, currentBidShort) ||
                const DeepCollectionEquality().equals(
                  other.currentBidShort,
                  currentBidShort,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.marketplace, marketplace) ||
                const DeepCollectionEquality().equals(
                  other.marketplace,
                  marketplace,
                )) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality().equals(
                  other.royalties,
                  royalties,
                )) &&
            (identical(other.currentWinner, currentWinner) ||
                const DeepCollectionEquality().equals(
                  other.currentWinner,
                  currentWinner,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auctionId) ^
      const DeepCollectionEquality().hash(seller) ^
      const DeepCollectionEquality().hash(minBid) ^
      const DeepCollectionEquality().hash(maxBid) ^
      const DeepCollectionEquality().hash(currentBid) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(deadline) ^
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenNonce) ^
      const DeepCollectionEquality().hash(auctionType) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(minBidShort) ^
      const DeepCollectionEquality().hash(minBidUsdValue) ^
      const DeepCollectionEquality().hash(maxBidShort) ^
      const DeepCollectionEquality().hash(maxBidUsdValue) ^
      const DeepCollectionEquality().hash(currentBidShort) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(marketplace) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(currentWinner) ^
      runtimeType.hashCode;
}

extension $NftSaleInfoExtension on NftSaleInfo {
  NftSaleInfo copyWith({
    double? auctionId,
    String? seller,
    String? minBid,
    String? maxBid,
    String? currentBid,
    double? startTime,
    double? deadline,
    String? paymentToken,
    double? paymentTokenNonce,
    enums.XoxnoAuctionTypeString? auctionType,
    double? timestamp,
    double? minBidShort,
    double? minBidUsdValue,
    double? maxBidShort,
    double? maxBidUsdValue,
    double? currentBidShort,
    double? quantity,
    enums.MarketplacesOnSaleNames? marketplace,
    double? royalties,
    String? currentWinner,
  }) {
    return NftSaleInfo(
      auctionId: auctionId ?? this.auctionId,
      seller: seller ?? this.seller,
      minBid: minBid ?? this.minBid,
      maxBid: maxBid ?? this.maxBid,
      currentBid: currentBid ?? this.currentBid,
      startTime: startTime ?? this.startTime,
      deadline: deadline ?? this.deadline,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      auctionType: auctionType ?? this.auctionType,
      timestamp: timestamp ?? this.timestamp,
      minBidShort: minBidShort ?? this.minBidShort,
      minBidUsdValue: minBidUsdValue ?? this.minBidUsdValue,
      maxBidShort: maxBidShort ?? this.maxBidShort,
      maxBidUsdValue: maxBidUsdValue ?? this.maxBidUsdValue,
      currentBidShort: currentBidShort ?? this.currentBidShort,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      royalties: royalties ?? this.royalties,
      currentWinner: currentWinner ?? this.currentWinner,
    );
  }

  NftSaleInfo copyWithWrapped({
    Wrapped<double>? auctionId,
    Wrapped<String>? seller,
    Wrapped<String>? minBid,
    Wrapped<String>? maxBid,
    Wrapped<String?>? currentBid,
    Wrapped<double>? startTime,
    Wrapped<double>? deadline,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<enums.XoxnoAuctionTypeString>? auctionType,
    Wrapped<double>? timestamp,
    Wrapped<double>? minBidShort,
    Wrapped<double?>? minBidUsdValue,
    Wrapped<double>? maxBidShort,
    Wrapped<double?>? maxBidUsdValue,
    Wrapped<double?>? currentBidShort,
    Wrapped<double>? quantity,
    Wrapped<enums.MarketplacesOnSaleNames>? marketplace,
    Wrapped<double?>? royalties,
    Wrapped<String?>? currentWinner,
  }) {
    return NftSaleInfo(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      seller: (seller != null ? seller.value : this.seller),
      minBid: (minBid != null ? minBid.value : this.minBid),
      maxBid: (maxBid != null ? maxBid.value : this.maxBid),
      currentBid: (currentBid != null ? currentBid.value : this.currentBid),
      startTime: (startTime != null ? startTime.value : this.startTime),
      deadline: (deadline != null ? deadline.value : this.deadline),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      minBidUsdValue: (minBidUsdValue != null
          ? minBidUsdValue.value
          : this.minBidUsdValue),
      maxBidShort: (maxBidShort != null ? maxBidShort.value : this.maxBidShort),
      maxBidUsdValue: (maxBidUsdValue != null
          ? maxBidUsdValue.value
          : this.maxBidUsdValue),
      currentBidShort: (currentBidShort != null
          ? currentBidShort.value
          : this.currentBidShort),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      royalties: (royalties != null ? royalties.value : this.royalties),
      currentWinner: (currentWinner != null
          ? currentWinner.value
          : this.currentWinner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestCheckIn {
  const EventGuestCheckIn({
    required this.ticketId,
    this.ticketProfile,
    required this.isCheckIn,
    required this.freeTicket,
    required this.receivedAt,
    this.invitationId,
    this.timestamp,
    this.quantity,
    this.transactionId,
  });

  factory EventGuestCheckIn.fromJson(Map<String, dynamic> json) =>
      _$EventGuestCheckInFromJson(json);

  static const toJsonFactory = _$EventGuestCheckInToJson;
  Map<String, dynamic> toJson() => _$EventGuestCheckInToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'ticketProfile')
  final TicketProfileSummary? ticketProfile;
  @JsonKey(name: 'isCheckIn')
  final bool isCheckIn;
  @JsonKey(name: 'freeTicket', defaultValue: false)
  final bool freeTicket;
  @JsonKey(name: 'receivedAt')
  final int receivedAt;
  @JsonKey(name: 'invitationId')
  final String? invitationId;
  @JsonKey(name: 'timestamp')
  final int? timestamp;
  @JsonKey(name: 'quantity')
  final int? quantity;
  @JsonKey(name: 'transactionId')
  final String? transactionId;
  static const fromJsonFactory = _$EventGuestCheckInFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventGuestCheckIn &&
            (identical(other.ticketId, ticketId) ||
                const DeepCollectionEquality().equals(
                  other.ticketId,
                  ticketId,
                )) &&
            (identical(other.ticketProfile, ticketProfile) ||
                const DeepCollectionEquality().equals(
                  other.ticketProfile,
                  ticketProfile,
                )) &&
            (identical(other.isCheckIn, isCheckIn) ||
                const DeepCollectionEquality().equals(
                  other.isCheckIn,
                  isCheckIn,
                )) &&
            (identical(other.freeTicket, freeTicket) ||
                const DeepCollectionEquality().equals(
                  other.freeTicket,
                  freeTicket,
                )) &&
            (identical(other.receivedAt, receivedAt) ||
                const DeepCollectionEquality().equals(
                  other.receivedAt,
                  receivedAt,
                )) &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality().equals(
                  other.invitationId,
                  invitationId,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality().equals(
                  other.transactionId,
                  transactionId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ticketId) ^
      const DeepCollectionEquality().hash(ticketProfile) ^
      const DeepCollectionEquality().hash(isCheckIn) ^
      const DeepCollectionEquality().hash(freeTicket) ^
      const DeepCollectionEquality().hash(receivedAt) ^
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $EventGuestCheckInExtension on EventGuestCheckIn {
  EventGuestCheckIn copyWith({
    String? ticketId,
    TicketProfileSummary? ticketProfile,
    bool? isCheckIn,
    bool? freeTicket,
    int? receivedAt,
    String? invitationId,
    int? timestamp,
    int? quantity,
    String? transactionId,
  }) {
    return EventGuestCheckIn(
      ticketId: ticketId ?? this.ticketId,
      ticketProfile: ticketProfile ?? this.ticketProfile,
      isCheckIn: isCheckIn ?? this.isCheckIn,
      freeTicket: freeTicket ?? this.freeTicket,
      receivedAt: receivedAt ?? this.receivedAt,
      invitationId: invitationId ?? this.invitationId,
      timestamp: timestamp ?? this.timestamp,
      quantity: quantity ?? this.quantity,
      transactionId: transactionId ?? this.transactionId,
    );
  }

  EventGuestCheckIn copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<TicketProfileSummary?>? ticketProfile,
    Wrapped<bool>? isCheckIn,
    Wrapped<bool>? freeTicket,
    Wrapped<int>? receivedAt,
    Wrapped<String?>? invitationId,
    Wrapped<int?>? timestamp,
    Wrapped<int?>? quantity,
    Wrapped<String?>? transactionId,
  }) {
    return EventGuestCheckIn(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      ticketProfile: (ticketProfile != null
          ? ticketProfile.value
          : this.ticketProfile),
      isCheckIn: (isCheckIn != null ? isCheckIn.value : this.isCheckIn),
      freeTicket: (freeTicket != null ? freeTicket.value : this.freeTicket),
      receivedAt: (receivedAt != null ? receivedAt.value : this.receivedAt),
      invitationId: (invitationId != null
          ? invitationId.value
          : this.invitationId),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      quantity: (quantity != null ? quantity.value : this.quantity),
      transactionId: (transactionId != null
          ? transactionId.value
          : this.transactionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressUploadPicturePut$RequestBody {
  const UserAddressUploadPicturePut$RequestBody({required this.file});

  factory UserAddressUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$UserAddressUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressUploadPicturePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserAddressUploadPicturePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $UserAddressUploadPicturePut$RequestBodyExtension
    on UserAddressUploadPicturePut$RequestBody {
  UserAddressUploadPicturePut$RequestBody copyWith({String? file}) {
    return UserAddressUploadPicturePut$RequestBody(file: file ?? this.file);
  }

  UserAddressUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressUploadBannerPut$RequestBody {
  const UserAddressUploadBannerPut$RequestBody({required this.file});

  factory UserAddressUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$UserAddressUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressUploadBannerPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserAddressUploadBannerPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $UserAddressUploadBannerPut$RequestBodyExtension
    on UserAddressUploadBannerPut$RequestBody {
  UserAddressUploadBannerPut$RequestBody copyWith({String? file}) {
    return UserAddressUploadBannerPut$RequestBody(file: file ?? this.file);
  }

  UserAddressUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressCreatorUploadPicturePut$RequestBody {
  const UserAddressCreatorUploadPicturePut$RequestBody({required this.file});

  factory UserAddressCreatorUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressCreatorUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$UserAddressCreatorUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressCreatorUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressCreatorUploadPicturePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserAddressCreatorUploadPicturePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $UserAddressCreatorUploadPicturePut$RequestBodyExtension
    on UserAddressCreatorUploadPicturePut$RequestBody {
  UserAddressCreatorUploadPicturePut$RequestBody copyWith({String? file}) {
    return UserAddressCreatorUploadPicturePut$RequestBody(
      file: file ?? this.file,
    );
  }

  UserAddressCreatorUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressCreatorUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressCreatorUploadBannerPut$RequestBody {
  const UserAddressCreatorUploadBannerPut$RequestBody({required this.file});

  factory UserAddressCreatorUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressCreatorUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$UserAddressCreatorUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressCreatorUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressCreatorUploadBannerPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserAddressCreatorUploadBannerPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $UserAddressCreatorUploadBannerPut$RequestBodyExtension
    on UserAddressCreatorUploadBannerPut$RequestBody {
  UserAddressCreatorUploadBannerPut$RequestBody copyWith({String? file}) {
    return UserAddressCreatorUploadBannerPut$RequestBody(
      file: file ?? this.file,
    );
  }

  UserAddressCreatorUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressCreatorUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionCollectionUploadPicturePut$RequestBody {
  const CollectionCollectionUploadPicturePut$RequestBody({required this.file});

  factory CollectionCollectionUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionCollectionUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$CollectionCollectionUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionCollectionUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$CollectionCollectionUploadPicturePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionCollectionUploadPicturePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $CollectionCollectionUploadPicturePut$RequestBodyExtension
    on CollectionCollectionUploadPicturePut$RequestBody {
  CollectionCollectionUploadPicturePut$RequestBody copyWith({String? file}) {
    return CollectionCollectionUploadPicturePut$RequestBody(
      file: file ?? this.file,
    );
  }

  CollectionCollectionUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return CollectionCollectionUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionCollectionUploadBannerPut$RequestBody {
  const CollectionCollectionUploadBannerPut$RequestBody({required this.file});

  factory CollectionCollectionUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionCollectionUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$CollectionCollectionUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionCollectionUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$CollectionCollectionUploadBannerPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionCollectionUploadBannerPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $CollectionCollectionUploadBannerPut$RequestBodyExtension
    on CollectionCollectionUploadBannerPut$RequestBody {
  CollectionCollectionUploadBannerPut$RequestBody copyWith({String? file}) {
    return CollectionCollectionUploadBannerPut$RequestBody(
      file: file ?? this.file,
    );
  }

  CollectionCollectionUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return CollectionCollectionUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PoolPoolIdUploadPicturePut$RequestBody {
  const PoolPoolIdUploadPicturePut$RequestBody({required this.file});

  factory PoolPoolIdUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$PoolPoolIdUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$PoolPoolIdUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$PoolPoolIdUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$PoolPoolIdUploadPicturePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PoolPoolIdUploadPicturePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $PoolPoolIdUploadPicturePut$RequestBodyExtension
    on PoolPoolIdUploadPicturePut$RequestBody {
  PoolPoolIdUploadPicturePut$RequestBody copyWith({String? file}) {
    return PoolPoolIdUploadPicturePut$RequestBody(file: file ?? this.file);
  }

  PoolPoolIdUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return PoolPoolIdUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdProfilePut$RequestBody {
  const EventEventIdProfilePut$RequestBody({required this.file});

  factory EventEventIdProfilePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdProfilePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdProfilePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdProfilePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory = _$EventEventIdProfilePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEventIdProfilePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $EventEventIdProfilePut$RequestBodyExtension
    on EventEventIdProfilePut$RequestBody {
  EventEventIdProfilePut$RequestBody copyWith({String? file}) {
    return EventEventIdProfilePut$RequestBody(file: file ?? this.file);
  }

  EventEventIdProfilePut$RequestBody copyWithWrapped({Wrapped<String>? file}) {
    return EventEventIdProfilePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdBackgroundPut$RequestBody {
  const EventEventIdBackgroundPut$RequestBody({required this.file});

  factory EventEventIdBackgroundPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdBackgroundPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdBackgroundPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdBackgroundPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdBackgroundPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEventIdBackgroundPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $EventEventIdBackgroundPut$RequestBodyExtension
    on EventEventIdBackgroundPut$RequestBody {
  EventEventIdBackgroundPut$RequestBody copyWith({String? file}) {
    return EventEventIdBackgroundPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdBackgroundPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdBackgroundPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdDescriptionPut$RequestBody {
  const EventEventIdDescriptionPut$RequestBody({required this.file});

  factory EventEventIdDescriptionPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdDescriptionPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdDescriptionPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdDescriptionPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdDescriptionPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEventIdDescriptionPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $EventEventIdDescriptionPut$RequestBodyExtension
    on EventEventIdDescriptionPut$RequestBody {
  EventEventIdDescriptionPut$RequestBody copyWith({String? file}) {
    return EventEventIdDescriptionPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdDescriptionPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdDescriptionPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdDescriptionImagePut$RequestBody {
  const EventEventIdDescriptionImagePut$RequestBody({required this.file});

  factory EventEventIdDescriptionImagePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdDescriptionImagePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$EventEventIdDescriptionImagePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdDescriptionImagePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdDescriptionImagePut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEventIdDescriptionImagePut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $EventEventIdDescriptionImagePut$RequestBodyExtension
    on EventEventIdDescriptionImagePut$RequestBody {
  EventEventIdDescriptionImagePut$RequestBody copyWith({String? file}) {
    return EventEventIdDescriptionImagePut$RequestBody(file: file ?? this.file);
  }

  EventEventIdDescriptionImagePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdDescriptionImagePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdTicketTicketIdPut$RequestBody {
  const EventEventIdTicketTicketIdPut$RequestBody({required this.file});

  factory EventEventIdTicketTicketIdPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdTicketTicketIdPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$EventEventIdTicketTicketIdPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdTicketTicketIdPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdTicketTicketIdPut$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEventIdTicketTicketIdPut$RequestBody &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^ runtimeType.hashCode;
}

extension $EventEventIdTicketTicketIdPut$RequestBodyExtension
    on EventEventIdTicketTicketIdPut$RequestBody {
  EventEventIdTicketTicketIdPut$RequestBody copyWith({String? file}) {
    return EventEventIdTicketTicketIdPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdTicketTicketIdPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdTicketTicketIdPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDataHydrated$OriginalPayment {
  const NftActivityDataHydrated$OriginalPayment({
    this.paymentToken,
    this.price,
  });

  factory NftActivityDataHydrated$OriginalPayment.fromJson(
    Map<String, dynamic> json,
  ) => _$NftActivityDataHydrated$OriginalPaymentFromJson(json);

  static const toJsonFactory = _$NftActivityDataHydrated$OriginalPaymentToJson;
  Map<String, dynamic> toJson() =>
      _$NftActivityDataHydrated$OriginalPaymentToJson(this);

  @JsonKey(name: 'paymentToken')
  final String? paymentToken;
  @JsonKey(name: 'price')
  final double? price;
  static const fromJsonFactory =
      _$NftActivityDataHydrated$OriginalPaymentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NftActivityDataHydrated$OriginalPayment &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality().equals(
                  other.paymentToken,
                  paymentToken,
                )) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(price) ^
      runtimeType.hashCode;
}

extension $NftActivityDataHydrated$OriginalPaymentExtension
    on NftActivityDataHydrated$OriginalPayment {
  NftActivityDataHydrated$OriginalPayment copyWith({
    String? paymentToken,
    double? price,
  }) {
    return NftActivityDataHydrated$OriginalPayment(
      paymentToken: paymentToken ?? this.paymentToken,
      price: price ?? this.price,
    );
  }

  NftActivityDataHydrated$OriginalPayment copyWithWrapped({
    Wrapped<String?>? paymentToken,
    Wrapped<double?>? price,
  }) {
    return NftActivityDataHydrated$OriginalPayment(
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      price: (price != null ? price.value : this.price),
    );
  }
}

String? activityChainNullableToJson(enums.ActivityChain? activityChain) {
  return activityChain?.value;
}

String? activityChainToJson(enums.ActivityChain activityChain) {
  return activityChain.value;
}

enums.ActivityChain activityChainFromJson(
  Object? activityChain, [
  enums.ActivityChain? defaultValue,
]) {
  return enums.ActivityChain.values.firstWhereOrNull(
        (e) => e.value == activityChain,
      ) ??
      defaultValue ??
      enums.ActivityChain.swaggerGeneratedUnknown;
}

enums.ActivityChain? activityChainNullableFromJson(
  Object? activityChain, [
  enums.ActivityChain? defaultValue,
]) {
  if (activityChain == null) {
    return null;
  }
  return enums.ActivityChain.values.firstWhereOrNull(
        (e) => e.value == activityChain,
      ) ??
      defaultValue;
}

String activityChainExplodedListToJson(
  List<enums.ActivityChain>? activityChain,
) {
  return activityChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> activityChainListToJson(List<enums.ActivityChain>? activityChain) {
  if (activityChain == null) {
    return [];
  }

  return activityChain.map((e) => e.value!).toList();
}

List<enums.ActivityChain> activityChainListFromJson(
  List? activityChain, [
  List<enums.ActivityChain>? defaultValue,
]) {
  if (activityChain == null) {
    return defaultValue ?? [];
  }

  return activityChain.map((e) => activityChainFromJson(e.toString())).toList();
}

List<enums.ActivityChain>? activityChainNullableListFromJson(
  List? activityChain, [
  List<enums.ActivityChain>? defaultValue,
]) {
  if (activityChain == null) {
    return defaultValue;
  }

  return activityChain.map((e) => activityChainFromJson(e.toString())).toList();
}

String? userProfileDocDataTypeNullableToJson(
  enums.UserProfileDocDataType? userProfileDocDataType,
) {
  return userProfileDocDataType?.value;
}

String? userProfileDocDataTypeToJson(
  enums.UserProfileDocDataType userProfileDocDataType,
) {
  return userProfileDocDataType.value;
}

enums.UserProfileDocDataType userProfileDocDataTypeFromJson(
  Object? userProfileDocDataType, [
  enums.UserProfileDocDataType? defaultValue,
]) {
  return enums.UserProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDocDataType,
      ) ??
      defaultValue ??
      enums.UserProfileDocDataType.swaggerGeneratedUnknown;
}

enums.UserProfileDocDataType? userProfileDocDataTypeNullableFromJson(
  Object? userProfileDocDataType, [
  enums.UserProfileDocDataType? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return null;
  }
  return enums.UserProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDocDataType,
      ) ??
      defaultValue;
}

String userProfileDocDataTypeExplodedListToJson(
  List<enums.UserProfileDocDataType>? userProfileDocDataType,
) {
  return userProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDocDataTypeListToJson(
  List<enums.UserProfileDocDataType>? userProfileDocDataType,
) {
  if (userProfileDocDataType == null) {
    return [];
  }

  return userProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.UserProfileDocDataType> userProfileDocDataTypeListFromJson(
  List? userProfileDocDataType, [
  List<enums.UserProfileDocDataType>? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return userProfileDocDataType
      .map((e) => userProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDocDataType>? userProfileDocDataTypeNullableListFromJson(
  List? userProfileDocDataType, [
  List<enums.UserProfileDocDataType>? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return defaultValue;
  }

  return userProfileDocDataType
      .map((e) => userProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? userProfileDocChainNullableToJson(
  enums.UserProfileDocChain? userProfileDocChain,
) {
  return userProfileDocChain?.value;
}

String? userProfileDocChainToJson(
  enums.UserProfileDocChain userProfileDocChain,
) {
  return userProfileDocChain.value;
}

enums.UserProfileDocChain userProfileDocChainFromJson(
  Object? userProfileDocChain, [
  enums.UserProfileDocChain? defaultValue,
]) {
  return enums.UserProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDocChain,
      ) ??
      defaultValue ??
      enums.UserProfileDocChain.swaggerGeneratedUnknown;
}

enums.UserProfileDocChain? userProfileDocChainNullableFromJson(
  Object? userProfileDocChain, [
  enums.UserProfileDocChain? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return null;
  }
  return enums.UserProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDocChain,
      ) ??
      defaultValue;
}

String userProfileDocChainExplodedListToJson(
  List<enums.UserProfileDocChain>? userProfileDocChain,
) {
  return userProfileDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDocChainListToJson(
  List<enums.UserProfileDocChain>? userProfileDocChain,
) {
  if (userProfileDocChain == null) {
    return [];
  }

  return userProfileDocChain.map((e) => e.value!).toList();
}

List<enums.UserProfileDocChain> userProfileDocChainListFromJson(
  List? userProfileDocChain, [
  List<enums.UserProfileDocChain>? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return defaultValue ?? [];
  }

  return userProfileDocChain
      .map((e) => userProfileDocChainFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDocChain>? userProfileDocChainNullableListFromJson(
  List? userProfileDocChain, [
  List<enums.UserProfileDocChain>? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return defaultValue;
  }

  return userProfileDocChain
      .map((e) => userProfileDocChainFromJson(e.toString()))
      .toList();
}

String? userProfileDtoDataTypeNullableToJson(
  enums.UserProfileDtoDataType? userProfileDtoDataType,
) {
  return userProfileDtoDataType?.value;
}

String? userProfileDtoDataTypeToJson(
  enums.UserProfileDtoDataType userProfileDtoDataType,
) {
  return userProfileDtoDataType.value;
}

enums.UserProfileDtoDataType userProfileDtoDataTypeFromJson(
  Object? userProfileDtoDataType, [
  enums.UserProfileDtoDataType? defaultValue,
]) {
  return enums.UserProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoDataType,
      ) ??
      defaultValue ??
      enums.UserProfileDtoDataType.swaggerGeneratedUnknown;
}

enums.UserProfileDtoDataType? userProfileDtoDataTypeNullableFromJson(
  Object? userProfileDtoDataType, [
  enums.UserProfileDtoDataType? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return null;
  }
  return enums.UserProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoDataType,
      ) ??
      defaultValue;
}

String userProfileDtoDataTypeExplodedListToJson(
  List<enums.UserProfileDtoDataType>? userProfileDtoDataType,
) {
  return userProfileDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDtoDataTypeListToJson(
  List<enums.UserProfileDtoDataType>? userProfileDtoDataType,
) {
  if (userProfileDtoDataType == null) {
    return [];
  }

  return userProfileDtoDataType.map((e) => e.value!).toList();
}

List<enums.UserProfileDtoDataType> userProfileDtoDataTypeListFromJson(
  List? userProfileDtoDataType, [
  List<enums.UserProfileDtoDataType>? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return defaultValue ?? [];
  }

  return userProfileDtoDataType
      .map((e) => userProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDtoDataType>? userProfileDtoDataTypeNullableListFromJson(
  List? userProfileDtoDataType, [
  List<enums.UserProfileDtoDataType>? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return defaultValue;
  }

  return userProfileDtoDataType
      .map((e) => userProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? userProfileDtoChainNullableToJson(
  enums.UserProfileDtoChain? userProfileDtoChain,
) {
  return userProfileDtoChain?.value;
}

String? userProfileDtoChainToJson(
  enums.UserProfileDtoChain userProfileDtoChain,
) {
  return userProfileDtoChain.value;
}

enums.UserProfileDtoChain userProfileDtoChainFromJson(
  Object? userProfileDtoChain, [
  enums.UserProfileDtoChain? defaultValue,
]) {
  return enums.UserProfileDtoChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoChain,
      ) ??
      defaultValue ??
      enums.UserProfileDtoChain.swaggerGeneratedUnknown;
}

enums.UserProfileDtoChain? userProfileDtoChainNullableFromJson(
  Object? userProfileDtoChain, [
  enums.UserProfileDtoChain? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return null;
  }
  return enums.UserProfileDtoChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoChain,
      ) ??
      defaultValue;
}

String userProfileDtoChainExplodedListToJson(
  List<enums.UserProfileDtoChain>? userProfileDtoChain,
) {
  return userProfileDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDtoChainListToJson(
  List<enums.UserProfileDtoChain>? userProfileDtoChain,
) {
  if (userProfileDtoChain == null) {
    return [];
  }

  return userProfileDtoChain.map((e) => e.value!).toList();
}

List<enums.UserProfileDtoChain> userProfileDtoChainListFromJson(
  List? userProfileDtoChain, [
  List<enums.UserProfileDtoChain>? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return defaultValue ?? [];
  }

  return userProfileDtoChain
      .map((e) => userProfileDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDtoChain>? userProfileDtoChainNullableListFromJson(
  List? userProfileDtoChain, [
  List<enums.UserProfileDtoChain>? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return defaultValue;
  }

  return userProfileDtoChain
      .map((e) => userProfileDtoChainFromJson(e.toString()))
      .toList();
}

String? creatorProfileDtoDataTypeNullableToJson(
  enums.CreatorProfileDtoDataType? creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType?.value;
}

String? creatorProfileDtoDataTypeToJson(
  enums.CreatorProfileDtoDataType creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType.value;
}

enums.CreatorProfileDtoDataType creatorProfileDtoDataTypeFromJson(
  Object? creatorProfileDtoDataType, [
  enums.CreatorProfileDtoDataType? defaultValue,
]) {
  return enums.CreatorProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDtoDataType,
      ) ??
      defaultValue ??
      enums.CreatorProfileDtoDataType.swaggerGeneratedUnknown;
}

enums.CreatorProfileDtoDataType? creatorProfileDtoDataTypeNullableFromJson(
  Object? creatorProfileDtoDataType, [
  enums.CreatorProfileDtoDataType? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return null;
  }
  return enums.CreatorProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDtoDataType,
      ) ??
      defaultValue;
}

String creatorProfileDtoDataTypeExplodedListToJson(
  List<enums.CreatorProfileDtoDataType>? creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorProfileDtoDataTypeListToJson(
  List<enums.CreatorProfileDtoDataType>? creatorProfileDtoDataType,
) {
  if (creatorProfileDtoDataType == null) {
    return [];
  }

  return creatorProfileDtoDataType.map((e) => e.value!).toList();
}

List<enums.CreatorProfileDtoDataType> creatorProfileDtoDataTypeListFromJson(
  List? creatorProfileDtoDataType, [
  List<enums.CreatorProfileDtoDataType>? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return defaultValue ?? [];
  }

  return creatorProfileDtoDataType
      .map((e) => creatorProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorProfileDtoDataType>?
creatorProfileDtoDataTypeNullableListFromJson(
  List? creatorProfileDtoDataType, [
  List<enums.CreatorProfileDtoDataType>? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return defaultValue;
  }

  return creatorProfileDtoDataType
      .map((e) => creatorProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? creatorProfileDocDataTypeNullableToJson(
  enums.CreatorProfileDocDataType? creatorProfileDocDataType,
) {
  return creatorProfileDocDataType?.value;
}

String? creatorProfileDocDataTypeToJson(
  enums.CreatorProfileDocDataType creatorProfileDocDataType,
) {
  return creatorProfileDocDataType.value;
}

enums.CreatorProfileDocDataType creatorProfileDocDataTypeFromJson(
  Object? creatorProfileDocDataType, [
  enums.CreatorProfileDocDataType? defaultValue,
]) {
  return enums.CreatorProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDocDataType,
      ) ??
      defaultValue ??
      enums.CreatorProfileDocDataType.swaggerGeneratedUnknown;
}

enums.CreatorProfileDocDataType? creatorProfileDocDataTypeNullableFromJson(
  Object? creatorProfileDocDataType, [
  enums.CreatorProfileDocDataType? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return null;
  }
  return enums.CreatorProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDocDataType,
      ) ??
      defaultValue;
}

String creatorProfileDocDataTypeExplodedListToJson(
  List<enums.CreatorProfileDocDataType>? creatorProfileDocDataType,
) {
  return creatorProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorProfileDocDataTypeListToJson(
  List<enums.CreatorProfileDocDataType>? creatorProfileDocDataType,
) {
  if (creatorProfileDocDataType == null) {
    return [];
  }

  return creatorProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.CreatorProfileDocDataType> creatorProfileDocDataTypeListFromJson(
  List? creatorProfileDocDataType, [
  List<enums.CreatorProfileDocDataType>? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return creatorProfileDocDataType
      .map((e) => creatorProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorProfileDocDataType>?
creatorProfileDocDataTypeNullableListFromJson(
  List? creatorProfileDocDataType, [
  List<enums.CreatorProfileDocDataType>? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return defaultValue;
  }

  return creatorProfileDocDataType
      .map((e) => creatorProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? collectionDataTypeNullableToJson(
  enums.CollectionDataType? collectionDataType,
) {
  return collectionDataType?.value;
}

String? collectionDataTypeToJson(enums.CollectionDataType collectionDataType) {
  return collectionDataType.value;
}

enums.CollectionDataType collectionDataTypeFromJson(
  Object? collectionDataType, [
  enums.CollectionDataType? defaultValue,
]) {
  return enums.CollectionDataType.values.firstWhereOrNull(
        (e) => e.value == collectionDataType,
      ) ??
      defaultValue ??
      enums.CollectionDataType.swaggerGeneratedUnknown;
}

enums.CollectionDataType? collectionDataTypeNullableFromJson(
  Object? collectionDataType, [
  enums.CollectionDataType? defaultValue,
]) {
  if (collectionDataType == null) {
    return null;
  }
  return enums.CollectionDataType.values.firstWhereOrNull(
        (e) => e.value == collectionDataType,
      ) ??
      defaultValue;
}

String collectionDataTypeExplodedListToJson(
  List<enums.CollectionDataType>? collectionDataType,
) {
  return collectionDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionDataTypeListToJson(
  List<enums.CollectionDataType>? collectionDataType,
) {
  if (collectionDataType == null) {
    return [];
  }

  return collectionDataType.map((e) => e.value!).toList();
}

List<enums.CollectionDataType> collectionDataTypeListFromJson(
  List? collectionDataType, [
  List<enums.CollectionDataType>? defaultValue,
]) {
  if (collectionDataType == null) {
    return defaultValue ?? [];
  }

  return collectionDataType
      .map((e) => collectionDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionDataType>? collectionDataTypeNullableListFromJson(
  List? collectionDataType, [
  List<enums.CollectionDataType>? defaultValue,
]) {
  if (collectionDataType == null) {
    return defaultValue;
  }

  return collectionDataType
      .map((e) => collectionDataTypeFromJson(e.toString()))
      .toList();
}

String? shortCollectionInfoDocChainNullableToJson(
  enums.ShortCollectionInfoDocChain? shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain?.value;
}

String? shortCollectionInfoDocChainToJson(
  enums.ShortCollectionInfoDocChain shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain.value;
}

enums.ShortCollectionInfoDocChain shortCollectionInfoDocChainFromJson(
  Object? shortCollectionInfoDocChain, [
  enums.ShortCollectionInfoDocChain? defaultValue,
]) {
  return enums.ShortCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionInfoDocChain,
      ) ??
      defaultValue ??
      enums.ShortCollectionInfoDocChain.swaggerGeneratedUnknown;
}

enums.ShortCollectionInfoDocChain? shortCollectionInfoDocChainNullableFromJson(
  Object? shortCollectionInfoDocChain, [
  enums.ShortCollectionInfoDocChain? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return null;
  }
  return enums.ShortCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionInfoDocChain,
      ) ??
      defaultValue;
}

String shortCollectionInfoDocChainExplodedListToJson(
  List<enums.ShortCollectionInfoDocChain>? shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortCollectionInfoDocChainListToJson(
  List<enums.ShortCollectionInfoDocChain>? shortCollectionInfoDocChain,
) {
  if (shortCollectionInfoDocChain == null) {
    return [];
  }

  return shortCollectionInfoDocChain.map((e) => e.value!).toList();
}

List<enums.ShortCollectionInfoDocChain> shortCollectionInfoDocChainListFromJson(
  List? shortCollectionInfoDocChain, [
  List<enums.ShortCollectionInfoDocChain>? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return defaultValue ?? [];
  }

  return shortCollectionInfoDocChain
      .map((e) => shortCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortCollectionInfoDocChain>?
shortCollectionInfoDocChainNullableListFromJson(
  List? shortCollectionInfoDocChain, [
  List<enums.ShortCollectionInfoDocChain>? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return defaultValue;
  }

  return shortCollectionInfoDocChain
      .map((e) => shortCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

String? collectionStatsDocHydratedChainNullableToJson(
  enums.CollectionStatsDocHydratedChain? collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain?.value;
}

String? collectionStatsDocHydratedChainToJson(
  enums.CollectionStatsDocHydratedChain collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain.value;
}

enums.CollectionStatsDocHydratedChain collectionStatsDocHydratedChainFromJson(
  Object? collectionStatsDocHydratedChain, [
  enums.CollectionStatsDocHydratedChain? defaultValue,
]) {
  return enums.CollectionStatsDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == collectionStatsDocHydratedChain,
      ) ??
      defaultValue ??
      enums.CollectionStatsDocHydratedChain.swaggerGeneratedUnknown;
}

enums.CollectionStatsDocHydratedChain?
collectionStatsDocHydratedChainNullableFromJson(
  Object? collectionStatsDocHydratedChain, [
  enums.CollectionStatsDocHydratedChain? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return null;
  }
  return enums.CollectionStatsDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == collectionStatsDocHydratedChain,
      ) ??
      defaultValue;
}

String collectionStatsDocHydratedChainExplodedListToJson(
  List<enums.CollectionStatsDocHydratedChain>? collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionStatsDocHydratedChainListToJson(
  List<enums.CollectionStatsDocHydratedChain>? collectionStatsDocHydratedChain,
) {
  if (collectionStatsDocHydratedChain == null) {
    return [];
  }

  return collectionStatsDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.CollectionStatsDocHydratedChain>
collectionStatsDocHydratedChainListFromJson(
  List? collectionStatsDocHydratedChain, [
  List<enums.CollectionStatsDocHydratedChain>? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return collectionStatsDocHydratedChain
      .map((e) => collectionStatsDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionStatsDocHydratedChain>?
collectionStatsDocHydratedChainNullableListFromJson(
  List? collectionStatsDocHydratedChain, [
  List<enums.CollectionStatsDocHydratedChain>? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return defaultValue;
  }

  return collectionStatsDocHydratedChain
      .map((e) => collectionStatsDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? tokenCategoryNullableToJson(enums.TokenCategory? tokenCategory) {
  return tokenCategory?.value;
}

String? tokenCategoryToJson(enums.TokenCategory tokenCategory) {
  return tokenCategory.value;
}

enums.TokenCategory tokenCategoryFromJson(
  Object? tokenCategory, [
  enums.TokenCategory? defaultValue,
]) {
  return enums.TokenCategory.values.firstWhereOrNull(
        (e) => e.value == tokenCategory,
      ) ??
      defaultValue ??
      enums.TokenCategory.swaggerGeneratedUnknown;
}

enums.TokenCategory? tokenCategoryNullableFromJson(
  Object? tokenCategory, [
  enums.TokenCategory? defaultValue,
]) {
  if (tokenCategory == null) {
    return null;
  }
  return enums.TokenCategory.values.firstWhereOrNull(
        (e) => e.value == tokenCategory,
      ) ??
      defaultValue;
}

String tokenCategoryExplodedListToJson(
  List<enums.TokenCategory>? tokenCategory,
) {
  return tokenCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> tokenCategoryListToJson(List<enums.TokenCategory>? tokenCategory) {
  if (tokenCategory == null) {
    return [];
  }

  return tokenCategory.map((e) => e.value!).toList();
}

List<enums.TokenCategory> tokenCategoryListFromJson(
  List? tokenCategory, [
  List<enums.TokenCategory>? defaultValue,
]) {
  if (tokenCategory == null) {
    return defaultValue ?? [];
  }

  return tokenCategory.map((e) => tokenCategoryFromJson(e.toString())).toList();
}

List<enums.TokenCategory>? tokenCategoryNullableListFromJson(
  List? tokenCategory, [
  List<enums.TokenCategory>? defaultValue,
]) {
  if (tokenCategory == null) {
    return defaultValue;
  }

  return tokenCategory.map((e) => tokenCategoryFromJson(e.toString())).toList();
}

String? tokenDataTypeNullableToJson(enums.TokenDataType? tokenDataType) {
  return tokenDataType?.value;
}

String? tokenDataTypeToJson(enums.TokenDataType tokenDataType) {
  return tokenDataType.value;
}

enums.TokenDataType tokenDataTypeFromJson(
  Object? tokenDataType, [
  enums.TokenDataType? defaultValue,
]) {
  return enums.TokenDataType.values.firstWhereOrNull(
        (e) => e.value == tokenDataType,
      ) ??
      defaultValue ??
      enums.TokenDataType.swaggerGeneratedUnknown;
}

enums.TokenDataType? tokenDataTypeNullableFromJson(
  Object? tokenDataType, [
  enums.TokenDataType? defaultValue,
]) {
  if (tokenDataType == null) {
    return null;
  }
  return enums.TokenDataType.values.firstWhereOrNull(
        (e) => e.value == tokenDataType,
      ) ??
      defaultValue;
}

String tokenDataTypeExplodedListToJson(
  List<enums.TokenDataType>? tokenDataType,
) {
  return tokenDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> tokenDataTypeListToJson(List<enums.TokenDataType>? tokenDataType) {
  if (tokenDataType == null) {
    return [];
  }

  return tokenDataType.map((e) => e.value!).toList();
}

List<enums.TokenDataType> tokenDataTypeListFromJson(
  List? tokenDataType, [
  List<enums.TokenDataType>? defaultValue,
]) {
  if (tokenDataType == null) {
    return defaultValue ?? [];
  }

  return tokenDataType.map((e) => tokenDataTypeFromJson(e.toString())).toList();
}

List<enums.TokenDataType>? tokenDataTypeNullableListFromJson(
  List? tokenDataType, [
  List<enums.TokenDataType>? defaultValue,
]) {
  if (tokenDataType == null) {
    return defaultValue;
  }

  return tokenDataType.map((e) => tokenDataTypeFromJson(e.toString())).toList();
}

String? lendingDataTypeNullableToJson(enums.LendingDataType? lendingDataType) {
  return lendingDataType?.value;
}

String? lendingDataTypeToJson(enums.LendingDataType lendingDataType) {
  return lendingDataType.value;
}

enums.LendingDataType lendingDataTypeFromJson(
  Object? lendingDataType, [
  enums.LendingDataType? defaultValue,
]) {
  return enums.LendingDataType.values.firstWhereOrNull(
        (e) => e.value == lendingDataType,
      ) ??
      defaultValue ??
      enums.LendingDataType.swaggerGeneratedUnknown;
}

enums.LendingDataType? lendingDataTypeNullableFromJson(
  Object? lendingDataType, [
  enums.LendingDataType? defaultValue,
]) {
  if (lendingDataType == null) {
    return null;
  }
  return enums.LendingDataType.values.firstWhereOrNull(
        (e) => e.value == lendingDataType,
      ) ??
      defaultValue;
}

String lendingDataTypeExplodedListToJson(
  List<enums.LendingDataType>? lendingDataType,
) {
  return lendingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> lendingDataTypeListToJson(
  List<enums.LendingDataType>? lendingDataType,
) {
  if (lendingDataType == null) {
    return [];
  }

  return lendingDataType.map((e) => e.value!).toList();
}

List<enums.LendingDataType> lendingDataTypeListFromJson(
  List? lendingDataType, [
  List<enums.LendingDataType>? defaultValue,
]) {
  if (lendingDataType == null) {
    return defaultValue ?? [];
  }

  return lendingDataType
      .map((e) => lendingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.LendingDataType>? lendingDataTypeNullableListFromJson(
  List? lendingDataType, [
  List<enums.LendingDataType>? defaultValue,
]) {
  if (lendingDataType == null) {
    return defaultValue;
  }

  return lendingDataType
      .map((e) => lendingDataTypeFromJson(e.toString()))
      .toList();
}

String? pricingMethodNullableToJson(enums.PricingMethod? pricingMethod) {
  return pricingMethod?.value;
}

String? pricingMethodToJson(enums.PricingMethod pricingMethod) {
  return pricingMethod.value;
}

enums.PricingMethod pricingMethodFromJson(
  Object? pricingMethod, [
  enums.PricingMethod? defaultValue,
]) {
  return enums.PricingMethod.values.firstWhereOrNull(
        (e) => e.value == pricingMethod,
      ) ??
      defaultValue ??
      enums.PricingMethod.swaggerGeneratedUnknown;
}

enums.PricingMethod? pricingMethodNullableFromJson(
  Object? pricingMethod, [
  enums.PricingMethod? defaultValue,
]) {
  if (pricingMethod == null) {
    return null;
  }
  return enums.PricingMethod.values.firstWhereOrNull(
        (e) => e.value == pricingMethod,
      ) ??
      defaultValue;
}

String pricingMethodExplodedListToJson(
  List<enums.PricingMethod>? pricingMethod,
) {
  return pricingMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> pricingMethodListToJson(List<enums.PricingMethod>? pricingMethod) {
  if (pricingMethod == null) {
    return [];
  }

  return pricingMethod.map((e) => e.value!).toList();
}

List<enums.PricingMethod> pricingMethodListFromJson(
  List? pricingMethod, [
  List<enums.PricingMethod>? defaultValue,
]) {
  if (pricingMethod == null) {
    return defaultValue ?? [];
  }

  return pricingMethod.map((e) => pricingMethodFromJson(e.toString())).toList();
}

List<enums.PricingMethod>? pricingMethodNullableListFromJson(
  List? pricingMethod, [
  List<enums.PricingMethod>? defaultValue,
]) {
  if (pricingMethod == null) {
    return defaultValue;
  }

  return pricingMethod.map((e) => pricingMethodFromJson(e.toString())).toList();
}

String? oracleTypeNullableToJson(enums.OracleType? oracleType) {
  return oracleType?.value;
}

String? oracleTypeToJson(enums.OracleType oracleType) {
  return oracleType.value;
}

enums.OracleType oracleTypeFromJson(
  Object? oracleType, [
  enums.OracleType? defaultValue,
]) {
  return enums.OracleType.values.firstWhereOrNull(
        (e) => e.value == oracleType,
      ) ??
      defaultValue ??
      enums.OracleType.swaggerGeneratedUnknown;
}

enums.OracleType? oracleTypeNullableFromJson(
  Object? oracleType, [
  enums.OracleType? defaultValue,
]) {
  if (oracleType == null) {
    return null;
  }
  return enums.OracleType.values.firstWhereOrNull(
        (e) => e.value == oracleType,
      ) ??
      defaultValue;
}

String oracleTypeExplodedListToJson(List<enums.OracleType>? oracleType) {
  return oracleType?.map((e) => e.value!).join(',') ?? '';
}

List<String> oracleTypeListToJson(List<enums.OracleType>? oracleType) {
  if (oracleType == null) {
    return [];
  }

  return oracleType.map((e) => e.value!).toList();
}

List<enums.OracleType> oracleTypeListFromJson(
  List? oracleType, [
  List<enums.OracleType>? defaultValue,
]) {
  if (oracleType == null) {
    return defaultValue ?? [];
  }

  return oracleType.map((e) => oracleTypeFromJson(e.toString())).toList();
}

List<enums.OracleType>? oracleTypeNullableListFromJson(
  List? oracleType, [
  List<enums.OracleType>? defaultValue,
]) {
  if (oracleType == null) {
    return defaultValue;
  }

  return oracleType.map((e) => oracleTypeFromJson(e.toString())).toList();
}

String? exchangeSourceNullableToJson(enums.ExchangeSource? exchangeSource) {
  return exchangeSource?.value;
}

String? exchangeSourceToJson(enums.ExchangeSource exchangeSource) {
  return exchangeSource.value;
}

enums.ExchangeSource exchangeSourceFromJson(
  Object? exchangeSource, [
  enums.ExchangeSource? defaultValue,
]) {
  return enums.ExchangeSource.values.firstWhereOrNull(
        (e) => e.value == exchangeSource,
      ) ??
      defaultValue ??
      enums.ExchangeSource.swaggerGeneratedUnknown;
}

enums.ExchangeSource? exchangeSourceNullableFromJson(
  Object? exchangeSource, [
  enums.ExchangeSource? defaultValue,
]) {
  if (exchangeSource == null) {
    return null;
  }
  return enums.ExchangeSource.values.firstWhereOrNull(
        (e) => e.value == exchangeSource,
      ) ??
      defaultValue;
}

String exchangeSourceExplodedListToJson(
  List<enums.ExchangeSource>? exchangeSource,
) {
  return exchangeSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> exchangeSourceListToJson(
  List<enums.ExchangeSource>? exchangeSource,
) {
  if (exchangeSource == null) {
    return [];
  }

  return exchangeSource.map((e) => e.value!).toList();
}

List<enums.ExchangeSource> exchangeSourceListFromJson(
  List? exchangeSource, [
  List<enums.ExchangeSource>? defaultValue,
]) {
  if (exchangeSource == null) {
    return defaultValue ?? [];
  }

  return exchangeSource
      .map((e) => exchangeSourceFromJson(e.toString()))
      .toList();
}

List<enums.ExchangeSource>? exchangeSourceNullableListFromJson(
  List? exchangeSource, [
  List<enums.ExchangeSource>? defaultValue,
]) {
  if (exchangeSource == null) {
    return defaultValue;
  }

  return exchangeSource
      .map((e) => exchangeSourceFromJson(e.toString()))
      .toList();
}

String? positionModeNullableToJson(enums.PositionMode? positionMode) {
  return positionMode?.value;
}

String? positionModeToJson(enums.PositionMode positionMode) {
  return positionMode.value;
}

enums.PositionMode positionModeFromJson(
  Object? positionMode, [
  enums.PositionMode? defaultValue,
]) {
  return enums.PositionMode.values.firstWhereOrNull(
        (e) => e.value == positionMode,
      ) ??
      defaultValue ??
      enums.PositionMode.swaggerGeneratedUnknown;
}

enums.PositionMode? positionModeNullableFromJson(
  Object? positionMode, [
  enums.PositionMode? defaultValue,
]) {
  if (positionMode == null) {
    return null;
  }
  return enums.PositionMode.values.firstWhereOrNull(
        (e) => e.value == positionMode,
      ) ??
      defaultValue;
}

String positionModeExplodedListToJson(List<enums.PositionMode>? positionMode) {
  return positionMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> positionModeListToJson(List<enums.PositionMode>? positionMode) {
  if (positionMode == null) {
    return [];
  }

  return positionMode.map((e) => e.value!).toList();
}

List<enums.PositionMode> positionModeListFromJson(
  List? positionMode, [
  List<enums.PositionMode>? defaultValue,
]) {
  if (positionMode == null) {
    return defaultValue ?? [];
  }

  return positionMode.map((e) => positionModeFromJson(e.toString())).toList();
}

List<enums.PositionMode>? positionModeNullableListFromJson(
  List? positionMode, [
  List<enums.PositionMode>? defaultValue,
]) {
  if (positionMode == null) {
    return defaultValue;
  }

  return positionMode.map((e) => positionModeFromJson(e.toString())).toList();
}

String? lendingPositionOrderByColumnNullableToJson(
  enums.LendingPositionOrderByColumn? lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn?.value;
}

String? lendingPositionOrderByColumnToJson(
  enums.LendingPositionOrderByColumn lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn.value;
}

enums.LendingPositionOrderByColumn lendingPositionOrderByColumnFromJson(
  Object? lendingPositionOrderByColumn, [
  enums.LendingPositionOrderByColumn? defaultValue,
]) {
  return enums.LendingPositionOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == lendingPositionOrderByColumn,
      ) ??
      defaultValue ??
      enums.LendingPositionOrderByColumn.swaggerGeneratedUnknown;
}

enums.LendingPositionOrderByColumn?
lendingPositionOrderByColumnNullableFromJson(
  Object? lendingPositionOrderByColumn, [
  enums.LendingPositionOrderByColumn? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return null;
  }
  return enums.LendingPositionOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == lendingPositionOrderByColumn,
      ) ??
      defaultValue;
}

String lendingPositionOrderByColumnExplodedListToJson(
  List<enums.LendingPositionOrderByColumn>? lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn?.map((e) => e.value!).join(',') ?? '';
}

List<String> lendingPositionOrderByColumnListToJson(
  List<enums.LendingPositionOrderByColumn>? lendingPositionOrderByColumn,
) {
  if (lendingPositionOrderByColumn == null) {
    return [];
  }

  return lendingPositionOrderByColumn.map((e) => e.value!).toList();
}

List<enums.LendingPositionOrderByColumn>
lendingPositionOrderByColumnListFromJson(
  List? lendingPositionOrderByColumn, [
  List<enums.LendingPositionOrderByColumn>? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return defaultValue ?? [];
  }

  return lendingPositionOrderByColumn
      .map((e) => lendingPositionOrderByColumnFromJson(e.toString()))
      .toList();
}

List<enums.LendingPositionOrderByColumn>?
lendingPositionOrderByColumnNullableListFromJson(
  List? lendingPositionOrderByColumn, [
  List<enums.LendingPositionOrderByColumn>? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return defaultValue;
  }

  return lendingPositionOrderByColumn
      .map((e) => lendingPositionOrderByColumnFromJson(e.toString()))
      .toList();
}

String? kustoOrderDirectionNullableToJson(
  enums.KustoOrderDirection? kustoOrderDirection,
) {
  return kustoOrderDirection?.value;
}

String? kustoOrderDirectionToJson(
  enums.KustoOrderDirection kustoOrderDirection,
) {
  return kustoOrderDirection.value;
}

enums.KustoOrderDirection kustoOrderDirectionFromJson(
  Object? kustoOrderDirection, [
  enums.KustoOrderDirection? defaultValue,
]) {
  return enums.KustoOrderDirection.values.firstWhereOrNull(
        (e) => e.value == kustoOrderDirection,
      ) ??
      defaultValue ??
      enums.KustoOrderDirection.swaggerGeneratedUnknown;
}

enums.KustoOrderDirection? kustoOrderDirectionNullableFromJson(
  Object? kustoOrderDirection, [
  enums.KustoOrderDirection? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return null;
  }
  return enums.KustoOrderDirection.values.firstWhereOrNull(
        (e) => e.value == kustoOrderDirection,
      ) ??
      defaultValue;
}

String kustoOrderDirectionExplodedListToJson(
  List<enums.KustoOrderDirection>? kustoOrderDirection,
) {
  return kustoOrderDirection?.map((e) => e.value!).join(',') ?? '';
}

List<String> kustoOrderDirectionListToJson(
  List<enums.KustoOrderDirection>? kustoOrderDirection,
) {
  if (kustoOrderDirection == null) {
    return [];
  }

  return kustoOrderDirection.map((e) => e.value!).toList();
}

List<enums.KustoOrderDirection> kustoOrderDirectionListFromJson(
  List? kustoOrderDirection, [
  List<enums.KustoOrderDirection>? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return defaultValue ?? [];
  }

  return kustoOrderDirection
      .map((e) => kustoOrderDirectionFromJson(e.toString()))
      .toList();
}

List<enums.KustoOrderDirection>? kustoOrderDirectionNullableListFromJson(
  List? kustoOrderDirection, [
  List<enums.KustoOrderDirection>? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return defaultValue;
  }

  return kustoOrderDirection
      .map((e) => kustoOrderDirectionFromJson(e.toString()))
      .toList();
}

String? esdtTokenTypeNullableToJson(enums.EsdtTokenType? esdtTokenType) {
  return esdtTokenType?.value;
}

String? esdtTokenTypeToJson(enums.EsdtTokenType esdtTokenType) {
  return esdtTokenType.value;
}

enums.EsdtTokenType esdtTokenTypeFromJson(
  Object? esdtTokenType, [
  enums.EsdtTokenType? defaultValue,
]) {
  return enums.EsdtTokenType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenType,
      ) ??
      defaultValue ??
      enums.EsdtTokenType.swaggerGeneratedUnknown;
}

enums.EsdtTokenType? esdtTokenTypeNullableFromJson(
  Object? esdtTokenType, [
  enums.EsdtTokenType? defaultValue,
]) {
  if (esdtTokenType == null) {
    return null;
  }
  return enums.EsdtTokenType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenType,
      ) ??
      defaultValue;
}

String esdtTokenTypeExplodedListToJson(
  List<enums.EsdtTokenType>? esdtTokenType,
) {
  return esdtTokenType?.map((e) => e.value!).join(',') ?? '';
}

List<String> esdtTokenTypeListToJson(List<enums.EsdtTokenType>? esdtTokenType) {
  if (esdtTokenType == null) {
    return [];
  }

  return esdtTokenType.map((e) => e.value!).toList();
}

List<enums.EsdtTokenType> esdtTokenTypeListFromJson(
  List? esdtTokenType, [
  List<enums.EsdtTokenType>? defaultValue,
]) {
  if (esdtTokenType == null) {
    return defaultValue ?? [];
  }

  return esdtTokenType.map((e) => esdtTokenTypeFromJson(e.toString())).toList();
}

List<enums.EsdtTokenType>? esdtTokenTypeNullableListFromJson(
  List? esdtTokenType, [
  List<enums.EsdtTokenType>? defaultValue,
]) {
  if (esdtTokenType == null) {
    return defaultValue;
  }

  return esdtTokenType.map((e) => esdtTokenTypeFromJson(e.toString())).toList();
}

String? esdtTokenSubTypeNullableToJson(
  enums.EsdtTokenSubType? esdtTokenSubType,
) {
  return esdtTokenSubType?.value;
}

String? esdtTokenSubTypeToJson(enums.EsdtTokenSubType esdtTokenSubType) {
  return esdtTokenSubType.value;
}

enums.EsdtTokenSubType esdtTokenSubTypeFromJson(
  Object? esdtTokenSubType, [
  enums.EsdtTokenSubType? defaultValue,
]) {
  return enums.EsdtTokenSubType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenSubType,
      ) ??
      defaultValue ??
      enums.EsdtTokenSubType.swaggerGeneratedUnknown;
}

enums.EsdtTokenSubType? esdtTokenSubTypeNullableFromJson(
  Object? esdtTokenSubType, [
  enums.EsdtTokenSubType? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return null;
  }
  return enums.EsdtTokenSubType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenSubType,
      ) ??
      defaultValue;
}

String esdtTokenSubTypeExplodedListToJson(
  List<enums.EsdtTokenSubType>? esdtTokenSubType,
) {
  return esdtTokenSubType?.map((e) => e.value!).join(',') ?? '';
}

List<String> esdtTokenSubTypeListToJson(
  List<enums.EsdtTokenSubType>? esdtTokenSubType,
) {
  if (esdtTokenSubType == null) {
    return [];
  }

  return esdtTokenSubType.map((e) => e.value!).toList();
}

List<enums.EsdtTokenSubType> esdtTokenSubTypeListFromJson(
  List? esdtTokenSubType, [
  List<enums.EsdtTokenSubType>? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return defaultValue ?? [];
  }

  return esdtTokenSubType
      .map((e) => esdtTokenSubTypeFromJson(e.toString()))
      .toList();
}

List<enums.EsdtTokenSubType>? esdtTokenSubTypeNullableListFromJson(
  List? esdtTokenSubType, [
  List<enums.EsdtTokenSubType>? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return defaultValue;
  }

  return esdtTokenSubType
      .map((e) => esdtTokenSubTypeFromJson(e.toString()))
      .toList();
}

String? xoxnoAuctionTypeStringNullableToJson(
  enums.XoxnoAuctionTypeString? xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString?.value;
}

String? xoxnoAuctionTypeStringToJson(
  enums.XoxnoAuctionTypeString xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString.value;
}

enums.XoxnoAuctionTypeString xoxnoAuctionTypeStringFromJson(
  Object? xoxnoAuctionTypeString, [
  enums.XoxnoAuctionTypeString? defaultValue,
]) {
  return enums.XoxnoAuctionTypeString.values.firstWhereOrNull(
        (e) => e.value == xoxnoAuctionTypeString,
      ) ??
      defaultValue ??
      enums.XoxnoAuctionTypeString.swaggerGeneratedUnknown;
}

enums.XoxnoAuctionTypeString? xoxnoAuctionTypeStringNullableFromJson(
  Object? xoxnoAuctionTypeString, [
  enums.XoxnoAuctionTypeString? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return null;
  }
  return enums.XoxnoAuctionTypeString.values.firstWhereOrNull(
        (e) => e.value == xoxnoAuctionTypeString,
      ) ??
      defaultValue;
}

String xoxnoAuctionTypeStringExplodedListToJson(
  List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> xoxnoAuctionTypeStringListToJson(
  List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeString,
) {
  if (xoxnoAuctionTypeString == null) {
    return [];
  }

  return xoxnoAuctionTypeString.map((e) => e.value!).toList();
}

List<enums.XoxnoAuctionTypeString> xoxnoAuctionTypeStringListFromJson(
  List? xoxnoAuctionTypeString, [
  List<enums.XoxnoAuctionTypeString>? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return defaultValue ?? [];
  }

  return xoxnoAuctionTypeString
      .map((e) => xoxnoAuctionTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeStringNullableListFromJson(
  List? xoxnoAuctionTypeString, [
  List<enums.XoxnoAuctionTypeString>? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return defaultValue;
  }

  return xoxnoAuctionTypeString
      .map((e) => xoxnoAuctionTypeStringFromJson(e.toString()))
      .toList();
}

String? marketplacesOnSaleNamesNullableToJson(
  enums.MarketplacesOnSaleNames? marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames?.value;
}

String? marketplacesOnSaleNamesToJson(
  enums.MarketplacesOnSaleNames marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames.value;
}

enums.MarketplacesOnSaleNames marketplacesOnSaleNamesFromJson(
  Object? marketplacesOnSaleNames, [
  enums.MarketplacesOnSaleNames? defaultValue,
]) {
  return enums.MarketplacesOnSaleNames.values.firstWhereOrNull(
        (e) => e.value == marketplacesOnSaleNames,
      ) ??
      defaultValue ??
      enums.MarketplacesOnSaleNames.swaggerGeneratedUnknown;
}

enums.MarketplacesOnSaleNames? marketplacesOnSaleNamesNullableFromJson(
  Object? marketplacesOnSaleNames, [
  enums.MarketplacesOnSaleNames? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return null;
  }
  return enums.MarketplacesOnSaleNames.values.firstWhereOrNull(
        (e) => e.value == marketplacesOnSaleNames,
      ) ??
      defaultValue;
}

String marketplacesOnSaleNamesExplodedListToJson(
  List<enums.MarketplacesOnSaleNames>? marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames?.map((e) => e.value!).join(',') ?? '';
}

List<String> marketplacesOnSaleNamesListToJson(
  List<enums.MarketplacesOnSaleNames>? marketplacesOnSaleNames,
) {
  if (marketplacesOnSaleNames == null) {
    return [];
  }

  return marketplacesOnSaleNames.map((e) => e.value!).toList();
}

List<enums.MarketplacesOnSaleNames> marketplacesOnSaleNamesListFromJson(
  List? marketplacesOnSaleNames, [
  List<enums.MarketplacesOnSaleNames>? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return defaultValue ?? [];
  }

  return marketplacesOnSaleNames
      .map((e) => marketplacesOnSaleNamesFromJson(e.toString()))
      .toList();
}

List<enums.MarketplacesOnSaleNames>?
marketplacesOnSaleNamesNullableListFromJson(
  List? marketplacesOnSaleNames, [
  List<enums.MarketplacesOnSaleNames>? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return defaultValue;
  }

  return marketplacesOnSaleNames
      .map((e) => marketplacesOnSaleNamesFromJson(e.toString()))
      .toList();
}

String? shortNftCollectionInfoDocChainNullableToJson(
  enums.ShortNftCollectionInfoDocChain? shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain?.value;
}

String? shortNftCollectionInfoDocChainToJson(
  enums.ShortNftCollectionInfoDocChain shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain.value;
}

enums.ShortNftCollectionInfoDocChain shortNftCollectionInfoDocChainFromJson(
  Object? shortNftCollectionInfoDocChain, [
  enums.ShortNftCollectionInfoDocChain? defaultValue,
]) {
  return enums.ShortNftCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortNftCollectionInfoDocChain,
      ) ??
      defaultValue ??
      enums.ShortNftCollectionInfoDocChain.swaggerGeneratedUnknown;
}

enums.ShortNftCollectionInfoDocChain?
shortNftCollectionInfoDocChainNullableFromJson(
  Object? shortNftCollectionInfoDocChain, [
  enums.ShortNftCollectionInfoDocChain? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return null;
  }
  return enums.ShortNftCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortNftCollectionInfoDocChain,
      ) ??
      defaultValue;
}

String shortNftCollectionInfoDocChainExplodedListToJson(
  List<enums.ShortNftCollectionInfoDocChain>? shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortNftCollectionInfoDocChainListToJson(
  List<enums.ShortNftCollectionInfoDocChain>? shortNftCollectionInfoDocChain,
) {
  if (shortNftCollectionInfoDocChain == null) {
    return [];
  }

  return shortNftCollectionInfoDocChain.map((e) => e.value!).toList();
}

List<enums.ShortNftCollectionInfoDocChain>
shortNftCollectionInfoDocChainListFromJson(
  List? shortNftCollectionInfoDocChain, [
  List<enums.ShortNftCollectionInfoDocChain>? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return defaultValue ?? [];
  }

  return shortNftCollectionInfoDocChain
      .map((e) => shortNftCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortNftCollectionInfoDocChain>?
shortNftCollectionInfoDocChainNullableListFromJson(
  List? shortNftCollectionInfoDocChain, [
  List<enums.ShortNftCollectionInfoDocChain>? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return defaultValue;
  }

  return shortNftCollectionInfoDocChain
      .map((e) => shortNftCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

String? inventorySummaryDtoHydratedChainNullableToJson(
  enums.InventorySummaryDtoHydratedChain? inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain?.value;
}

String? inventorySummaryDtoHydratedChainToJson(
  enums.InventorySummaryDtoHydratedChain inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain.value;
}

enums.InventorySummaryDtoHydratedChain inventorySummaryDtoHydratedChainFromJson(
  Object? inventorySummaryDtoHydratedChain, [
  enums.InventorySummaryDtoHydratedChain? defaultValue,
]) {
  return enums.InventorySummaryDtoHydratedChain.values.firstWhereOrNull(
        (e) => e.value == inventorySummaryDtoHydratedChain,
      ) ??
      defaultValue ??
      enums.InventorySummaryDtoHydratedChain.swaggerGeneratedUnknown;
}

enums.InventorySummaryDtoHydratedChain?
inventorySummaryDtoHydratedChainNullableFromJson(
  Object? inventorySummaryDtoHydratedChain, [
  enums.InventorySummaryDtoHydratedChain? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return null;
  }
  return enums.InventorySummaryDtoHydratedChain.values.firstWhereOrNull(
        (e) => e.value == inventorySummaryDtoHydratedChain,
      ) ??
      defaultValue;
}

String inventorySummaryDtoHydratedChainExplodedListToJson(
  List<enums.InventorySummaryDtoHydratedChain>?
  inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> inventorySummaryDtoHydratedChainListToJson(
  List<enums.InventorySummaryDtoHydratedChain>?
  inventorySummaryDtoHydratedChain,
) {
  if (inventorySummaryDtoHydratedChain == null) {
    return [];
  }

  return inventorySummaryDtoHydratedChain.map((e) => e.value!).toList();
}

List<enums.InventorySummaryDtoHydratedChain>
inventorySummaryDtoHydratedChainListFromJson(
  List? inventorySummaryDtoHydratedChain, [
  List<enums.InventorySummaryDtoHydratedChain>? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return defaultValue ?? [];
  }

  return inventorySummaryDtoHydratedChain
      .map((e) => inventorySummaryDtoHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.InventorySummaryDtoHydratedChain>?
inventorySummaryDtoHydratedChainNullableListFromJson(
  List? inventorySummaryDtoHydratedChain, [
  List<enums.InventorySummaryDtoHydratedChain>? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return defaultValue;
  }

  return inventorySummaryDtoHydratedChain
      .map((e) => inventorySummaryDtoHydratedChainFromJson(e.toString()))
      .toList();
}

String? offerTypeNullableToJson(enums.OfferType? offerType) {
  return offerType?.value;
}

String? offerTypeToJson(enums.OfferType offerType) {
  return offerType.value;
}

enums.OfferType offerTypeFromJson(
  Object? offerType, [
  enums.OfferType? defaultValue,
]) {
  return enums.OfferType.values.firstWhereOrNull((e) => e.value == offerType) ??
      defaultValue ??
      enums.OfferType.swaggerGeneratedUnknown;
}

enums.OfferType? offerTypeNullableFromJson(
  Object? offerType, [
  enums.OfferType? defaultValue,
]) {
  if (offerType == null) {
    return null;
  }
  return enums.OfferType.values.firstWhereOrNull((e) => e.value == offerType) ??
      defaultValue;
}

String offerTypeExplodedListToJson(List<enums.OfferType>? offerType) {
  return offerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> offerTypeListToJson(List<enums.OfferType>? offerType) {
  if (offerType == null) {
    return [];
  }

  return offerType.map((e) => e.value!).toList();
}

List<enums.OfferType> offerTypeListFromJson(
  List? offerType, [
  List<enums.OfferType>? defaultValue,
]) {
  if (offerType == null) {
    return defaultValue ?? [];
  }

  return offerType.map((e) => offerTypeFromJson(e.toString())).toList();
}

List<enums.OfferType>? offerTypeNullableListFromJson(
  List? offerType, [
  List<enums.OfferType>? defaultValue,
]) {
  if (offerType == null) {
    return defaultValue;
  }

  return offerType.map((e) => offerTypeFromJson(e.toString())).toList();
}

String? nftOfferDocHydratedDataTypeNullableToJson(
  enums.NftOfferDocHydratedDataType? nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType?.value;
}

String? nftOfferDocHydratedDataTypeToJson(
  enums.NftOfferDocHydratedDataType nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType.value;
}

enums.NftOfferDocHydratedDataType nftOfferDocHydratedDataTypeFromJson(
  Object? nftOfferDocHydratedDataType, [
  enums.NftOfferDocHydratedDataType? defaultValue,
]) {
  return enums.NftOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.NftOfferDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.NftOfferDocHydratedDataType? nftOfferDocHydratedDataTypeNullableFromJson(
  Object? nftOfferDocHydratedDataType, [
  enums.NftOfferDocHydratedDataType? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return null;
  }
  return enums.NftOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedDataType,
      ) ??
      defaultValue;
}

String nftOfferDocHydratedDataTypeExplodedListToJson(
  List<enums.NftOfferDocHydratedDataType>? nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftOfferDocHydratedDataTypeListToJson(
  List<enums.NftOfferDocHydratedDataType>? nftOfferDocHydratedDataType,
) {
  if (nftOfferDocHydratedDataType == null) {
    return [];
  }

  return nftOfferDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.NftOfferDocHydratedDataType> nftOfferDocHydratedDataTypeListFromJson(
  List? nftOfferDocHydratedDataType, [
  List<enums.NftOfferDocHydratedDataType>? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return nftOfferDocHydratedDataType
      .map((e) => nftOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftOfferDocHydratedDataType>?
nftOfferDocHydratedDataTypeNullableListFromJson(
  List? nftOfferDocHydratedDataType, [
  List<enums.NftOfferDocHydratedDataType>? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return defaultValue;
  }

  return nftOfferDocHydratedDataType
      .map((e) => nftOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? nftOfferDocHydratedChainNullableToJson(
  enums.NftOfferDocHydratedChain? nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain?.value;
}

String? nftOfferDocHydratedChainToJson(
  enums.NftOfferDocHydratedChain nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain.value;
}

enums.NftOfferDocHydratedChain nftOfferDocHydratedChainFromJson(
  Object? nftOfferDocHydratedChain, [
  enums.NftOfferDocHydratedChain? defaultValue,
]) {
  return enums.NftOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedChain,
      ) ??
      defaultValue ??
      enums.NftOfferDocHydratedChain.swaggerGeneratedUnknown;
}

enums.NftOfferDocHydratedChain? nftOfferDocHydratedChainNullableFromJson(
  Object? nftOfferDocHydratedChain, [
  enums.NftOfferDocHydratedChain? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return null;
  }
  return enums.NftOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedChain,
      ) ??
      defaultValue;
}

String nftOfferDocHydratedChainExplodedListToJson(
  List<enums.NftOfferDocHydratedChain>? nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftOfferDocHydratedChainListToJson(
  List<enums.NftOfferDocHydratedChain>? nftOfferDocHydratedChain,
) {
  if (nftOfferDocHydratedChain == null) {
    return [];
  }

  return nftOfferDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.NftOfferDocHydratedChain> nftOfferDocHydratedChainListFromJson(
  List? nftOfferDocHydratedChain, [
  List<enums.NftOfferDocHydratedChain>? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return nftOfferDocHydratedChain
      .map((e) => nftOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.NftOfferDocHydratedChain>?
nftOfferDocHydratedChainNullableListFromJson(
  List? nftOfferDocHydratedChain, [
  List<enums.NftOfferDocHydratedChain>? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return defaultValue;
  }

  return nftOfferDocHydratedChain
      .map((e) => nftOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? shortCollectionDocChainNullableToJson(
  enums.ShortCollectionDocChain? shortCollectionDocChain,
) {
  return shortCollectionDocChain?.value;
}

String? shortCollectionDocChainToJson(
  enums.ShortCollectionDocChain shortCollectionDocChain,
) {
  return shortCollectionDocChain.value;
}

enums.ShortCollectionDocChain shortCollectionDocChainFromJson(
  Object? shortCollectionDocChain, [
  enums.ShortCollectionDocChain? defaultValue,
]) {
  return enums.ShortCollectionDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionDocChain,
      ) ??
      defaultValue ??
      enums.ShortCollectionDocChain.swaggerGeneratedUnknown;
}

enums.ShortCollectionDocChain? shortCollectionDocChainNullableFromJson(
  Object? shortCollectionDocChain, [
  enums.ShortCollectionDocChain? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return null;
  }
  return enums.ShortCollectionDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionDocChain,
      ) ??
      defaultValue;
}

String shortCollectionDocChainExplodedListToJson(
  List<enums.ShortCollectionDocChain>? shortCollectionDocChain,
) {
  return shortCollectionDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortCollectionDocChainListToJson(
  List<enums.ShortCollectionDocChain>? shortCollectionDocChain,
) {
  if (shortCollectionDocChain == null) {
    return [];
  }

  return shortCollectionDocChain.map((e) => e.value!).toList();
}

List<enums.ShortCollectionDocChain> shortCollectionDocChainListFromJson(
  List? shortCollectionDocChain, [
  List<enums.ShortCollectionDocChain>? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return defaultValue ?? [];
  }

  return shortCollectionDocChain
      .map((e) => shortCollectionDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortCollectionDocChain>?
shortCollectionDocChainNullableListFromJson(
  List? shortCollectionDocChain, [
  List<enums.ShortCollectionDocChain>? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return defaultValue;
  }

  return shortCollectionDocChain
      .map((e) => shortCollectionDocChainFromJson(e.toString()))
      .toList();
}

String? globalOfferDocHydratedDataTypeNullableToJson(
  enums.GlobalOfferDocHydratedDataType? globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType?.value;
}

String? globalOfferDocHydratedDataTypeToJson(
  enums.GlobalOfferDocHydratedDataType globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType.value;
}

enums.GlobalOfferDocHydratedDataType globalOfferDocHydratedDataTypeFromJson(
  Object? globalOfferDocHydratedDataType, [
  enums.GlobalOfferDocHydratedDataType? defaultValue,
]) {
  return enums.GlobalOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.GlobalOfferDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.GlobalOfferDocHydratedDataType?
globalOfferDocHydratedDataTypeNullableFromJson(
  Object? globalOfferDocHydratedDataType, [
  enums.GlobalOfferDocHydratedDataType? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return null;
  }
  return enums.GlobalOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedDataType,
      ) ??
      defaultValue;
}

String globalOfferDocHydratedDataTypeExplodedListToJson(
  List<enums.GlobalOfferDocHydratedDataType>? globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> globalOfferDocHydratedDataTypeListToJson(
  List<enums.GlobalOfferDocHydratedDataType>? globalOfferDocHydratedDataType,
) {
  if (globalOfferDocHydratedDataType == null) {
    return [];
  }

  return globalOfferDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.GlobalOfferDocHydratedDataType>
globalOfferDocHydratedDataTypeListFromJson(
  List? globalOfferDocHydratedDataType, [
  List<enums.GlobalOfferDocHydratedDataType>? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return globalOfferDocHydratedDataType
      .map((e) => globalOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.GlobalOfferDocHydratedDataType>?
globalOfferDocHydratedDataTypeNullableListFromJson(
  List? globalOfferDocHydratedDataType, [
  List<enums.GlobalOfferDocHydratedDataType>? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return defaultValue;
  }

  return globalOfferDocHydratedDataType
      .map((e) => globalOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? globalOfferDocHydratedChainNullableToJson(
  enums.GlobalOfferDocHydratedChain? globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain?.value;
}

String? globalOfferDocHydratedChainToJson(
  enums.GlobalOfferDocHydratedChain globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain.value;
}

enums.GlobalOfferDocHydratedChain globalOfferDocHydratedChainFromJson(
  Object? globalOfferDocHydratedChain, [
  enums.GlobalOfferDocHydratedChain? defaultValue,
]) {
  return enums.GlobalOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedChain,
      ) ??
      defaultValue ??
      enums.GlobalOfferDocHydratedChain.swaggerGeneratedUnknown;
}

enums.GlobalOfferDocHydratedChain? globalOfferDocHydratedChainNullableFromJson(
  Object? globalOfferDocHydratedChain, [
  enums.GlobalOfferDocHydratedChain? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return null;
  }
  return enums.GlobalOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedChain,
      ) ??
      defaultValue;
}

String globalOfferDocHydratedChainExplodedListToJson(
  List<enums.GlobalOfferDocHydratedChain>? globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> globalOfferDocHydratedChainListToJson(
  List<enums.GlobalOfferDocHydratedChain>? globalOfferDocHydratedChain,
) {
  if (globalOfferDocHydratedChain == null) {
    return [];
  }

  return globalOfferDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.GlobalOfferDocHydratedChain> globalOfferDocHydratedChainListFromJson(
  List? globalOfferDocHydratedChain, [
  List<enums.GlobalOfferDocHydratedChain>? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return globalOfferDocHydratedChain
      .map((e) => globalOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.GlobalOfferDocHydratedChain>?
globalOfferDocHydratedChainNullableListFromJson(
  List? globalOfferDocHydratedChain, [
  List<enums.GlobalOfferDocHydratedChain>? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return defaultValue;
  }

  return globalOfferDocHydratedChain
      .map((e) => globalOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocDataTypeNullableToJson(
  enums.CollectionProfileDocDataType? collectionProfileDocDataType,
) {
  return collectionProfileDocDataType?.value;
}

String? collectionProfileDocDataTypeToJson(
  enums.CollectionProfileDocDataType collectionProfileDocDataType,
) {
  return collectionProfileDocDataType.value;
}

enums.CollectionProfileDocDataType collectionProfileDocDataTypeFromJson(
  Object? collectionProfileDocDataType, [
  enums.CollectionProfileDocDataType? defaultValue,
]) {
  return enums.CollectionProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocDataType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocDataType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocDataType?
collectionProfileDocDataTypeNullableFromJson(
  Object? collectionProfileDocDataType, [
  enums.CollectionProfileDocDataType? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return null;
  }
  return enums.CollectionProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocDataType,
      ) ??
      defaultValue;
}

String collectionProfileDocDataTypeExplodedListToJson(
  List<enums.CollectionProfileDocDataType>? collectionProfileDocDataType,
) {
  return collectionProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocDataTypeListToJson(
  List<enums.CollectionProfileDocDataType>? collectionProfileDocDataType,
) {
  if (collectionProfileDocDataType == null) {
    return [];
  }

  return collectionProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocDataType>
collectionProfileDocDataTypeListFromJson(
  List? collectionProfileDocDataType, [
  List<enums.CollectionProfileDocDataType>? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocDataType
      .map((e) => collectionProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocDataType>?
collectionProfileDocDataTypeNullableListFromJson(
  List? collectionProfileDocDataType, [
  List<enums.CollectionProfileDocDataType>? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return defaultValue;
  }

  return collectionProfileDocDataType
      .map((e) => collectionProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocTypeNullableToJson(
  enums.CollectionProfileDocType? collectionProfileDocType,
) {
  return collectionProfileDocType?.value;
}

String? collectionProfileDocTypeToJson(
  enums.CollectionProfileDocType collectionProfileDocType,
) {
  return collectionProfileDocType.value;
}

enums.CollectionProfileDocType collectionProfileDocTypeFromJson(
  Object? collectionProfileDocType, [
  enums.CollectionProfileDocType? defaultValue,
]) {
  return enums.CollectionProfileDocType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocType? collectionProfileDocTypeNullableFromJson(
  Object? collectionProfileDocType, [
  enums.CollectionProfileDocType? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return null;
  }
  return enums.CollectionProfileDocType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocType,
      ) ??
      defaultValue;
}

String collectionProfileDocTypeExplodedListToJson(
  List<enums.CollectionProfileDocType>? collectionProfileDocType,
) {
  return collectionProfileDocType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocTypeListToJson(
  List<enums.CollectionProfileDocType>? collectionProfileDocType,
) {
  if (collectionProfileDocType == null) {
    return [];
  }

  return collectionProfileDocType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocType> collectionProfileDocTypeListFromJson(
  List? collectionProfileDocType, [
  List<enums.CollectionProfileDocType>? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocType
      .map((e) => collectionProfileDocTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocType>?
collectionProfileDocTypeNullableListFromJson(
  List? collectionProfileDocType, [
  List<enums.CollectionProfileDocType>? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return defaultValue;
  }

  return collectionProfileDocType
      .map((e) => collectionProfileDocTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocSubTypeNullableToJson(
  enums.CollectionProfileDocSubType? collectionProfileDocSubType,
) {
  return collectionProfileDocSubType?.value;
}

String? collectionProfileDocSubTypeToJson(
  enums.CollectionProfileDocSubType collectionProfileDocSubType,
) {
  return collectionProfileDocSubType.value;
}

enums.CollectionProfileDocSubType collectionProfileDocSubTypeFromJson(
  Object? collectionProfileDocSubType, [
  enums.CollectionProfileDocSubType? defaultValue,
]) {
  return enums.CollectionProfileDocSubType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocSubType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocSubType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocSubType? collectionProfileDocSubTypeNullableFromJson(
  Object? collectionProfileDocSubType, [
  enums.CollectionProfileDocSubType? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return null;
  }
  return enums.CollectionProfileDocSubType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocSubType,
      ) ??
      defaultValue;
}

String collectionProfileDocSubTypeExplodedListToJson(
  List<enums.CollectionProfileDocSubType>? collectionProfileDocSubType,
) {
  return collectionProfileDocSubType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocSubTypeListToJson(
  List<enums.CollectionProfileDocSubType>? collectionProfileDocSubType,
) {
  if (collectionProfileDocSubType == null) {
    return [];
  }

  return collectionProfileDocSubType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocSubType> collectionProfileDocSubTypeListFromJson(
  List? collectionProfileDocSubType, [
  List<enums.CollectionProfileDocSubType>? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocSubType
      .map((e) => collectionProfileDocSubTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocSubType>?
collectionProfileDocSubTypeNullableListFromJson(
  List? collectionProfileDocSubType, [
  List<enums.CollectionProfileDocSubType>? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return defaultValue;
  }

  return collectionProfileDocSubType
      .map((e) => collectionProfileDocSubTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocChainNullableToJson(
  enums.CollectionProfileDocChain? collectionProfileDocChain,
) {
  return collectionProfileDocChain?.value;
}

String? collectionProfileDocChainToJson(
  enums.CollectionProfileDocChain collectionProfileDocChain,
) {
  return collectionProfileDocChain.value;
}

enums.CollectionProfileDocChain collectionProfileDocChainFromJson(
  Object? collectionProfileDocChain, [
  enums.CollectionProfileDocChain? defaultValue,
]) {
  return enums.CollectionProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocChain,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocChain.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocChain? collectionProfileDocChainNullableFromJson(
  Object? collectionProfileDocChain, [
  enums.CollectionProfileDocChain? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return null;
  }
  return enums.CollectionProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocChain,
      ) ??
      defaultValue;
}

String collectionProfileDocChainExplodedListToJson(
  List<enums.CollectionProfileDocChain>? collectionProfileDocChain,
) {
  return collectionProfileDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocChainListToJson(
  List<enums.CollectionProfileDocChain>? collectionProfileDocChain,
) {
  if (collectionProfileDocChain == null) {
    return [];
  }

  return collectionProfileDocChain.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocChain> collectionProfileDocChainListFromJson(
  List? collectionProfileDocChain, [
  List<enums.CollectionProfileDocChain>? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocChain
      .map((e) => collectionProfileDocChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocChain>?
collectionProfileDocChainNullableListFromJson(
  List? collectionProfileDocChain, [
  List<enums.CollectionProfileDocChain>? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return defaultValue;
  }

  return collectionProfileDocChain
      .map((e) => collectionProfileDocChainFromJson(e.toString()))
      .toList();
}

String? pinnedCollectionDtoChainNullableToJson(
  enums.PinnedCollectionDtoChain? pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain?.value;
}

String? pinnedCollectionDtoChainToJson(
  enums.PinnedCollectionDtoChain pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain.value;
}

enums.PinnedCollectionDtoChain pinnedCollectionDtoChainFromJson(
  Object? pinnedCollectionDtoChain, [
  enums.PinnedCollectionDtoChain? defaultValue,
]) {
  return enums.PinnedCollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == pinnedCollectionDtoChain,
      ) ??
      defaultValue ??
      enums.PinnedCollectionDtoChain.swaggerGeneratedUnknown;
}

enums.PinnedCollectionDtoChain? pinnedCollectionDtoChainNullableFromJson(
  Object? pinnedCollectionDtoChain, [
  enums.PinnedCollectionDtoChain? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return null;
  }
  return enums.PinnedCollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == pinnedCollectionDtoChain,
      ) ??
      defaultValue;
}

String pinnedCollectionDtoChainExplodedListToJson(
  List<enums.PinnedCollectionDtoChain>? pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> pinnedCollectionDtoChainListToJson(
  List<enums.PinnedCollectionDtoChain>? pinnedCollectionDtoChain,
) {
  if (pinnedCollectionDtoChain == null) {
    return [];
  }

  return pinnedCollectionDtoChain.map((e) => e.value!).toList();
}

List<enums.PinnedCollectionDtoChain> pinnedCollectionDtoChainListFromJson(
  List? pinnedCollectionDtoChain, [
  List<enums.PinnedCollectionDtoChain>? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return defaultValue ?? [];
  }

  return pinnedCollectionDtoChain
      .map((e) => pinnedCollectionDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.PinnedCollectionDtoChain>?
pinnedCollectionDtoChainNullableListFromJson(
  List? pinnedCollectionDtoChain, [
  List<enums.PinnedCollectionDtoChain>? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return defaultValue;
  }

  return pinnedCollectionDtoChain
      .map((e) => pinnedCollectionDtoChainFromJson(e.toString()))
      .toList();
}

String? collectionMintProfileDocHydratedDataTypeNullableToJson(
  enums.CollectionMintProfileDocHydratedDataType?
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType?.value;
}

String? collectionMintProfileDocHydratedDataTypeToJson(
  enums.CollectionMintProfileDocHydratedDataType
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType.value;
}

enums.CollectionMintProfileDocHydratedDataType
collectionMintProfileDocHydratedDataTypeFromJson(
  Object? collectionMintProfileDocHydratedDataType, [
  enums.CollectionMintProfileDocHydratedDataType? defaultValue,
]) {
  return enums.CollectionMintProfileDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == collectionMintProfileDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.CollectionMintProfileDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.CollectionMintProfileDocHydratedDataType?
collectionMintProfileDocHydratedDataTypeNullableFromJson(
  Object? collectionMintProfileDocHydratedDataType, [
  enums.CollectionMintProfileDocHydratedDataType? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return null;
  }
  return enums.CollectionMintProfileDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == collectionMintProfileDocHydratedDataType,
      ) ??
      defaultValue;
}

String collectionMintProfileDocHydratedDataTypeExplodedListToJson(
  List<enums.CollectionMintProfileDocHydratedDataType>?
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> collectionMintProfileDocHydratedDataTypeListToJson(
  List<enums.CollectionMintProfileDocHydratedDataType>?
  collectionMintProfileDocHydratedDataType,
) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return [];
  }

  return collectionMintProfileDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.CollectionMintProfileDocHydratedDataType>
collectionMintProfileDocHydratedDataTypeListFromJson(
  List? collectionMintProfileDocHydratedDataType, [
  List<enums.CollectionMintProfileDocHydratedDataType>? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return collectionMintProfileDocHydratedDataType
      .map(
        (e) => collectionMintProfileDocHydratedDataTypeFromJson(e.toString()),
      )
      .toList();
}

List<enums.CollectionMintProfileDocHydratedDataType>?
collectionMintProfileDocHydratedDataTypeNullableListFromJson(
  List? collectionMintProfileDocHydratedDataType, [
  List<enums.CollectionMintProfileDocHydratedDataType>? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return defaultValue;
  }

  return collectionMintProfileDocHydratedDataType
      .map(
        (e) => collectionMintProfileDocHydratedDataTypeFromJson(e.toString()),
      )
      .toList();
}

String? mintingListingDtoDataTypeNullableToJson(
  enums.MintingListingDtoDataType? mintingListingDtoDataType,
) {
  return mintingListingDtoDataType?.value;
}

String? mintingListingDtoDataTypeToJson(
  enums.MintingListingDtoDataType mintingListingDtoDataType,
) {
  return mintingListingDtoDataType.value;
}

enums.MintingListingDtoDataType mintingListingDtoDataTypeFromJson(
  Object? mintingListingDtoDataType, [
  enums.MintingListingDtoDataType? defaultValue,
]) {
  return enums.MintingListingDtoDataType.values.firstWhereOrNull(
        (e) => e.value == mintingListingDtoDataType,
      ) ??
      defaultValue ??
      enums.MintingListingDtoDataType.swaggerGeneratedUnknown;
}

enums.MintingListingDtoDataType? mintingListingDtoDataTypeNullableFromJson(
  Object? mintingListingDtoDataType, [
  enums.MintingListingDtoDataType? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return null;
  }
  return enums.MintingListingDtoDataType.values.firstWhereOrNull(
        (e) => e.value == mintingListingDtoDataType,
      ) ??
      defaultValue;
}

String mintingListingDtoDataTypeExplodedListToJson(
  List<enums.MintingListingDtoDataType>? mintingListingDtoDataType,
) {
  return mintingListingDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mintingListingDtoDataTypeListToJson(
  List<enums.MintingListingDtoDataType>? mintingListingDtoDataType,
) {
  if (mintingListingDtoDataType == null) {
    return [];
  }

  return mintingListingDtoDataType.map((e) => e.value!).toList();
}

List<enums.MintingListingDtoDataType> mintingListingDtoDataTypeListFromJson(
  List? mintingListingDtoDataType, [
  List<enums.MintingListingDtoDataType>? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return defaultValue ?? [];
  }

  return mintingListingDtoDataType
      .map((e) => mintingListingDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.MintingListingDtoDataType>?
mintingListingDtoDataTypeNullableListFromJson(
  List? mintingListingDtoDataType, [
  List<enums.MintingListingDtoDataType>? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return defaultValue;
  }

  return mintingListingDtoDataType
      .map((e) => mintingListingDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? ticketingDataTypeNullableToJson(
  enums.TicketingDataType? ticketingDataType,
) {
  return ticketingDataType?.value;
}

String? ticketingDataTypeToJson(enums.TicketingDataType ticketingDataType) {
  return ticketingDataType.value;
}

enums.TicketingDataType ticketingDataTypeFromJson(
  Object? ticketingDataType, [
  enums.TicketingDataType? defaultValue,
]) {
  return enums.TicketingDataType.values.firstWhereOrNull(
        (e) => e.value == ticketingDataType,
      ) ??
      defaultValue ??
      enums.TicketingDataType.swaggerGeneratedUnknown;
}

enums.TicketingDataType? ticketingDataTypeNullableFromJson(
  Object? ticketingDataType, [
  enums.TicketingDataType? defaultValue,
]) {
  if (ticketingDataType == null) {
    return null;
  }
  return enums.TicketingDataType.values.firstWhereOrNull(
        (e) => e.value == ticketingDataType,
      ) ??
      defaultValue;
}

String ticketingDataTypeExplodedListToJson(
  List<enums.TicketingDataType>? ticketingDataType,
) {
  return ticketingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> ticketingDataTypeListToJson(
  List<enums.TicketingDataType>? ticketingDataType,
) {
  if (ticketingDataType == null) {
    return [];
  }

  return ticketingDataType.map((e) => e.value!).toList();
}

List<enums.TicketingDataType> ticketingDataTypeListFromJson(
  List? ticketingDataType, [
  List<enums.TicketingDataType>? defaultValue,
]) {
  if (ticketingDataType == null) {
    return defaultValue ?? [];
  }

  return ticketingDataType
      .map((e) => ticketingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.TicketingDataType>? ticketingDataTypeNullableListFromJson(
  List? ticketingDataType, [
  List<enums.TicketingDataType>? defaultValue,
]) {
  if (ticketingDataType == null) {
    return defaultValue;
  }

  return ticketingDataType
      .map((e) => ticketingDataTypeFromJson(e.toString()))
      .toList();
}

String? eventCategoryNullableToJson(enums.EventCategory? eventCategory) {
  return eventCategory?.value;
}

String? eventCategoryToJson(enums.EventCategory eventCategory) {
  return eventCategory.value;
}

enums.EventCategory eventCategoryFromJson(
  Object? eventCategory, [
  enums.EventCategory? defaultValue,
]) {
  return enums.EventCategory.values.firstWhereOrNull(
        (e) => e.value == eventCategory,
      ) ??
      defaultValue ??
      enums.EventCategory.swaggerGeneratedUnknown;
}

enums.EventCategory? eventCategoryNullableFromJson(
  Object? eventCategory, [
  enums.EventCategory? defaultValue,
]) {
  if (eventCategory == null) {
    return null;
  }
  return enums.EventCategory.values.firstWhereOrNull(
        (e) => e.value == eventCategory,
      ) ??
      defaultValue;
}

String eventCategoryExplodedListToJson(
  List<enums.EventCategory>? eventCategory,
) {
  return eventCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventCategoryListToJson(List<enums.EventCategory>? eventCategory) {
  if (eventCategory == null) {
    return [];
  }

  return eventCategory.map((e) => e.value!).toList();
}

List<enums.EventCategory> eventCategoryListFromJson(
  List? eventCategory, [
  List<enums.EventCategory>? defaultValue,
]) {
  if (eventCategory == null) {
    return defaultValue ?? [];
  }

  return eventCategory.map((e) => eventCategoryFromJson(e.toString())).toList();
}

List<enums.EventCategory>? eventCategoryNullableListFromJson(
  List? eventCategory, [
  List<enums.EventCategory>? defaultValue,
]) {
  if (eventCategory == null) {
    return defaultValue;
  }

  return eventCategory.map((e) => eventCategoryFromJson(e.toString())).toList();
}

String? eventSubCategoryNullableToJson(
  enums.EventSubCategory? eventSubCategory,
) {
  return eventSubCategory?.value;
}

String? eventSubCategoryToJson(enums.EventSubCategory eventSubCategory) {
  return eventSubCategory.value;
}

enums.EventSubCategory eventSubCategoryFromJson(
  Object? eventSubCategory, [
  enums.EventSubCategory? defaultValue,
]) {
  return enums.EventSubCategory.values.firstWhereOrNull(
        (e) => e.value == eventSubCategory,
      ) ??
      defaultValue ??
      enums.EventSubCategory.swaggerGeneratedUnknown;
}

enums.EventSubCategory? eventSubCategoryNullableFromJson(
  Object? eventSubCategory, [
  enums.EventSubCategory? defaultValue,
]) {
  if (eventSubCategory == null) {
    return null;
  }
  return enums.EventSubCategory.values.firstWhereOrNull(
        (e) => e.value == eventSubCategory,
      ) ??
      defaultValue;
}

String eventSubCategoryExplodedListToJson(
  List<enums.EventSubCategory>? eventSubCategory,
) {
  return eventSubCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventSubCategoryListToJson(
  List<enums.EventSubCategory>? eventSubCategory,
) {
  if (eventSubCategory == null) {
    return [];
  }

  return eventSubCategory.map((e) => e.value!).toList();
}

List<enums.EventSubCategory> eventSubCategoryListFromJson(
  List? eventSubCategory, [
  List<enums.EventSubCategory>? defaultValue,
]) {
  if (eventSubCategory == null) {
    return defaultValue ?? [];
  }

  return eventSubCategory
      .map((e) => eventSubCategoryFromJson(e.toString()))
      .toList();
}

List<enums.EventSubCategory>? eventSubCategoryNullableListFromJson(
  List? eventSubCategory, [
  List<enums.EventSubCategory>? defaultValue,
]) {
  if (eventSubCategory == null) {
    return defaultValue;
  }

  return eventSubCategory
      .map((e) => eventSubCategoryFromJson(e.toString()))
      .toList();
}

String? visibilityNullableToJson(enums.Visibility? visibility) {
  return visibility?.value;
}

String? visibilityToJson(enums.Visibility visibility) {
  return visibility.value;
}

enums.Visibility visibilityFromJson(
  Object? visibility, [
  enums.Visibility? defaultValue,
]) {
  return enums.Visibility.values.firstWhereOrNull(
        (e) => e.value == visibility,
      ) ??
      defaultValue ??
      enums.Visibility.swaggerGeneratedUnknown;
}

enums.Visibility? visibilityNullableFromJson(
  Object? visibility, [
  enums.Visibility? defaultValue,
]) {
  if (visibility == null) {
    return null;
  }
  return enums.Visibility.values.firstWhereOrNull(
        (e) => e.value == visibility,
      ) ??
      defaultValue;
}

String visibilityExplodedListToJson(List<enums.Visibility>? visibility) {
  return visibility?.map((e) => e.value!).join(',') ?? '';
}

List<String> visibilityListToJson(List<enums.Visibility>? visibility) {
  if (visibility == null) {
    return [];
  }

  return visibility.map((e) => e.value!).toList();
}

List<enums.Visibility> visibilityListFromJson(
  List? visibility, [
  List<enums.Visibility>? defaultValue,
]) {
  if (visibility == null) {
    return defaultValue ?? [];
  }

  return visibility.map((e) => visibilityFromJson(e.toString())).toList();
}

List<enums.Visibility>? visibilityNullableListFromJson(
  List? visibility, [
  List<enums.Visibility>? defaultValue,
]) {
  if (visibility == null) {
    return defaultValue;
  }

  return visibility.map((e) => visibilityFromJson(e.toString())).toList();
}

String? eventUserRolesNullableToJson(enums.EventUserRoles? eventUserRoles) {
  return eventUserRoles?.value;
}

String? eventUserRolesToJson(enums.EventUserRoles eventUserRoles) {
  return eventUserRoles.value;
}

enums.EventUserRoles eventUserRolesFromJson(
  Object? eventUserRoles, [
  enums.EventUserRoles? defaultValue,
]) {
  return enums.EventUserRoles.values.firstWhereOrNull(
        (e) => e.value == eventUserRoles,
      ) ??
      defaultValue ??
      enums.EventUserRoles.swaggerGeneratedUnknown;
}

enums.EventUserRoles? eventUserRolesNullableFromJson(
  Object? eventUserRoles, [
  enums.EventUserRoles? defaultValue,
]) {
  if (eventUserRoles == null) {
    return null;
  }
  return enums.EventUserRoles.values.firstWhereOrNull(
        (e) => e.value == eventUserRoles,
      ) ??
      defaultValue;
}

String eventUserRolesExplodedListToJson(
  List<enums.EventUserRoles>? eventUserRoles,
) {
  return eventUserRoles?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventUserRolesListToJson(
  List<enums.EventUserRoles>? eventUserRoles,
) {
  if (eventUserRoles == null) {
    return [];
  }

  return eventUserRoles.map((e) => e.value!).toList();
}

List<enums.EventUserRoles> eventUserRolesListFromJson(
  List? eventUserRoles, [
  List<enums.EventUserRoles>? defaultValue,
]) {
  if (eventUserRoles == null) {
    return defaultValue ?? [];
  }

  return eventUserRoles
      .map((e) => eventUserRolesFromJson(e.toString()))
      .toList();
}

List<enums.EventUserRoles>? eventUserRolesNullableListFromJson(
  List? eventUserRoles, [
  List<enums.EventUserRoles>? defaultValue,
]) {
  if (eventUserRoles == null) {
    return defaultValue;
  }

  return eventUserRoles
      .map((e) => eventUserRolesFromJson(e.toString()))
      .toList();
}

String? eventUserRolePermissionNullableToJson(
  enums.EventUserRolePermission? eventUserRolePermission,
) {
  return eventUserRolePermission?.value;
}

String? eventUserRolePermissionToJson(
  enums.EventUserRolePermission eventUserRolePermission,
) {
  return eventUserRolePermission.value;
}

enums.EventUserRolePermission eventUserRolePermissionFromJson(
  Object? eventUserRolePermission, [
  enums.EventUserRolePermission? defaultValue,
]) {
  return enums.EventUserRolePermission.values.firstWhereOrNull(
        (e) => e.value == eventUserRolePermission,
      ) ??
      defaultValue ??
      enums.EventUserRolePermission.swaggerGeneratedUnknown;
}

enums.EventUserRolePermission? eventUserRolePermissionNullableFromJson(
  Object? eventUserRolePermission, [
  enums.EventUserRolePermission? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return null;
  }
  return enums.EventUserRolePermission.values.firstWhereOrNull(
        (e) => e.value == eventUserRolePermission,
      ) ??
      defaultValue;
}

String eventUserRolePermissionExplodedListToJson(
  List<enums.EventUserRolePermission>? eventUserRolePermission,
) {
  return eventUserRolePermission?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventUserRolePermissionListToJson(
  List<enums.EventUserRolePermission>? eventUserRolePermission,
) {
  if (eventUserRolePermission == null) {
    return [];
  }

  return eventUserRolePermission.map((e) => e.value!).toList();
}

List<enums.EventUserRolePermission> eventUserRolePermissionListFromJson(
  List? eventUserRolePermission, [
  List<enums.EventUserRolePermission>? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return defaultValue ?? [];
  }

  return eventUserRolePermission
      .map((e) => eventUserRolePermissionFromJson(e.toString()))
      .toList();
}

List<enums.EventUserRolePermission>?
eventUserRolePermissionNullableListFromJson(
  List? eventUserRolePermission, [
  List<enums.EventUserRolePermission>? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return defaultValue;
  }

  return eventUserRolePermission
      .map((e) => eventUserRolePermissionFromJson(e.toString()))
      .toList();
}

String? roleStatusNullableToJson(enums.RoleStatus? roleStatus) {
  return roleStatus?.value;
}

String? roleStatusToJson(enums.RoleStatus roleStatus) {
  return roleStatus.value;
}

enums.RoleStatus roleStatusFromJson(
  Object? roleStatus, [
  enums.RoleStatus? defaultValue,
]) {
  return enums.RoleStatus.values.firstWhereOrNull(
        (e) => e.value == roleStatus,
      ) ??
      defaultValue ??
      enums.RoleStatus.swaggerGeneratedUnknown;
}

enums.RoleStatus? roleStatusNullableFromJson(
  Object? roleStatus, [
  enums.RoleStatus? defaultValue,
]) {
  if (roleStatus == null) {
    return null;
  }
  return enums.RoleStatus.values.firstWhereOrNull(
        (e) => e.value == roleStatus,
      ) ??
      defaultValue;
}

String roleStatusExplodedListToJson(List<enums.RoleStatus>? roleStatus) {
  return roleStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> roleStatusListToJson(List<enums.RoleStatus>? roleStatus) {
  if (roleStatus == null) {
    return [];
  }

  return roleStatus.map((e) => e.value!).toList();
}

List<enums.RoleStatus> roleStatusListFromJson(
  List? roleStatus, [
  List<enums.RoleStatus>? defaultValue,
]) {
  if (roleStatus == null) {
    return defaultValue ?? [];
  }

  return roleStatus.map((e) => roleStatusFromJson(e.toString())).toList();
}

List<enums.RoleStatus>? roleStatusNullableListFromJson(
  List? roleStatus, [
  List<enums.RoleStatus>? defaultValue,
]) {
  if (roleStatus == null) {
    return defaultValue;
  }

  return roleStatus.map((e) => roleStatusFromJson(e.toString())).toList();
}

String? eventGuestStatusNullableToJson(
  enums.EventGuestStatus? eventGuestStatus,
) {
  return eventGuestStatus?.value;
}

String? eventGuestStatusToJson(enums.EventGuestStatus eventGuestStatus) {
  return eventGuestStatus.value;
}

enums.EventGuestStatus eventGuestStatusFromJson(
  Object? eventGuestStatus, [
  enums.EventGuestStatus? defaultValue,
]) {
  return enums.EventGuestStatus.values.firstWhereOrNull(
        (e) => e.value == eventGuestStatus,
      ) ??
      defaultValue ??
      enums.EventGuestStatus.swaggerGeneratedUnknown;
}

enums.EventGuestStatus? eventGuestStatusNullableFromJson(
  Object? eventGuestStatus, [
  enums.EventGuestStatus? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return null;
  }
  return enums.EventGuestStatus.values.firstWhereOrNull(
        (e) => e.value == eventGuestStatus,
      ) ??
      defaultValue;
}

String eventGuestStatusExplodedListToJson(
  List<enums.EventGuestStatus>? eventGuestStatus,
) {
  return eventGuestStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventGuestStatusListToJson(
  List<enums.EventGuestStatus>? eventGuestStatus,
) {
  if (eventGuestStatus == null) {
    return [];
  }

  return eventGuestStatus.map((e) => e.value!).toList();
}

List<enums.EventGuestStatus> eventGuestStatusListFromJson(
  List? eventGuestStatus, [
  List<enums.EventGuestStatus>? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return defaultValue ?? [];
  }

  return eventGuestStatus
      .map((e) => eventGuestStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventGuestStatus>? eventGuestStatusNullableListFromJson(
  List? eventGuestStatus, [
  List<enums.EventGuestStatus>? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return defaultValue;
  }

  return eventGuestStatus
      .map((e) => eventGuestStatusFromJson(e.toString()))
      .toList();
}

String? creatorDetailsDtoDataTypeNullableToJson(
  enums.CreatorDetailsDtoDataType? creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType?.value;
}

String? creatorDetailsDtoDataTypeToJson(
  enums.CreatorDetailsDtoDataType creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType.value;
}

enums.CreatorDetailsDtoDataType creatorDetailsDtoDataTypeFromJson(
  Object? creatorDetailsDtoDataType, [
  enums.CreatorDetailsDtoDataType? defaultValue,
]) {
  return enums.CreatorDetailsDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorDetailsDtoDataType,
      ) ??
      defaultValue ??
      enums.CreatorDetailsDtoDataType.swaggerGeneratedUnknown;
}

enums.CreatorDetailsDtoDataType? creatorDetailsDtoDataTypeNullableFromJson(
  Object? creatorDetailsDtoDataType, [
  enums.CreatorDetailsDtoDataType? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return null;
  }
  return enums.CreatorDetailsDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorDetailsDtoDataType,
      ) ??
      defaultValue;
}

String creatorDetailsDtoDataTypeExplodedListToJson(
  List<enums.CreatorDetailsDtoDataType>? creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorDetailsDtoDataTypeListToJson(
  List<enums.CreatorDetailsDtoDataType>? creatorDetailsDtoDataType,
) {
  if (creatorDetailsDtoDataType == null) {
    return [];
  }

  return creatorDetailsDtoDataType.map((e) => e.value!).toList();
}

List<enums.CreatorDetailsDtoDataType> creatorDetailsDtoDataTypeListFromJson(
  List? creatorDetailsDtoDataType, [
  List<enums.CreatorDetailsDtoDataType>? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return defaultValue ?? [];
  }

  return creatorDetailsDtoDataType
      .map((e) => creatorDetailsDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorDetailsDtoDataType>?
creatorDetailsDtoDataTypeNullableListFromJson(
  List? creatorDetailsDtoDataType, [
  List<enums.CreatorDetailsDtoDataType>? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return defaultValue;
  }

  return creatorDetailsDtoDataType
      .map((e) => creatorDetailsDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? linkedAccountTypeNullableToJson(
  enums.LinkedAccountType? linkedAccountType,
) {
  return linkedAccountType?.value;
}

String? linkedAccountTypeToJson(enums.LinkedAccountType linkedAccountType) {
  return linkedAccountType.value;
}

enums.LinkedAccountType linkedAccountTypeFromJson(
  Object? linkedAccountType, [
  enums.LinkedAccountType? defaultValue,
]) {
  return enums.LinkedAccountType.values.firstWhereOrNull(
        (e) => e.value == linkedAccountType,
      ) ??
      defaultValue ??
      enums.LinkedAccountType.swaggerGeneratedUnknown;
}

enums.LinkedAccountType? linkedAccountTypeNullableFromJson(
  Object? linkedAccountType, [
  enums.LinkedAccountType? defaultValue,
]) {
  if (linkedAccountType == null) {
    return null;
  }
  return enums.LinkedAccountType.values.firstWhereOrNull(
        (e) => e.value == linkedAccountType,
      ) ??
      defaultValue;
}

String linkedAccountTypeExplodedListToJson(
  List<enums.LinkedAccountType>? linkedAccountType,
) {
  return linkedAccountType?.map((e) => e.value!).join(',') ?? '';
}

List<String> linkedAccountTypeListToJson(
  List<enums.LinkedAccountType>? linkedAccountType,
) {
  if (linkedAccountType == null) {
    return [];
  }

  return linkedAccountType.map((e) => e.value!).toList();
}

List<enums.LinkedAccountType> linkedAccountTypeListFromJson(
  List? linkedAccountType, [
  List<enums.LinkedAccountType>? defaultValue,
]) {
  if (linkedAccountType == null) {
    return defaultValue ?? [];
  }

  return linkedAccountType
      .map((e) => linkedAccountTypeFromJson(e.toString()))
      .toList();
}

List<enums.LinkedAccountType>? linkedAccountTypeNullableListFromJson(
  List? linkedAccountType, [
  List<enums.LinkedAccountType>? defaultValue,
]) {
  if (linkedAccountType == null) {
    return defaultValue;
  }

  return linkedAccountType
      .map((e) => linkedAccountTypeFromJson(e.toString()))
      .toList();
}

String? walletClientTypeNullableToJson(
  enums.WalletClientType? walletClientType,
) {
  return walletClientType?.value;
}

String? walletClientTypeToJson(enums.WalletClientType walletClientType) {
  return walletClientType.value;
}

enums.WalletClientType walletClientTypeFromJson(
  Object? walletClientType, [
  enums.WalletClientType? defaultValue,
]) {
  return enums.WalletClientType.values.firstWhereOrNull(
        (e) => e.value == walletClientType,
      ) ??
      defaultValue ??
      enums.WalletClientType.swaggerGeneratedUnknown;
}

enums.WalletClientType? walletClientTypeNullableFromJson(
  Object? walletClientType, [
  enums.WalletClientType? defaultValue,
]) {
  if (walletClientType == null) {
    return null;
  }
  return enums.WalletClientType.values.firstWhereOrNull(
        (e) => e.value == walletClientType,
      ) ??
      defaultValue;
}

String walletClientTypeExplodedListToJson(
  List<enums.WalletClientType>? walletClientType,
) {
  return walletClientType?.map((e) => e.value!).join(',') ?? '';
}

List<String> walletClientTypeListToJson(
  List<enums.WalletClientType>? walletClientType,
) {
  if (walletClientType == null) {
    return [];
  }

  return walletClientType.map((e) => e.value!).toList();
}

List<enums.WalletClientType> walletClientTypeListFromJson(
  List? walletClientType, [
  List<enums.WalletClientType>? defaultValue,
]) {
  if (walletClientType == null) {
    return defaultValue ?? [];
  }

  return walletClientType
      .map((e) => walletClientTypeFromJson(e.toString()))
      .toList();
}

List<enums.WalletClientType>? walletClientTypeNullableListFromJson(
  List? walletClientType, [
  List<enums.WalletClientType>? defaultValue,
]) {
  if (walletClientType == null) {
    return defaultValue;
  }

  return walletClientType
      .map((e) => walletClientTypeFromJson(e.toString()))
      .toList();
}

String? stakingDataTypeNullableToJson(enums.StakingDataType? stakingDataType) {
  return stakingDataType?.value;
}

String? stakingDataTypeToJson(enums.StakingDataType stakingDataType) {
  return stakingDataType.value;
}

enums.StakingDataType stakingDataTypeFromJson(
  Object? stakingDataType, [
  enums.StakingDataType? defaultValue,
]) {
  return enums.StakingDataType.values.firstWhereOrNull(
        (e) => e.value == stakingDataType,
      ) ??
      defaultValue ??
      enums.StakingDataType.swaggerGeneratedUnknown;
}

enums.StakingDataType? stakingDataTypeNullableFromJson(
  Object? stakingDataType, [
  enums.StakingDataType? defaultValue,
]) {
  if (stakingDataType == null) {
    return null;
  }
  return enums.StakingDataType.values.firstWhereOrNull(
        (e) => e.value == stakingDataType,
      ) ??
      defaultValue;
}

String stakingDataTypeExplodedListToJson(
  List<enums.StakingDataType>? stakingDataType,
) {
  return stakingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingDataTypeListToJson(
  List<enums.StakingDataType>? stakingDataType,
) {
  if (stakingDataType == null) {
    return [];
  }

  return stakingDataType.map((e) => e.value!).toList();
}

List<enums.StakingDataType> stakingDataTypeListFromJson(
  List? stakingDataType, [
  List<enums.StakingDataType>? defaultValue,
]) {
  if (stakingDataType == null) {
    return defaultValue ?? [];
  }

  return stakingDataType
      .map((e) => stakingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.StakingDataType>? stakingDataTypeNullableListFromJson(
  List? stakingDataType, [
  List<enums.StakingDataType>? defaultValue,
]) {
  if (stakingDataType == null) {
    return defaultValue;
  }

  return stakingDataType
      .map((e) => stakingDataTypeFromJson(e.toString()))
      .toList();
}

String? stakingPoolTypeStringNullableToJson(
  enums.StakingPoolTypeString? stakingPoolTypeString,
) {
  return stakingPoolTypeString?.value;
}

String? stakingPoolTypeStringToJson(
  enums.StakingPoolTypeString stakingPoolTypeString,
) {
  return stakingPoolTypeString.value;
}

enums.StakingPoolTypeString stakingPoolTypeStringFromJson(
  Object? stakingPoolTypeString, [
  enums.StakingPoolTypeString? defaultValue,
]) {
  return enums.StakingPoolTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingPoolTypeString,
      ) ??
      defaultValue ??
      enums.StakingPoolTypeString.swaggerGeneratedUnknown;
}

enums.StakingPoolTypeString? stakingPoolTypeStringNullableFromJson(
  Object? stakingPoolTypeString, [
  enums.StakingPoolTypeString? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return null;
  }
  return enums.StakingPoolTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingPoolTypeString,
      ) ??
      defaultValue;
}

String stakingPoolTypeStringExplodedListToJson(
  List<enums.StakingPoolTypeString>? stakingPoolTypeString,
) {
  return stakingPoolTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingPoolTypeStringListToJson(
  List<enums.StakingPoolTypeString>? stakingPoolTypeString,
) {
  if (stakingPoolTypeString == null) {
    return [];
  }

  return stakingPoolTypeString.map((e) => e.value!).toList();
}

List<enums.StakingPoolTypeString> stakingPoolTypeStringListFromJson(
  List? stakingPoolTypeString, [
  List<enums.StakingPoolTypeString>? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return defaultValue ?? [];
  }

  return stakingPoolTypeString
      .map((e) => stakingPoolTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.StakingPoolTypeString>? stakingPoolTypeStringNullableListFromJson(
  List? stakingPoolTypeString, [
  List<enums.StakingPoolTypeString>? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return defaultValue;
  }

  return stakingPoolTypeString
      .map((e) => stakingPoolTypeStringFromJson(e.toString()))
      .toList();
}

String? stakingIssuingTypeStringNullableToJson(
  enums.StakingIssuingTypeString? stakingIssuingTypeString,
) {
  return stakingIssuingTypeString?.value;
}

String? stakingIssuingTypeStringToJson(
  enums.StakingIssuingTypeString stakingIssuingTypeString,
) {
  return stakingIssuingTypeString.value;
}

enums.StakingIssuingTypeString stakingIssuingTypeStringFromJson(
  Object? stakingIssuingTypeString, [
  enums.StakingIssuingTypeString? defaultValue,
]) {
  return enums.StakingIssuingTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingIssuingTypeString,
      ) ??
      defaultValue ??
      enums.StakingIssuingTypeString.swaggerGeneratedUnknown;
}

enums.StakingIssuingTypeString? stakingIssuingTypeStringNullableFromJson(
  Object? stakingIssuingTypeString, [
  enums.StakingIssuingTypeString? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return null;
  }
  return enums.StakingIssuingTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingIssuingTypeString,
      ) ??
      defaultValue;
}

String stakingIssuingTypeStringExplodedListToJson(
  List<enums.StakingIssuingTypeString>? stakingIssuingTypeString,
) {
  return stakingIssuingTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingIssuingTypeStringListToJson(
  List<enums.StakingIssuingTypeString>? stakingIssuingTypeString,
) {
  if (stakingIssuingTypeString == null) {
    return [];
  }

  return stakingIssuingTypeString.map((e) => e.value!).toList();
}

List<enums.StakingIssuingTypeString> stakingIssuingTypeStringListFromJson(
  List? stakingIssuingTypeString, [
  List<enums.StakingIssuingTypeString>? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return defaultValue ?? [];
  }

  return stakingIssuingTypeString
      .map((e) => stakingIssuingTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.StakingIssuingTypeString>?
stakingIssuingTypeStringNullableListFromJson(
  List? stakingIssuingTypeString, [
  List<enums.StakingIssuingTypeString>? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return defaultValue;
  }

  return stakingIssuingTypeString
      .map((e) => stakingIssuingTypeStringFromJson(e.toString()))
      .toList();
}

String? stakingStatusNullableToJson(enums.StakingStatus? stakingStatus) {
  return stakingStatus?.value;
}

String? stakingStatusToJson(enums.StakingStatus stakingStatus) {
  return stakingStatus.value;
}

enums.StakingStatus stakingStatusFromJson(
  Object? stakingStatus, [
  enums.StakingStatus? defaultValue,
]) {
  return enums.StakingStatus.values.firstWhereOrNull(
        (e) => e.value == stakingStatus,
      ) ??
      defaultValue ??
      enums.StakingStatus.swaggerGeneratedUnknown;
}

enums.StakingStatus? stakingStatusNullableFromJson(
  Object? stakingStatus, [
  enums.StakingStatus? defaultValue,
]) {
  if (stakingStatus == null) {
    return null;
  }
  return enums.StakingStatus.values.firstWhereOrNull(
        (e) => e.value == stakingStatus,
      ) ??
      defaultValue;
}

String stakingStatusExplodedListToJson(
  List<enums.StakingStatus>? stakingStatus,
) {
  return stakingStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingStatusListToJson(List<enums.StakingStatus>? stakingStatus) {
  if (stakingStatus == null) {
    return [];
  }

  return stakingStatus.map((e) => e.value!).toList();
}

List<enums.StakingStatus> stakingStatusListFromJson(
  List? stakingStatus, [
  List<enums.StakingStatus>? defaultValue,
]) {
  if (stakingStatus == null) {
    return defaultValue ?? [];
  }

  return stakingStatus.map((e) => stakingStatusFromJson(e.toString())).toList();
}

List<enums.StakingStatus>? stakingStatusNullableListFromJson(
  List? stakingStatus, [
  List<enums.StakingStatus>? defaultValue,
]) {
  if (stakingStatus == null) {
    return defaultValue;
  }

  return stakingStatus.map((e) => stakingStatusFromJson(e.toString())).toList();
}

String? collectionDtoChainNullableToJson(
  enums.CollectionDtoChain? collectionDtoChain,
) {
  return collectionDtoChain?.value;
}

String? collectionDtoChainToJson(enums.CollectionDtoChain collectionDtoChain) {
  return collectionDtoChain.value;
}

enums.CollectionDtoChain collectionDtoChainFromJson(
  Object? collectionDtoChain, [
  enums.CollectionDtoChain? defaultValue,
]) {
  return enums.CollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == collectionDtoChain,
      ) ??
      defaultValue ??
      enums.CollectionDtoChain.swaggerGeneratedUnknown;
}

enums.CollectionDtoChain? collectionDtoChainNullableFromJson(
  Object? collectionDtoChain, [
  enums.CollectionDtoChain? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return null;
  }
  return enums.CollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == collectionDtoChain,
      ) ??
      defaultValue;
}

String collectionDtoChainExplodedListToJson(
  List<enums.CollectionDtoChain>? collectionDtoChain,
) {
  return collectionDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionDtoChainListToJson(
  List<enums.CollectionDtoChain>? collectionDtoChain,
) {
  if (collectionDtoChain == null) {
    return [];
  }

  return collectionDtoChain.map((e) => e.value!).toList();
}

List<enums.CollectionDtoChain> collectionDtoChainListFromJson(
  List? collectionDtoChain, [
  List<enums.CollectionDtoChain>? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return defaultValue ?? [];
  }

  return collectionDtoChain
      .map((e) => collectionDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionDtoChain>? collectionDtoChainNullableListFromJson(
  List? collectionDtoChain, [
  List<enums.CollectionDtoChain>? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return defaultValue;
  }

  return collectionDtoChain
      .map((e) => collectionDtoChainFromJson(e.toString()))
      .toList();
}

String? userDtoChainNullableToJson(enums.UserDtoChain? userDtoChain) {
  return userDtoChain?.value;
}

String? userDtoChainToJson(enums.UserDtoChain userDtoChain) {
  return userDtoChain.value;
}

enums.UserDtoChain userDtoChainFromJson(
  Object? userDtoChain, [
  enums.UserDtoChain? defaultValue,
]) {
  return enums.UserDtoChain.values.firstWhereOrNull(
        (e) => e.value == userDtoChain,
      ) ??
      defaultValue ??
      enums.UserDtoChain.swaggerGeneratedUnknown;
}

enums.UserDtoChain? userDtoChainNullableFromJson(
  Object? userDtoChain, [
  enums.UserDtoChain? defaultValue,
]) {
  if (userDtoChain == null) {
    return null;
  }
  return enums.UserDtoChain.values.firstWhereOrNull(
        (e) => e.value == userDtoChain,
      ) ??
      defaultValue;
}

String userDtoChainExplodedListToJson(List<enums.UserDtoChain>? userDtoChain) {
  return userDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userDtoChainListToJson(List<enums.UserDtoChain>? userDtoChain) {
  if (userDtoChain == null) {
    return [];
  }

  return userDtoChain.map((e) => e.value!).toList();
}

List<enums.UserDtoChain> userDtoChainListFromJson(
  List? userDtoChain, [
  List<enums.UserDtoChain>? defaultValue,
]) {
  if (userDtoChain == null) {
    return defaultValue ?? [];
  }

  return userDtoChain.map((e) => userDtoChainFromJson(e.toString())).toList();
}

List<enums.UserDtoChain>? userDtoChainNullableListFromJson(
  List? userDtoChain, [
  List<enums.UserDtoChain>? defaultValue,
]) {
  if (userDtoChain == null) {
    return defaultValue;
  }

  return userDtoChain.map((e) => userDtoChainFromJson(e.toString())).toList();
}

String? creatorDtoChainNullableToJson(enums.CreatorDtoChain? creatorDtoChain) {
  return creatorDtoChain?.value;
}

String? creatorDtoChainToJson(enums.CreatorDtoChain creatorDtoChain) {
  return creatorDtoChain.value;
}

enums.CreatorDtoChain creatorDtoChainFromJson(
  Object? creatorDtoChain, [
  enums.CreatorDtoChain? defaultValue,
]) {
  return enums.CreatorDtoChain.values.firstWhereOrNull(
        (e) => e.value == creatorDtoChain,
      ) ??
      defaultValue ??
      enums.CreatorDtoChain.swaggerGeneratedUnknown;
}

enums.CreatorDtoChain? creatorDtoChainNullableFromJson(
  Object? creatorDtoChain, [
  enums.CreatorDtoChain? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return null;
  }
  return enums.CreatorDtoChain.values.firstWhereOrNull(
        (e) => e.value == creatorDtoChain,
      ) ??
      defaultValue;
}

String creatorDtoChainExplodedListToJson(
  List<enums.CreatorDtoChain>? creatorDtoChain,
) {
  return creatorDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorDtoChainListToJson(
  List<enums.CreatorDtoChain>? creatorDtoChain,
) {
  if (creatorDtoChain == null) {
    return [];
  }

  return creatorDtoChain.map((e) => e.value!).toList();
}

List<enums.CreatorDtoChain> creatorDtoChainListFromJson(
  List? creatorDtoChain, [
  List<enums.CreatorDtoChain>? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return defaultValue ?? [];
  }

  return creatorDtoChain
      .map((e) => creatorDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.CreatorDtoChain>? creatorDtoChainNullableListFromJson(
  List? creatorDtoChain, [
  List<enums.CreatorDtoChain>? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return defaultValue;
  }

  return creatorDtoChain
      .map((e) => creatorDtoChainFromJson(e.toString()))
      .toList();
}

String? nftDtoChainNullableToJson(enums.NftDtoChain? nftDtoChain) {
  return nftDtoChain?.value;
}

String? nftDtoChainToJson(enums.NftDtoChain nftDtoChain) {
  return nftDtoChain.value;
}

enums.NftDtoChain nftDtoChainFromJson(
  Object? nftDtoChain, [
  enums.NftDtoChain? defaultValue,
]) {
  return enums.NftDtoChain.values.firstWhereOrNull(
        (e) => e.value == nftDtoChain,
      ) ??
      defaultValue ??
      enums.NftDtoChain.swaggerGeneratedUnknown;
}

enums.NftDtoChain? nftDtoChainNullableFromJson(
  Object? nftDtoChain, [
  enums.NftDtoChain? defaultValue,
]) {
  if (nftDtoChain == null) {
    return null;
  }
  return enums.NftDtoChain.values.firstWhereOrNull(
        (e) => e.value == nftDtoChain,
      ) ??
      defaultValue;
}

String nftDtoChainExplodedListToJson(List<enums.NftDtoChain>? nftDtoChain) {
  return nftDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftDtoChainListToJson(List<enums.NftDtoChain>? nftDtoChain) {
  if (nftDtoChain == null) {
    return [];
  }

  return nftDtoChain.map((e) => e.value!).toList();
}

List<enums.NftDtoChain> nftDtoChainListFromJson(
  List? nftDtoChain, [
  List<enums.NftDtoChain>? defaultValue,
]) {
  if (nftDtoChain == null) {
    return defaultValue ?? [];
  }

  return nftDtoChain.map((e) => nftDtoChainFromJson(e.toString())).toList();
}

List<enums.NftDtoChain>? nftDtoChainNullableListFromJson(
  List? nftDtoChain, [
  List<enums.NftDtoChain>? defaultValue,
]) {
  if (nftDtoChain == null) {
    return defaultValue;
  }

  return nftDtoChain.map((e) => nftDtoChainFromJson(e.toString())).toList();
}

String? notificationDocDataTypeNullableToJson(
  enums.NotificationDocDataType? notificationDocDataType,
) {
  return notificationDocDataType?.value;
}

String? notificationDocDataTypeToJson(
  enums.NotificationDocDataType notificationDocDataType,
) {
  return notificationDocDataType.value;
}

enums.NotificationDocDataType notificationDocDataTypeFromJson(
  Object? notificationDocDataType, [
  enums.NotificationDocDataType? defaultValue,
]) {
  return enums.NotificationDocDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDocDataType,
      ) ??
      defaultValue ??
      enums.NotificationDocDataType.swaggerGeneratedUnknown;
}

enums.NotificationDocDataType? notificationDocDataTypeNullableFromJson(
  Object? notificationDocDataType, [
  enums.NotificationDocDataType? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return null;
  }
  return enums.NotificationDocDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDocDataType,
      ) ??
      defaultValue;
}

String notificationDocDataTypeExplodedListToJson(
  List<enums.NotificationDocDataType>? notificationDocDataType,
) {
  return notificationDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDocDataTypeListToJson(
  List<enums.NotificationDocDataType>? notificationDocDataType,
) {
  if (notificationDocDataType == null) {
    return [];
  }

  return notificationDocDataType.map((e) => e.value!).toList();
}

List<enums.NotificationDocDataType> notificationDocDataTypeListFromJson(
  List? notificationDocDataType, [
  List<enums.NotificationDocDataType>? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return defaultValue ?? [];
  }

  return notificationDocDataType
      .map((e) => notificationDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDocDataType>?
notificationDocDataTypeNullableListFromJson(
  List? notificationDocDataType, [
  List<enums.NotificationDocDataType>? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return defaultValue;
  }

  return notificationDocDataType
      .map((e) => notificationDocDataTypeFromJson(e.toString()))
      .toList();
}

String? notificationDocActivityTypeNullableToJson(
  enums.NotificationDocActivityType? notificationDocActivityType,
) {
  return notificationDocActivityType?.value;
}

String? notificationDocActivityTypeToJson(
  enums.NotificationDocActivityType notificationDocActivityType,
) {
  return notificationDocActivityType.value;
}

enums.NotificationDocActivityType notificationDocActivityTypeFromJson(
  Object? notificationDocActivityType, [
  enums.NotificationDocActivityType? defaultValue,
]) {
  return enums.NotificationDocActivityType.values.firstWhereOrNull(
        (e) => e.value == notificationDocActivityType,
      ) ??
      defaultValue ??
      enums.NotificationDocActivityType.swaggerGeneratedUnknown;
}

enums.NotificationDocActivityType? notificationDocActivityTypeNullableFromJson(
  Object? notificationDocActivityType, [
  enums.NotificationDocActivityType? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return null;
  }
  return enums.NotificationDocActivityType.values.firstWhereOrNull(
        (e) => e.value == notificationDocActivityType,
      ) ??
      defaultValue;
}

String notificationDocActivityTypeExplodedListToJson(
  List<enums.NotificationDocActivityType>? notificationDocActivityType,
) {
  return notificationDocActivityType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDocActivityTypeListToJson(
  List<enums.NotificationDocActivityType>? notificationDocActivityType,
) {
  if (notificationDocActivityType == null) {
    return [];
  }

  return notificationDocActivityType.map((e) => e.value!).toList();
}

List<enums.NotificationDocActivityType> notificationDocActivityTypeListFromJson(
  List? notificationDocActivityType, [
  List<enums.NotificationDocActivityType>? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return defaultValue ?? [];
  }

  return notificationDocActivityType
      .map((e) => notificationDocActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDocActivityType>?
notificationDocActivityTypeNullableListFromJson(
  List? notificationDocActivityType, [
  List<enums.NotificationDocActivityType>? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return defaultValue;
  }

  return notificationDocActivityType
      .map((e) => notificationDocActivityTypeFromJson(e.toString()))
      .toList();
}

String? devicePlatformNullableToJson(enums.DevicePlatform? devicePlatform) {
  return devicePlatform?.value;
}

String? devicePlatformToJson(enums.DevicePlatform devicePlatform) {
  return devicePlatform.value;
}

enums.DevicePlatform devicePlatformFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  return enums.DevicePlatform.values.firstWhereOrNull(
        (e) => e.value == devicePlatform,
      ) ??
      defaultValue ??
      enums.DevicePlatform.swaggerGeneratedUnknown;
}

enums.DevicePlatform? devicePlatformNullableFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  if (devicePlatform == null) {
    return null;
  }
  return enums.DevicePlatform.values.firstWhereOrNull(
        (e) => e.value == devicePlatform,
      ) ??
      defaultValue;
}

String devicePlatformExplodedListToJson(
  List<enums.DevicePlatform>? devicePlatform,
) {
  return devicePlatform?.map((e) => e.value!).join(',') ?? '';
}

List<String> devicePlatformListToJson(
  List<enums.DevicePlatform>? devicePlatform,
) {
  if (devicePlatform == null) {
    return [];
  }

  return devicePlatform.map((e) => e.value!).toList();
}

List<enums.DevicePlatform> devicePlatformListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue ?? [];
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

List<enums.DevicePlatform>? devicePlatformNullableListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue;
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

String? notificationDataTypeNullableToJson(
  enums.NotificationDataType? notificationDataType,
) {
  return notificationDataType?.value;
}

String? notificationDataTypeToJson(
  enums.NotificationDataType notificationDataType,
) {
  return notificationDataType.value;
}

enums.NotificationDataType notificationDataTypeFromJson(
  Object? notificationDataType, [
  enums.NotificationDataType? defaultValue,
]) {
  return enums.NotificationDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDataType,
      ) ??
      defaultValue ??
      enums.NotificationDataType.swaggerGeneratedUnknown;
}

enums.NotificationDataType? notificationDataTypeNullableFromJson(
  Object? notificationDataType, [
  enums.NotificationDataType? defaultValue,
]) {
  if (notificationDataType == null) {
    return null;
  }
  return enums.NotificationDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDataType,
      ) ??
      defaultValue;
}

String notificationDataTypeExplodedListToJson(
  List<enums.NotificationDataType>? notificationDataType,
) {
  return notificationDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDataTypeListToJson(
  List<enums.NotificationDataType>? notificationDataType,
) {
  if (notificationDataType == null) {
    return [];
  }

  return notificationDataType.map((e) => e.value!).toList();
}

List<enums.NotificationDataType> notificationDataTypeListFromJson(
  List? notificationDataType, [
  List<enums.NotificationDataType>? defaultValue,
]) {
  if (notificationDataType == null) {
    return defaultValue ?? [];
  }

  return notificationDataType
      .map((e) => notificationDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDataType>? notificationDataTypeNullableListFromJson(
  List? notificationDataType, [
  List<enums.NotificationDataType>? defaultValue,
]) {
  if (notificationDataType == null) {
    return defaultValue;
  }

  return notificationDataType
      .map((e) => notificationDataTypeFromJson(e.toString()))
      .toList();
}

String? pushNotificationTypeNullableToJson(
  enums.PushNotificationType? pushNotificationType,
) {
  return pushNotificationType?.value;
}

String? pushNotificationTypeToJson(
  enums.PushNotificationType pushNotificationType,
) {
  return pushNotificationType.value;
}

enums.PushNotificationType pushNotificationTypeFromJson(
  Object? pushNotificationType, [
  enums.PushNotificationType? defaultValue,
]) {
  return enums.PushNotificationType.values.firstWhereOrNull(
        (e) => e.value == pushNotificationType,
      ) ??
      defaultValue ??
      enums.PushNotificationType.swaggerGeneratedUnknown;
}

enums.PushNotificationType? pushNotificationTypeNullableFromJson(
  Object? pushNotificationType, [
  enums.PushNotificationType? defaultValue,
]) {
  if (pushNotificationType == null) {
    return null;
  }
  return enums.PushNotificationType.values.firstWhereOrNull(
        (e) => e.value == pushNotificationType,
      ) ??
      defaultValue;
}

String pushNotificationTypeExplodedListToJson(
  List<enums.PushNotificationType>? pushNotificationType,
) {
  return pushNotificationType?.map((e) => e.value!).join(',') ?? '';
}

List<String> pushNotificationTypeListToJson(
  List<enums.PushNotificationType>? pushNotificationType,
) {
  if (pushNotificationType == null) {
    return [];
  }

  return pushNotificationType.map((e) => e.value!).toList();
}

List<enums.PushNotificationType> pushNotificationTypeListFromJson(
  List? pushNotificationType, [
  List<enums.PushNotificationType>? defaultValue,
]) {
  if (pushNotificationType == null) {
    return defaultValue ?? [];
  }

  return pushNotificationType
      .map((e) => pushNotificationTypeFromJson(e.toString()))
      .toList();
}

List<enums.PushNotificationType>? pushNotificationTypeNullableListFromJson(
  List? pushNotificationType, [
  List<enums.PushNotificationType>? defaultValue,
]) {
  if (pushNotificationType == null) {
    return defaultValue;
  }

  return pushNotificationType
      .map((e) => pushNotificationTypeFromJson(e.toString()))
      .toList();
}

String? pushNotificationStatusNullableToJson(
  enums.PushNotificationStatus? pushNotificationStatus,
) {
  return pushNotificationStatus?.value;
}

String? pushNotificationStatusToJson(
  enums.PushNotificationStatus pushNotificationStatus,
) {
  return pushNotificationStatus.value;
}

enums.PushNotificationStatus pushNotificationStatusFromJson(
  Object? pushNotificationStatus, [
  enums.PushNotificationStatus? defaultValue,
]) {
  return enums.PushNotificationStatus.values.firstWhereOrNull(
        (e) => e.value == pushNotificationStatus,
      ) ??
      defaultValue ??
      enums.PushNotificationStatus.swaggerGeneratedUnknown;
}

enums.PushNotificationStatus? pushNotificationStatusNullableFromJson(
  Object? pushNotificationStatus, [
  enums.PushNotificationStatus? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return null;
  }
  return enums.PushNotificationStatus.values.firstWhereOrNull(
        (e) => e.value == pushNotificationStatus,
      ) ??
      defaultValue;
}

String pushNotificationStatusExplodedListToJson(
  List<enums.PushNotificationStatus>? pushNotificationStatus,
) {
  return pushNotificationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> pushNotificationStatusListToJson(
  List<enums.PushNotificationStatus>? pushNotificationStatus,
) {
  if (pushNotificationStatus == null) {
    return [];
  }

  return pushNotificationStatus.map((e) => e.value!).toList();
}

List<enums.PushNotificationStatus> pushNotificationStatusListFromJson(
  List? pushNotificationStatus, [
  List<enums.PushNotificationStatus>? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return defaultValue ?? [];
  }

  return pushNotificationStatus
      .map((e) => pushNotificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.PushNotificationStatus>? pushNotificationStatusNullableListFromJson(
  List? pushNotificationStatus, [
  List<enums.PushNotificationStatus>? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return defaultValue;
  }

  return pushNotificationStatus
      .map((e) => pushNotificationStatusFromJson(e.toString()))
      .toList();
}

String? nftActivityTypeNullableToJson(enums.NftActivityType? nftActivityType) {
  return nftActivityType?.value;
}

String? nftActivityTypeToJson(enums.NftActivityType nftActivityType) {
  return nftActivityType.value;
}

enums.NftActivityType nftActivityTypeFromJson(
  Object? nftActivityType, [
  enums.NftActivityType? defaultValue,
]) {
  return enums.NftActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityType,
      ) ??
      defaultValue ??
      enums.NftActivityType.swaggerGeneratedUnknown;
}

enums.NftActivityType? nftActivityTypeNullableFromJson(
  Object? nftActivityType, [
  enums.NftActivityType? defaultValue,
]) {
  if (nftActivityType == null) {
    return null;
  }
  return enums.NftActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityType,
      ) ??
      defaultValue;
}

String nftActivityTypeExplodedListToJson(
  List<enums.NftActivityType>? nftActivityType,
) {
  return nftActivityType?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityTypeListToJson(
  List<enums.NftActivityType>? nftActivityType,
) {
  if (nftActivityType == null) {
    return [];
  }

  return nftActivityType.map((e) => e.value!).toList();
}

List<enums.NftActivityType> nftActivityTypeListFromJson(
  List? nftActivityType, [
  List<enums.NftActivityType>? defaultValue,
]) {
  if (nftActivityType == null) {
    return defaultValue ?? [];
  }

  return nftActivityType
      .map((e) => nftActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityType>? nftActivityTypeNullableListFromJson(
  List? nftActivityType, [
  List<enums.NftActivityType>? defaultValue,
]) {
  if (nftActivityType == null) {
    return defaultValue;
  }

  return nftActivityType
      .map((e) => nftActivityTypeFromJson(e.toString()))
      .toList();
}

String? nftActivityEventSourceNullableToJson(
  enums.NftActivityEventSource? nftActivityEventSource,
) {
  return nftActivityEventSource?.value;
}

String? nftActivityEventSourceToJson(
  enums.NftActivityEventSource nftActivityEventSource,
) {
  return nftActivityEventSource.value;
}

enums.NftActivityEventSource nftActivityEventSourceFromJson(
  Object? nftActivityEventSource, [
  enums.NftActivityEventSource? defaultValue,
]) {
  return enums.NftActivityEventSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityEventSource,
      ) ??
      defaultValue ??
      enums.NftActivityEventSource.swaggerGeneratedUnknown;
}

enums.NftActivityEventSource? nftActivityEventSourceNullableFromJson(
  Object? nftActivityEventSource, [
  enums.NftActivityEventSource? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return null;
  }
  return enums.NftActivityEventSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityEventSource,
      ) ??
      defaultValue;
}

String nftActivityEventSourceExplodedListToJson(
  List<enums.NftActivityEventSource>? nftActivityEventSource,
) {
  return nftActivityEventSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityEventSourceListToJson(
  List<enums.NftActivityEventSource>? nftActivityEventSource,
) {
  if (nftActivityEventSource == null) {
    return [];
  }

  return nftActivityEventSource.map((e) => e.value!).toList();
}

List<enums.NftActivityEventSource> nftActivityEventSourceListFromJson(
  List? nftActivityEventSource, [
  List<enums.NftActivityEventSource>? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return defaultValue ?? [];
  }

  return nftActivityEventSource
      .map((e) => nftActivityEventSourceFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityEventSource>? nftActivityEventSourceNullableListFromJson(
  List? nftActivityEventSource, [
  List<enums.NftActivityEventSource>? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return defaultValue;
  }

  return nftActivityEventSource
      .map((e) => nftActivityEventSourceFromJson(e.toString()))
      .toList();
}

String? nftActivityDataHydratedAuctionTypeNullableToJson(
  enums.NftActivityDataHydratedAuctionType? nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType?.value;
}

String? nftActivityDataHydratedAuctionTypeToJson(
  enums.NftActivityDataHydratedAuctionType nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType.value;
}

enums.NftActivityDataHydratedAuctionType
nftActivityDataHydratedAuctionTypeFromJson(
  Object? nftActivityDataHydratedAuctionType, [
  enums.NftActivityDataHydratedAuctionType? defaultValue,
]) {
  return enums.NftActivityDataHydratedAuctionType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDataHydratedAuctionType,
      ) ??
      defaultValue ??
      enums.NftActivityDataHydratedAuctionType.swaggerGeneratedUnknown;
}

enums.NftActivityDataHydratedAuctionType?
nftActivityDataHydratedAuctionTypeNullableFromJson(
  Object? nftActivityDataHydratedAuctionType, [
  enums.NftActivityDataHydratedAuctionType? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return null;
  }
  return enums.NftActivityDataHydratedAuctionType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDataHydratedAuctionType,
      ) ??
      defaultValue;
}

String nftActivityDataHydratedAuctionTypeExplodedListToJson(
  List<enums.NftActivityDataHydratedAuctionType>?
  nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> nftActivityDataHydratedAuctionTypeListToJson(
  List<enums.NftActivityDataHydratedAuctionType>?
  nftActivityDataHydratedAuctionType,
) {
  if (nftActivityDataHydratedAuctionType == null) {
    return [];
  }

  return nftActivityDataHydratedAuctionType.map((e) => e.value!).toList();
}

List<enums.NftActivityDataHydratedAuctionType>
nftActivityDataHydratedAuctionTypeListFromJson(
  List? nftActivityDataHydratedAuctionType, [
  List<enums.NftActivityDataHydratedAuctionType>? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return defaultValue ?? [];
  }

  return nftActivityDataHydratedAuctionType
      .map((e) => nftActivityDataHydratedAuctionTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDataHydratedAuctionType>?
nftActivityDataHydratedAuctionTypeNullableListFromJson(
  List? nftActivityDataHydratedAuctionType, [
  List<enums.NftActivityDataHydratedAuctionType>? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return defaultValue;
  }

  return nftActivityDataHydratedAuctionType
      .map((e) => nftActivityDataHydratedAuctionTypeFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedChainNullableToJson(
  enums.NftActivityDocHydratedChain? nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain?.value;
}

String? nftActivityDocHydratedChainToJson(
  enums.NftActivityDocHydratedChain nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain.value;
}

enums.NftActivityDocHydratedChain nftActivityDocHydratedChainFromJson(
  Object? nftActivityDocHydratedChain, [
  enums.NftActivityDocHydratedChain? defaultValue,
]) {
  return enums.NftActivityDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedChain,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedChain.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedChain? nftActivityDocHydratedChainNullableFromJson(
  Object? nftActivityDocHydratedChain, [
  enums.NftActivityDocHydratedChain? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return null;
  }
  return enums.NftActivityDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedChain,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedChainExplodedListToJson(
  List<enums.NftActivityDocHydratedChain>? nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityDocHydratedChainListToJson(
  List<enums.NftActivityDocHydratedChain>? nftActivityDocHydratedChain,
) {
  if (nftActivityDocHydratedChain == null) {
    return [];
  }

  return nftActivityDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedChain> nftActivityDocHydratedChainListFromJson(
  List? nftActivityDocHydratedChain, [
  List<enums.NftActivityDocHydratedChain>? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedChain
      .map((e) => nftActivityDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedChain>?
nftActivityDocHydratedChainNullableListFromJson(
  List? nftActivityDocHydratedChain, [
  List<enums.NftActivityDocHydratedChain>? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedChain
      .map((e) => nftActivityDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedSourceNullableToJson(
  enums.NftActivityDocHydratedSource? nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource?.value;
}

String? nftActivityDocHydratedSourceToJson(
  enums.NftActivityDocHydratedSource nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource.value;
}

enums.NftActivityDocHydratedSource nftActivityDocHydratedSourceFromJson(
  Object? nftActivityDocHydratedSource, [
  enums.NftActivityDocHydratedSource? defaultValue,
]) {
  return enums.NftActivityDocHydratedSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedSource,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedSource.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedSource?
nftActivityDocHydratedSourceNullableFromJson(
  Object? nftActivityDocHydratedSource, [
  enums.NftActivityDocHydratedSource? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return null;
  }
  return enums.NftActivityDocHydratedSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedSource,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedSourceExplodedListToJson(
  List<enums.NftActivityDocHydratedSource>? nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityDocHydratedSourceListToJson(
  List<enums.NftActivityDocHydratedSource>? nftActivityDocHydratedSource,
) {
  if (nftActivityDocHydratedSource == null) {
    return [];
  }

  return nftActivityDocHydratedSource.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedSource>
nftActivityDocHydratedSourceListFromJson(
  List? nftActivityDocHydratedSource, [
  List<enums.NftActivityDocHydratedSource>? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedSource
      .map((e) => nftActivityDocHydratedSourceFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedSource>?
nftActivityDocHydratedSourceNullableListFromJson(
  List? nftActivityDocHydratedSource, [
  List<enums.NftActivityDocHydratedSource>? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedSource
      .map((e) => nftActivityDocHydratedSourceFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedActivityTypeNullableToJson(
  enums.NftActivityDocHydratedActivityType? nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType?.value;
}

String? nftActivityDocHydratedActivityTypeToJson(
  enums.NftActivityDocHydratedActivityType nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType.value;
}

enums.NftActivityDocHydratedActivityType
nftActivityDocHydratedActivityTypeFromJson(
  Object? nftActivityDocHydratedActivityType, [
  enums.NftActivityDocHydratedActivityType? defaultValue,
]) {
  return enums.NftActivityDocHydratedActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedActivityType,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedActivityType.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedActivityType?
nftActivityDocHydratedActivityTypeNullableFromJson(
  Object? nftActivityDocHydratedActivityType, [
  enums.NftActivityDocHydratedActivityType? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return null;
  }
  return enums.NftActivityDocHydratedActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedActivityType,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedActivityTypeExplodedListToJson(
  List<enums.NftActivityDocHydratedActivityType>?
  nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> nftActivityDocHydratedActivityTypeListToJson(
  List<enums.NftActivityDocHydratedActivityType>?
  nftActivityDocHydratedActivityType,
) {
  if (nftActivityDocHydratedActivityType == null) {
    return [];
  }

  return nftActivityDocHydratedActivityType.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedActivityType>
nftActivityDocHydratedActivityTypeListFromJson(
  List? nftActivityDocHydratedActivityType, [
  List<enums.NftActivityDocHydratedActivityType>? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedActivityType
      .map((e) => nftActivityDocHydratedActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedActivityType>?
nftActivityDocHydratedActivityTypeNullableListFromJson(
  List? nftActivityDocHydratedActivityType, [
  List<enums.NftActivityDocHydratedActivityType>? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedActivityType
      .map((e) => nftActivityDocHydratedActivityTypeFromJson(e.toString()))
      .toList();
}

String? userStatsOrderByColumnNullableToJson(
  enums.UserStatsOrderByColumn? userStatsOrderByColumn,
) {
  return userStatsOrderByColumn?.value;
}

String? userStatsOrderByColumnToJson(
  enums.UserStatsOrderByColumn userStatsOrderByColumn,
) {
  return userStatsOrderByColumn.value;
}

enums.UserStatsOrderByColumn userStatsOrderByColumnFromJson(
  Object? userStatsOrderByColumn, [
  enums.UserStatsOrderByColumn? defaultValue,
]) {
  return enums.UserStatsOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == userStatsOrderByColumn,
      ) ??
      defaultValue ??
      enums.UserStatsOrderByColumn.swaggerGeneratedUnknown;
}

enums.UserStatsOrderByColumn? userStatsOrderByColumnNullableFromJson(
  Object? userStatsOrderByColumn, [
  enums.UserStatsOrderByColumn? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return null;
  }
  return enums.UserStatsOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == userStatsOrderByColumn,
      ) ??
      defaultValue;
}

String userStatsOrderByColumnExplodedListToJson(
  List<enums.UserStatsOrderByColumn>? userStatsOrderByColumn,
) {
  return userStatsOrderByColumn?.map((e) => e.value!).join(',') ?? '';
}

List<String> userStatsOrderByColumnListToJson(
  List<enums.UserStatsOrderByColumn>? userStatsOrderByColumn,
) {
  if (userStatsOrderByColumn == null) {
    return [];
  }

  return userStatsOrderByColumn.map((e) => e.value!).toList();
}

List<enums.UserStatsOrderByColumn> userStatsOrderByColumnListFromJson(
  List? userStatsOrderByColumn, [
  List<enums.UserStatsOrderByColumn>? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return defaultValue ?? [];
  }

  return userStatsOrderByColumn
      .map((e) => userStatsOrderByColumnFromJson(e.toString()))
      .toList();
}

List<enums.UserStatsOrderByColumn>? userStatsOrderByColumnNullableListFromJson(
  List? userStatsOrderByColumn, [
  List<enums.UserStatsOrderByColumn>? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return defaultValue;
  }

  return userStatsOrderByColumn
      .map((e) => userStatsOrderByColumnFromJson(e.toString()))
      .toList();
}

String? loginRequestDtoServiceNullableToJson(
  enums.LoginRequestDtoService? loginRequestDtoService,
) {
  return loginRequestDtoService?.value;
}

String? loginRequestDtoServiceToJson(
  enums.LoginRequestDtoService loginRequestDtoService,
) {
  return loginRequestDtoService.value;
}

enums.LoginRequestDtoService loginRequestDtoServiceFromJson(
  Object? loginRequestDtoService, [
  enums.LoginRequestDtoService? defaultValue,
]) {
  return enums.LoginRequestDtoService.values.firstWhereOrNull(
        (e) => e.value == loginRequestDtoService,
      ) ??
      defaultValue ??
      enums.LoginRequestDtoService.swaggerGeneratedUnknown;
}

enums.LoginRequestDtoService? loginRequestDtoServiceNullableFromJson(
  Object? loginRequestDtoService, [
  enums.LoginRequestDtoService? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return null;
  }
  return enums.LoginRequestDtoService.values.firstWhereOrNull(
        (e) => e.value == loginRequestDtoService,
      ) ??
      defaultValue;
}

String loginRequestDtoServiceExplodedListToJson(
  List<enums.LoginRequestDtoService>? loginRequestDtoService,
) {
  return loginRequestDtoService?.map((e) => e.value!).join(',') ?? '';
}

List<String> loginRequestDtoServiceListToJson(
  List<enums.LoginRequestDtoService>? loginRequestDtoService,
) {
  if (loginRequestDtoService == null) {
    return [];
  }

  return loginRequestDtoService.map((e) => e.value!).toList();
}

List<enums.LoginRequestDtoService> loginRequestDtoServiceListFromJson(
  List? loginRequestDtoService, [
  List<enums.LoginRequestDtoService>? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return defaultValue ?? [];
  }

  return loginRequestDtoService
      .map((e) => loginRequestDtoServiceFromJson(e.toString()))
      .toList();
}

List<enums.LoginRequestDtoService>? loginRequestDtoServiceNullableListFromJson(
  List? loginRequestDtoService, [
  List<enums.LoginRequestDtoService>? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return defaultValue;
  }

  return loginRequestDtoService
      .map((e) => loginRequestDtoServiceFromJson(e.toString()))
      .toList();
}

String? transactionTypeNullableToJson(enums.TransactionType? transactionType) {
  return transactionType?.value;
}

String? transactionTypeToJson(enums.TransactionType transactionType) {
  return transactionType.value;
}

enums.TransactionType transactionTypeFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  return enums.TransactionType.values.firstWhereOrNull(
        (e) => e.value == transactionType,
      ) ??
      defaultValue ??
      enums.TransactionType.swaggerGeneratedUnknown;
}

enums.TransactionType? transactionTypeNullableFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  if (transactionType == null) {
    return null;
  }
  return enums.TransactionType.values.firstWhereOrNull(
        (e) => e.value == transactionType,
      ) ??
      defaultValue;
}

String transactionTypeExplodedListToJson(
  List<enums.TransactionType>? transactionType,
) {
  return transactionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> transactionTypeListToJson(
  List<enums.TransactionType>? transactionType,
) {
  if (transactionType == null) {
    return [];
  }

  return transactionType.map((e) => e.value!).toList();
}

List<enums.TransactionType> transactionTypeListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue ?? [];
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionType>? transactionTypeNullableListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue;
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

String? transactionStatusNullableToJson(
  enums.TransactionStatus? transactionStatus,
) {
  return transactionStatus?.value;
}

String? transactionStatusToJson(enums.TransactionStatus transactionStatus) {
  return transactionStatus.value;
}

enums.TransactionStatus transactionStatusFromJson(
  Object? transactionStatus, [
  enums.TransactionStatus? defaultValue,
]) {
  return enums.TransactionStatus.values.firstWhereOrNull(
        (e) => e.value == transactionStatus,
      ) ??
      defaultValue ??
      enums.TransactionStatus.swaggerGeneratedUnknown;
}

enums.TransactionStatus? transactionStatusNullableFromJson(
  Object? transactionStatus, [
  enums.TransactionStatus? defaultValue,
]) {
  if (transactionStatus == null) {
    return null;
  }
  return enums.TransactionStatus.values.firstWhereOrNull(
        (e) => e.value == transactionStatus,
      ) ??
      defaultValue;
}

String transactionStatusExplodedListToJson(
  List<enums.TransactionStatus>? transactionStatus,
) {
  return transactionStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> transactionStatusListToJson(
  List<enums.TransactionStatus>? transactionStatus,
) {
  if (transactionStatus == null) {
    return [];
  }

  return transactionStatus.map((e) => e.value!).toList();
}

List<enums.TransactionStatus> transactionStatusListFromJson(
  List? transactionStatus, [
  List<enums.TransactionStatus>? defaultValue,
]) {
  if (transactionStatus == null) {
    return defaultValue ?? [];
  }

  return transactionStatus
      .map((e) => transactionStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransactionStatus>? transactionStatusNullableListFromJson(
  List? transactionStatus, [
  List<enums.TransactionStatus>? defaultValue,
]) {
  if (transactionStatus == null) {
    return defaultValue;
  }

  return transactionStatus
      .map((e) => transactionStatusFromJson(e.toString()))
      .toList();
}

String? userConversationDocHydratedDataTypeNullableToJson(
  enums.UserConversationDocHydratedDataType?
  userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType?.value;
}

String? userConversationDocHydratedDataTypeToJson(
  enums.UserConversationDocHydratedDataType userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType.value;
}

enums.UserConversationDocHydratedDataType
userConversationDocHydratedDataTypeFromJson(
  Object? userConversationDocHydratedDataType, [
  enums.UserConversationDocHydratedDataType? defaultValue,
]) {
  return enums.UserConversationDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userConversationDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.UserConversationDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.UserConversationDocHydratedDataType?
userConversationDocHydratedDataTypeNullableFromJson(
  Object? userConversationDocHydratedDataType, [
  enums.UserConversationDocHydratedDataType? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return null;
  }
  return enums.UserConversationDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userConversationDocHydratedDataType,
      ) ??
      defaultValue;
}

String userConversationDocHydratedDataTypeExplodedListToJson(
  List<enums.UserConversationDocHydratedDataType>?
  userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> userConversationDocHydratedDataTypeListToJson(
  List<enums.UserConversationDocHydratedDataType>?
  userConversationDocHydratedDataType,
) {
  if (userConversationDocHydratedDataType == null) {
    return [];
  }

  return userConversationDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.UserConversationDocHydratedDataType>
userConversationDocHydratedDataTypeListFromJson(
  List? userConversationDocHydratedDataType, [
  List<enums.UserConversationDocHydratedDataType>? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return userConversationDocHydratedDataType
      .map((e) => userConversationDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserConversationDocHydratedDataType>?
userConversationDocHydratedDataTypeNullableListFromJson(
  List? userConversationDocHydratedDataType, [
  List<enums.UserConversationDocHydratedDataType>? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return defaultValue;
  }

  return userConversationDocHydratedDataType
      .map((e) => userConversationDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? userBlockDocHydratedDataTypeNullableToJson(
  enums.UserBlockDocHydratedDataType? userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType?.value;
}

String? userBlockDocHydratedDataTypeToJson(
  enums.UserBlockDocHydratedDataType userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType.value;
}

enums.UserBlockDocHydratedDataType userBlockDocHydratedDataTypeFromJson(
  Object? userBlockDocHydratedDataType, [
  enums.UserBlockDocHydratedDataType? defaultValue,
]) {
  return enums.UserBlockDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userBlockDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.UserBlockDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.UserBlockDocHydratedDataType?
userBlockDocHydratedDataTypeNullableFromJson(
  Object? userBlockDocHydratedDataType, [
  enums.UserBlockDocHydratedDataType? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return null;
  }
  return enums.UserBlockDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userBlockDocHydratedDataType,
      ) ??
      defaultValue;
}

String userBlockDocHydratedDataTypeExplodedListToJson(
  List<enums.UserBlockDocHydratedDataType>? userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userBlockDocHydratedDataTypeListToJson(
  List<enums.UserBlockDocHydratedDataType>? userBlockDocHydratedDataType,
) {
  if (userBlockDocHydratedDataType == null) {
    return [];
  }

  return userBlockDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.UserBlockDocHydratedDataType>
userBlockDocHydratedDataTypeListFromJson(
  List? userBlockDocHydratedDataType, [
  List<enums.UserBlockDocHydratedDataType>? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return userBlockDocHydratedDataType
      .map((e) => userBlockDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserBlockDocHydratedDataType>?
userBlockDocHydratedDataTypeNullableListFromJson(
  List? userBlockDocHydratedDataType, [
  List<enums.UserBlockDocHydratedDataType>? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return defaultValue;
  }

  return userBlockDocHydratedDataType
      .map((e) => userBlockDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? paymentProviderNullableToJson(enums.PaymentProvider? paymentProvider) {
  return paymentProvider?.value;
}

String? paymentProviderToJson(enums.PaymentProvider paymentProvider) {
  return paymentProvider.value;
}

enums.PaymentProvider paymentProviderFromJson(
  Object? paymentProvider, [
  enums.PaymentProvider? defaultValue,
]) {
  return enums.PaymentProvider.values.firstWhereOrNull(
        (e) => e.value == paymentProvider,
      ) ??
      defaultValue ??
      enums.PaymentProvider.swaggerGeneratedUnknown;
}

enums.PaymentProvider? paymentProviderNullableFromJson(
  Object? paymentProvider, [
  enums.PaymentProvider? defaultValue,
]) {
  if (paymentProvider == null) {
    return null;
  }
  return enums.PaymentProvider.values.firstWhereOrNull(
        (e) => e.value == paymentProvider,
      ) ??
      defaultValue;
}

String paymentProviderExplodedListToJson(
  List<enums.PaymentProvider>? paymentProvider,
) {
  return paymentProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> paymentProviderListToJson(
  List<enums.PaymentProvider>? paymentProvider,
) {
  if (paymentProvider == null) {
    return [];
  }

  return paymentProvider.map((e) => e.value!).toList();
}

List<enums.PaymentProvider> paymentProviderListFromJson(
  List? paymentProvider, [
  List<enums.PaymentProvider>? defaultValue,
]) {
  if (paymentProvider == null) {
    return defaultValue ?? [];
  }

  return paymentProvider
      .map((e) => paymentProviderFromJson(e.toString()))
      .toList();
}

List<enums.PaymentProvider>? paymentProviderNullableListFromJson(
  List? paymentProvider, [
  List<enums.PaymentProvider>? defaultValue,
]) {
  if (paymentProvider == null) {
    return defaultValue;
  }

  return paymentProvider
      .map((e) => paymentProviderFromJson(e.toString()))
      .toList();
}

String? eventInvitationStatusNullableToJson(
  enums.EventInvitationStatus? eventInvitationStatus,
) {
  return eventInvitationStatus?.value;
}

String? eventInvitationStatusToJson(
  enums.EventInvitationStatus eventInvitationStatus,
) {
  return eventInvitationStatus.value;
}

enums.EventInvitationStatus eventInvitationStatusFromJson(
  Object? eventInvitationStatus, [
  enums.EventInvitationStatus? defaultValue,
]) {
  return enums.EventInvitationStatus.values.firstWhereOrNull(
        (e) => e.value == eventInvitationStatus,
      ) ??
      defaultValue ??
      enums.EventInvitationStatus.swaggerGeneratedUnknown;
}

enums.EventInvitationStatus? eventInvitationStatusNullableFromJson(
  Object? eventInvitationStatus, [
  enums.EventInvitationStatus? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return null;
  }
  return enums.EventInvitationStatus.values.firstWhereOrNull(
        (e) => e.value == eventInvitationStatus,
      ) ??
      defaultValue;
}

String eventInvitationStatusExplodedListToJson(
  List<enums.EventInvitationStatus>? eventInvitationStatus,
) {
  return eventInvitationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventInvitationStatusListToJson(
  List<enums.EventInvitationStatus>? eventInvitationStatus,
) {
  if (eventInvitationStatus == null) {
    return [];
  }

  return eventInvitationStatus.map((e) => e.value!).toList();
}

List<enums.EventInvitationStatus> eventInvitationStatusListFromJson(
  List? eventInvitationStatus, [
  List<enums.EventInvitationStatus>? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return defaultValue ?? [];
  }

  return eventInvitationStatus
      .map((e) => eventInvitationStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventInvitationStatus>? eventInvitationStatusNullableListFromJson(
  List? eventInvitationStatus, [
  List<enums.EventInvitationStatus>? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return defaultValue;
  }

  return eventInvitationStatus
      .map((e) => eventInvitationStatusFromJson(e.toString()))
      .toList();
}

String? voucherTypeNullableToJson(enums.VoucherType? voucherType) {
  return voucherType?.value;
}

String? voucherTypeToJson(enums.VoucherType voucherType) {
  return voucherType.value;
}

enums.VoucherType voucherTypeFromJson(
  Object? voucherType, [
  enums.VoucherType? defaultValue,
]) {
  return enums.VoucherType.values.firstWhereOrNull(
        (e) => e.value == voucherType,
      ) ??
      defaultValue ??
      enums.VoucherType.swaggerGeneratedUnknown;
}

enums.VoucherType? voucherTypeNullableFromJson(
  Object? voucherType, [
  enums.VoucherType? defaultValue,
]) {
  if (voucherType == null) {
    return null;
  }
  return enums.VoucherType.values.firstWhereOrNull(
        (e) => e.value == voucherType,
      ) ??
      defaultValue;
}

String voucherTypeExplodedListToJson(List<enums.VoucherType>? voucherType) {
  return voucherType?.map((e) => e.value!).join(',') ?? '';
}

List<String> voucherTypeListToJson(List<enums.VoucherType>? voucherType) {
  if (voucherType == null) {
    return [];
  }

  return voucherType.map((e) => e.value!).toList();
}

List<enums.VoucherType> voucherTypeListFromJson(
  List? voucherType, [
  List<enums.VoucherType>? defaultValue,
]) {
  if (voucherType == null) {
    return defaultValue ?? [];
  }

  return voucherType.map((e) => voucherTypeFromJson(e.toString())).toList();
}

List<enums.VoucherType>? voucherTypeNullableListFromJson(
  List? voucherType, [
  List<enums.VoucherType>? defaultValue,
]) {
  if (voucherType == null) {
    return defaultValue;
  }

  return voucherType.map((e) => voucherTypeFromJson(e.toString())).toList();
}

String? eventQuestionAnswerTypeNullableToJson(
  enums.EventQuestionAnswerType? eventQuestionAnswerType,
) {
  return eventQuestionAnswerType?.value;
}

String? eventQuestionAnswerTypeToJson(
  enums.EventQuestionAnswerType eventQuestionAnswerType,
) {
  return eventQuestionAnswerType.value;
}

enums.EventQuestionAnswerType eventQuestionAnswerTypeFromJson(
  Object? eventQuestionAnswerType, [
  enums.EventQuestionAnswerType? defaultValue,
]) {
  return enums.EventQuestionAnswerType.values.firstWhereOrNull(
        (e) => e.value == eventQuestionAnswerType,
      ) ??
      defaultValue ??
      enums.EventQuestionAnswerType.swaggerGeneratedUnknown;
}

enums.EventQuestionAnswerType? eventQuestionAnswerTypeNullableFromJson(
  Object? eventQuestionAnswerType, [
  enums.EventQuestionAnswerType? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return null;
  }
  return enums.EventQuestionAnswerType.values.firstWhereOrNull(
        (e) => e.value == eventQuestionAnswerType,
      ) ??
      defaultValue;
}

String eventQuestionAnswerTypeExplodedListToJson(
  List<enums.EventQuestionAnswerType>? eventQuestionAnswerType,
) {
  return eventQuestionAnswerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventQuestionAnswerTypeListToJson(
  List<enums.EventQuestionAnswerType>? eventQuestionAnswerType,
) {
  if (eventQuestionAnswerType == null) {
    return [];
  }

  return eventQuestionAnswerType.map((e) => e.value!).toList();
}

List<enums.EventQuestionAnswerType> eventQuestionAnswerTypeListFromJson(
  List? eventQuestionAnswerType, [
  List<enums.EventQuestionAnswerType>? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return defaultValue ?? [];
  }

  return eventQuestionAnswerType
      .map((e) => eventQuestionAnswerTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventQuestionAnswerType>?
eventQuestionAnswerTypeNullableListFromJson(
  List? eventQuestionAnswerType, [
  List<enums.EventQuestionAnswerType>? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return defaultValue;
  }

  return eventQuestionAnswerType
      .map((e) => eventQuestionAnswerTypeFromJson(e.toString()))
      .toList();
}

String? eventTicketQrTypeNullableToJson(
  enums.EventTicketQrType? eventTicketQrType,
) {
  return eventTicketQrType?.value;
}

String? eventTicketQrTypeToJson(enums.EventTicketQrType eventTicketQrType) {
  return eventTicketQrType.value;
}

enums.EventTicketQrType eventTicketQrTypeFromJson(
  Object? eventTicketQrType, [
  enums.EventTicketQrType? defaultValue,
]) {
  return enums.EventTicketQrType.values.firstWhereOrNull(
        (e) => e.value == eventTicketQrType,
      ) ??
      defaultValue ??
      enums.EventTicketQrType.swaggerGeneratedUnknown;
}

enums.EventTicketQrType? eventTicketQrTypeNullableFromJson(
  Object? eventTicketQrType, [
  enums.EventTicketQrType? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return null;
  }
  return enums.EventTicketQrType.values.firstWhereOrNull(
        (e) => e.value == eventTicketQrType,
      ) ??
      defaultValue;
}

String eventTicketQrTypeExplodedListToJson(
  List<enums.EventTicketQrType>? eventTicketQrType,
) {
  return eventTicketQrType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventTicketQrTypeListToJson(
  List<enums.EventTicketQrType>? eventTicketQrType,
) {
  if (eventTicketQrType == null) {
    return [];
  }

  return eventTicketQrType.map((e) => e.value!).toList();
}

List<enums.EventTicketQrType> eventTicketQrTypeListFromJson(
  List? eventTicketQrType, [
  List<enums.EventTicketQrType>? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return defaultValue ?? [];
  }

  return eventTicketQrType
      .map((e) => eventTicketQrTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventTicketQrType>? eventTicketQrTypeNullableListFromJson(
  List? eventTicketQrType, [
  List<enums.EventTicketQrType>? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return defaultValue;
  }

  return eventTicketQrType
      .map((e) => eventTicketQrTypeFromJson(e.toString()))
      .toList();
}

String? eventScanStatusNullableToJson(enums.EventScanStatus? eventScanStatus) {
  return eventScanStatus?.value;
}

String? eventScanStatusToJson(enums.EventScanStatus eventScanStatus) {
  return eventScanStatus.value;
}

enums.EventScanStatus eventScanStatusFromJson(
  Object? eventScanStatus, [
  enums.EventScanStatus? defaultValue,
]) {
  return enums.EventScanStatus.values.firstWhereOrNull(
        (e) => e.value == eventScanStatus,
      ) ??
      defaultValue ??
      enums.EventScanStatus.swaggerGeneratedUnknown;
}

enums.EventScanStatus? eventScanStatusNullableFromJson(
  Object? eventScanStatus, [
  enums.EventScanStatus? defaultValue,
]) {
  if (eventScanStatus == null) {
    return null;
  }
  return enums.EventScanStatus.values.firstWhereOrNull(
        (e) => e.value == eventScanStatus,
      ) ??
      defaultValue;
}

String eventScanStatusExplodedListToJson(
  List<enums.EventScanStatus>? eventScanStatus,
) {
  return eventScanStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventScanStatusListToJson(
  List<enums.EventScanStatus>? eventScanStatus,
) {
  if (eventScanStatus == null) {
    return [];
  }

  return eventScanStatus.map((e) => e.value!).toList();
}

List<enums.EventScanStatus> eventScanStatusListFromJson(
  List? eventScanStatus, [
  List<enums.EventScanStatus>? defaultValue,
]) {
  if (eventScanStatus == null) {
    return defaultValue ?? [];
  }

  return eventScanStatus
      .map((e) => eventScanStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventScanStatus>? eventScanStatusNullableListFromJson(
  List? eventScanStatus, [
  List<enums.EventScanStatus>? defaultValue,
]) {
  if (eventScanStatus == null) {
    return defaultValue;
  }

  return eventScanStatus
      .map((e) => eventScanStatusFromJson(e.toString()))
      .toList();
}

String? eventScanMessageNullableToJson(
  enums.EventScanMessage? eventScanMessage,
) {
  return eventScanMessage?.value;
}

String? eventScanMessageToJson(enums.EventScanMessage eventScanMessage) {
  return eventScanMessage.value;
}

enums.EventScanMessage eventScanMessageFromJson(
  Object? eventScanMessage, [
  enums.EventScanMessage? defaultValue,
]) {
  return enums.EventScanMessage.values.firstWhereOrNull(
        (e) => e.value == eventScanMessage,
      ) ??
      defaultValue ??
      enums.EventScanMessage.swaggerGeneratedUnknown;
}

enums.EventScanMessage? eventScanMessageNullableFromJson(
  Object? eventScanMessage, [
  enums.EventScanMessage? defaultValue,
]) {
  if (eventScanMessage == null) {
    return null;
  }
  return enums.EventScanMessage.values.firstWhereOrNull(
        (e) => e.value == eventScanMessage,
      ) ??
      defaultValue;
}

String eventScanMessageExplodedListToJson(
  List<enums.EventScanMessage>? eventScanMessage,
) {
  return eventScanMessage?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventScanMessageListToJson(
  List<enums.EventScanMessage>? eventScanMessage,
) {
  if (eventScanMessage == null) {
    return [];
  }

  return eventScanMessage.map((e) => e.value!).toList();
}

List<enums.EventScanMessage> eventScanMessageListFromJson(
  List? eventScanMessage, [
  List<enums.EventScanMessage>? defaultValue,
]) {
  if (eventScanMessage == null) {
    return defaultValue ?? [];
  }

  return eventScanMessage
      .map((e) => eventScanMessageFromJson(e.toString()))
      .toList();
}

List<enums.EventScanMessage>? eventScanMessageNullableListFromJson(
  List? eventScanMessage, [
  List<enums.EventScanMessage>? defaultValue,
]) {
  if (eventScanMessage == null) {
    return defaultValue;
  }

  return eventScanMessage
      .map((e) => eventScanMessageFromJson(e.toString()))
      .toList();
}

String? eventReferralEnumNullableToJson(
  enums.EventReferralEnum? eventReferralEnum,
) {
  return eventReferralEnum?.value;
}

String? eventReferralEnumToJson(enums.EventReferralEnum eventReferralEnum) {
  return eventReferralEnum.value;
}

enums.EventReferralEnum eventReferralEnumFromJson(
  Object? eventReferralEnum, [
  enums.EventReferralEnum? defaultValue,
]) {
  return enums.EventReferralEnum.values.firstWhereOrNull(
        (e) => e.value == eventReferralEnum,
      ) ??
      defaultValue ??
      enums.EventReferralEnum.swaggerGeneratedUnknown;
}

enums.EventReferralEnum? eventReferralEnumNullableFromJson(
  Object? eventReferralEnum, [
  enums.EventReferralEnum? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return null;
  }
  return enums.EventReferralEnum.values.firstWhereOrNull(
        (e) => e.value == eventReferralEnum,
      ) ??
      defaultValue;
}

String eventReferralEnumExplodedListToJson(
  List<enums.EventReferralEnum>? eventReferralEnum,
) {
  return eventReferralEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventReferralEnumListToJson(
  List<enums.EventReferralEnum>? eventReferralEnum,
) {
  if (eventReferralEnum == null) {
    return [];
  }

  return eventReferralEnum.map((e) => e.value!).toList();
}

List<enums.EventReferralEnum> eventReferralEnumListFromJson(
  List? eventReferralEnum, [
  List<enums.EventReferralEnum>? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return defaultValue ?? [];
  }

  return eventReferralEnum
      .map((e) => eventReferralEnumFromJson(e.toString()))
      .toList();
}

List<enums.EventReferralEnum>? eventReferralEnumNullableListFromJson(
  List? eventReferralEnum, [
  List<enums.EventReferralEnum>? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return defaultValue;
  }

  return eventReferralEnum
      .map((e) => eventReferralEnumFromJson(e.toString()))
      .toList();
}

String? referralConditionTypeNullableToJson(
  enums.ReferralConditionType? referralConditionType,
) {
  return referralConditionType?.value;
}

String? referralConditionTypeToJson(
  enums.ReferralConditionType referralConditionType,
) {
  return referralConditionType.value;
}

enums.ReferralConditionType referralConditionTypeFromJson(
  Object? referralConditionType, [
  enums.ReferralConditionType? defaultValue,
]) {
  return enums.ReferralConditionType.values.firstWhereOrNull(
        (e) => e.value == referralConditionType,
      ) ??
      defaultValue ??
      enums.ReferralConditionType.swaggerGeneratedUnknown;
}

enums.ReferralConditionType? referralConditionTypeNullableFromJson(
  Object? referralConditionType, [
  enums.ReferralConditionType? defaultValue,
]) {
  if (referralConditionType == null) {
    return null;
  }
  return enums.ReferralConditionType.values.firstWhereOrNull(
        (e) => e.value == referralConditionType,
      ) ??
      defaultValue;
}

String referralConditionTypeExplodedListToJson(
  List<enums.ReferralConditionType>? referralConditionType,
) {
  return referralConditionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> referralConditionTypeListToJson(
  List<enums.ReferralConditionType>? referralConditionType,
) {
  if (referralConditionType == null) {
    return [];
  }

  return referralConditionType.map((e) => e.value!).toList();
}

List<enums.ReferralConditionType> referralConditionTypeListFromJson(
  List? referralConditionType, [
  List<enums.ReferralConditionType>? defaultValue,
]) {
  if (referralConditionType == null) {
    return defaultValue ?? [];
  }

  return referralConditionType
      .map((e) => referralConditionTypeFromJson(e.toString()))
      .toList();
}

List<enums.ReferralConditionType>? referralConditionTypeNullableListFromJson(
  List? referralConditionType, [
  List<enums.ReferralConditionType>? defaultValue,
]) {
  if (referralConditionType == null) {
    return defaultValue;
  }

  return referralConditionType
      .map((e) => referralConditionTypeFromJson(e.toString()))
      .toList();
}

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
