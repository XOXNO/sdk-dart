// coverage:ignore-file
// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'xoxno.enums.swagger.dart' as enums;

part 'xoxno.models.swagger.g.dart';

@JsonSerializable(explicitToJson: true)
class ErrorResponseDto {
  const ErrorResponseDto({
    required this.statusCode,
    required this.message,
    required this.timestamp,
    required this.path,
  });

  factory ErrorResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ErrorResponseDtoFromJson(json);

  static const toJsonFactory = _$ErrorResponseDtoToJson;
  Map<String, dynamic> toJson() => _$ErrorResponseDtoToJson(this);

  @JsonKey(name: 'statusCode')
  final double statusCode;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'timestamp')
  final String timestamp;
  @JsonKey(name: 'path')
  final String path;
  static const fromJsonFactory = _$ErrorResponseDtoFromJson;
}

extension $ErrorResponseDtoExtension on ErrorResponseDto {
  ErrorResponseDto copyWith({
    double? statusCode,
    String? message,
    String? timestamp,
    String? path,
  }) {
    return ErrorResponseDto(
      statusCode: statusCode ?? this.statusCode,
      message: message ?? this.message,
      timestamp: timestamp ?? this.timestamp,
      path: path ?? this.path,
    );
  }

  ErrorResponseDto copyWithWrapped({
    Wrapped<double>? statusCode,
    Wrapped<String>? message,
    Wrapped<String>? timestamp,
    Wrapped<String>? path,
  }) {
    return ErrorResponseDto(
      statusCode: (statusCode != null ? statusCode.value : this.statusCode),
      message: (message != null ? message.value : this.message),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      path: (path != null ? path.value : this.path),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveGuardianDto {
  const ActiveGuardianDto({
    required this.activationEpoch,
    required this.address,
    required this.serviceUID,
  });

  factory ActiveGuardianDto.fromJson(Map<String, dynamic> json) =>
      _$ActiveGuardianDtoFromJson(json);

  static const toJsonFactory = _$ActiveGuardianDtoToJson;
  Map<String, dynamic> toJson() => _$ActiveGuardianDtoToJson(this);

  @JsonKey(name: 'activationEpoch')
  final double activationEpoch;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'serviceUID')
  final String serviceUID;
  static const fromJsonFactory = _$ActiveGuardianDtoFromJson;
}

extension $ActiveGuardianDtoExtension on ActiveGuardianDto {
  ActiveGuardianDto copyWith({
    double? activationEpoch,
    String? address,
    String? serviceUID,
  }) {
    return ActiveGuardianDto(
      activationEpoch: activationEpoch ?? this.activationEpoch,
      address: address ?? this.address,
      serviceUID: serviceUID ?? this.serviceUID,
    );
  }

  ActiveGuardianDto copyWithWrapped({
    Wrapped<double>? activationEpoch,
    Wrapped<String>? address,
    Wrapped<String>? serviceUID,
  }) {
    return ActiveGuardianDto(
      activationEpoch: (activationEpoch != null
          ? activationEpoch.value
          : this.activationEpoch),
      address: (address != null ? address.value : this.address),
      serviceUID: (serviceUID != null ? serviceUID.value : this.serviceUID),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserNetworkInfoDto {
  const UserNetworkInfoDto({
    required this.address,
    required this.nonce,
    required this.balanceShort,
    required this.username,
    this.isUpgradeable,
    this.isReadable,
    this.isGuarded,
    this.isPayable,
    this.isPayableBySmartContract,
    required this.balance,
    required this.shard,
    required this.guarded,
    this.activeGuardian,
    required this.usdValue,
  });

  factory UserNetworkInfoDto.fromJson(Map<String, dynamic> json) =>
      _$UserNetworkInfoDtoFromJson(json);

  static const toJsonFactory = _$UserNetworkInfoDtoToJson;
  Map<String, dynamic> toJson() => _$UserNetworkInfoDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'balanceShort')
  final double balanceShort;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'isUpgradeable')
  final bool? isUpgradeable;
  @JsonKey(name: 'isReadable')
  final bool? isReadable;
  @JsonKey(name: 'isGuarded')
  final bool? isGuarded;
  @JsonKey(name: 'isPayable')
  final bool? isPayable;
  @JsonKey(name: 'isPayableBySmartContract')
  final bool? isPayableBySmartContract;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'guarded')
  final bool guarded;
  @JsonKey(name: 'activeGuardian')
  final ActiveGuardianDto? activeGuardian;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  static const fromJsonFactory = _$UserNetworkInfoDtoFromJson;
}

extension $UserNetworkInfoDtoExtension on UserNetworkInfoDto {
  UserNetworkInfoDto copyWith({
    String? address,
    double? nonce,
    double? balanceShort,
    String? username,
    bool? isUpgradeable,
    bool? isReadable,
    bool? isGuarded,
    bool? isPayable,
    bool? isPayableBySmartContract,
    String? balance,
    double? shard,
    bool? guarded,
    ActiveGuardianDto? activeGuardian,
    double? usdValue,
  }) {
    return UserNetworkInfoDto(
      address: address ?? this.address,
      nonce: nonce ?? this.nonce,
      balanceShort: balanceShort ?? this.balanceShort,
      username: username ?? this.username,
      isUpgradeable: isUpgradeable ?? this.isUpgradeable,
      isReadable: isReadable ?? this.isReadable,
      isGuarded: isGuarded ?? this.isGuarded,
      isPayable: isPayable ?? this.isPayable,
      isPayableBySmartContract:
          isPayableBySmartContract ?? this.isPayableBySmartContract,
      balance: balance ?? this.balance,
      shard: shard ?? this.shard,
      guarded: guarded ?? this.guarded,
      activeGuardian: activeGuardian ?? this.activeGuardian,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  UserNetworkInfoDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? nonce,
    Wrapped<double>? balanceShort,
    Wrapped<String>? username,
    Wrapped<bool?>? isUpgradeable,
    Wrapped<bool?>? isReadable,
    Wrapped<bool?>? isGuarded,
    Wrapped<bool?>? isPayable,
    Wrapped<bool?>? isPayableBySmartContract,
    Wrapped<String>? balance,
    Wrapped<double>? shard,
    Wrapped<bool>? guarded,
    Wrapped<ActiveGuardianDto?>? activeGuardian,
    Wrapped<double>? usdValue,
  }) {
    return UserNetworkInfoDto(
      address: (address != null ? address.value : this.address),
      nonce: (nonce != null ? nonce.value : this.nonce),
      balanceShort: (balanceShort != null
          ? balanceShort.value
          : this.balanceShort),
      username: (username != null ? username.value : this.username),
      isUpgradeable: (isUpgradeable != null
          ? isUpgradeable.value
          : this.isUpgradeable),
      isReadable: (isReadable != null ? isReadable.value : this.isReadable),
      isGuarded: (isGuarded != null ? isGuarded.value : this.isGuarded),
      isPayable: (isPayable != null ? isPayable.value : this.isPayable),
      isPayableBySmartContract: (isPayableBySmartContract != null
          ? isPayableBySmartContract.value
          : this.isPayableBySmartContract),
      balance: (balance != null ? balance.value : this.balance),
      shard: (shard != null ? shard.value : this.shard),
      guarded: (guarded != null ? guarded.value : this.guarded),
      activeGuardian: (activeGuardian != null
          ? activeGuardian.value
          : this.activeGuardian),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WalletDto {
  const WalletDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory WalletDto.fromJson(Map<String, dynamic> json) =>
      _$WalletDtoFromJson(json);

  static const toJsonFactory = _$WalletDtoToJson;
  Map<String, dynamic> toJson() => _$WalletDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$WalletDtoFromJson;
}

extension $WalletDtoExtension on WalletDto {
  WalletDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return WalletDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  WalletDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return WalletDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EsdtsDto {
  const EsdtsDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory EsdtsDto.fromJson(Map<String, dynamic> json) =>
      _$EsdtsDtoFromJson(json);

  static const toJsonFactory = _$EsdtsDtoToJson;
  Map<String, dynamic> toJson() => _$EsdtsDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$EsdtsDtoFromJson;
}

extension $EsdtsDtoExtension on EsdtsDto {
  EsdtsDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return EsdtsDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  EsdtsDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return EsdtsDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StablesDto {
  const StablesDto({
    required this.usdValue,
    required this.egldValue,
    required this.weight,
  });

  factory StablesDto.fromJson(Map<String, dynamic> json) =>
      _$StablesDtoFromJson(json);

  static const toJsonFactory = _$StablesDtoToJson;
  Map<String, dynamic> toJson() => _$StablesDtoToJson(this);

  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  static const fromJsonFactory = _$StablesDtoFromJson;
}

extension $StablesDtoExtension on StablesDto {
  StablesDto copyWith({double? usdValue, double? egldValue, double? weight}) {
    return StablesDto(
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
    );
  }

  StablesDto copyWithWrapped({
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
  }) {
    return StablesDto(
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuiCoinObjectDto {
  const SuiCoinObjectDto({
    required this.objectId,
    required this.balance,
    required this.digest,
    required this.version,
  });

  factory SuiCoinObjectDto.fromJson(Map<String, dynamic> json) =>
      _$SuiCoinObjectDtoFromJson(json);

  static const toJsonFactory = _$SuiCoinObjectDtoToJson;
  Map<String, dynamic> toJson() => _$SuiCoinObjectDtoToJson(this);

  @JsonKey(name: 'objectId')
  final String objectId;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'digest')
  final String digest;
  @JsonKey(name: 'version')
  final String version;
  static const fromJsonFactory = _$SuiCoinObjectDtoFromJson;
}

extension $SuiCoinObjectDtoExtension on SuiCoinObjectDto {
  SuiCoinObjectDto copyWith({
    String? objectId,
    String? balance,
    String? digest,
    String? version,
  }) {
    return SuiCoinObjectDto(
      objectId: objectId ?? this.objectId,
      balance: balance ?? this.balance,
      digest: digest ?? this.digest,
      version: version ?? this.version,
    );
  }

  SuiCoinObjectDto copyWithWrapped({
    Wrapped<String>? objectId,
    Wrapped<String>? balance,
    Wrapped<String>? digest,
    Wrapped<String>? version,
  }) {
    return SuiCoinObjectDto(
      objectId: (objectId != null ? objectId.value : this.objectId),
      balance: (balance != null ? balance.value : this.balance),
      digest: (digest != null ? digest.value : this.digest),
      version: (version != null ? version.value : this.version),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TokenDataDocWithBalance {
  const TokenDataDocWithBalance({
    required this.identifier,
    required this.decimals,
    required this.ticker,
    required this.name,
    required this.svgUrl,
    required this.pngUrl,
    required this.chain,
    required this.usdPrice,
    required this.nonce,
    required this.balance,
    required this.shortBalance,
    required this.usdValue,
    required this.egldValue,
    required this.weight,
    this.objects,
  });

  factory TokenDataDocWithBalance.fromJson(Map<String, dynamic> json) =>
      _$TokenDataDocWithBalanceFromJson(json);

  static const toJsonFactory = _$TokenDataDocWithBalanceToJson;
  Map<String, dynamic> toJson() => _$TokenDataDocWithBalanceToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final int decimals;
  @JsonKey(name: 'ticker')
  final String ticker;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'svgUrl')
  final String svgUrl;
  @JsonKey(name: 'pngUrl')
  final String pngUrl;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainChainFromJson,
  )
  final enums.ActivityChain chain;
  static enums.ActivityChain activityChainChainFromJson(Object? value) =>
      activityChainFromJson(value, enums.ActivityChain.mvx);

  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'shortBalance')
  final double shortBalance;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(name: 'weight')
  final double weight;
  @JsonKey(name: 'objects', defaultValue: <SuiCoinObjectDto>[])
  final List<SuiCoinObjectDto>? objects;
  static const fromJsonFactory = _$TokenDataDocWithBalanceFromJson;
}

extension $TokenDataDocWithBalanceExtension on TokenDataDocWithBalance {
  TokenDataDocWithBalance copyWith({
    String? identifier,
    int? decimals,
    String? ticker,
    String? name,
    String? svgUrl,
    String? pngUrl,
    enums.ActivityChain? chain,
    double? usdPrice,
    double? nonce,
    String? balance,
    double? shortBalance,
    double? usdValue,
    double? egldValue,
    double? weight,
    List<SuiCoinObjectDto>? objects,
  }) {
    return TokenDataDocWithBalance(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      ticker: ticker ?? this.ticker,
      name: name ?? this.name,
      svgUrl: svgUrl ?? this.svgUrl,
      pngUrl: pngUrl ?? this.pngUrl,
      chain: chain ?? this.chain,
      usdPrice: usdPrice ?? this.usdPrice,
      nonce: nonce ?? this.nonce,
      balance: balance ?? this.balance,
      shortBalance: shortBalance ?? this.shortBalance,
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      weight: weight ?? this.weight,
      objects: objects ?? this.objects,
    );
  }

  TokenDataDocWithBalance copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<int>? decimals,
    Wrapped<String>? ticker,
    Wrapped<String>? name,
    Wrapped<String>? svgUrl,
    Wrapped<String>? pngUrl,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<double>? usdPrice,
    Wrapped<double>? nonce,
    Wrapped<String>? balance,
    Wrapped<double>? shortBalance,
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<double>? weight,
    Wrapped<List<SuiCoinObjectDto>?>? objects,
  }) {
    return TokenDataDocWithBalance(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      ticker: (ticker != null ? ticker.value : this.ticker),
      name: (name != null ? name.value : this.name),
      svgUrl: (svgUrl != null ? svgUrl.value : this.svgUrl),
      pngUrl: (pngUrl != null ? pngUrl.value : this.pngUrl),
      chain: (chain != null ? chain.value : this.chain),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
      nonce: (nonce != null ? nonce.value : this.nonce),
      balance: (balance != null ? balance.value : this.balance),
      shortBalance: (shortBalance != null
          ? shortBalance.value
          : this.shortBalance),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      weight: (weight != null ? weight.value : this.weight),
      objects: (objects != null ? objects.value : this.objects),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserTokenInventoryResponseDto {
  const UserTokenInventoryResponseDto({
    required this.wallet,
    required this.esdts,
    required this.stables,
    required this.tokens,
    required this.chain,
  });

  factory UserTokenInventoryResponseDto.fromJson(Map<String, dynamic> json) =>
      _$UserTokenInventoryResponseDtoFromJson(json);

  static const toJsonFactory = _$UserTokenInventoryResponseDtoToJson;
  Map<String, dynamic> toJson() => _$UserTokenInventoryResponseDtoToJson(this);

  @JsonKey(name: 'wallet')
  final WalletDto wallet;
  @JsonKey(name: 'esdts')
  final EsdtsDto esdts;
  @JsonKey(name: 'stables')
  final StablesDto stables;
  @JsonKey(name: 'tokens', defaultValue: <TokenDataDocWithBalance>[])
  final List<TokenDataDocWithBalance> tokens;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  static const fromJsonFactory = _$UserTokenInventoryResponseDtoFromJson;
}

extension $UserTokenInventoryResponseDtoExtension
    on UserTokenInventoryResponseDto {
  UserTokenInventoryResponseDto copyWith({
    WalletDto? wallet,
    EsdtsDto? esdts,
    StablesDto? stables,
    List<TokenDataDocWithBalance>? tokens,
    enums.ActivityChain? chain,
  }) {
    return UserTokenInventoryResponseDto(
      wallet: wallet ?? this.wallet,
      esdts: esdts ?? this.esdts,
      stables: stables ?? this.stables,
      tokens: tokens ?? this.tokens,
      chain: chain ?? this.chain,
    );
  }

  UserTokenInventoryResponseDto copyWithWrapped({
    Wrapped<WalletDto>? wallet,
    Wrapped<EsdtsDto>? esdts,
    Wrapped<StablesDto>? stables,
    Wrapped<List<TokenDataDocWithBalance>>? tokens,
    Wrapped<enums.ActivityChain>? chain,
  }) {
    return UserTokenInventoryResponseDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      esdts: (esdts != null ? esdts.value : this.esdts),
      stables: (stables != null ? stables.value : this.stables),
      tokens: (tokens != null ? tokens.value : this.tokens),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SocialsDto {
  const SocialsDto({
    this.twitter,
    this.instagram,
    this.website,
    this.telegram,
    this.discord,
    this.facebook,
    this.youtube,
  });

  factory SocialsDto.fromJson(Map<String, dynamic> json) =>
      _$SocialsDtoFromJson(json);

  static const toJsonFactory = _$SocialsDtoToJson;
  Map<String, dynamic> toJson() => _$SocialsDtoToJson(this);

  @JsonKey(name: 'twitter')
  final String? twitter;
  @JsonKey(name: 'instagram')
  final String? instagram;
  @JsonKey(name: 'website')
  final String? website;
  @JsonKey(name: 'telegram')
  final String? telegram;
  @JsonKey(name: 'discord')
  final String? discord;
  @JsonKey(name: 'facebook')
  final String? facebook;
  @JsonKey(name: 'youtube')
  final String? youtube;
  static const fromJsonFactory = _$SocialsDtoFromJson;
}

extension $SocialsDtoExtension on SocialsDto {
  SocialsDto copyWith({
    String? twitter,
    String? instagram,
    String? website,
    String? telegram,
    String? discord,
    String? facebook,
    String? youtube,
  }) {
    return SocialsDto(
      twitter: twitter ?? this.twitter,
      instagram: instagram ?? this.instagram,
      website: website ?? this.website,
      telegram: telegram ?? this.telegram,
      discord: discord ?? this.discord,
      facebook: facebook ?? this.facebook,
      youtube: youtube ?? this.youtube,
    );
  }

  SocialsDto copyWithWrapped({
    Wrapped<String?>? twitter,
    Wrapped<String?>? instagram,
    Wrapped<String?>? website,
    Wrapped<String?>? telegram,
    Wrapped<String?>? discord,
    Wrapped<String?>? facebook,
    Wrapped<String?>? youtube,
  }) {
    return SocialsDto(
      twitter: (twitter != null ? twitter.value : this.twitter),
      instagram: (instagram != null ? instagram.value : this.instagram),
      website: (website != null ? website.value : this.website),
      telegram: (telegram != null ? telegram.value : this.telegram),
      discord: (discord != null ? discord.value : this.discord),
      facebook: (facebook != null ? facebook.value : this.facebook),
      youtube: (youtube != null ? youtube.value : this.youtube),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserDeposit {
  const UserDeposit({
    required this.balance,
    required this.balanceShort,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.usdPrice,
  });

  factory UserDeposit.fromJson(Map<String, dynamic> json) =>
      _$UserDepositFromJson(json);

  static const toJsonFactory = _$UserDepositToJson;
  Map<String, dynamic> toJson() => _$UserDepositToJson(this);

  @JsonKey(name: 'balance')
  final String balance;
  @JsonKey(name: 'balanceShort')
  final double balanceShort;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  static const fromJsonFactory = _$UserDepositFromJson;
}

extension $UserDepositExtension on UserDeposit {
  UserDeposit copyWith({
    String? balance,
    double? balanceShort,
    String? paymentToken,
    double? paymentTokenNonce,
    double? usdPrice,
  }) {
    return UserDeposit(
      balance: balance ?? this.balance,
      balanceShort: balanceShort ?? this.balanceShort,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      usdPrice: usdPrice ?? this.usdPrice,
    );
  }

  UserDeposit copyWithWrapped({
    Wrapped<String>? balance,
    Wrapped<double>? balanceShort,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<double>? usdPrice,
  }) {
    return UserDeposit(
      balance: (balance != null ? balance.value : this.balance),
      balanceShort: (balanceShort != null
          ? balanceShort.value
          : this.balanceShort),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileDoc {
  const UserProfileDoc({
    required this.dataType,
    required this.address,
    required this.isBanned,
    required this.isVerified,
    required this.socials,
    required this.followCount,
    required this.joinedDate,
    required this.profile,
    required this.banner,
    this.description,
    required this.herotag,
    required this.isCreator,
    required this.isPoolOwner,
    required this.shard,
    required this.userDeposit,
    required this.chain,
    required this.ts,
    required this.id,
    this.isBoberBattleUser,
  });

  factory UserProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$UserProfileDocFromJson(json);

  static const toJsonFactory = _$UserProfileDocToJson;
  Map<String, dynamic> toJson() => _$UserProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userProfileDocDataTypeToJson,
    fromJson: userProfileDocDataTypeFromJson,
  )
  final enums.UserProfileDocDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'isBanned')
  final bool isBanned;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'isPoolOwner')
  final bool isPoolOwner;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'userDeposit', defaultValue: <UserDeposit>[])
  final List<UserDeposit> userDeposit;
  @JsonKey(
    name: 'chain',
    toJson: userProfileDocChainToJson,
    fromJson: userProfileDocChainFromJson,
  )
  final enums.UserProfileDocChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  static const fromJsonFactory = _$UserProfileDocFromJson;
}

extension $UserProfileDocExtension on UserProfileDoc {
  UserProfileDoc copyWith({
    enums.UserProfileDocDataType? dataType,
    String? address,
    bool? isBanned,
    bool? isVerified,
    SocialsDto? socials,
    double? followCount,
    double? joinedDate,
    String? profile,
    String? banner,
    String? description,
    String? herotag,
    bool? isCreator,
    bool? isPoolOwner,
    double? shard,
    List<UserDeposit>? userDeposit,
    enums.UserProfileDocChain? chain,
    double? ts,
    String? id,
    bool? isBoberBattleUser,
  }) {
    return UserProfileDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      isBanned: isBanned ?? this.isBanned,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      followCount: followCount ?? this.followCount,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      description: description ?? this.description,
      herotag: herotag ?? this.herotag,
      isCreator: isCreator ?? this.isCreator,
      isPoolOwner: isPoolOwner ?? this.isPoolOwner,
      shard: shard ?? this.shard,
      userDeposit: userDeposit ?? this.userDeposit,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
    );
  }

  UserProfileDoc copyWithWrapped({
    Wrapped<enums.UserProfileDocDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<bool>? isBanned,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<double>? followCount,
    Wrapped<double>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<String?>? description,
    Wrapped<String>? herotag,
    Wrapped<bool>? isCreator,
    Wrapped<bool>? isPoolOwner,
    Wrapped<double>? shard,
    Wrapped<List<UserDeposit>>? userDeposit,
    Wrapped<enums.UserProfileDocChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<bool?>? isBoberBattleUser,
  }) {
    return UserProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      isBanned: (isBanned != null ? isBanned.value : this.isBanned),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      followCount: (followCount != null ? followCount.value : this.followCount),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      description: (description != null ? description.value : this.description),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      isPoolOwner: (isPoolOwner != null ? isPoolOwner.value : this.isPoolOwner),
      shard: (shard != null ? shard.value : this.shard),
      userDeposit: (userDeposit != null ? userDeposit.value : this.userDeposit),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserEmailNotificationSettings {
  const UserEmailNotificationSettings({
    required this.enabled,
    required this.emailAddress,
    required this.isEmailVerificationPending,
    required this.isEmailVerified,
    required this.isWeb2User,
    this.timestamp,
  });

  factory UserEmailNotificationSettings.fromJson(Map<String, dynamic> json) =>
      _$UserEmailNotificationSettingsFromJson(json);

  static const toJsonFactory = _$UserEmailNotificationSettingsToJson;
  Map<String, dynamic> toJson() => _$UserEmailNotificationSettingsToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'emailAddress')
  final String emailAddress;
  @JsonKey(name: 'isEmailVerificationPending')
  final bool isEmailVerificationPending;
  @JsonKey(name: 'isEmailVerified')
  final bool isEmailVerified;
  @JsonKey(name: 'isWeb2User')
  final bool isWeb2User;
  @JsonKey(name: 'timestamp')
  final int? timestamp;
  static const fromJsonFactory = _$UserEmailNotificationSettingsFromJson;
}

extension $UserEmailNotificationSettingsExtension
    on UserEmailNotificationSettings {
  UserEmailNotificationSettings copyWith({
    bool? enabled,
    String? emailAddress,
    bool? isEmailVerificationPending,
    bool? isEmailVerified,
    bool? isWeb2User,
    int? timestamp,
  }) {
    return UserEmailNotificationSettings(
      enabled: enabled ?? this.enabled,
      emailAddress: emailAddress ?? this.emailAddress,
      isEmailVerificationPending:
          isEmailVerificationPending ?? this.isEmailVerificationPending,
      isEmailVerified: isEmailVerified ?? this.isEmailVerified,
      isWeb2User: isWeb2User ?? this.isWeb2User,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  UserEmailNotificationSettings copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String>? emailAddress,
    Wrapped<bool>? isEmailVerificationPending,
    Wrapped<bool>? isEmailVerified,
    Wrapped<bool>? isWeb2User,
    Wrapped<int?>? timestamp,
  }) {
    return UserEmailNotificationSettings(
      enabled: (enabled != null ? enabled.value : this.enabled),
      emailAddress: (emailAddress != null
          ? emailAddress.value
          : this.emailAddress),
      isEmailVerificationPending: (isEmailVerificationPending != null
          ? isEmailVerificationPending.value
          : this.isEmailVerificationPending),
      isEmailVerified: (isEmailVerified != null
          ? isEmailVerified.value
          : this.isEmailVerified),
      isWeb2User: (isWeb2User != null ? isWeb2User.value : this.isWeb2User),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserNotificationPreferences {
  const UserNotificationPreferences({
    this.sales,
    this.bids,
    this.offersReceived,
    this.offersAccepted,
    this.offersRejected,
    this.deposits,
    this.eventUpdates,
    this.eventReminders,
    this.eventCheckIn,
    this.eventMarketing,
  });

  factory UserNotificationPreferences.fromJson(Map<String, dynamic> json) =>
      _$UserNotificationPreferencesFromJson(json);

  static const toJsonFactory = _$UserNotificationPreferencesToJson;
  Map<String, dynamic> toJson() => _$UserNotificationPreferencesToJson(this);

  @JsonKey(name: 'sales')
  final bool? sales;
  @JsonKey(name: 'bids')
  final bool? bids;
  @JsonKey(name: 'offersReceived')
  final bool? offersReceived;
  @JsonKey(name: 'offersAccepted')
  final bool? offersAccepted;
  @JsonKey(name: 'offersRejected')
  final bool? offersRejected;
  @JsonKey(name: 'deposits')
  final bool? deposits;
  @JsonKey(name: 'eventUpdates')
  final bool? eventUpdates;
  @JsonKey(name: 'eventReminders')
  final bool? eventReminders;
  @JsonKey(name: 'eventCheckIn')
  final bool? eventCheckIn;
  @JsonKey(name: 'eventMarketing')
  final bool? eventMarketing;
  static const fromJsonFactory = _$UserNotificationPreferencesFromJson;
}

extension $UserNotificationPreferencesExtension on UserNotificationPreferences {
  UserNotificationPreferences copyWith({
    bool? sales,
    bool? bids,
    bool? offersReceived,
    bool? offersAccepted,
    bool? offersRejected,
    bool? deposits,
    bool? eventUpdates,
    bool? eventReminders,
    bool? eventCheckIn,
    bool? eventMarketing,
  }) {
    return UserNotificationPreferences(
      sales: sales ?? this.sales,
      bids: bids ?? this.bids,
      offersReceived: offersReceived ?? this.offersReceived,
      offersAccepted: offersAccepted ?? this.offersAccepted,
      offersRejected: offersRejected ?? this.offersRejected,
      deposits: deposits ?? this.deposits,
      eventUpdates: eventUpdates ?? this.eventUpdates,
      eventReminders: eventReminders ?? this.eventReminders,
      eventCheckIn: eventCheckIn ?? this.eventCheckIn,
      eventMarketing: eventMarketing ?? this.eventMarketing,
    );
  }

  UserNotificationPreferences copyWithWrapped({
    Wrapped<bool?>? sales,
    Wrapped<bool?>? bids,
    Wrapped<bool?>? offersReceived,
    Wrapped<bool?>? offersAccepted,
    Wrapped<bool?>? offersRejected,
    Wrapped<bool?>? deposits,
    Wrapped<bool?>? eventUpdates,
    Wrapped<bool?>? eventReminders,
    Wrapped<bool?>? eventCheckIn,
    Wrapped<bool?>? eventMarketing,
  }) {
    return UserNotificationPreferences(
      sales: (sales != null ? sales.value : this.sales),
      bids: (bids != null ? bids.value : this.bids),
      offersReceived: (offersReceived != null
          ? offersReceived.value
          : this.offersReceived),
      offersAccepted: (offersAccepted != null
          ? offersAccepted.value
          : this.offersAccepted),
      offersRejected: (offersRejected != null
          ? offersRejected.value
          : this.offersRejected),
      deposits: (deposits != null ? deposits.value : this.deposits),
      eventUpdates: (eventUpdates != null
          ? eventUpdates.value
          : this.eventUpdates),
      eventReminders: (eventReminders != null
          ? eventReminders.value
          : this.eventReminders),
      eventCheckIn: (eventCheckIn != null
          ? eventCheckIn.value
          : this.eventCheckIn),
      eventMarketing: (eventMarketing != null
          ? eventMarketing.value
          : this.eventMarketing),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSettingsDto {
  const UserSettingsDto({
    required this.emailNotifications,
    required this.notificationPreferences,
    required this.address,
    required this.id,
    required this.ts,
  });

  factory UserSettingsDto.fromJson(Map<String, dynamic> json) =>
      _$UserSettingsDtoFromJson(json);

  static const toJsonFactory = _$UserSettingsDtoToJson;
  Map<String, dynamic> toJson() => _$UserSettingsDtoToJson(this);

  @JsonKey(name: 'emailNotifications')
  final UserEmailNotificationSettings emailNotifications;
  @JsonKey(name: 'notificationPreferences')
  final UserNotificationPreferences notificationPreferences;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  static const fromJsonFactory = _$UserSettingsDtoFromJson;
}

extension $UserSettingsDtoExtension on UserSettingsDto {
  UserSettingsDto copyWith({
    UserEmailNotificationSettings? emailNotifications,
    UserNotificationPreferences? notificationPreferences,
    String? address,
    String? id,
    double? ts,
  }) {
    return UserSettingsDto(
      emailNotifications: emailNotifications ?? this.emailNotifications,
      notificationPreferences:
          notificationPreferences ?? this.notificationPreferences,
      address: address ?? this.address,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  UserSettingsDto copyWithWrapped({
    Wrapped<UserEmailNotificationSettings>? emailNotifications,
    Wrapped<UserNotificationPreferences>? notificationPreferences,
    Wrapped<String>? address,
    Wrapped<String>? id,
    Wrapped<double>? ts,
  }) {
    return UserSettingsDto(
      emailNotifications: (emailNotifications != null
          ? emailNotifications.value
          : this.emailNotifications),
      notificationPreferences: (notificationPreferences != null
          ? notificationPreferences.value
          : this.notificationPreferences),
      address: (address != null ? address.value : this.address),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileDto {
  const UserProfileDto({
    required this.dataType,
    required this.address,
    required this.isBanned,
    required this.isVerified,
    required this.socials,
    required this.followCount,
    required this.joinedDate,
    required this.profile,
    required this.banner,
    this.description,
    required this.herotag,
    required this.isCreator,
    required this.isPoolOwner,
    required this.shard,
    required this.userDeposit,
    required this.chain,
    required this.ts,
    required this.id,
    this.isBoberBattleUser,
    this.userSettings,
  });

  factory UserProfileDto.fromJson(Map<String, dynamic> json) =>
      _$UserProfileDtoFromJson(json);

  static const toJsonFactory = _$UserProfileDtoToJson;
  Map<String, dynamic> toJson() => _$UserProfileDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userProfileDtoDataTypeToJson,
    fromJson: userProfileDtoDataTypeFromJson,
  )
  final enums.UserProfileDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'isBanned')
  final bool isBanned;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'joinedDate')
  final double joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'isPoolOwner')
  final bool isPoolOwner;
  @JsonKey(name: 'shard')
  final double shard;
  @JsonKey(name: 'userDeposit', defaultValue: <UserDeposit>[])
  final List<UserDeposit> userDeposit;
  @JsonKey(
    name: 'chain',
    toJson: userProfileDtoChainToJson,
    fromJson: userProfileDtoChainFromJson,
  )
  final enums.UserProfileDtoChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  @JsonKey(name: 'userSettings')
  final UserSettingsDto? userSettings;
  static const fromJsonFactory = _$UserProfileDtoFromJson;
}

extension $UserProfileDtoExtension on UserProfileDto {
  UserProfileDto copyWith({
    enums.UserProfileDtoDataType? dataType,
    String? address,
    bool? isBanned,
    bool? isVerified,
    SocialsDto? socials,
    double? followCount,
    double? joinedDate,
    String? profile,
    String? banner,
    String? description,
    String? herotag,
    bool? isCreator,
    bool? isPoolOwner,
    double? shard,
    List<UserDeposit>? userDeposit,
    enums.UserProfileDtoChain? chain,
    double? ts,
    String? id,
    bool? isBoberBattleUser,
    UserSettingsDto? userSettings,
  }) {
    return UserProfileDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      isBanned: isBanned ?? this.isBanned,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      followCount: followCount ?? this.followCount,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      description: description ?? this.description,
      herotag: herotag ?? this.herotag,
      isCreator: isCreator ?? this.isCreator,
      isPoolOwner: isPoolOwner ?? this.isPoolOwner,
      shard: shard ?? this.shard,
      userDeposit: userDeposit ?? this.userDeposit,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
      userSettings: userSettings ?? this.userSettings,
    );
  }

  UserProfileDto copyWithWrapped({
    Wrapped<enums.UserProfileDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<bool>? isBanned,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<double>? followCount,
    Wrapped<double>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<String?>? description,
    Wrapped<String>? herotag,
    Wrapped<bool>? isCreator,
    Wrapped<bool>? isPoolOwner,
    Wrapped<double>? shard,
    Wrapped<List<UserDeposit>>? userDeposit,
    Wrapped<enums.UserProfileDtoChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<bool?>? isBoberBattleUser,
    Wrapped<UserSettingsDto?>? userSettings,
  }) {
    return UserProfileDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      isBanned: (isBanned != null ? isBanned.value : this.isBanned),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      followCount: (followCount != null ? followCount.value : this.followCount),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      description: (description != null ? description.value : this.description),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      isPoolOwner: (isPoolOwner != null ? isPoolOwner.value : this.isPoolOwner),
      shard: (shard != null ? shard.value : this.shard),
      userDeposit: (userDeposit != null ? userDeposit.value : this.userDeposit),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
      userSettings: (userSettings != null
          ? userSettings.value
          : this.userSettings),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBillingDetails {
  const UserBillingDetails({
    required this.isCompany,
    required this.name,
    this.companyRegistrationNumber,
    this.companyVatNumber,
    required this.email,
    required this.country,
    required this.city,
    required this.address1,
    this.address2,
    this.postalCode,
  });

  factory UserBillingDetails.fromJson(Map<String, dynamic> json) =>
      _$UserBillingDetailsFromJson(json);

  static const toJsonFactory = _$UserBillingDetailsToJson;
  Map<String, dynamic> toJson() => _$UserBillingDetailsToJson(this);

  @JsonKey(name: 'isCompany')
  final bool isCompany;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'companyRegistrationNumber')
  final String? companyRegistrationNumber;
  @JsonKey(name: 'companyVatNumber')
  final String? companyVatNumber;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'address1')
  final String address1;
  @JsonKey(name: 'address2')
  final String? address2;
  @JsonKey(name: 'postalCode')
  final String? postalCode;
  static const fromJsonFactory = _$UserBillingDetailsFromJson;
}

extension $UserBillingDetailsExtension on UserBillingDetails {
  UserBillingDetails copyWith({
    bool? isCompany,
    String? name,
    String? companyRegistrationNumber,
    String? companyVatNumber,
    String? email,
    String? country,
    String? city,
    String? address1,
    String? address2,
    String? postalCode,
  }) {
    return UserBillingDetails(
      isCompany: isCompany ?? this.isCompany,
      name: name ?? this.name,
      companyRegistrationNumber:
          companyRegistrationNumber ?? this.companyRegistrationNumber,
      companyVatNumber: companyVatNumber ?? this.companyVatNumber,
      email: email ?? this.email,
      country: country ?? this.country,
      city: city ?? this.city,
      address1: address1 ?? this.address1,
      address2: address2 ?? this.address2,
      postalCode: postalCode ?? this.postalCode,
    );
  }

  UserBillingDetails copyWithWrapped({
    Wrapped<bool>? isCompany,
    Wrapped<String>? name,
    Wrapped<String?>? companyRegistrationNumber,
    Wrapped<String?>? companyVatNumber,
    Wrapped<String>? email,
    Wrapped<String>? country,
    Wrapped<String>? city,
    Wrapped<String>? address1,
    Wrapped<String?>? address2,
    Wrapped<String?>? postalCode,
  }) {
    return UserBillingDetails(
      isCompany: (isCompany != null ? isCompany.value : this.isCompany),
      name: (name != null ? name.value : this.name),
      companyRegistrationNumber: (companyRegistrationNumber != null
          ? companyRegistrationNumber.value
          : this.companyRegistrationNumber),
      companyVatNumber: (companyVatNumber != null
          ? companyVatNumber.value
          : this.companyVatNumber),
      email: (email != null ? email.value : this.email),
      country: (country != null ? country.value : this.country),
      city: (city != null ? city.value : this.city),
      address1: (address1 != null ? address1.value : this.address1),
      address2: (address2 != null ? address2.value : this.address2),
      postalCode: (postalCode != null ? postalCode.value : this.postalCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPhoneNotificationSettings {
  const UserPhoneNotificationSettings({
    required this.enabled,
    required this.phoneNumber,
    required this.isPhoneVerificationPending,
    required this.isPhoneVerified,
    this.timestamp,
  });

  factory UserPhoneNotificationSettings.fromJson(Map<String, dynamic> json) =>
      _$UserPhoneNotificationSettingsFromJson(json);

  static const toJsonFactory = _$UserPhoneNotificationSettingsToJson;
  Map<String, dynamic> toJson() => _$UserPhoneNotificationSettingsToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'phoneNumber')
  final String phoneNumber;
  @JsonKey(name: 'isPhoneVerificationPending')
  final bool isPhoneVerificationPending;
  @JsonKey(name: 'isPhoneVerified')
  final bool isPhoneVerified;
  @JsonKey(name: 'timestamp')
  final int? timestamp;
  static const fromJsonFactory = _$UserPhoneNotificationSettingsFromJson;
}

extension $UserPhoneNotificationSettingsExtension
    on UserPhoneNotificationSettings {
  UserPhoneNotificationSettings copyWith({
    bool? enabled,
    String? phoneNumber,
    bool? isPhoneVerificationPending,
    bool? isPhoneVerified,
    int? timestamp,
  }) {
    return UserPhoneNotificationSettings(
      enabled: enabled ?? this.enabled,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      isPhoneVerificationPending:
          isPhoneVerificationPending ?? this.isPhoneVerificationPending,
      isPhoneVerified: isPhoneVerified ?? this.isPhoneVerified,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  UserPhoneNotificationSettings copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String>? phoneNumber,
    Wrapped<bool>? isPhoneVerificationPending,
    Wrapped<bool>? isPhoneVerified,
    Wrapped<int?>? timestamp,
  }) {
    return UserPhoneNotificationSettings(
      enabled: (enabled != null ? enabled.value : this.enabled),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
      isPhoneVerificationPending: (isPhoneVerificationPending != null
          ? isPhoneVerificationPending.value
          : this.isPhoneVerificationPending),
      isPhoneVerified: (isPhoneVerified != null
          ? isPhoneVerified.value
          : this.isPhoneVerified),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSettingsDoc {
  const UserSettingsDoc({
    required this.dataType,
    required this.address,
    this.name,
    this.billingDetails,
    required this.emailNotifications,
    this.phoneNotifications,
    required this.notificationPreferences,
    required this.id,
    this.ts,
  });

  factory UserSettingsDoc.fromJson(Map<String, dynamic> json) =>
      _$UserSettingsDocFromJson(json);

  static const toJsonFactory = _$UserSettingsDocToJson;
  Map<String, dynamic> toJson() => _$UserSettingsDocToJson(this);

  @JsonKey(name: 'dataType')
  final String dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'billingDetails')
  final UserBillingDetails? billingDetails;
  @JsonKey(name: 'emailNotifications')
  final UserEmailNotificationSettings emailNotifications;
  @JsonKey(name: 'phoneNotifications')
  final UserPhoneNotificationSettings? phoneNotifications;
  @JsonKey(name: 'notificationPreferences')
  final UserNotificationPreferences notificationPreferences;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$UserSettingsDocFromJson;
}

extension $UserSettingsDocExtension on UserSettingsDoc {
  UserSettingsDoc copyWith({
    String? dataType,
    String? address,
    String? name,
    UserBillingDetails? billingDetails,
    UserEmailNotificationSettings? emailNotifications,
    UserPhoneNotificationSettings? phoneNotifications,
    UserNotificationPreferences? notificationPreferences,
    String? id,
    double? ts,
  }) {
    return UserSettingsDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      billingDetails: billingDetails ?? this.billingDetails,
      emailNotifications: emailNotifications ?? this.emailNotifications,
      phoneNotifications: phoneNotifications ?? this.phoneNotifications,
      notificationPreferences:
          notificationPreferences ?? this.notificationPreferences,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  UserSettingsDoc copyWithWrapped({
    Wrapped<String>? dataType,
    Wrapped<String>? address,
    Wrapped<String?>? name,
    Wrapped<UserBillingDetails?>? billingDetails,
    Wrapped<UserEmailNotificationSettings>? emailNotifications,
    Wrapped<UserPhoneNotificationSettings?>? phoneNotifications,
    Wrapped<UserNotificationPreferences>? notificationPreferences,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
  }) {
    return UserSettingsDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      billingDetails: (billingDetails != null
          ? billingDetails.value
          : this.billingDetails),
      emailNotifications: (emailNotifications != null
          ? emailNotifications.value
          : this.emailNotifications),
      phoneNotifications: (phoneNotifications != null
          ? phoneNotifications.value
          : this.phoneNotifications),
      notificationPreferences: (notificationPreferences != null
          ? notificationPreferences.value
          : this.notificationPreferences),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationPreferencesPostDto {
  const NotificationPreferencesPostDto({
    required this.sales,
    required this.bids,
    required this.offersReceived,
    required this.offersAccepted,
    required this.offersRejected,
    required this.deposits,
  });

  factory NotificationPreferencesPostDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationPreferencesPostDtoFromJson(json);

  static const toJsonFactory = _$NotificationPreferencesPostDtoToJson;
  Map<String, dynamic> toJson() => _$NotificationPreferencesPostDtoToJson(this);

  @JsonKey(name: 'sales')
  final bool sales;
  @JsonKey(name: 'bids')
  final bool bids;
  @JsonKey(name: 'offersReceived')
  final bool offersReceived;
  @JsonKey(name: 'offersAccepted')
  final bool offersAccepted;
  @JsonKey(name: 'offersRejected')
  final bool offersRejected;
  @JsonKey(name: 'deposits')
  final bool deposits;
  static const fromJsonFactory = _$NotificationPreferencesPostDtoFromJson;
}

extension $NotificationPreferencesPostDtoExtension
    on NotificationPreferencesPostDto {
  NotificationPreferencesPostDto copyWith({
    bool? sales,
    bool? bids,
    bool? offersReceived,
    bool? offersAccepted,
    bool? offersRejected,
    bool? deposits,
  }) {
    return NotificationPreferencesPostDto(
      sales: sales ?? this.sales,
      bids: bids ?? this.bids,
      offersReceived: offersReceived ?? this.offersReceived,
      offersAccepted: offersAccepted ?? this.offersAccepted,
      offersRejected: offersRejected ?? this.offersRejected,
      deposits: deposits ?? this.deposits,
    );
  }

  NotificationPreferencesPostDto copyWithWrapped({
    Wrapped<bool>? sales,
    Wrapped<bool>? bids,
    Wrapped<bool>? offersReceived,
    Wrapped<bool>? offersAccepted,
    Wrapped<bool>? offersRejected,
    Wrapped<bool>? deposits,
  }) {
    return NotificationPreferencesPostDto(
      sales: (sales != null ? sales.value : this.sales),
      bids: (bids != null ? bids.value : this.bids),
      offersReceived: (offersReceived != null
          ? offersReceived.value
          : this.offersReceived),
      offersAccepted: (offersAccepted != null
          ? offersAccepted.value
          : this.offersAccepted),
      offersRejected: (offersRejected != null
          ? offersRejected.value
          : this.offersRejected),
      deposits: (deposits != null ? deposits.value : this.deposits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SetEmailDto {
  const SetEmailDto({required this.enabled, this.emailAddress});

  factory SetEmailDto.fromJson(Map<String, dynamic> json) =>
      _$SetEmailDtoFromJson(json);

  static const toJsonFactory = _$SetEmailDtoToJson;
  Map<String, dynamic> toJson() => _$SetEmailDtoToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'emailAddress')
  final String? emailAddress;
  static const fromJsonFactory = _$SetEmailDtoFromJson;
}

extension $SetEmailDtoExtension on SetEmailDto {
  SetEmailDto copyWith({bool? enabled, String? emailAddress}) {
    return SetEmailDto(
      enabled: enabled ?? this.enabled,
      emailAddress: emailAddress ?? this.emailAddress,
    );
  }

  SetEmailDto copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String?>? emailAddress,
  }) {
    return SetEmailDto(
      enabled: (enabled != null ? enabled.value : this.enabled),
      emailAddress: (emailAddress != null
          ? emailAddress.value
          : this.emailAddress),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SetPhoneDto {
  const SetPhoneDto({required this.enabled, this.phoneNumber});

  factory SetPhoneDto.fromJson(Map<String, dynamic> json) =>
      _$SetPhoneDtoFromJson(json);

  static const toJsonFactory = _$SetPhoneDtoToJson;
  Map<String, dynamic> toJson() => _$SetPhoneDtoToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'phoneNumber')
  final String? phoneNumber;
  static const fromJsonFactory = _$SetPhoneDtoFromJson;
}

extension $SetPhoneDtoExtension on SetPhoneDto {
  SetPhoneDto copyWith({bool? enabled, String? phoneNumber}) {
    return SetPhoneDto(
      enabled: enabled ?? this.enabled,
      phoneNumber: phoneNumber ?? this.phoneNumber,
    );
  }

  SetPhoneDto copyWithWrapped({
    Wrapped<bool>? enabled,
    Wrapped<String?>? phoneNumber,
  }) {
    return SetPhoneDto(
      enabled: (enabled != null ? enabled.value : this.enabled),
      phoneNumber: (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyEmailDto {
  const VerifyEmailDto({required this.verificationCode});

  factory VerifyEmailDto.fromJson(Map<String, dynamic> json) =>
      _$VerifyEmailDtoFromJson(json);

  static const toJsonFactory = _$VerifyEmailDtoToJson;
  Map<String, dynamic> toJson() => _$VerifyEmailDtoToJson(this);

  @JsonKey(name: 'verificationCode')
  final String verificationCode;
  static const fromJsonFactory = _$VerifyEmailDtoFromJson;
}

extension $VerifyEmailDtoExtension on VerifyEmailDto {
  VerifyEmailDto copyWith({String? verificationCode}) {
    return VerifyEmailDto(
      verificationCode: verificationCode ?? this.verificationCode,
    );
  }

  VerifyEmailDto copyWithWrapped({Wrapped<String>? verificationCode}) {
    return VerifyEmailDto(
      verificationCode: (verificationCode != null
          ? verificationCode.value
          : this.verificationCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradesilvaniaSignature {
  const TradesilvaniaSignature({required this.url});

  factory TradesilvaniaSignature.fromJson(Map<String, dynamic> json) =>
      _$TradesilvaniaSignatureFromJson(json);

  static const toJsonFactory = _$TradesilvaniaSignatureToJson;
  Map<String, dynamic> toJson() => _$TradesilvaniaSignatureToJson(this);

  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$TradesilvaniaSignatureFromJson;
}

extension $TradesilvaniaSignatureExtension on TradesilvaniaSignature {
  TradesilvaniaSignature copyWith({String? url}) {
    return TradesilvaniaSignature(url: url ?? this.url);
  }

  TradesilvaniaSignature copyWithWrapped({Wrapped<String>? url}) {
    return TradesilvaniaSignature(url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class UserProfileEditDto {
  const UserProfileEditDto({
    this.socials,
    this.description,
    this.isBoberBattleUser,
  });

  factory UserProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$UserProfileEditDtoFromJson(json);

  static const toJsonFactory = _$UserProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$UserProfileEditDtoToJson(this);

  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'isBoberBattleUser')
  final bool? isBoberBattleUser;
  static const fromJsonFactory = _$UserProfileEditDtoFromJson;
}

extension $UserProfileEditDtoExtension on UserProfileEditDto {
  UserProfileEditDto copyWith({
    SocialsDto? socials,
    String? description,
    bool? isBoberBattleUser,
  }) {
    return UserProfileEditDto(
      socials: socials ?? this.socials,
      description: description ?? this.description,
      isBoberBattleUser: isBoberBattleUser ?? this.isBoberBattleUser,
    );
  }

  UserProfileEditDto copyWithWrapped({
    Wrapped<SocialsDto?>? socials,
    Wrapped<String?>? description,
    Wrapped<bool?>? isBoberBattleUser,
  }) {
    return UserProfileEditDto(
      socials: (socials != null ? socials.value : this.socials),
      description: (description != null ? description.value : this.description),
      isBoberBattleUser: (isBoberBattleUser != null
          ? isBoberBattleUser.value
          : this.isBoberBattleUser),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuccessDto {
  const SuccessDto({required this.success});

  factory SuccessDto.fromJson(Map<String, dynamic> json) =>
      _$SuccessDtoFromJson(json);

  static const toJsonFactory = _$SuccessDtoToJson;
  Map<String, dynamic> toJson() => _$SuccessDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  static const fromJsonFactory = _$SuccessDtoFromJson;
}

extension $SuccessDtoExtension on SuccessDto {
  SuccessDto copyWith({bool? success}) {
    return SuccessDto(success: success ?? this.success);
  }

  SuccessDto copyWithWrapped({Wrapped<bool>? success}) {
    return SuccessDto(
      success: (success != null ? success.value : this.success),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorProfileDto {
  const CreatorProfileDto({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    this.joinedDate,
    this.description,
    required this.socials,
    this.id,
    this.ts,
    required this.followCount,
  });

  factory CreatorProfileDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorProfileDtoFromJson(json);

  static const toJsonFactory = _$CreatorProfileDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorProfileDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorProfileDtoDataTypeToJson,
    fromJson: creatorProfileDtoDataTypeFromJson,
  )
  final enums.CreatorProfileDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double? joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'followCount')
  final double followCount;
  static const fromJsonFactory = _$CreatorProfileDtoFromJson;
}

extension $CreatorProfileDtoExtension on CreatorProfileDto {
  CreatorProfileDto copyWith({
    enums.CreatorProfileDtoDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
    double? followCount,
  }) {
    return CreatorProfileDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      followCount: followCount ?? this.followCount,
    );
  }

  CreatorProfileDto copyWithWrapped({
    Wrapped<enums.CreatorProfileDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double?>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<double>? followCount,
  }) {
    return CreatorProfileDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorProfileDoc {
  const CreatorProfileDoc({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    this.joinedDate,
    this.description,
    required this.socials,
    this.id,
    this.ts,
  });

  factory CreatorProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$CreatorProfileDocFromJson(json);

  static const toJsonFactory = _$CreatorProfileDocToJson;
  Map<String, dynamic> toJson() => _$CreatorProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorProfileDocDataTypeToJson,
    fromJson: creatorProfileDocDataTypeFromJson,
  )
  final enums.CreatorProfileDocDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double? joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$CreatorProfileDocFromJson;
}

extension $CreatorProfileDocExtension on CreatorProfileDoc {
  CreatorProfileDoc copyWith({
    enums.CreatorProfileDocDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
  }) {
    return CreatorProfileDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  CreatorProfileDoc copyWithWrapped({
    Wrapped<enums.CreatorProfileDocDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double?>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
  }) {
    return CreatorProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RangeFilter {
  const RangeFilter({this.min, this.max, this.field});

  factory RangeFilter.fromJson(Map<String, dynamic> json) =>
      _$RangeFilterFromJson(json);

  static const toJsonFactory = _$RangeFilterToJson;
  Map<String, dynamic> toJson() => _$RangeFilterToJson(this);

  @JsonKey(name: 'min')
  final double? min;
  @JsonKey(name: 'max')
  final double? max;
  @JsonKey(name: 'field')
  final String? field;
  static const fromJsonFactory = _$RangeFilterFromJson;
}

extension $RangeFilterExtension on RangeFilter {
  RangeFilter copyWith({double? min, double? max, String? field}) {
    return RangeFilter(
      min: min ?? this.min,
      max: max ?? this.max,
      field: field ?? this.field,
    );
  }

  RangeFilter copyWithWrapped({
    Wrapped<double?>? min,
    Wrapped<double?>? max,
    Wrapped<String?>? field,
  }) {
    return RangeFilter(
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
      field: (field != null ? field.value : this.field),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsFilterCriteriaDto {
  const CollectionStatsFilterCriteriaDto({
    this.dataType,
    this.collection,
    this.verifiedOnly,
    this.range,
  });

  factory CollectionStatsFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionStatsFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$CollectionStatsFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionStatsFilterCriteriaDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionDataTypeNullableToJson,
    fromJson: collectionDataTypeNullableFromJson,
  )
  final enums.CollectionDataType? dataType;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'verifiedOnly')
  final bool? verifiedOnly;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$CollectionStatsFilterCriteriaDtoFromJson;
}

extension $CollectionStatsFilterCriteriaDtoExtension
    on CollectionStatsFilterCriteriaDto {
  CollectionStatsFilterCriteriaDto copyWith({
    enums.CollectionDataType? dataType,
    List<String>? collection,
    bool? verifiedOnly,
    List<RangeFilter>? range,
  }) {
    return CollectionStatsFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      verifiedOnly: verifiedOnly ?? this.verifiedOnly,
      range: range ?? this.range,
    );
  }

  CollectionStatsFilterCriteriaDto copyWithWrapped({
    Wrapped<enums.CollectionDataType?>? dataType,
    Wrapped<List<String>?>? collection,
    Wrapped<bool?>? verifiedOnly,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return CollectionStatsFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      verifiedOnly: (verifiedOnly != null
          ? verifiedOnly.value
          : this.verifiedOnly),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsFilter {
  const CollectionStatsFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory CollectionStatsFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsFilterFromJson(json);

  static const toJsonFactory = _$CollectionStatsFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final CollectionStatsFilterCriteriaDto filters;
  static const fromJsonFactory = _$CollectionStatsFilterFromJson;
}

extension $CollectionStatsFilterExtension on CollectionStatsFilter {
  CollectionStatsFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    CollectionStatsFilterCriteriaDto? filters,
  }) {
    return CollectionStatsFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  CollectionStatsFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<CollectionStatsFilterCriteriaDto>? filters,
  }) {
    return CollectionStatsFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AllTimeHigh {
  const AllTimeHigh({
    required this.price,
    required this.timestamp,
    required this.txHash,
    required this.identifier,
  });

  factory AllTimeHigh.fromJson(Map<String, dynamic> json) =>
      _$AllTimeHighFromJson(json);

  static const toJsonFactory = _$AllTimeHighToJson;
  Map<String, dynamic> toJson() => _$AllTimeHighToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$AllTimeHighFromJson;
}

extension $AllTimeHighExtension on AllTimeHigh {
  AllTimeHigh copyWith({
    double? price,
    double? timestamp,
    String? txHash,
    String? identifier,
  }) {
    return AllTimeHigh(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      identifier: identifier ?? this.identifier,
    );
  }

  AllTimeHigh copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? identifier,
  }) {
    return AllTimeHigh(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingDataSummary {
  const TradingDataSummary({
    required this.volume,
    required this.volumeMargin,
    required this.trades,
    required this.tradesMargin,
    this.minPrice,
    this.maxPrice,
    this.averagePrice,
  });

  factory TradingDataSummary.fromJson(Map<String, dynamic> json) =>
      _$TradingDataSummaryFromJson(json);

  static const toJsonFactory = _$TradingDataSummaryToJson;
  Map<String, dynamic> toJson() => _$TradingDataSummaryToJson(this);

  @JsonKey(name: 'volume')
  final double volume;
  @JsonKey(name: 'volumeMargin')
  final double volumeMargin;
  @JsonKey(name: 'trades')
  final double trades;
  @JsonKey(name: 'tradesMargin')
  final double tradesMargin;
  @JsonKey(name: 'minPrice')
  final double? minPrice;
  @JsonKey(name: 'maxPrice')
  final double? maxPrice;
  @JsonKey(name: 'averagePrice')
  final double? averagePrice;
  static const fromJsonFactory = _$TradingDataSummaryFromJson;
}

extension $TradingDataSummaryExtension on TradingDataSummary {
  TradingDataSummary copyWith({
    double? volume,
    double? volumeMargin,
    double? trades,
    double? tradesMargin,
    double? minPrice,
    double? maxPrice,
    double? averagePrice,
  }) {
    return TradingDataSummary(
      volume: volume ?? this.volume,
      volumeMargin: volumeMargin ?? this.volumeMargin,
      trades: trades ?? this.trades,
      tradesMargin: tradesMargin ?? this.tradesMargin,
      minPrice: minPrice ?? this.minPrice,
      maxPrice: maxPrice ?? this.maxPrice,
      averagePrice: averagePrice ?? this.averagePrice,
    );
  }

  TradingDataSummary copyWithWrapped({
    Wrapped<double>? volume,
    Wrapped<double>? volumeMargin,
    Wrapped<double>? trades,
    Wrapped<double>? tradesMargin,
    Wrapped<double?>? minPrice,
    Wrapped<double?>? maxPrice,
    Wrapped<double?>? averagePrice,
  }) {
    return TradingDataSummary(
      volume: (volume != null ? volume.value : this.volume),
      volumeMargin: (volumeMargin != null
          ? volumeMargin.value
          : this.volumeMargin),
      trades: (trades != null ? trades.value : this.trades),
      tradesMargin: (tradesMargin != null
          ? tradesMargin.value
          : this.tradesMargin),
      minPrice: (minPrice != null ? minPrice.value : this.minPrice),
      maxPrice: (maxPrice != null ? maxPrice.value : this.maxPrice),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingStatistics {
  const TradingStatistics({
    required this.totalVolume,
    required this.totalTrades,
    this.averagePrice,
    required this.allTimeHigh,
    required this.day,
    required this.week,
    required this.month,
    required this.quarter,
    required this.halfYear,
    required this.year,
  });

  factory TradingStatistics.fromJson(Map<String, dynamic> json) =>
      _$TradingStatisticsFromJson(json);

  static const toJsonFactory = _$TradingStatisticsToJson;
  Map<String, dynamic> toJson() => _$TradingStatisticsToJson(this);

  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'averagePrice')
  final double? averagePrice;
  @JsonKey(name: 'allTimeHigh')
  final AllTimeHigh allTimeHigh;
  @JsonKey(name: 'day')
  final TradingDataSummary day;
  @JsonKey(name: 'week')
  final TradingDataSummary week;
  @JsonKey(name: 'month')
  final TradingDataSummary month;
  @JsonKey(name: 'quarter')
  final TradingDataSummary quarter;
  @JsonKey(name: 'halfYear')
  final TradingDataSummary halfYear;
  @JsonKey(name: 'year')
  final TradingDataSummary year;
  static const fromJsonFactory = _$TradingStatisticsFromJson;
}

extension $TradingStatisticsExtension on TradingStatistics {
  TradingStatistics copyWith({
    double? totalVolume,
    double? totalTrades,
    double? averagePrice,
    AllTimeHigh? allTimeHigh,
    TradingDataSummary? day,
    TradingDataSummary? week,
    TradingDataSummary? month,
    TradingDataSummary? quarter,
    TradingDataSummary? halfYear,
    TradingDataSummary? year,
  }) {
    return TradingStatistics(
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      averagePrice: averagePrice ?? this.averagePrice,
      allTimeHigh: allTimeHigh ?? this.allTimeHigh,
      day: day ?? this.day,
      week: week ?? this.week,
      month: month ?? this.month,
      quarter: quarter ?? this.quarter,
      halfYear: halfYear ?? this.halfYear,
      year: year ?? this.year,
    );
  }

  TradingStatistics copyWithWrapped({
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double?>? averagePrice,
    Wrapped<AllTimeHigh>? allTimeHigh,
    Wrapped<TradingDataSummary>? day,
    Wrapped<TradingDataSummary>? week,
    Wrapped<TradingDataSummary>? month,
    Wrapped<TradingDataSummary>? quarter,
    Wrapped<TradingDataSummary>? halfYear,
    Wrapped<TradingDataSummary>? year,
  }) {
    return TradingStatistics(
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
      allTimeHigh: (allTimeHigh != null ? allTimeHigh.value : this.allTimeHigh),
      day: (day != null ? day.value : this.day),
      week: (week != null ? week.value : this.week),
      month: (month != null ? month.value : this.month),
      quarter: (quarter != null ? quarter.value : this.quarter),
      halfYear: (halfYear != null ? halfYear.value : this.halfYear),
      year: (year != null ? year.value : this.year),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCollectionInfoDoc {
  const ShortCollectionInfoDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.socials,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.owner,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
    required this.volume,
  });

  factory ShortCollectionInfoDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCollectionInfoDocFromJson(json);

  static const toJsonFactory = _$ShortCollectionInfoDocToJson;
  Map<String, dynamic> toJson() => _$ShortCollectionInfoDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: shortCollectionInfoDocChainToJson,
    fromJson: shortCollectionInfoDocChainFromJson,
  )
  final enums.ShortCollectionInfoDocChain chain;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  @JsonKey(name: 'volume')
  final double volume;
  static const fromJsonFactory = _$ShortCollectionInfoDocFromJson;
}

extension $ShortCollectionInfoDocExtension on ShortCollectionInfoDoc {
  ShortCollectionInfoDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    SocialsDto? socials,
    String? profile,
    String? banner,
    enums.ShortCollectionInfoDocChain? chain,
    String? owner,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
    double? volume,
  }) {
    return ShortCollectionInfoDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      owner: owner ?? this.owner,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
      volume: volume ?? this.volume,
    );
  }

  ShortCollectionInfoDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.ShortCollectionInfoDocChain>? chain,
    Wrapped<String>? owner,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
    Wrapped<double>? volume,
  }) {
    return ShortCollectionInfoDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      owner: (owner != null ? owner.value : this.owner),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
      volume: (volume != null ? volume.value : this.volume),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsDocHydrated {
  const CollectionStatsDocHydrated({
    required this.dataType,
    required this.collection,
    this.floorPrice,
    required this.listedCount,
    required this.tradingStats,
    required this.chain,
    required this.ts,
    required this.id,
    this.collectionInfo,
  });

  factory CollectionStatsDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsDocHydratedFromJson(json);

  static const toJsonFactory = _$CollectionStatsDocHydratedToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsDocHydratedToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'floorPrice')
  final double? floorPrice;
  @JsonKey(name: 'listedCount')
  final double listedCount;
  @JsonKey(name: 'tradingStats')
  final TradingStatistics tradingStats;
  @JsonKey(
    name: 'chain',
    toJson: collectionStatsDocHydratedChainToJson,
    fromJson: collectionStatsDocHydratedChainFromJson,
  )
  final enums.CollectionStatsDocHydratedChain chain;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc? collectionInfo;
  static const fromJsonFactory = _$CollectionStatsDocHydratedFromJson;
}

extension $CollectionStatsDocHydratedExtension on CollectionStatsDocHydrated {
  CollectionStatsDocHydrated copyWith({
    Object? dataType,
    String? collection,
    double? floorPrice,
    double? listedCount,
    TradingStatistics? tradingStats,
    enums.CollectionStatsDocHydratedChain? chain,
    double? ts,
    String? id,
    ShortCollectionInfoDoc? collectionInfo,
  }) {
    return CollectionStatsDocHydrated(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      floorPrice: floorPrice ?? this.floorPrice,
      listedCount: listedCount ?? this.listedCount,
      tradingStats: tradingStats ?? this.tradingStats,
      chain: chain ?? this.chain,
      ts: ts ?? this.ts,
      id: id ?? this.id,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  CollectionStatsDocHydrated copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? collection,
    Wrapped<double?>? floorPrice,
    Wrapped<double>? listedCount,
    Wrapped<TradingStatistics>? tradingStats,
    Wrapped<enums.CollectionStatsDocHydratedChain>? chain,
    Wrapped<double>? ts,
    Wrapped<String>? id,
    Wrapped<ShortCollectionInfoDoc?>? collectionInfo,
  }) {
    return CollectionStatsDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      listedCount: (listedCount != null ? listedCount.value : this.listedCount),
      tradingStats: (tradingStats != null
          ? tradingStats.value
          : this.tradingStats),
      chain: (chain != null ? chain.value : this.chain),
      ts: (ts != null ? ts.value : this.ts),
      id: (id != null ? id.value : this.id),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionStatsPaginated {
  const CollectionStatsPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionStatsPaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionStatsPaginatedFromJson(json);

  static const toJsonFactory = _$CollectionStatsPaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionStatsPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <CollectionStatsDocHydrated>[])
  final List<CollectionStatsDocHydrated> resources;
  static const fromJsonFactory = _$CollectionStatsPaginatedFromJson;
}

extension $CollectionStatsPaginatedExtension on CollectionStatsPaginated {
  CollectionStatsPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionStatsDocHydrated>? resources,
  }) {
    return CollectionStatsPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionStatsPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionStatsDocHydrated>>? resources,
  }) {
    return CollectionStatsPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CheckLikeStatusResponseDto {
  const CheckLikeStatusResponseDto({required this.isFavorite});

  factory CheckLikeStatusResponseDto.fromJson(Map<String, dynamic> json) =>
      _$CheckLikeStatusResponseDtoFromJson(json);

  static const toJsonFactory = _$CheckLikeStatusResponseDtoToJson;
  Map<String, dynamic> toJson() => _$CheckLikeStatusResponseDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  static const fromJsonFactory = _$CheckLikeStatusResponseDtoFromJson;
}

extension $CheckLikeStatusResponseDtoExtension on CheckLikeStatusResponseDto {
  CheckLikeStatusResponseDto copyWith({bool? isFavorite}) {
    return CheckLikeStatusResponseDto(
      isFavorite: isFavorite ?? this.isFavorite,
    );
  }

  CheckLikeStatusResponseDto copyWithWrapped({Wrapped<bool>? isFavorite}) {
    return CheckLikeStatusResponseDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserFavoriteResponseDto {
  const UserFavoriteResponseDto({
    required this.isFavorite,
    required this.addressFavorite,
  });

  factory UserFavoriteResponseDto.fromJson(Map<String, dynamic> json) =>
      _$UserFavoriteResponseDtoFromJson(json);

  static const toJsonFactory = _$UserFavoriteResponseDtoToJson;
  Map<String, dynamic> toJson() => _$UserFavoriteResponseDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'addressFavorite')
  final String addressFavorite;
  static const fromJsonFactory = _$UserFavoriteResponseDtoFromJson;
}

extension $UserFavoriteResponseDtoExtension on UserFavoriteResponseDto {
  UserFavoriteResponseDto copyWith({
    bool? isFavorite,
    String? addressFavorite,
  }) {
    return UserFavoriteResponseDto(
      isFavorite: isFavorite ?? this.isFavorite,
      addressFavorite: addressFavorite ?? this.addressFavorite,
    );
  }

  UserFavoriteResponseDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String>? addressFavorite,
  }) {
    return UserFavoriteResponseDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      addressFavorite: (addressFavorite != null
          ? addressFavorite.value
          : this.addressFavorite),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TokenDataDocHydrated {
  const TokenDataDocHydrated({
    required this.identifier,
    required this.decimals,
    required this.ticker,
    required this.name,
    required this.svgUrl,
    required this.pngUrl,
    required this.chain,
    required this.id,
    required this.collection,
    required this.dataType,
    required this.type,
    required this.category,
    required this.ts,
    required this.usdPrice,
  });

  factory TokenDataDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$TokenDataDocHydratedFromJson(json);

  static const toJsonFactory = _$TokenDataDocHydratedToJson;
  Map<String, dynamic> toJson() => _$TokenDataDocHydratedToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final int decimals;
  @JsonKey(name: 'ticker')
  final String ticker;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'svgUrl')
  final String svgUrl;
  @JsonKey(name: 'pngUrl')
  final String pngUrl;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainChainFromJson,
  )
  final enums.ActivityChain chain;
  static enums.ActivityChain activityChainChainFromJson(Object? value) =>
      activityChainFromJson(value, enums.ActivityChain.mvx);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.fungibletokenprofile);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String> category;
  @JsonKey(name: '_ts')
  final int ts;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  static const fromJsonFactory = _$TokenDataDocHydratedFromJson;
}

extension $TokenDataDocHydratedExtension on TokenDataDocHydrated {
  TokenDataDocHydrated copyWith({
    String? identifier,
    int? decimals,
    String? ticker,
    String? name,
    String? svgUrl,
    String? pngUrl,
    enums.ActivityChain? chain,
    String? id,
    String? collection,
    enums.TokenDataType? dataType,
    String? type,
    List<String>? category,
    int? ts,
    double? usdPrice,
  }) {
    return TokenDataDocHydrated(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      ticker: ticker ?? this.ticker,
      name: name ?? this.name,
      svgUrl: svgUrl ?? this.svgUrl,
      pngUrl: pngUrl ?? this.pngUrl,
      chain: chain ?? this.chain,
      id: id ?? this.id,
      collection: collection ?? this.collection,
      dataType: dataType ?? this.dataType,
      type: type ?? this.type,
      category: category ?? this.category,
      ts: ts ?? this.ts,
      usdPrice: usdPrice ?? this.usdPrice,
    );
  }

  TokenDataDocHydrated copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<int>? decimals,
    Wrapped<String>? ticker,
    Wrapped<String>? name,
    Wrapped<String>? svgUrl,
    Wrapped<String>? pngUrl,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String>? id,
    Wrapped<String>? collection,
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? type,
    Wrapped<List<String>>? category,
    Wrapped<int>? ts,
    Wrapped<double>? usdPrice,
  }) {
    return TokenDataDocHydrated(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      ticker: (ticker != null ? ticker.value : this.ticker),
      name: (name != null ? name.value : this.name),
      svgUrl: (svgUrl != null ? svgUrl.value : this.svgUrl),
      pngUrl: (pngUrl != null ? pngUrl.value : this.pngUrl),
      chain: (chain != null ? chain.value : this.chain),
      id: (id != null ? id.value : this.id),
      collection: (collection != null ? collection.value : this.collection),
      dataType: (dataType != null ? dataType.value : this.dataType),
      type: (type != null ? type.value : this.type),
      category: (category != null ? category.value : this.category),
      ts: (ts != null ? ts.value : this.ts),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoInfo {
  const XoxnoInfo({
    required this.price,
    required this.marketCap,
    required this.fdv,
    required this.tradeVol,
    required this.supply,
    required this.burnedShort,
    required this.circulatingSupply,
    required this.holdersCount,
    required this.totalSupply,
    required this.idoPrice,
    required this.listingDate,
  });

  factory XoxnoInfo.fromJson(Map<String, dynamic> json) =>
      _$XoxnoInfoFromJson(json);

  static const toJsonFactory = _$XoxnoInfoToJson;
  Map<String, dynamic> toJson() => _$XoxnoInfoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'marketCap')
  final double marketCap;
  @JsonKey(name: 'fdv')
  final double fdv;
  @JsonKey(name: 'tradeVol')
  final double tradeVol;
  @JsonKey(name: 'supply')
  final double supply;
  @JsonKey(name: 'burnedShort')
  final double burnedShort;
  @JsonKey(name: 'circulatingSupply')
  final double circulatingSupply;
  @JsonKey(name: 'holdersCount')
  final double holdersCount;
  @JsonKey(name: 'totalSupply')
  final double totalSupply;
  @JsonKey(name: 'idoPrice')
  final double idoPrice;
  @JsonKey(name: 'listingDate')
  final DateTime listingDate;
  static const fromJsonFactory = _$XoxnoInfoFromJson;
}

extension $XoxnoInfoExtension on XoxnoInfo {
  XoxnoInfo copyWith({
    double? price,
    double? marketCap,
    double? fdv,
    double? tradeVol,
    double? supply,
    double? burnedShort,
    double? circulatingSupply,
    double? holdersCount,
    double? totalSupply,
    double? idoPrice,
    DateTime? listingDate,
  }) {
    return XoxnoInfo(
      price: price ?? this.price,
      marketCap: marketCap ?? this.marketCap,
      fdv: fdv ?? this.fdv,
      tradeVol: tradeVol ?? this.tradeVol,
      supply: supply ?? this.supply,
      burnedShort: burnedShort ?? this.burnedShort,
      circulatingSupply: circulatingSupply ?? this.circulatingSupply,
      holdersCount: holdersCount ?? this.holdersCount,
      totalSupply: totalSupply ?? this.totalSupply,
      idoPrice: idoPrice ?? this.idoPrice,
      listingDate: listingDate ?? this.listingDate,
    );
  }

  XoxnoInfo copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? marketCap,
    Wrapped<double>? fdv,
    Wrapped<double>? tradeVol,
    Wrapped<double>? supply,
    Wrapped<double>? burnedShort,
    Wrapped<double>? circulatingSupply,
    Wrapped<double>? holdersCount,
    Wrapped<double>? totalSupply,
    Wrapped<double>? idoPrice,
    Wrapped<DateTime>? listingDate,
  }) {
    return XoxnoInfo(
      price: (price != null ? price.value : this.price),
      marketCap: (marketCap != null ? marketCap.value : this.marketCap),
      fdv: (fdv != null ? fdv.value : this.fdv),
      tradeVol: (tradeVol != null ? tradeVol.value : this.tradeVol),
      supply: (supply != null ? supply.value : this.supply),
      burnedShort: (burnedShort != null ? burnedShort.value : this.burnedShort),
      circulatingSupply: (circulatingSupply != null
          ? circulatingSupply.value
          : this.circulatingSupply),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      totalSupply: (totalSupply != null ? totalSupply.value : this.totalSupply),
      idoPrice: (idoPrice != null ? idoPrice.value : this.idoPrice),
      listingDate: (listingDate != null ? listingDate.value : this.listingDate),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RateType {
  const RateType({
    required this.rateShort,
    required this.rate,
    required this.reverseRate,
    required this.reverseRateShort,
  });

  factory RateType.fromJson(Map<String, dynamic> json) =>
      _$RateTypeFromJson(json);

  static const toJsonFactory = _$RateTypeToJson;
  Map<String, dynamic> toJson() => _$RateTypeToJson(this);

  @JsonKey(name: 'rateShort')
  final double rateShort;
  @JsonKey(name: 'rate')
  final String rate;
  @JsonKey(name: 'reverseRate')
  final String reverseRate;
  @JsonKey(name: 'reverseRateShort')
  final double reverseRateShort;
  static const fromJsonFactory = _$RateTypeFromJson;
}

extension $RateTypeExtension on RateType {
  RateType copyWith({
    double? rateShort,
    String? rate,
    String? reverseRate,
    double? reverseRateShort,
  }) {
    return RateType(
      rateShort: rateShort ?? this.rateShort,
      rate: rate ?? this.rate,
      reverseRate: reverseRate ?? this.reverseRate,
      reverseRateShort: reverseRateShort ?? this.reverseRateShort,
    );
  }

  RateType copyWithWrapped({
    Wrapped<double>? rateShort,
    Wrapped<String>? rate,
    Wrapped<String>? reverseRate,
    Wrapped<double>? reverseRateShort,
  }) {
    return RateType(
      rateShort: (rateShort != null ? rateShort.value : this.rateShort),
      rate: (rate != null ? rate.value : this.rate),
      reverseRate: (reverseRate != null ? reverseRate.value : this.reverseRate),
      reverseRateShort: (reverseRateShort != null
          ? reverseRateShort.value
          : this.reverseRateShort),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoLiquidStatsDto {
  const XoxnoLiquidStatsDto({
    required this.participants,
    required this.totalRewards,
    required this.totalStaked,
    required this.yearlyAPR,
    this.apy,
    required this.totalRewardsUsdValue,
    required this.totalStakedUsdValue,
    required this.rateInfo,
    required this.serviceFee,
    required this.instantUnstake,
    required this.instantPendingUnstake,
  });

  factory XoxnoLiquidStatsDto.fromJson(Map<String, dynamic> json) =>
      _$XoxnoLiquidStatsDtoFromJson(json);

  static const toJsonFactory = _$XoxnoLiquidStatsDtoToJson;
  Map<String, dynamic> toJson() => _$XoxnoLiquidStatsDtoToJson(this);

  @JsonKey(name: 'participants')
  final double participants;
  @JsonKey(name: 'totalRewards')
  final double totalRewards;
  @JsonKey(name: 'totalStaked')
  final double totalStaked;
  @JsonKey(name: 'yearlyAPR')
  final double yearlyAPR;
  @JsonKey(name: 'apy')
  final double? apy;
  @JsonKey(name: 'totalRewardsUsdValue')
  final double totalRewardsUsdValue;
  @JsonKey(name: 'totalStakedUsdValue')
  final double totalStakedUsdValue;
  @JsonKey(name: 'rateInfo')
  final RateType rateInfo;
  @JsonKey(name: 'serviceFee')
  final double serviceFee;
  @JsonKey(name: 'instantUnstake')
  final String instantUnstake;
  @JsonKey(name: 'instantPendingUnstake')
  final String instantPendingUnstake;
  static const fromJsonFactory = _$XoxnoLiquidStatsDtoFromJson;
}

extension $XoxnoLiquidStatsDtoExtension on XoxnoLiquidStatsDto {
  XoxnoLiquidStatsDto copyWith({
    double? participants,
    double? totalRewards,
    double? totalStaked,
    double? yearlyAPR,
    double? apy,
    double? totalRewardsUsdValue,
    double? totalStakedUsdValue,
    RateType? rateInfo,
    double? serviceFee,
    String? instantUnstake,
    String? instantPendingUnstake,
  }) {
    return XoxnoLiquidStatsDto(
      participants: participants ?? this.participants,
      totalRewards: totalRewards ?? this.totalRewards,
      totalStaked: totalStaked ?? this.totalStaked,
      yearlyAPR: yearlyAPR ?? this.yearlyAPR,
      apy: apy ?? this.apy,
      totalRewardsUsdValue: totalRewardsUsdValue ?? this.totalRewardsUsdValue,
      totalStakedUsdValue: totalStakedUsdValue ?? this.totalStakedUsdValue,
      rateInfo: rateInfo ?? this.rateInfo,
      serviceFee: serviceFee ?? this.serviceFee,
      instantUnstake: instantUnstake ?? this.instantUnstake,
      instantPendingUnstake:
          instantPendingUnstake ?? this.instantPendingUnstake,
    );
  }

  XoxnoLiquidStatsDto copyWithWrapped({
    Wrapped<double>? participants,
    Wrapped<double>? totalRewards,
    Wrapped<double>? totalStaked,
    Wrapped<double>? yearlyAPR,
    Wrapped<double?>? apy,
    Wrapped<double>? totalRewardsUsdValue,
    Wrapped<double>? totalStakedUsdValue,
    Wrapped<RateType>? rateInfo,
    Wrapped<double>? serviceFee,
    Wrapped<String>? instantUnstake,
    Wrapped<String>? instantPendingUnstake,
  }) {
    return XoxnoLiquidStatsDto(
      participants: (participants != null
          ? participants.value
          : this.participants),
      totalRewards: (totalRewards != null
          ? totalRewards.value
          : this.totalRewards),
      totalStaked: (totalStaked != null ? totalStaked.value : this.totalStaked),
      yearlyAPR: (yearlyAPR != null ? yearlyAPR.value : this.yearlyAPR),
      apy: (apy != null ? apy.value : this.apy),
      totalRewardsUsdValue: (totalRewardsUsdValue != null
          ? totalRewardsUsdValue.value
          : this.totalRewardsUsdValue),
      totalStakedUsdValue: (totalStakedUsdValue != null
          ? totalStakedUsdValue.value
          : this.totalStakedUsdValue),
      rateInfo: (rateInfo != null ? rateInfo.value : this.rateInfo),
      serviceFee: (serviceFee != null ? serviceFee.value : this.serviceFee),
      instantUnstake: (instantUnstake != null
          ? instantUnstake.value
          : this.instantUnstake),
      instantPendingUnstake: (instantPendingUnstake != null
          ? instantPendingUnstake.value
          : this.instantPendingUnstake),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsMarketplaceUniqueUsers {
  const AnalyticsMarketplaceUniqueUsers({
    required this.day,
    required this.uniqueUsers,
    required this.uniqueBuyers,
    required this.uniqueSellers,
  });

  factory AnalyticsMarketplaceUniqueUsers.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsMarketplaceUniqueUsersFromJson(json);

  static const toJsonFactory = _$AnalyticsMarketplaceUniqueUsersToJson;
  Map<String, dynamic> toJson() =>
      _$AnalyticsMarketplaceUniqueUsersToJson(this);

  @JsonKey(name: 'Day')
  final DateTime day;
  @JsonKey(name: 'UniqueUsers')
  final int uniqueUsers;
  @JsonKey(name: 'UniqueBuyers')
  final int uniqueBuyers;
  @JsonKey(name: 'UniqueSellers')
  final int uniqueSellers;
  static const fromJsonFactory = _$AnalyticsMarketplaceUniqueUsersFromJson;
}

extension $AnalyticsMarketplaceUniqueUsersExtension
    on AnalyticsMarketplaceUniqueUsers {
  AnalyticsMarketplaceUniqueUsers copyWith({
    DateTime? day,
    int? uniqueUsers,
    int? uniqueBuyers,
    int? uniqueSellers,
  }) {
    return AnalyticsMarketplaceUniqueUsers(
      day: day ?? this.day,
      uniqueUsers: uniqueUsers ?? this.uniqueUsers,
      uniqueBuyers: uniqueBuyers ?? this.uniqueBuyers,
      uniqueSellers: uniqueSellers ?? this.uniqueSellers,
    );
  }

  AnalyticsMarketplaceUniqueUsers copyWithWrapped({
    Wrapped<DateTime>? day,
    Wrapped<int>? uniqueUsers,
    Wrapped<int>? uniqueBuyers,
    Wrapped<int>? uniqueSellers,
  }) {
    return AnalyticsMarketplaceUniqueUsers(
      day: (day != null ? day.value : this.day),
      uniqueUsers: (uniqueUsers != null ? uniqueUsers.value : this.uniqueUsers),
      uniqueBuyers: (uniqueBuyers != null
          ? uniqueBuyers.value
          : this.uniqueBuyers),
      uniqueSellers: (uniqueSellers != null
          ? uniqueSellers.value
          : this.uniqueSellers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ProtocolAprType {
  const ProtocolAprType({required this.apr, this.apy});

  factory ProtocolAprType.fromJson(Map<String, dynamic> json) =>
      _$ProtocolAprTypeFromJson(json);

  static const toJsonFactory = _$ProtocolAprTypeToJson;
  Map<String, dynamic> toJson() => _$ProtocolAprTypeToJson(this);

  @JsonKey(name: 'apr')
  final double apr;
  @JsonKey(name: 'apy')
  final double? apy;
  static const fromJsonFactory = _$ProtocolAprTypeFromJson;
}

extension $ProtocolAprTypeExtension on ProtocolAprType {
  ProtocolAprType copyWith({double? apr, double? apy}) {
    return ProtocolAprType(apr: apr ?? this.apr, apy: apy ?? this.apy);
  }

  ProtocolAprType copyWithWrapped({
    Wrapped<double>? apr,
    Wrapped<double?>? apy,
  }) {
    return ProtocolAprType(
      apr: (apr != null ? apr.value : this.apr),
      apy: (apy != null ? apy.value : this.apy),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ProviderDto {
  const ProviderDto({
    required this.address,
    this.profile,
    this.name,
    this.delegationCap,
    this.nodes,
    this.apr,
    this.identity,
    required this.totalStaked,
    required this.protocolStakedAmount,
  });

  factory ProviderDto.fromJson(Map<String, dynamic> json) =>
      _$ProviderDtoFromJson(json);

  static const toJsonFactory = _$ProviderDtoToJson;
  Map<String, dynamic> toJson() => _$ProviderDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'delegationCap')
  final double? delegationCap;
  @JsonKey(name: 'nodes')
  final double? nodes;
  @JsonKey(name: 'apr')
  final double? apr;
  @JsonKey(name: 'identity')
  final String? identity;
  @JsonKey(name: 'totalStaked')
  final double totalStaked;
  @JsonKey(name: 'protocolStakedAmount')
  final double protocolStakedAmount;
  static const fromJsonFactory = _$ProviderDtoFromJson;
}

extension $ProviderDtoExtension on ProviderDto {
  ProviderDto copyWith({
    String? address,
    String? profile,
    String? name,
    double? delegationCap,
    double? nodes,
    double? apr,
    String? identity,
    double? totalStaked,
    double? protocolStakedAmount,
  }) {
    return ProviderDto(
      address: address ?? this.address,
      profile: profile ?? this.profile,
      name: name ?? this.name,
      delegationCap: delegationCap ?? this.delegationCap,
      nodes: nodes ?? this.nodes,
      apr: apr ?? this.apr,
      identity: identity ?? this.identity,
      totalStaked: totalStaked ?? this.totalStaked,
      protocolStakedAmount: protocolStakedAmount ?? this.protocolStakedAmount,
    );
  }

  ProviderDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String?>? profile,
    Wrapped<String?>? name,
    Wrapped<double?>? delegationCap,
    Wrapped<double?>? nodes,
    Wrapped<double?>? apr,
    Wrapped<String?>? identity,
    Wrapped<double>? totalStaked,
    Wrapped<double>? protocolStakedAmount,
  }) {
    return ProviderDto(
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
      name: (name != null ? name.value : this.name),
      delegationCap: (delegationCap != null
          ? delegationCap.value
          : this.delegationCap),
      nodes: (nodes != null ? nodes.value : this.nodes),
      apr: (apr != null ? apr.value : this.apr),
      identity: (identity != null ? identity.value : this.identity),
      totalStaked: (totalStaked != null ? totalStaked.value : this.totalStaked),
      protocolStakedAmount: (protocolStakedAmount != null
          ? protocolStakedAmount.value
          : this.protocolStakedAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DelegationDataOutput {
  const DelegationDataOutput({
    required this.address,
    required this.contract,
    required this.activeStake,
    required this.activeStakeShort,
    required this.unDelegateInfo,
    required this.claimableRewards,
    required this.claimableRewardsShort,
    required this.totalUnbondEligible,
  });

  factory DelegationDataOutput.fromJson(Map<String, dynamic> json) =>
      _$DelegationDataOutputFromJson(json);

  static const toJsonFactory = _$DelegationDataOutputToJson;
  Map<String, dynamic> toJson() => _$DelegationDataOutputToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'contract')
  final String contract;
  @JsonKey(name: 'activeStake')
  final String activeStake;
  @JsonKey(name: 'activeStakeShort')
  final double activeStakeShort;
  @JsonKey(name: 'unDelegateInfo', defaultValue: <List<Object?>>[])
  final List<List<Object?>> unDelegateInfo;
  @JsonKey(name: 'claimableRewards')
  final double claimableRewards;
  @JsonKey(name: 'claimableRewardsShort')
  final double claimableRewardsShort;
  @JsonKey(name: 'totalUnbondEligible')
  final String totalUnbondEligible;
  static const fromJsonFactory = _$DelegationDataOutputFromJson;
}

extension $DelegationDataOutputExtension on DelegationDataOutput {
  DelegationDataOutput copyWith({
    String? address,
    String? contract,
    String? activeStake,
    double? activeStakeShort,
    List<List<Object?>>? unDelegateInfo,
    double? claimableRewards,
    double? claimableRewardsShort,
    String? totalUnbondEligible,
  }) {
    return DelegationDataOutput(
      address: address ?? this.address,
      contract: contract ?? this.contract,
      activeStake: activeStake ?? this.activeStake,
      activeStakeShort: activeStakeShort ?? this.activeStakeShort,
      unDelegateInfo: unDelegateInfo ?? this.unDelegateInfo,
      claimableRewards: claimableRewards ?? this.claimableRewards,
      claimableRewardsShort:
          claimableRewardsShort ?? this.claimableRewardsShort,
      totalUnbondEligible: totalUnbondEligible ?? this.totalUnbondEligible,
    );
  }

  DelegationDataOutput copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? contract,
    Wrapped<String>? activeStake,
    Wrapped<double>? activeStakeShort,
    Wrapped<List<List<Object?>>>? unDelegateInfo,
    Wrapped<double>? claimableRewards,
    Wrapped<double>? claimableRewardsShort,
    Wrapped<String>? totalUnbondEligible,
  }) {
    return DelegationDataOutput(
      address: (address != null ? address.value : this.address),
      contract: (contract != null ? contract.value : this.contract),
      activeStake: (activeStake != null ? activeStake.value : this.activeStake),
      activeStakeShort: (activeStakeShort != null
          ? activeStakeShort.value
          : this.activeStakeShort),
      unDelegateInfo: (unDelegateInfo != null
          ? unDelegateInfo.value
          : this.unDelegateInfo),
      claimableRewards: (claimableRewards != null
          ? claimableRewards.value
          : this.claimableRewards),
      claimableRewardsShort: (claimableRewardsShort != null
          ? claimableRewardsShort.value
          : this.claimableRewardsShort),
      totalUnbondEligible: (totalUnbondEligible != null
          ? totalUnbondEligible.value
          : this.totalUnbondEligible),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SwapDto {
  const SwapDto({
    required this.poolId,
    required this.assetInIndex,
    required this.assetOutIndex,
    required this.amount,
    required this.returnAmount,
    required this.assetIn,
    required this.assetOut,
    required this.functionName,
    required this.arguments,
  });

  factory SwapDto.fromJson(Map<String, dynamic> json) =>
      _$SwapDtoFromJson(json);

  static const toJsonFactory = _$SwapDtoToJson;
  Map<String, dynamic> toJson() => _$SwapDtoToJson(this);

  @JsonKey(name: 'poolId')
  final String poolId;
  @JsonKey(name: 'assetInIndex')
  final double assetInIndex;
  @JsonKey(name: 'assetOutIndex')
  final double assetOutIndex;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'returnAmount')
  final String returnAmount;
  @JsonKey(name: 'assetIn')
  final String assetIn;
  @JsonKey(name: 'assetOut')
  final String assetOut;
  @JsonKey(name: 'functionName')
  final String functionName;
  @JsonKey(name: 'arguments', defaultValue: <List<Object?>>[])
  final List<List<Object?>> arguments;
  static const fromJsonFactory = _$SwapDtoFromJson;
}

extension $SwapDtoExtension on SwapDto {
  SwapDto copyWith({
    String? poolId,
    double? assetInIndex,
    double? assetOutIndex,
    String? amount,
    String? returnAmount,
    String? assetIn,
    String? assetOut,
    String? functionName,
    List<List<Object?>>? arguments,
  }) {
    return SwapDto(
      poolId: poolId ?? this.poolId,
      assetInIndex: assetInIndex ?? this.assetInIndex,
      assetOutIndex: assetOutIndex ?? this.assetOutIndex,
      amount: amount ?? this.amount,
      returnAmount: returnAmount ?? this.returnAmount,
      assetIn: assetIn ?? this.assetIn,
      assetOut: assetOut ?? this.assetOut,
      functionName: functionName ?? this.functionName,
      arguments: arguments ?? this.arguments,
    );
  }

  SwapDto copyWithWrapped({
    Wrapped<String>? poolId,
    Wrapped<double>? assetInIndex,
    Wrapped<double>? assetOutIndex,
    Wrapped<String>? amount,
    Wrapped<String>? returnAmount,
    Wrapped<String>? assetIn,
    Wrapped<String>? assetOut,
    Wrapped<String>? functionName,
    Wrapped<List<List<Object?>>>? arguments,
  }) {
    return SwapDto(
      poolId: (poolId != null ? poolId.value : this.poolId),
      assetInIndex: (assetInIndex != null
          ? assetInIndex.value
          : this.assetInIndex),
      assetOutIndex: (assetOutIndex != null
          ? assetOutIndex.value
          : this.assetOutIndex),
      amount: (amount != null ? amount.value : this.amount),
      returnAmount: (returnAmount != null
          ? returnAmount.value
          : this.returnAmount),
      assetIn: (assetIn != null ? assetIn.value : this.assetIn),
      assetOut: (assetOut != null ? assetOut.value : this.assetOut),
      functionName: (functionName != null
          ? functionName.value
          : this.functionName),
      arguments: (arguments != null ? arguments.value : this.arguments),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AshTokenDto {
  const AshTokenDto({required this.address, required this.decimal});

  factory AshTokenDto.fromJson(Map<String, dynamic> json) =>
      _$AshTokenDtoFromJson(json);

  static const toJsonFactory = _$AshTokenDtoToJson;
  Map<String, dynamic> toJson() => _$AshTokenDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'decimal')
  final double decimal;
  static const fromJsonFactory = _$AshTokenDtoFromJson;
}

extension $AshTokenDtoExtension on AshTokenDto {
  AshTokenDto copyWith({String? address, double? decimal}) {
    return AshTokenDto(
      address: address ?? this.address,
      decimal: decimal ?? this.decimal,
    );
  }

  AshTokenDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? decimal,
  }) {
    return AshTokenDto(
      address: (address != null ? address.value : this.address),
      decimal: (decimal != null ? decimal.value : this.decimal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PoolDto {
  const PoolDto({required this.allTokens, required this.type});

  factory PoolDto.fromJson(Map<String, dynamic> json) =>
      _$PoolDtoFromJson(json);

  static const toJsonFactory = _$PoolDtoToJson;
  Map<String, dynamic> toJson() => _$PoolDtoToJson(this);

  @JsonKey(name: 'allTokens', defaultValue: <AshTokenDto>[])
  final List<AshTokenDto> allTokens;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$PoolDtoFromJson;
}

extension $PoolDtoExtension on PoolDto {
  PoolDto copyWith({List<AshTokenDto>? allTokens, String? type}) {
    return PoolDto(
      allTokens: allTokens ?? this.allTokens,
      type: type ?? this.type,
    );
  }

  PoolDto copyWithWrapped({
    Wrapped<List<AshTokenDto>>? allTokens,
    Wrapped<String>? type,
  }) {
    return PoolDto(
      allTokens: (allTokens != null ? allTokens.value : this.allTokens),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HopDto {
  const HopDto({
    required this.poolId,
    required this.pool,
    required this.tokenIn,
    required this.tokenInAmount,
    required this.tokenOut,
    required this.tokenOutAmount,
  });

  factory HopDto.fromJson(Map<String, dynamic> json) => _$HopDtoFromJson(json);

  static const toJsonFactory = _$HopDtoToJson;
  Map<String, dynamic> toJson() => _$HopDtoToJson(this);

  @JsonKey(name: 'poolId')
  final String poolId;
  @JsonKey(name: 'pool')
  final PoolDto pool;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenInAmount')
  final String tokenInAmount;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'tokenOutAmount')
  final String tokenOutAmount;
  static const fromJsonFactory = _$HopDtoFromJson;
}

extension $HopDtoExtension on HopDto {
  HopDto copyWith({
    String? poolId,
    PoolDto? pool,
    String? tokenIn,
    String? tokenInAmount,
    String? tokenOut,
    String? tokenOutAmount,
  }) {
    return HopDto(
      poolId: poolId ?? this.poolId,
      pool: pool ?? this.pool,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenInAmount: tokenInAmount ?? this.tokenInAmount,
      tokenOut: tokenOut ?? this.tokenOut,
      tokenOutAmount: tokenOutAmount ?? this.tokenOutAmount,
    );
  }

  HopDto copyWithWrapped({
    Wrapped<String>? poolId,
    Wrapped<PoolDto>? pool,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenInAmount,
    Wrapped<String>? tokenOut,
    Wrapped<String>? tokenOutAmount,
  }) {
    return HopDto(
      poolId: (poolId != null ? poolId.value : this.poolId),
      pool: (pool != null ? pool.value : this.pool),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenInAmount: (tokenInAmount != null
          ? tokenInAmount.value
          : this.tokenInAmount),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      tokenOutAmount: (tokenOutAmount != null
          ? tokenOutAmount.value
          : this.tokenOutAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RouteDto {
  const RouteDto({
    required this.hops,
    required this.tokenIn,
    required this.tokenInAmount,
    required this.tokenOut,
    required this.tokenOutAmount,
  });

  factory RouteDto.fromJson(Map<String, dynamic> json) =>
      _$RouteDtoFromJson(json);

  static const toJsonFactory = _$RouteDtoToJson;
  Map<String, dynamic> toJson() => _$RouteDtoToJson(this);

  @JsonKey(name: 'hops', defaultValue: <HopDto>[])
  final List<HopDto> hops;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenInAmount')
  final String tokenInAmount;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'tokenOutAmount')
  final String tokenOutAmount;
  static const fromJsonFactory = _$RouteDtoFromJson;
}

extension $RouteDtoExtension on RouteDto {
  RouteDto copyWith({
    List<HopDto>? hops,
    String? tokenIn,
    String? tokenInAmount,
    String? tokenOut,
    String? tokenOutAmount,
  }) {
    return RouteDto(
      hops: hops ?? this.hops,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenInAmount: tokenInAmount ?? this.tokenInAmount,
      tokenOut: tokenOut ?? this.tokenOut,
      tokenOutAmount: tokenOutAmount ?? this.tokenOutAmount,
    );
  }

  RouteDto copyWithWrapped({
    Wrapped<List<HopDto>>? hops,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenInAmount,
    Wrapped<String>? tokenOut,
    Wrapped<String>? tokenOutAmount,
  }) {
    return RouteDto(
      hops: (hops != null ? hops.value : this.hops),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenInAmount: (tokenInAmount != null
          ? tokenInAmount.value
          : this.tokenInAmount),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      tokenOutAmount: (tokenOutAmount != null
          ? tokenOutAmount.value
          : this.tokenOutAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OriginalDto {
  const OriginalDto({
    required this.tokenAddresses,
    required this.swaps,
    required this.swapAmount,
    required this.returnAmount,
    required this.swapAmountWithDecimal,
    required this.returnAmountWithDecimal,
    required this.tokenIn,
    required this.tokenOut,
    required this.marketSp,
    required this.routes,
    required this.effectivePrice,
    required this.effectivePriceReserved,
    required this.priceImpact,
    required this.warning,
    required this.minReturnAmount,
    required this.minReturnAmountWithDecimal,
  });

  factory OriginalDto.fromJson(Map<String, dynamic> json) =>
      _$OriginalDtoFromJson(json);

  static const toJsonFactory = _$OriginalDtoToJson;
  Map<String, dynamic> toJson() => _$OriginalDtoToJson(this);

  @JsonKey(name: 'tokenAddresses', defaultValue: <String>[])
  final List<String> tokenAddresses;
  @JsonKey(name: 'swaps', defaultValue: <SwapDto>[])
  final List<SwapDto> swaps;
  @JsonKey(name: 'swapAmount')
  final String swapAmount;
  @JsonKey(name: 'returnAmount')
  final String returnAmount;
  @JsonKey(name: 'swapAmountWithDecimal')
  final String swapAmountWithDecimal;
  @JsonKey(name: 'returnAmountWithDecimal')
  final String returnAmountWithDecimal;
  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'marketSp')
  final String marketSp;
  @JsonKey(name: 'routes', defaultValue: <RouteDto>[])
  final List<RouteDto> routes;
  @JsonKey(name: 'effectivePrice')
  final double effectivePrice;
  @JsonKey(name: 'effectivePriceReserved')
  final double effectivePriceReserved;
  @JsonKey(name: 'priceImpact')
  final double priceImpact;
  @JsonKey(name: 'warning')
  final String warning;
  @JsonKey(name: 'minReturnAmount')
  final String minReturnAmount;
  @JsonKey(name: 'minReturnAmountWithDecimal')
  final String minReturnAmountWithDecimal;
  static const fromJsonFactory = _$OriginalDtoFromJson;
}

extension $OriginalDtoExtension on OriginalDto {
  OriginalDto copyWith({
    List<String>? tokenAddresses,
    List<SwapDto>? swaps,
    String? swapAmount,
    String? returnAmount,
    String? swapAmountWithDecimal,
    String? returnAmountWithDecimal,
    String? tokenIn,
    String? tokenOut,
    String? marketSp,
    List<RouteDto>? routes,
    double? effectivePrice,
    double? effectivePriceReserved,
    double? priceImpact,
    String? warning,
    String? minReturnAmount,
    String? minReturnAmountWithDecimal,
  }) {
    return OriginalDto(
      tokenAddresses: tokenAddresses ?? this.tokenAddresses,
      swaps: swaps ?? this.swaps,
      swapAmount: swapAmount ?? this.swapAmount,
      returnAmount: returnAmount ?? this.returnAmount,
      swapAmountWithDecimal:
          swapAmountWithDecimal ?? this.swapAmountWithDecimal,
      returnAmountWithDecimal:
          returnAmountWithDecimal ?? this.returnAmountWithDecimal,
      tokenIn: tokenIn ?? this.tokenIn,
      tokenOut: tokenOut ?? this.tokenOut,
      marketSp: marketSp ?? this.marketSp,
      routes: routes ?? this.routes,
      effectivePrice: effectivePrice ?? this.effectivePrice,
      effectivePriceReserved:
          effectivePriceReserved ?? this.effectivePriceReserved,
      priceImpact: priceImpact ?? this.priceImpact,
      warning: warning ?? this.warning,
      minReturnAmount: minReturnAmount ?? this.minReturnAmount,
      minReturnAmountWithDecimal:
          minReturnAmountWithDecimal ?? this.minReturnAmountWithDecimal,
    );
  }

  OriginalDto copyWithWrapped({
    Wrapped<List<String>>? tokenAddresses,
    Wrapped<List<SwapDto>>? swaps,
    Wrapped<String>? swapAmount,
    Wrapped<String>? returnAmount,
    Wrapped<String>? swapAmountWithDecimal,
    Wrapped<String>? returnAmountWithDecimal,
    Wrapped<String>? tokenIn,
    Wrapped<String>? tokenOut,
    Wrapped<String>? marketSp,
    Wrapped<List<RouteDto>>? routes,
    Wrapped<double>? effectivePrice,
    Wrapped<double>? effectivePriceReserved,
    Wrapped<double>? priceImpact,
    Wrapped<String>? warning,
    Wrapped<String>? minReturnAmount,
    Wrapped<String>? minReturnAmountWithDecimal,
  }) {
    return OriginalDto(
      tokenAddresses: (tokenAddresses != null
          ? tokenAddresses.value
          : this.tokenAddresses),
      swaps: (swaps != null ? swaps.value : this.swaps),
      swapAmount: (swapAmount != null ? swapAmount.value : this.swapAmount),
      returnAmount: (returnAmount != null
          ? returnAmount.value
          : this.returnAmount),
      swapAmountWithDecimal: (swapAmountWithDecimal != null
          ? swapAmountWithDecimal.value
          : this.swapAmountWithDecimal),
      returnAmountWithDecimal: (returnAmountWithDecimal != null
          ? returnAmountWithDecimal.value
          : this.returnAmountWithDecimal),
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      marketSp: (marketSp != null ? marketSp.value : this.marketSp),
      routes: (routes != null ? routes.value : this.routes),
      effectivePrice: (effectivePrice != null
          ? effectivePrice.value
          : this.effectivePrice),
      effectivePriceReserved: (effectivePriceReserved != null
          ? effectivePriceReserved.value
          : this.effectivePriceReserved),
      priceImpact: (priceImpact != null ? priceImpact.value : this.priceImpact),
      warning: (warning != null ? warning.value : this.warning),
      minReturnAmount: (minReturnAmount != null
          ? minReturnAmount.value
          : this.minReturnAmount),
      minReturnAmountWithDecimal: (minReturnAmountWithDecimal != null
          ? minReturnAmountWithDecimal.value
          : this.minReturnAmountWithDecimal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FetchSwapRoutesResponseDto {
  const FetchSwapRoutesResponseDto({
    required this.argument,
    required this.limits,
    required this.extraGasLimit,
    required this.swapAmount,
    required this.paymentToken,
    required this.bigUintAmount,
    required this.original,
  });

  factory FetchSwapRoutesResponseDto.fromJson(Map<String, dynamic> json) =>
      _$FetchSwapRoutesResponseDtoFromJson(json);

  static const toJsonFactory = _$FetchSwapRoutesResponseDtoToJson;
  Map<String, dynamic> toJson() => _$FetchSwapRoutesResponseDtoToJson(this);

  @JsonKey(name: 'argument')
  final String argument;
  @JsonKey(name: 'limits')
  final String limits;
  @JsonKey(name: 'extraGasLimit')
  final double extraGasLimit;
  @JsonKey(name: 'swapAmount')
  final double swapAmount;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'bigUintAmount')
  final String bigUintAmount;
  @JsonKey(name: 'original')
  final OriginalDto original;
  static const fromJsonFactory = _$FetchSwapRoutesResponseDtoFromJson;
}

extension $FetchSwapRoutesResponseDtoExtension on FetchSwapRoutesResponseDto {
  FetchSwapRoutesResponseDto copyWith({
    String? argument,
    String? limits,
    double? extraGasLimit,
    double? swapAmount,
    String? paymentToken,
    String? bigUintAmount,
    OriginalDto? original,
  }) {
    return FetchSwapRoutesResponseDto(
      argument: argument ?? this.argument,
      limits: limits ?? this.limits,
      extraGasLimit: extraGasLimit ?? this.extraGasLimit,
      swapAmount: swapAmount ?? this.swapAmount,
      paymentToken: paymentToken ?? this.paymentToken,
      bigUintAmount: bigUintAmount ?? this.bigUintAmount,
      original: original ?? this.original,
    );
  }

  FetchSwapRoutesResponseDto copyWithWrapped({
    Wrapped<String>? argument,
    Wrapped<String>? limits,
    Wrapped<double>? extraGasLimit,
    Wrapped<double>? swapAmount,
    Wrapped<String>? paymentToken,
    Wrapped<String>? bigUintAmount,
    Wrapped<OriginalDto>? original,
  }) {
    return FetchSwapRoutesResponseDto(
      argument: (argument != null ? argument.value : this.argument),
      limits: (limits != null ? limits.value : this.limits),
      extraGasLimit: (extraGasLimit != null
          ? extraGasLimit.value
          : this.extraGasLimit),
      swapAmount: (swapAmount != null ? swapAmount.value : this.swapAmount),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      bigUintAmount: (bigUintAmount != null
          ? bigUintAmount.value
          : this.bigUintAmount),
      original: (original != null ? original.value : this.original),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ArdaSwapResultDto {
  const ArdaSwapResultDto({
    required this.tokenIn,
    required this.amountIn,
    required this.amountInShort,
    required this.tokenOut,
    required this.amountOut,
    required this.amountOutShort,
    required this.argument,
    required this.gasLimit,
  });

  factory ArdaSwapResultDto.fromJson(Map<String, dynamic> json) =>
      _$ArdaSwapResultDtoFromJson(json);

  static const toJsonFactory = _$ArdaSwapResultDtoToJson;
  Map<String, dynamic> toJson() => _$ArdaSwapResultDtoToJson(this);

  @JsonKey(name: 'tokenIn')
  final String tokenIn;
  @JsonKey(name: 'amountIn')
  final String amountIn;
  @JsonKey(name: 'amountInShort')
  final String amountInShort;
  @JsonKey(name: 'tokenOut')
  final String tokenOut;
  @JsonKey(name: 'amountOut')
  final String amountOut;
  @JsonKey(name: 'amountOutShort')
  final String amountOutShort;
  @JsonKey(name: 'argument')
  final String argument;
  @JsonKey(name: 'gasLimit')
  final double gasLimit;
  static const fromJsonFactory = _$ArdaSwapResultDtoFromJson;
}

extension $ArdaSwapResultDtoExtension on ArdaSwapResultDto {
  ArdaSwapResultDto copyWith({
    String? tokenIn,
    String? amountIn,
    String? amountInShort,
    String? tokenOut,
    String? amountOut,
    String? amountOutShort,
    String? argument,
    double? gasLimit,
  }) {
    return ArdaSwapResultDto(
      tokenIn: tokenIn ?? this.tokenIn,
      amountIn: amountIn ?? this.amountIn,
      amountInShort: amountInShort ?? this.amountInShort,
      tokenOut: tokenOut ?? this.tokenOut,
      amountOut: amountOut ?? this.amountOut,
      amountOutShort: amountOutShort ?? this.amountOutShort,
      argument: argument ?? this.argument,
      gasLimit: gasLimit ?? this.gasLimit,
    );
  }

  ArdaSwapResultDto copyWithWrapped({
    Wrapped<String>? tokenIn,
    Wrapped<String>? amountIn,
    Wrapped<String>? amountInShort,
    Wrapped<String>? tokenOut,
    Wrapped<String>? amountOut,
    Wrapped<String>? amountOutShort,
    Wrapped<String>? argument,
    Wrapped<double>? gasLimit,
  }) {
    return ArdaSwapResultDto(
      tokenIn: (tokenIn != null ? tokenIn.value : this.tokenIn),
      amountIn: (amountIn != null ? amountIn.value : this.amountIn),
      amountInShort: (amountInShort != null
          ? amountInShort.value
          : this.amountInShort),
      tokenOut: (tokenOut != null ? tokenOut.value : this.tokenOut),
      amountOut: (amountOut != null ? amountOut.value : this.amountOut),
      amountOutShort: (amountOutShort != null
          ? amountOutShort.value
          : this.amountOutShort),
      argument: (argument != null ? argument.value : this.argument),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OraclePriceFluctuation {
  const OraclePriceFluctuation({
    required this.firstUpperRatio,
    required this.firstLowerRatio,
    required this.lastUpperRatio,
    required this.lastLowerRatio,
  });

  factory OraclePriceFluctuation.fromJson(Map<String, dynamic> json) =>
      _$OraclePriceFluctuationFromJson(json);

  static const toJsonFactory = _$OraclePriceFluctuationToJson;
  Map<String, dynamic> toJson() => _$OraclePriceFluctuationToJson(this);

  @JsonKey(name: 'firstUpperRatio')
  final int firstUpperRatio;
  @JsonKey(name: 'firstLowerRatio')
  final int firstLowerRatio;
  @JsonKey(name: 'lastUpperRatio')
  final int lastUpperRatio;
  @JsonKey(name: 'lastLowerRatio')
  final int lastLowerRatio;
  static const fromJsonFactory = _$OraclePriceFluctuationFromJson;
}

extension $OraclePriceFluctuationExtension on OraclePriceFluctuation {
  OraclePriceFluctuation copyWith({
    int? firstUpperRatio,
    int? firstLowerRatio,
    int? lastUpperRatio,
    int? lastLowerRatio,
  }) {
    return OraclePriceFluctuation(
      firstUpperRatio: firstUpperRatio ?? this.firstUpperRatio,
      firstLowerRatio: firstLowerRatio ?? this.firstLowerRatio,
      lastUpperRatio: lastUpperRatio ?? this.lastUpperRatio,
      lastLowerRatio: lastLowerRatio ?? this.lastLowerRatio,
    );
  }

  OraclePriceFluctuation copyWithWrapped({
    Wrapped<int>? firstUpperRatio,
    Wrapped<int>? firstLowerRatio,
    Wrapped<int>? lastUpperRatio,
    Wrapped<int>? lastLowerRatio,
  }) {
    return OraclePriceFluctuation(
      firstUpperRatio: (firstUpperRatio != null
          ? firstUpperRatio.value
          : this.firstUpperRatio),
      firstLowerRatio: (firstLowerRatio != null
          ? firstLowerRatio.value
          : this.firstLowerRatio),
      lastUpperRatio: (lastUpperRatio != null
          ? lastUpperRatio.value
          : this.lastUpperRatio),
      lastLowerRatio: (lastLowerRatio != null
          ? lastLowerRatio.value
          : this.lastLowerRatio),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingOracleUpdateStruct {
  const LendingOracleUpdateStruct({
    required this.baseTokenId,
    required this.quoteTokenId,
    required this.tolerance,
    required this.oracleContractAddress,
    required this.pricingMethod,
    required this.oracleType,
    required this.exchangeSource,
    required this.assetDecimals,
    required this.onedexPairId,
    required this.maxPriceStaleSeconds,
  });

  factory LendingOracleUpdateStruct.fromJson(Map<String, dynamic> json) =>
      _$LendingOracleUpdateStructFromJson(json);

  static const toJsonFactory = _$LendingOracleUpdateStructToJson;
  Map<String, dynamic> toJson() => _$LendingOracleUpdateStructToJson(this);

  @JsonKey(name: 'baseTokenId')
  final String baseTokenId;
  @JsonKey(name: 'quoteTokenId')
  final String quoteTokenId;
  @JsonKey(name: 'tolerance')
  final OraclePriceFluctuation tolerance;
  @JsonKey(name: 'oracleContractAddress')
  final String oracleContractAddress;
  @JsonKey(
    name: 'pricingMethod',
    toJson: pricingMethodToJson,
    fromJson: pricingMethodFromJson,
  )
  final enums.PricingMethod pricingMethod;
  @JsonKey(
    name: 'oracleType',
    toJson: oracleTypeToJson,
    fromJson: oracleTypeFromJson,
  )
  final enums.OracleType oracleType;
  @JsonKey(
    name: 'exchangeSource',
    toJson: exchangeSourceToJson,
    fromJson: exchangeSourceFromJson,
  )
  final enums.ExchangeSource exchangeSource;
  @JsonKey(name: 'assetDecimals')
  final int assetDecimals;
  @JsonKey(name: 'onedexPairId')
  final int onedexPairId;
  @JsonKey(name: 'maxPriceStaleSeconds')
  final int maxPriceStaleSeconds;
  static const fromJsonFactory = _$LendingOracleUpdateStructFromJson;
}

extension $LendingOracleUpdateStructExtension on LendingOracleUpdateStruct {
  LendingOracleUpdateStruct copyWith({
    String? baseTokenId,
    String? quoteTokenId,
    OraclePriceFluctuation? tolerance,
    String? oracleContractAddress,
    enums.PricingMethod? pricingMethod,
    enums.OracleType? oracleType,
    enums.ExchangeSource? exchangeSource,
    int? assetDecimals,
    int? onedexPairId,
    int? maxPriceStaleSeconds,
  }) {
    return LendingOracleUpdateStruct(
      baseTokenId: baseTokenId ?? this.baseTokenId,
      quoteTokenId: quoteTokenId ?? this.quoteTokenId,
      tolerance: tolerance ?? this.tolerance,
      oracleContractAddress:
          oracleContractAddress ?? this.oracleContractAddress,
      pricingMethod: pricingMethod ?? this.pricingMethod,
      oracleType: oracleType ?? this.oracleType,
      exchangeSource: exchangeSource ?? this.exchangeSource,
      assetDecimals: assetDecimals ?? this.assetDecimals,
      onedexPairId: onedexPairId ?? this.onedexPairId,
      maxPriceStaleSeconds: maxPriceStaleSeconds ?? this.maxPriceStaleSeconds,
    );
  }

  LendingOracleUpdateStruct copyWithWrapped({
    Wrapped<String>? baseTokenId,
    Wrapped<String>? quoteTokenId,
    Wrapped<OraclePriceFluctuation>? tolerance,
    Wrapped<String>? oracleContractAddress,
    Wrapped<enums.PricingMethod>? pricingMethod,
    Wrapped<enums.OracleType>? oracleType,
    Wrapped<enums.ExchangeSource>? exchangeSource,
    Wrapped<int>? assetDecimals,
    Wrapped<int>? onedexPairId,
    Wrapped<int>? maxPriceStaleSeconds,
  }) {
    return LendingOracleUpdateStruct(
      baseTokenId: (baseTokenId != null ? baseTokenId.value : this.baseTokenId),
      quoteTokenId: (quoteTokenId != null
          ? quoteTokenId.value
          : this.quoteTokenId),
      tolerance: (tolerance != null ? tolerance.value : this.tolerance),
      oracleContractAddress: (oracleContractAddress != null
          ? oracleContractAddress.value
          : this.oracleContractAddress),
      pricingMethod: (pricingMethod != null
          ? pricingMethod.value
          : this.pricingMethod),
      oracleType: (oracleType != null ? oracleType.value : this.oracleType),
      exchangeSource: (exchangeSource != null
          ? exchangeSource.value
          : this.exchangeSource),
      assetDecimals: (assetDecimals != null
          ? assetDecimals.value
          : this.assetDecimals),
      onedexPairId: (onedexPairId != null
          ? onedexPairId.value
          : this.onedexPairId),
      maxPriceStaleSeconds: (maxPriceStaleSeconds != null
          ? maxPriceStaleSeconds.value
          : this.maxPriceStaleSeconds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketParticipants {
  const LendingMarketParticipants({required this.count, required this.wallets});

  factory LendingMarketParticipants.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketParticipantsFromJson(json);

  static const toJsonFactory = _$LendingMarketParticipantsToJson;
  Map<String, dynamic> toJson() => _$LendingMarketParticipantsToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'wallets', defaultValue: <List<Object?>>[])
  final List<List<Object?>> wallets;
  static const fromJsonFactory = _$LendingMarketParticipantsFromJson;
}

extension $LendingMarketParticipantsExtension on LendingMarketParticipants {
  LendingMarketParticipants copyWith({
    double? count,
    List<List<Object?>>? wallets,
  }) {
    return LendingMarketParticipants(
      count: count ?? this.count,
      wallets: wallets ?? this.wallets,
    );
  }

  LendingMarketParticipants copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<List<List<Object?>>>? wallets,
  }) {
    return LendingMarketParticipants(
      count: (count != null ? count.value : this.count),
      wallets: (wallets != null ? wallets.value : this.wallets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketExtraApy {
  const MarketExtraApy({this.nativeApy, this.feesApr});

  factory MarketExtraApy.fromJson(Map<String, dynamic> json) =>
      _$MarketExtraApyFromJson(json);

  static const toJsonFactory = _$MarketExtraApyToJson;
  Map<String, dynamic> toJson() => _$MarketExtraApyToJson(this);

  @JsonKey(name: 'nativeApy')
  final double? nativeApy;
  @JsonKey(name: 'feesApr')
  final double? feesApr;
  static const fromJsonFactory = _$MarketExtraApyFromJson;
}

extension $MarketExtraApyExtension on MarketExtraApy {
  MarketExtraApy copyWith({double? nativeApy, double? feesApr}) {
    return MarketExtraApy(
      nativeApy: nativeApy ?? this.nativeApy,
      feesApr: feesApr ?? this.feesApr,
    );
  }

  MarketExtraApy copyWithWrapped({
    Wrapped<double?>? nativeApy,
    Wrapped<double?>? feesApr,
  }) {
    return MarketExtraApy(
      nativeApy: (nativeApy != null ? nativeApy.value : this.nativeApy),
      feesApr: (feesApr != null ? feesApr.value : this.feesApr),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingIndexesDto {
  const LendingIndexesDto({
    required this.supplyIndex,
    required this.supplyIndexShort,
    required this.borrowIndex,
    required this.borrowIndexShort,
    required this.egldPrice,
    required this.egldPriceShort,
    required this.usdPrice,
    required this.usdPriceShort,
    required this.safePriceEgld,
    required this.safePriceEgldShort,
    required this.safePriceUsd,
    required this.safePriceUsdShort,
    required this.aggregatorPriceEgld,
    required this.aggregatorPriceEgldShort,
    required this.aggregatorPriceUsd,
    required this.aggregatorPriceUsdShort,
    required this.withinFirstTolerance,
    required this.withinSecondTolerance,
  });

  factory LendingIndexesDto.fromJson(Map<String, dynamic> json) =>
      _$LendingIndexesDtoFromJson(json);

  static const toJsonFactory = _$LendingIndexesDtoToJson;
  Map<String, dynamic> toJson() => _$LendingIndexesDtoToJson(this);

  @JsonKey(name: 'supplyIndex')
  final String supplyIndex;
  @JsonKey(name: 'supplyIndexShort')
  final double supplyIndexShort;
  @JsonKey(name: 'borrowIndex')
  final String borrowIndex;
  @JsonKey(name: 'borrowIndexShort')
  final double borrowIndexShort;
  @JsonKey(name: 'egldPrice')
  final String egldPrice;
  @JsonKey(name: 'egldPriceShort')
  final double egldPriceShort;
  @JsonKey(name: 'usdPrice')
  final String usdPrice;
  @JsonKey(name: 'usdPriceShort')
  final double usdPriceShort;
  @JsonKey(name: 'safePriceEgld')
  final String safePriceEgld;
  @JsonKey(name: 'safePriceEgldShort')
  final double safePriceEgldShort;
  @JsonKey(name: 'safePriceUsd')
  final String safePriceUsd;
  @JsonKey(name: 'safePriceUsdShort')
  final double safePriceUsdShort;
  @JsonKey(name: 'aggregatorPriceEgld')
  final String aggregatorPriceEgld;
  @JsonKey(name: 'aggregatorPriceEgldShort')
  final double aggregatorPriceEgldShort;
  @JsonKey(name: 'aggregatorPriceUsd')
  final String aggregatorPriceUsd;
  @JsonKey(name: 'aggregatorPriceUsdShort')
  final double aggregatorPriceUsdShort;
  @JsonKey(name: 'withinFirstTolerance')
  final bool withinFirstTolerance;
  @JsonKey(name: 'withinSecondTolerance')
  final bool withinSecondTolerance;
  static const fromJsonFactory = _$LendingIndexesDtoFromJson;
}

extension $LendingIndexesDtoExtension on LendingIndexesDto {
  LendingIndexesDto copyWith({
    String? supplyIndex,
    double? supplyIndexShort,
    String? borrowIndex,
    double? borrowIndexShort,
    String? egldPrice,
    double? egldPriceShort,
    String? usdPrice,
    double? usdPriceShort,
    String? safePriceEgld,
    double? safePriceEgldShort,
    String? safePriceUsd,
    double? safePriceUsdShort,
    String? aggregatorPriceEgld,
    double? aggregatorPriceEgldShort,
    String? aggregatorPriceUsd,
    double? aggregatorPriceUsdShort,
    bool? withinFirstTolerance,
    bool? withinSecondTolerance,
  }) {
    return LendingIndexesDto(
      supplyIndex: supplyIndex ?? this.supplyIndex,
      supplyIndexShort: supplyIndexShort ?? this.supplyIndexShort,
      borrowIndex: borrowIndex ?? this.borrowIndex,
      borrowIndexShort: borrowIndexShort ?? this.borrowIndexShort,
      egldPrice: egldPrice ?? this.egldPrice,
      egldPriceShort: egldPriceShort ?? this.egldPriceShort,
      usdPrice: usdPrice ?? this.usdPrice,
      usdPriceShort: usdPriceShort ?? this.usdPriceShort,
      safePriceEgld: safePriceEgld ?? this.safePriceEgld,
      safePriceEgldShort: safePriceEgldShort ?? this.safePriceEgldShort,
      safePriceUsd: safePriceUsd ?? this.safePriceUsd,
      safePriceUsdShort: safePriceUsdShort ?? this.safePriceUsdShort,
      aggregatorPriceEgld: aggregatorPriceEgld ?? this.aggregatorPriceEgld,
      aggregatorPriceEgldShort:
          aggregatorPriceEgldShort ?? this.aggregatorPriceEgldShort,
      aggregatorPriceUsd: aggregatorPriceUsd ?? this.aggregatorPriceUsd,
      aggregatorPriceUsdShort:
          aggregatorPriceUsdShort ?? this.aggregatorPriceUsdShort,
      withinFirstTolerance: withinFirstTolerance ?? this.withinFirstTolerance,
      withinSecondTolerance:
          withinSecondTolerance ?? this.withinSecondTolerance,
    );
  }

  LendingIndexesDto copyWithWrapped({
    Wrapped<String>? supplyIndex,
    Wrapped<double>? supplyIndexShort,
    Wrapped<String>? borrowIndex,
    Wrapped<double>? borrowIndexShort,
    Wrapped<String>? egldPrice,
    Wrapped<double>? egldPriceShort,
    Wrapped<String>? usdPrice,
    Wrapped<double>? usdPriceShort,
    Wrapped<String>? safePriceEgld,
    Wrapped<double>? safePriceEgldShort,
    Wrapped<String>? safePriceUsd,
    Wrapped<double>? safePriceUsdShort,
    Wrapped<String>? aggregatorPriceEgld,
    Wrapped<double>? aggregatorPriceEgldShort,
    Wrapped<String>? aggregatorPriceUsd,
    Wrapped<double>? aggregatorPriceUsdShort,
    Wrapped<bool>? withinFirstTolerance,
    Wrapped<bool>? withinSecondTolerance,
  }) {
    return LendingIndexesDto(
      supplyIndex: (supplyIndex != null ? supplyIndex.value : this.supplyIndex),
      supplyIndexShort: (supplyIndexShort != null
          ? supplyIndexShort.value
          : this.supplyIndexShort),
      borrowIndex: (borrowIndex != null ? borrowIndex.value : this.borrowIndex),
      borrowIndexShort: (borrowIndexShort != null
          ? borrowIndexShort.value
          : this.borrowIndexShort),
      egldPrice: (egldPrice != null ? egldPrice.value : this.egldPrice),
      egldPriceShort: (egldPriceShort != null
          ? egldPriceShort.value
          : this.egldPriceShort),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
      usdPriceShort: (usdPriceShort != null
          ? usdPriceShort.value
          : this.usdPriceShort),
      safePriceEgld: (safePriceEgld != null
          ? safePriceEgld.value
          : this.safePriceEgld),
      safePriceEgldShort: (safePriceEgldShort != null
          ? safePriceEgldShort.value
          : this.safePriceEgldShort),
      safePriceUsd: (safePriceUsd != null
          ? safePriceUsd.value
          : this.safePriceUsd),
      safePriceUsdShort: (safePriceUsdShort != null
          ? safePriceUsdShort.value
          : this.safePriceUsdShort),
      aggregatorPriceEgld: (aggregatorPriceEgld != null
          ? aggregatorPriceEgld.value
          : this.aggregatorPriceEgld),
      aggregatorPriceEgldShort: (aggregatorPriceEgldShort != null
          ? aggregatorPriceEgldShort.value
          : this.aggregatorPriceEgldShort),
      aggregatorPriceUsd: (aggregatorPriceUsd != null
          ? aggregatorPriceUsd.value
          : this.aggregatorPriceUsd),
      aggregatorPriceUsdShort: (aggregatorPriceUsdShort != null
          ? aggregatorPriceUsdShort.value
          : this.aggregatorPriceUsdShort),
      withinFirstTolerance: (withinFirstTolerance != null
          ? withinFirstTolerance.value
          : this.withinFirstTolerance),
      withinSecondTolerance: (withinSecondTolerance != null
          ? withinSecondTolerance.value
          : this.withinSecondTolerance),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfile {
  const LendingMarketProfile({
    required this.dataType,
    required this.token,
    required this.name,
    required this.decimals,
    required this.address,
    required this.baseRate,
    required this.maxBorrowRate,
    required this.slopeRate1,
    required this.slopeRate2,
    required this.slopeRate3,
    required this.midUsageRate,
    required this.optimalUsageRate,
    required this.reserveFactor,
    required this.liquidationFee,
    required this.ltv,
    required this.liquidationBonus,
    required this.liquidationThreshold,
    required this.rewardsReserve,
    required this.rewardsReserveShort,
    required this.reserves,
    required this.reservesShort,
    required this.supplyAmount,
    required this.supplyAmountScaled,
    required this.borrowAmount,
    required this.supplyAmountShort,
    required this.borrowAmountShort,
    required this.borrowAmountScaled,
    required this.supplyCap,
    required this.borrowCap,
    required this.supplyCapShort,
    required this.borrowCapShort,
    required this.timestamp,
    required this.borrowApy,
    required this.supplyApy,
    required this.utilizationRate,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.eMode,
    required this.eModeCategories,
    required this.isolated,
    required this.maxDebtUsd,
    required this.maxDebtUsdShort,
    this.debtCeiling,
    this.debtCeilingShort,
    required this.siloed,
    required this.flashLoan,
    required this.flashLoanFee,
    required this.canBorrowInIsolation,
    required this.oracleProvider,
    required this.id,
    required this.pk,
    required this.ts,
    required this.eModeCategoryProfiles,
    required this.participants,
    this.extraApy,
    required this.indexes,
  });

  factory LendingMarketProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'baseRate')
  final String baseRate;
  @JsonKey(name: 'maxBorrowRate')
  final String maxBorrowRate;
  @JsonKey(name: 'slopeRate1')
  final String slopeRate1;
  @JsonKey(name: 'slopeRate2')
  final String slopeRate2;
  @JsonKey(name: 'slopeRate3')
  final String slopeRate3;
  @JsonKey(name: 'midUsageRate')
  final String midUsageRate;
  @JsonKey(name: 'optimalUsageRate')
  final String optimalUsageRate;
  @JsonKey(name: 'reserveFactor')
  final String reserveFactor;
  @JsonKey(name: 'liquidationFee')
  final String liquidationFee;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'rewardsReserve')
  final Object rewardsReserve;
  @JsonKey(name: 'rewardsReserveShort')
  final Object rewardsReserveShort;
  @JsonKey(name: 'reserves')
  final Object reserves;
  @JsonKey(name: 'reservesShort')
  final Object reservesShort;
  @JsonKey(name: 'supplyAmount')
  final Object supplyAmount;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmount')
  final Object borrowAmount;
  @JsonKey(name: 'supplyAmountShort')
  final Object supplyAmountShort;
  @JsonKey(name: 'borrowAmountShort')
  final Object borrowAmountShort;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'supplyCap')
  final String supplyCap;
  @JsonKey(name: 'borrowCap')
  final String borrowCap;
  @JsonKey(name: 'supplyCapShort')
  final Object supplyCapShort;
  @JsonKey(name: 'borrowCapShort')
  final Object borrowCapShort;
  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'borrowApy')
  final Object borrowApy;
  @JsonKey(name: 'supplyApy')
  final Object supplyApy;
  @JsonKey(name: 'utilizationRate')
  final Object utilizationRate;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'eMode')
  final bool eMode;
  @JsonKey(name: 'eModeCategories', defaultValue: <List<Object?>>[])
  final List<List<Object?>> eModeCategories;
  @JsonKey(name: 'isolated')
  final bool isolated;
  @JsonKey(name: 'maxDebtUsd')
  final Object maxDebtUsd;
  @JsonKey(name: 'maxDebtUsdShort')
  final Object maxDebtUsdShort;
  @JsonKey(name: 'debtCeiling')
  final String? debtCeiling;
  @JsonKey(name: 'debtCeilingShort')
  final double? debtCeilingShort;
  @JsonKey(name: 'siloed')
  final bool siloed;
  @JsonKey(name: 'flashLoan')
  final bool flashLoan;
  @JsonKey(name: 'flashLoanFee')
  final String flashLoanFee;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool canBorrowInIsolation;
  @JsonKey(name: 'oracleProvider')
  final LendingOracleUpdateStruct oracleProvider;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'eModeCategoryProfiles', defaultValue: <List<Object?>>[])
  final List<List<Object?>> eModeCategoryProfiles;
  @JsonKey(name: 'participants')
  final LendingMarketParticipants participants;
  @JsonKey(name: 'extraApy')
  final MarketExtraApy? extraApy;
  @JsonKey(name: 'indexes')
  final LendingIndexesDto indexes;
  static const fromJsonFactory = _$LendingMarketProfileFromJson;
}

extension $LendingMarketProfileExtension on LendingMarketProfile {
  LendingMarketProfile copyWith({
    enums.LendingDataType? dataType,
    String? token,
    String? name,
    double? decimals,
    String? address,
    String? baseRate,
    String? maxBorrowRate,
    String? slopeRate1,
    String? slopeRate2,
    String? slopeRate3,
    String? midUsageRate,
    String? optimalUsageRate,
    String? reserveFactor,
    String? liquidationFee,
    String? ltv,
    String? liquidationBonus,
    String? liquidationThreshold,
    Object? rewardsReserve,
    Object? rewardsReserveShort,
    Object? reserves,
    Object? reservesShort,
    Object? supplyAmount,
    Object? supplyAmountScaled,
    Object? borrowAmount,
    Object? supplyAmountShort,
    Object? borrowAmountShort,
    Object? borrowAmountScaled,
    String? supplyCap,
    String? borrowCap,
    Object? supplyCapShort,
    Object? borrowCapShort,
    Object? timestamp,
    Object? borrowApy,
    Object? supplyApy,
    Object? utilizationRate,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? eMode,
    List<List<Object?>>? eModeCategories,
    bool? isolated,
    Object? maxDebtUsd,
    Object? maxDebtUsdShort,
    String? debtCeiling,
    double? debtCeilingShort,
    bool? siloed,
    bool? flashLoan,
    String? flashLoanFee,
    bool? canBorrowInIsolation,
    LendingOracleUpdateStruct? oracleProvider,
    String? id,
    String? pk,
    double? ts,
    List<List<Object?>>? eModeCategoryProfiles,
    LendingMarketParticipants? participants,
    MarketExtraApy? extraApy,
    LendingIndexesDto? indexes,
  }) {
    return LendingMarketProfile(
      dataType: dataType ?? this.dataType,
      token: token ?? this.token,
      name: name ?? this.name,
      decimals: decimals ?? this.decimals,
      address: address ?? this.address,
      baseRate: baseRate ?? this.baseRate,
      maxBorrowRate: maxBorrowRate ?? this.maxBorrowRate,
      slopeRate1: slopeRate1 ?? this.slopeRate1,
      slopeRate2: slopeRate2 ?? this.slopeRate2,
      slopeRate3: slopeRate3 ?? this.slopeRate3,
      midUsageRate: midUsageRate ?? this.midUsageRate,
      optimalUsageRate: optimalUsageRate ?? this.optimalUsageRate,
      reserveFactor: reserveFactor ?? this.reserveFactor,
      liquidationFee: liquidationFee ?? this.liquidationFee,
      ltv: ltv ?? this.ltv,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      rewardsReserve: rewardsReserve ?? this.rewardsReserve,
      rewardsReserveShort: rewardsReserveShort ?? this.rewardsReserveShort,
      reserves: reserves ?? this.reserves,
      reservesShort: reservesShort ?? this.reservesShort,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      supplyAmountShort: supplyAmountShort ?? this.supplyAmountShort,
      borrowAmountShort: borrowAmountShort ?? this.borrowAmountShort,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      supplyCap: supplyCap ?? this.supplyCap,
      borrowCap: borrowCap ?? this.borrowCap,
      supplyCapShort: supplyCapShort ?? this.supplyCapShort,
      borrowCapShort: borrowCapShort ?? this.borrowCapShort,
      timestamp: timestamp ?? this.timestamp,
      borrowApy: borrowApy ?? this.borrowApy,
      supplyApy: supplyApy ?? this.supplyApy,
      utilizationRate: utilizationRate ?? this.utilizationRate,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      eMode: eMode ?? this.eMode,
      eModeCategories: eModeCategories ?? this.eModeCategories,
      isolated: isolated ?? this.isolated,
      maxDebtUsd: maxDebtUsd ?? this.maxDebtUsd,
      maxDebtUsdShort: maxDebtUsdShort ?? this.maxDebtUsdShort,
      debtCeiling: debtCeiling ?? this.debtCeiling,
      debtCeilingShort: debtCeilingShort ?? this.debtCeilingShort,
      siloed: siloed ?? this.siloed,
      flashLoan: flashLoan ?? this.flashLoan,
      flashLoanFee: flashLoanFee ?? this.flashLoanFee,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      oracleProvider: oracleProvider ?? this.oracleProvider,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      eModeCategoryProfiles:
          eModeCategoryProfiles ?? this.eModeCategoryProfiles,
      participants: participants ?? this.participants,
      extraApy: extraApy ?? this.extraApy,
      indexes: indexes ?? this.indexes,
    );
  }

  LendingMarketProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? token,
    Wrapped<String>? name,
    Wrapped<double>? decimals,
    Wrapped<String>? address,
    Wrapped<String>? baseRate,
    Wrapped<String>? maxBorrowRate,
    Wrapped<String>? slopeRate1,
    Wrapped<String>? slopeRate2,
    Wrapped<String>? slopeRate3,
    Wrapped<String>? midUsageRate,
    Wrapped<String>? optimalUsageRate,
    Wrapped<String>? reserveFactor,
    Wrapped<String>? liquidationFee,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationBonus,
    Wrapped<String>? liquidationThreshold,
    Wrapped<Object>? rewardsReserve,
    Wrapped<Object>? rewardsReserveShort,
    Wrapped<Object>? reserves,
    Wrapped<Object>? reservesShort,
    Wrapped<Object>? supplyAmount,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmount,
    Wrapped<Object>? supplyAmountShort,
    Wrapped<Object>? borrowAmountShort,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<String>? supplyCap,
    Wrapped<String>? borrowCap,
    Wrapped<Object>? supplyCapShort,
    Wrapped<Object>? borrowCapShort,
    Wrapped<Object>? timestamp,
    Wrapped<Object>? borrowApy,
    Wrapped<Object>? supplyApy,
    Wrapped<Object>? utilizationRate,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<bool>? eMode,
    Wrapped<List<List<Object?>>>? eModeCategories,
    Wrapped<bool>? isolated,
    Wrapped<Object>? maxDebtUsd,
    Wrapped<Object>? maxDebtUsdShort,
    Wrapped<String?>? debtCeiling,
    Wrapped<double?>? debtCeilingShort,
    Wrapped<bool>? siloed,
    Wrapped<bool>? flashLoan,
    Wrapped<String>? flashLoanFee,
    Wrapped<bool>? canBorrowInIsolation,
    Wrapped<LendingOracleUpdateStruct>? oracleProvider,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<List<List<Object?>>>? eModeCategoryProfiles,
    Wrapped<LendingMarketParticipants>? participants,
    Wrapped<MarketExtraApy?>? extraApy,
    Wrapped<LendingIndexesDto>? indexes,
  }) {
    return LendingMarketProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      token: (token != null ? token.value : this.token),
      name: (name != null ? name.value : this.name),
      decimals: (decimals != null ? decimals.value : this.decimals),
      address: (address != null ? address.value : this.address),
      baseRate: (baseRate != null ? baseRate.value : this.baseRate),
      maxBorrowRate: (maxBorrowRate != null
          ? maxBorrowRate.value
          : this.maxBorrowRate),
      slopeRate1: (slopeRate1 != null ? slopeRate1.value : this.slopeRate1),
      slopeRate2: (slopeRate2 != null ? slopeRate2.value : this.slopeRate2),
      slopeRate3: (slopeRate3 != null ? slopeRate3.value : this.slopeRate3),
      midUsageRate: (midUsageRate != null
          ? midUsageRate.value
          : this.midUsageRate),
      optimalUsageRate: (optimalUsageRate != null
          ? optimalUsageRate.value
          : this.optimalUsageRate),
      reserveFactor: (reserveFactor != null
          ? reserveFactor.value
          : this.reserveFactor),
      liquidationFee: (liquidationFee != null
          ? liquidationFee.value
          : this.liquidationFee),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      rewardsReserve: (rewardsReserve != null
          ? rewardsReserve.value
          : this.rewardsReserve),
      rewardsReserveShort: (rewardsReserveShort != null
          ? rewardsReserveShort.value
          : this.rewardsReserveShort),
      reserves: (reserves != null ? reserves.value : this.reserves),
      reservesShort: (reservesShort != null
          ? reservesShort.value
          : this.reservesShort),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      supplyAmountShort: (supplyAmountShort != null
          ? supplyAmountShort.value
          : this.supplyAmountShort),
      borrowAmountShort: (borrowAmountShort != null
          ? borrowAmountShort.value
          : this.borrowAmountShort),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      supplyCap: (supplyCap != null ? supplyCap.value : this.supplyCap),
      borrowCap: (borrowCap != null ? borrowCap.value : this.borrowCap),
      supplyCapShort: (supplyCapShort != null
          ? supplyCapShort.value
          : this.supplyCapShort),
      borrowCapShort: (borrowCapShort != null
          ? borrowCapShort.value
          : this.borrowCapShort),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      borrowApy: (borrowApy != null ? borrowApy.value : this.borrowApy),
      supplyApy: (supplyApy != null ? supplyApy.value : this.supplyApy),
      utilizationRate: (utilizationRate != null
          ? utilizationRate.value
          : this.utilizationRate),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      eMode: (eMode != null ? eMode.value : this.eMode),
      eModeCategories: (eModeCategories != null
          ? eModeCategories.value
          : this.eModeCategories),
      isolated: (isolated != null ? isolated.value : this.isolated),
      maxDebtUsd: (maxDebtUsd != null ? maxDebtUsd.value : this.maxDebtUsd),
      maxDebtUsdShort: (maxDebtUsdShort != null
          ? maxDebtUsdShort.value
          : this.maxDebtUsdShort),
      debtCeiling: (debtCeiling != null ? debtCeiling.value : this.debtCeiling),
      debtCeilingShort: (debtCeilingShort != null
          ? debtCeilingShort.value
          : this.debtCeilingShort),
      siloed: (siloed != null ? siloed.value : this.siloed),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      flashLoanFee: (flashLoanFee != null
          ? flashLoanFee.value
          : this.flashLoanFee),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      oracleProvider: (oracleProvider != null
          ? oracleProvider.value
          : this.oracleProvider),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      eModeCategoryProfiles: (eModeCategoryProfiles != null
          ? eModeCategoryProfiles.value
          : this.eModeCategoryProfiles),
      participants: (participants != null
          ? participants.value
          : this.participants),
      extraApy: (extraApy != null ? extraApy.value : this.extraApy),
      indexes: (indexes != null ? indexes.value : this.indexes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileFilterCriteriaDto {
  const LendingMarketProfileFilterCriteriaDto({
    this.token,
    this.range,
    this.eMode,
    this.flashLoan,
    this.isolated,
    this.siloed,
    this.canBeCollateral,
    this.canBeBorrowed,
    this.canBorrowInIsolation,
    this.isDebtCeilingReached,
  });

  factory LendingMarketProfileFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$LendingMarketProfileFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$LendingMarketProfileFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'token', defaultValue: <String>[])
  final List<String>? token;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'eMode')
  final bool? eMode;
  @JsonKey(name: 'flashLoan')
  final bool? flashLoan;
  @JsonKey(name: 'isolated')
  final bool? isolated;
  @JsonKey(name: 'siloed')
  final bool? siloed;
  @JsonKey(name: 'canBeCollateral')
  final bool? canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool? canBeBorrowed;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool? canBorrowInIsolation;
  @JsonKey(name: 'isDebtCeilingReached')
  final bool? isDebtCeilingReached;
  static const fromJsonFactory =
      _$LendingMarketProfileFilterCriteriaDtoFromJson;
}

extension $LendingMarketProfileFilterCriteriaDtoExtension
    on LendingMarketProfileFilterCriteriaDto {
  LendingMarketProfileFilterCriteriaDto copyWith({
    List<String>? token,
    List<RangeFilter>? range,
    bool? eMode,
    bool? flashLoan,
    bool? isolated,
    bool? siloed,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? canBorrowInIsolation,
    bool? isDebtCeilingReached,
  }) {
    return LendingMarketProfileFilterCriteriaDto(
      token: token ?? this.token,
      range: range ?? this.range,
      eMode: eMode ?? this.eMode,
      flashLoan: flashLoan ?? this.flashLoan,
      isolated: isolated ?? this.isolated,
      siloed: siloed ?? this.siloed,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      isDebtCeilingReached: isDebtCeilingReached ?? this.isDebtCeilingReached,
    );
  }

  LendingMarketProfileFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? token,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<bool?>? eMode,
    Wrapped<bool?>? flashLoan,
    Wrapped<bool?>? isolated,
    Wrapped<bool?>? siloed,
    Wrapped<bool?>? canBeCollateral,
    Wrapped<bool?>? canBeBorrowed,
    Wrapped<bool?>? canBorrowInIsolation,
    Wrapped<bool?>? isDebtCeilingReached,
  }) {
    return LendingMarketProfileFilterCriteriaDto(
      token: (token != null ? token.value : this.token),
      range: (range != null ? range.value : this.range),
      eMode: (eMode != null ? eMode.value : this.eMode),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      isolated: (isolated != null ? isolated.value : this.isolated),
      siloed: (siloed != null ? siloed.value : this.siloed),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      isDebtCeilingReached: (isDebtCeilingReached != null
          ? isDebtCeilingReached.value
          : this.isDebtCeilingReached),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileExtraProperties {
  const LendingMarketProfileExtraProperties({
    this.eModeCategoryProfile,
    this.participants,
  });

  factory LendingMarketProfileExtraProperties.fromJson(
    Map<String, dynamic> json,
  ) => _$LendingMarketProfileExtraPropertiesFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileExtraPropertiesToJson;
  Map<String, dynamic> toJson() =>
      _$LendingMarketProfileExtraPropertiesToJson(this);

  @JsonKey(name: 'eModeCategoryProfile')
  final bool? eModeCategoryProfile;
  @JsonKey(name: 'participants')
  final bool? participants;
  static const fromJsonFactory = _$LendingMarketProfileExtraPropertiesFromJson;
}

extension $LendingMarketProfileExtraPropertiesExtension
    on LendingMarketProfileExtraProperties {
  LendingMarketProfileExtraProperties copyWith({
    bool? eModeCategoryProfile,
    bool? participants,
  }) {
    return LendingMarketProfileExtraProperties(
      eModeCategoryProfile: eModeCategoryProfile ?? this.eModeCategoryProfile,
      participants: participants ?? this.participants,
    );
  }

  LendingMarketProfileExtraProperties copyWithWrapped({
    Wrapped<bool?>? eModeCategoryProfile,
    Wrapped<bool?>? participants,
  }) {
    return LendingMarketProfileExtraProperties(
      eModeCategoryProfile: (eModeCategoryProfile != null
          ? eModeCategoryProfile.value
          : this.eModeCategoryProfile),
      participants: (participants != null
          ? participants.value
          : this.participants),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileFilter {
  const LendingMarketProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
    this.extraProperties,
  });

  factory LendingMarketProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileFilterFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileFilterToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final LendingMarketProfileFilterCriteriaDto filters;
  @JsonKey(name: 'extraProperties')
  final LendingMarketProfileExtraProperties? extraProperties;
  static const fromJsonFactory = _$LendingMarketProfileFilterFromJson;
}

extension $LendingMarketProfileFilterExtension on LendingMarketProfileFilter {
  LendingMarketProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    LendingMarketProfileFilterCriteriaDto? filters,
    LendingMarketProfileExtraProperties? extraProperties,
  }) {
    return LendingMarketProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  LendingMarketProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<LendingMarketProfileFilterCriteriaDto>? filters,
    Wrapped<LendingMarketProfileExtraProperties?>? extraProperties,
  }) {
    return LendingMarketProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketProfileQuery {
  const LendingMarketProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory LendingMarketProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketProfileQueryFromJson(json);

  static const toJsonFactory = _$LendingMarketProfileQueryToJson;
  Map<String, dynamic> toJson() => _$LendingMarketProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <LendingMarketProfile>[])
  final List<LendingMarketProfile> resources;
  static const fromJsonFactory = _$LendingMarketProfileQueryFromJson;
}

extension $LendingMarketProfileQueryExtension on LendingMarketProfileQuery {
  LendingMarketProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<LendingMarketProfile>? resources,
  }) {
    return LendingMarketProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  LendingMarketProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<LendingMarketProfile>>? resources,
  }) {
    return LendingMarketProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class InitialPaymentMultiplier {
  const InitialPaymentMultiplier({
    required this.initialPaymentAmount,
    required this.initialPaymentToken,
    required this.usdValue,
  });

  factory InitialPaymentMultiplier.fromJson(Map<String, dynamic> json) =>
      _$InitialPaymentMultiplierFromJson(json);

  static const toJsonFactory = _$InitialPaymentMultiplierToJson;
  Map<String, dynamic> toJson() => _$InitialPaymentMultiplierToJson(this);

  @JsonKey(name: 'initialPaymentAmount')
  final String initialPaymentAmount;
  @JsonKey(name: 'initialPaymentToken')
  final String initialPaymentToken;
  @JsonKey(name: 'usdValue')
  final String usdValue;
  static const fromJsonFactory = _$InitialPaymentMultiplierFromJson;
}

extension $InitialPaymentMultiplierExtension on InitialPaymentMultiplier {
  InitialPaymentMultiplier copyWith({
    String? initialPaymentAmount,
    String? initialPaymentToken,
    String? usdValue,
  }) {
    return InitialPaymentMultiplier(
      initialPaymentAmount: initialPaymentAmount ?? this.initialPaymentAmount,
      initialPaymentToken: initialPaymentToken ?? this.initialPaymentToken,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  InitialPaymentMultiplier copyWithWrapped({
    Wrapped<String>? initialPaymentAmount,
    Wrapped<String>? initialPaymentToken,
    Wrapped<String>? usdValue,
  }) {
    return InitialPaymentMultiplier(
      initialPaymentAmount: (initialPaymentAmount != null
          ? initialPaymentAmount.value
          : this.initialPaymentAmount),
      initialPaymentToken: (initialPaymentToken != null
          ? initialPaymentToken.value
          : this.initialPaymentToken),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingEModeCategoryProfileDoc {
  const LendingEModeCategoryProfileDoc({
    required this.dataType,
    required this.name,
    required this.ltv,
    required this.liquidationThreshold,
    required this.liquidationBonus,
    required this.isDeprecated,
    required this.id,
    required this.pk,
    this.ts,
  });

  factory LendingEModeCategoryProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$LendingEModeCategoryProfileDocFromJson(json);

  static const toJsonFactory = _$LendingEModeCategoryProfileDocToJson;
  Map<String, dynamic> toJson() => _$LendingEModeCategoryProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'isDeprecated')
  final bool isDeprecated;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$LendingEModeCategoryProfileDocFromJson;
}

extension $LendingEModeCategoryProfileDocExtension
    on LendingEModeCategoryProfileDoc {
  LendingEModeCategoryProfileDoc copyWith({
    enums.LendingDataType? dataType,
    String? name,
    String? ltv,
    String? liquidationThreshold,
    String? liquidationBonus,
    bool? isDeprecated,
    String? id,
    String? pk,
    double? ts,
  }) {
    return LendingEModeCategoryProfileDoc(
      dataType: dataType ?? this.dataType,
      name: name ?? this.name,
      ltv: ltv ?? this.ltv,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      isDeprecated: isDeprecated ?? this.isDeprecated,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  LendingEModeCategoryProfileDoc copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? name,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationThreshold,
    Wrapped<String>? liquidationBonus,
    Wrapped<bool>? isDeprecated,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
  }) {
    return LendingEModeCategoryProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      name: (name != null ? name.value : this.name),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      isDeprecated: (isDeprecated != null
          ? isDeprecated.value
          : this.isDeprecated),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PickTypeClass {
  const PickTypeClass({
    required this.token,
    required this.name,
    required this.decimals,
    required this.address,
    required this.baseRate,
    required this.maxBorrowRate,
    required this.slopeRate1,
    required this.slopeRate2,
    required this.slopeRate3,
    required this.midUsageRate,
    required this.optimalUsageRate,
    required this.reserveFactor,
    required this.liquidationFee,
    required this.ltv,
    required this.liquidationBonus,
    required this.liquidationThreshold,
    required this.rewardsReserve,
    required this.reserves,
    required this.supplyAmount,
    required this.supplyAmountScaled,
    required this.borrowAmount,
    required this.borrowAmountScaled,
    required this.supplyCap,
    required this.borrowCap,
    required this.timestamp,
    required this.borrowApy,
    required this.supplyApy,
    required this.utilizationRate,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.isolated,
    required this.maxDebtUsd,
    this.debtCeiling,
    required this.siloed,
    required this.flashLoan,
    required this.flashLoanFee,
    required this.canBorrowInIsolation,
    required this.oracleProvider,
    this.extraApy,
    required this.indexes,
  });

  factory PickTypeClass.fromJson(Map<String, dynamic> json) =>
      _$PickTypeClassFromJson(json);

  static const toJsonFactory = _$PickTypeClassToJson;
  Map<String, dynamic> toJson() => _$PickTypeClassToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'baseRate')
  final String baseRate;
  @JsonKey(name: 'maxBorrowRate')
  final String maxBorrowRate;
  @JsonKey(name: 'slopeRate1')
  final String slopeRate1;
  @JsonKey(name: 'slopeRate2')
  final String slopeRate2;
  @JsonKey(name: 'slopeRate3')
  final String slopeRate3;
  @JsonKey(name: 'midUsageRate')
  final String midUsageRate;
  @JsonKey(name: 'optimalUsageRate')
  final String optimalUsageRate;
  @JsonKey(name: 'reserveFactor')
  final String reserveFactor;
  @JsonKey(name: 'liquidationFee')
  final String liquidationFee;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'rewardsReserve')
  final Object rewardsReserve;
  @JsonKey(name: 'reserves')
  final Object reserves;
  @JsonKey(name: 'supplyAmount')
  final Object supplyAmount;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmount')
  final Object borrowAmount;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'supplyCap')
  final String supplyCap;
  @JsonKey(name: 'borrowCap')
  final String borrowCap;
  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'borrowApy')
  final Object borrowApy;
  @JsonKey(name: 'supplyApy')
  final Object supplyApy;
  @JsonKey(name: 'utilizationRate')
  final Object utilizationRate;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'isolated')
  final bool isolated;
  @JsonKey(name: 'maxDebtUsd')
  final Object maxDebtUsd;
  @JsonKey(name: 'debtCeiling')
  final String? debtCeiling;
  @JsonKey(name: 'siloed')
  final bool siloed;
  @JsonKey(name: 'flashLoan')
  final bool flashLoan;
  @JsonKey(name: 'flashLoanFee')
  final String flashLoanFee;
  @JsonKey(name: 'canBorrowInIsolation')
  final bool canBorrowInIsolation;
  @JsonKey(name: 'oracleProvider')
  final LendingOracleUpdateStruct oracleProvider;
  @JsonKey(name: 'extraApy')
  final MarketExtraApy? extraApy;
  @JsonKey(name: 'indexes')
  final LendingIndexesDto indexes;
  static const fromJsonFactory = _$PickTypeClassFromJson;
}

extension $PickTypeClassExtension on PickTypeClass {
  PickTypeClass copyWith({
    String? token,
    String? name,
    double? decimals,
    String? address,
    String? baseRate,
    String? maxBorrowRate,
    String? slopeRate1,
    String? slopeRate2,
    String? slopeRate3,
    String? midUsageRate,
    String? optimalUsageRate,
    String? reserveFactor,
    String? liquidationFee,
    String? ltv,
    String? liquidationBonus,
    String? liquidationThreshold,
    Object? rewardsReserve,
    Object? reserves,
    Object? supplyAmount,
    Object? supplyAmountScaled,
    Object? borrowAmount,
    Object? borrowAmountScaled,
    String? supplyCap,
    String? borrowCap,
    Object? timestamp,
    Object? borrowApy,
    Object? supplyApy,
    Object? utilizationRate,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    bool? isolated,
    Object? maxDebtUsd,
    String? debtCeiling,
    bool? siloed,
    bool? flashLoan,
    String? flashLoanFee,
    bool? canBorrowInIsolation,
    LendingOracleUpdateStruct? oracleProvider,
    MarketExtraApy? extraApy,
    LendingIndexesDto? indexes,
  }) {
    return PickTypeClass(
      token: token ?? this.token,
      name: name ?? this.name,
      decimals: decimals ?? this.decimals,
      address: address ?? this.address,
      baseRate: baseRate ?? this.baseRate,
      maxBorrowRate: maxBorrowRate ?? this.maxBorrowRate,
      slopeRate1: slopeRate1 ?? this.slopeRate1,
      slopeRate2: slopeRate2 ?? this.slopeRate2,
      slopeRate3: slopeRate3 ?? this.slopeRate3,
      midUsageRate: midUsageRate ?? this.midUsageRate,
      optimalUsageRate: optimalUsageRate ?? this.optimalUsageRate,
      reserveFactor: reserveFactor ?? this.reserveFactor,
      liquidationFee: liquidationFee ?? this.liquidationFee,
      ltv: ltv ?? this.ltv,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      rewardsReserve: rewardsReserve ?? this.rewardsReserve,
      reserves: reserves ?? this.reserves,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      supplyCap: supplyCap ?? this.supplyCap,
      borrowCap: borrowCap ?? this.borrowCap,
      timestamp: timestamp ?? this.timestamp,
      borrowApy: borrowApy ?? this.borrowApy,
      supplyApy: supplyApy ?? this.supplyApy,
      utilizationRate: utilizationRate ?? this.utilizationRate,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      isolated: isolated ?? this.isolated,
      maxDebtUsd: maxDebtUsd ?? this.maxDebtUsd,
      debtCeiling: debtCeiling ?? this.debtCeiling,
      siloed: siloed ?? this.siloed,
      flashLoan: flashLoan ?? this.flashLoan,
      flashLoanFee: flashLoanFee ?? this.flashLoanFee,
      canBorrowInIsolation: canBorrowInIsolation ?? this.canBorrowInIsolation,
      oracleProvider: oracleProvider ?? this.oracleProvider,
      extraApy: extraApy ?? this.extraApy,
      indexes: indexes ?? this.indexes,
    );
  }

  PickTypeClass copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<String>? name,
    Wrapped<double>? decimals,
    Wrapped<String>? address,
    Wrapped<String>? baseRate,
    Wrapped<String>? maxBorrowRate,
    Wrapped<String>? slopeRate1,
    Wrapped<String>? slopeRate2,
    Wrapped<String>? slopeRate3,
    Wrapped<String>? midUsageRate,
    Wrapped<String>? optimalUsageRate,
    Wrapped<String>? reserveFactor,
    Wrapped<String>? liquidationFee,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationBonus,
    Wrapped<String>? liquidationThreshold,
    Wrapped<Object>? rewardsReserve,
    Wrapped<Object>? reserves,
    Wrapped<Object>? supplyAmount,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmount,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<String>? supplyCap,
    Wrapped<String>? borrowCap,
    Wrapped<Object>? timestamp,
    Wrapped<Object>? borrowApy,
    Wrapped<Object>? supplyApy,
    Wrapped<Object>? utilizationRate,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<bool>? isolated,
    Wrapped<Object>? maxDebtUsd,
    Wrapped<String?>? debtCeiling,
    Wrapped<bool>? siloed,
    Wrapped<bool>? flashLoan,
    Wrapped<String>? flashLoanFee,
    Wrapped<bool>? canBorrowInIsolation,
    Wrapped<LendingOracleUpdateStruct>? oracleProvider,
    Wrapped<MarketExtraApy?>? extraApy,
    Wrapped<LendingIndexesDto>? indexes,
  }) {
    return PickTypeClass(
      token: (token != null ? token.value : this.token),
      name: (name != null ? name.value : this.name),
      decimals: (decimals != null ? decimals.value : this.decimals),
      address: (address != null ? address.value : this.address),
      baseRate: (baseRate != null ? baseRate.value : this.baseRate),
      maxBorrowRate: (maxBorrowRate != null
          ? maxBorrowRate.value
          : this.maxBorrowRate),
      slopeRate1: (slopeRate1 != null ? slopeRate1.value : this.slopeRate1),
      slopeRate2: (slopeRate2 != null ? slopeRate2.value : this.slopeRate2),
      slopeRate3: (slopeRate3 != null ? slopeRate3.value : this.slopeRate3),
      midUsageRate: (midUsageRate != null
          ? midUsageRate.value
          : this.midUsageRate),
      optimalUsageRate: (optimalUsageRate != null
          ? optimalUsageRate.value
          : this.optimalUsageRate),
      reserveFactor: (reserveFactor != null
          ? reserveFactor.value
          : this.reserveFactor),
      liquidationFee: (liquidationFee != null
          ? liquidationFee.value
          : this.liquidationFee),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      rewardsReserve: (rewardsReserve != null
          ? rewardsReserve.value
          : this.rewardsReserve),
      reserves: (reserves != null ? reserves.value : this.reserves),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      supplyCap: (supplyCap != null ? supplyCap.value : this.supplyCap),
      borrowCap: (borrowCap != null ? borrowCap.value : this.borrowCap),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      borrowApy: (borrowApy != null ? borrowApy.value : this.borrowApy),
      supplyApy: (supplyApy != null ? supplyApy.value : this.supplyApy),
      utilizationRate: (utilizationRate != null
          ? utilizationRate.value
          : this.utilizationRate),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      isolated: (isolated != null ? isolated.value : this.isolated),
      maxDebtUsd: (maxDebtUsd != null ? maxDebtUsd.value : this.maxDebtUsd),
      debtCeiling: (debtCeiling != null ? debtCeiling.value : this.debtCeiling),
      siloed: (siloed != null ? siloed.value : this.siloed),
      flashLoan: (flashLoan != null ? flashLoan.value : this.flashLoan),
      flashLoanFee: (flashLoanFee != null
          ? flashLoanFee.value
          : this.flashLoanFee),
      canBorrowInIsolation: (canBorrowInIsolation != null
          ? canBorrowInIsolation.value
          : this.canBorrowInIsolation),
      oracleProvider: (oracleProvider != null
          ? oracleProvider.value
          : this.oracleProvider),
      extraApy: (extraApy != null ? extraApy.value : this.extraApy),
      indexes: (indexes != null ? indexes.value : this.indexes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingAccountProfile {
  const LendingAccountProfile({
    required this.dataType,
    required this.identifier,
    required this.nonce,
    required this.token,
    required this.supplyAmountScaled,
    required this.borrowAmountScaled,
    required this.entryLiquidationThreshold,
    required this.entryLiquidationBonus,
    required this.entryLiquidationFee,
    required this.entryLtv,
    this.isolated,
    required this.positionMode,
    this.eModeCategory,
    required this.address,
    this.initialPaymentMultiplier,
    required this.isClassic,
    required this.id,
    required this.pk,
    required this.ts,
    required this.supplyAmount,
    required this.borrowAmount,
    this.eModeCategoryProfile,
    required this.marketProfile,
  });

  factory LendingAccountProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingAccountProfileFromJson(json);

  static const toJsonFactory = _$LendingAccountProfileToJson;
  Map<String, dynamic> toJson() => _$LendingAccountProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'supplyAmountScaled')
  final Object supplyAmountScaled;
  @JsonKey(name: 'borrowAmountScaled')
  final Object borrowAmountScaled;
  @JsonKey(name: 'entryLiquidationThreshold')
  final String entryLiquidationThreshold;
  @JsonKey(name: 'entryLiquidationBonus')
  final String entryLiquidationBonus;
  @JsonKey(name: 'entryLiquidationFee')
  final String entryLiquidationFee;
  @JsonKey(name: 'entryLtv')
  final String entryLtv;
  @JsonKey(name: 'isolated')
  final bool? isolated;
  @JsonKey(
    name: 'positionMode',
    toJson: positionModeToJson,
    fromJson: positionModeFromJson,
  )
  final enums.PositionMode positionMode;
  @JsonKey(name: 'eModeCategory')
  final String? eModeCategory;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'initialPaymentMultiplier')
  final InitialPaymentMultiplier? initialPaymentMultiplier;
  @JsonKey(name: 'isClassic')
  final bool isClassic;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'supplyAmount')
  final String supplyAmount;
  @JsonKey(name: 'borrowAmount')
  final String borrowAmount;
  @JsonKey(name: 'eModeCategoryProfile')
  final LendingEModeCategoryProfileDoc? eModeCategoryProfile;
  @JsonKey(name: 'marketProfile')
  final PickTypeClass marketProfile;
  static const fromJsonFactory = _$LendingAccountProfileFromJson;
}

extension $LendingAccountProfileExtension on LendingAccountProfile {
  LendingAccountProfile copyWith({
    enums.LendingDataType? dataType,
    String? identifier,
    double? nonce,
    String? token,
    Object? supplyAmountScaled,
    Object? borrowAmountScaled,
    String? entryLiquidationThreshold,
    String? entryLiquidationBonus,
    String? entryLiquidationFee,
    String? entryLtv,
    bool? isolated,
    enums.PositionMode? positionMode,
    String? eModeCategory,
    String? address,
    InitialPaymentMultiplier? initialPaymentMultiplier,
    bool? isClassic,
    String? id,
    String? pk,
    double? ts,
    String? supplyAmount,
    String? borrowAmount,
    LendingEModeCategoryProfileDoc? eModeCategoryProfile,
    PickTypeClass? marketProfile,
  }) {
    return LendingAccountProfile(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      nonce: nonce ?? this.nonce,
      token: token ?? this.token,
      supplyAmountScaled: supplyAmountScaled ?? this.supplyAmountScaled,
      borrowAmountScaled: borrowAmountScaled ?? this.borrowAmountScaled,
      entryLiquidationThreshold:
          entryLiquidationThreshold ?? this.entryLiquidationThreshold,
      entryLiquidationBonus:
          entryLiquidationBonus ?? this.entryLiquidationBonus,
      entryLiquidationFee: entryLiquidationFee ?? this.entryLiquidationFee,
      entryLtv: entryLtv ?? this.entryLtv,
      isolated: isolated ?? this.isolated,
      positionMode: positionMode ?? this.positionMode,
      eModeCategory: eModeCategory ?? this.eModeCategory,
      address: address ?? this.address,
      initialPaymentMultiplier:
          initialPaymentMultiplier ?? this.initialPaymentMultiplier,
      isClassic: isClassic ?? this.isClassic,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      supplyAmount: supplyAmount ?? this.supplyAmount,
      borrowAmount: borrowAmount ?? this.borrowAmount,
      eModeCategoryProfile: eModeCategoryProfile ?? this.eModeCategoryProfile,
      marketProfile: marketProfile ?? this.marketProfile,
    );
  }

  LendingAccountProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<double>? nonce,
    Wrapped<String>? token,
    Wrapped<Object>? supplyAmountScaled,
    Wrapped<Object>? borrowAmountScaled,
    Wrapped<String>? entryLiquidationThreshold,
    Wrapped<String>? entryLiquidationBonus,
    Wrapped<String>? entryLiquidationFee,
    Wrapped<String>? entryLtv,
    Wrapped<bool?>? isolated,
    Wrapped<enums.PositionMode>? positionMode,
    Wrapped<String?>? eModeCategory,
    Wrapped<String>? address,
    Wrapped<InitialPaymentMultiplier?>? initialPaymentMultiplier,
    Wrapped<bool>? isClassic,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<String>? supplyAmount,
    Wrapped<String>? borrowAmount,
    Wrapped<LendingEModeCategoryProfileDoc?>? eModeCategoryProfile,
    Wrapped<PickTypeClass>? marketProfile,
  }) {
    return LendingAccountProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      nonce: (nonce != null ? nonce.value : this.nonce),
      token: (token != null ? token.value : this.token),
      supplyAmountScaled: (supplyAmountScaled != null
          ? supplyAmountScaled.value
          : this.supplyAmountScaled),
      borrowAmountScaled: (borrowAmountScaled != null
          ? borrowAmountScaled.value
          : this.borrowAmountScaled),
      entryLiquidationThreshold: (entryLiquidationThreshold != null
          ? entryLiquidationThreshold.value
          : this.entryLiquidationThreshold),
      entryLiquidationBonus: (entryLiquidationBonus != null
          ? entryLiquidationBonus.value
          : this.entryLiquidationBonus),
      entryLiquidationFee: (entryLiquidationFee != null
          ? entryLiquidationFee.value
          : this.entryLiquidationFee),
      entryLtv: (entryLtv != null ? entryLtv.value : this.entryLtv),
      isolated: (isolated != null ? isolated.value : this.isolated),
      positionMode: (positionMode != null
          ? positionMode.value
          : this.positionMode),
      eModeCategory: (eModeCategory != null
          ? eModeCategory.value
          : this.eModeCategory),
      address: (address != null ? address.value : this.address),
      initialPaymentMultiplier: (initialPaymentMultiplier != null
          ? initialPaymentMultiplier.value
          : this.initialPaymentMultiplier),
      isClassic: (isClassic != null ? isClassic.value : this.isClassic),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      supplyAmount: (supplyAmount != null
          ? supplyAmount.value
          : this.supplyAmount),
      borrowAmount: (borrowAmount != null
          ? borrowAmount.value
          : this.borrowAmount),
      eModeCategoryProfile: (eModeCategoryProfile != null
          ? eModeCategoryProfile.value
          : this.eModeCategoryProfile),
      marketProfile: (marketProfile != null
          ? marketProfile.value
          : this.marketProfile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingAccountPnl {
  const LendingAccountPnl({
    required this.token,
    required this.identifier,
    required this.pnlUSD,
    required this.pnlToken,
    required this.debt,
    required this.debtUSD,
    required this.interest,
    required this.interestUSD,
  });

  factory LendingAccountPnl.fromJson(Map<String, dynamic> json) =>
      _$LendingAccountPnlFromJson(json);

  static const toJsonFactory = _$LendingAccountPnlToJson;
  Map<String, dynamic> toJson() => _$LendingAccountPnlToJson(this);

  @JsonKey(name: 'Token')
  final String token;
  @JsonKey(name: 'Identifier')
  final String identifier;
  @JsonKey(name: 'PnlUSD')
  final double pnlUSD;
  @JsonKey(name: 'PnlToken')
  final double pnlToken;
  @JsonKey(name: 'Debt')
  final double debt;
  @JsonKey(name: 'DebtUSD')
  final double debtUSD;
  @JsonKey(name: 'Interest')
  final double interest;
  @JsonKey(name: 'InterestUSD')
  final double interestUSD;
  static const fromJsonFactory = _$LendingAccountPnlFromJson;
}

extension $LendingAccountPnlExtension on LendingAccountPnl {
  LendingAccountPnl copyWith({
    String? token,
    String? identifier,
    double? pnlUSD,
    double? pnlToken,
    double? debt,
    double? debtUSD,
    double? interest,
    double? interestUSD,
  }) {
    return LendingAccountPnl(
      token: token ?? this.token,
      identifier: identifier ?? this.identifier,
      pnlUSD: pnlUSD ?? this.pnlUSD,
      pnlToken: pnlToken ?? this.pnlToken,
      debt: debt ?? this.debt,
      debtUSD: debtUSD ?? this.debtUSD,
      interest: interest ?? this.interest,
      interestUSD: interestUSD ?? this.interestUSD,
    );
  }

  LendingAccountPnl copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<String>? identifier,
    Wrapped<double>? pnlUSD,
    Wrapped<double>? pnlToken,
    Wrapped<double>? debt,
    Wrapped<double>? debtUSD,
    Wrapped<double>? interest,
    Wrapped<double>? interestUSD,
  }) {
    return LendingAccountPnl(
      token: (token != null ? token.value : this.token),
      identifier: (identifier != null ? identifier.value : this.identifier),
      pnlUSD: (pnlUSD != null ? pnlUSD.value : this.pnlUSD),
      pnlToken: (pnlToken != null ? pnlToken.value : this.pnlToken),
      debt: (debt != null ? debt.value : this.debt),
      debtUSD: (debtUSD != null ? debtUSD.value : this.debtUSD),
      interest: (interest != null ? interest.value : this.interest),
      interestUSD: (interestUSD != null ? interestUSD.value : this.interestUSD),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingAccountSummary {
  const LendingAccountSummary({
    required this.supplied,
    required this.borrowed,
    required this.liquidationCollateralInDollars,
    required this.collateralInDollars,
    required this.borrowedInDollars,
    required this.collateralInEgld,
    required this.borrowedInEgld,
    required this.totalApy,
    required this.healthFactor,
  });

  factory LendingAccountSummary.fromJson(Map<String, dynamic> json) =>
      _$LendingAccountSummaryFromJson(json);

  static const toJsonFactory = _$LendingAccountSummaryToJson;
  Map<String, dynamic> toJson() => _$LendingAccountSummaryToJson(this);

  @JsonKey(name: 'supplied', defaultValue: <String>[])
  final List<String> supplied;
  @JsonKey(name: 'borrowed', defaultValue: <String>[])
  final List<String> borrowed;
  @JsonKey(name: 'liquidationCollateralInDollars')
  final String liquidationCollateralInDollars;
  @JsonKey(name: 'collateralInDollars')
  final String collateralInDollars;
  @JsonKey(name: 'borrowedInDollars')
  final String borrowedInDollars;
  @JsonKey(name: 'collateralInEgld')
  final String collateralInEgld;
  @JsonKey(name: 'borrowedInEgld')
  final String borrowedInEgld;
  @JsonKey(name: 'totalApy')
  final String totalApy;
  @JsonKey(name: 'healthFactor')
  final String healthFactor;
  static const fromJsonFactory = _$LendingAccountSummaryFromJson;
}

extension $LendingAccountSummaryExtension on LendingAccountSummary {
  LendingAccountSummary copyWith({
    List<String>? supplied,
    List<String>? borrowed,
    String? liquidationCollateralInDollars,
    String? collateralInDollars,
    String? borrowedInDollars,
    String? collateralInEgld,
    String? borrowedInEgld,
    String? totalApy,
    String? healthFactor,
  }) {
    return LendingAccountSummary(
      supplied: supplied ?? this.supplied,
      borrowed: borrowed ?? this.borrowed,
      liquidationCollateralInDollars:
          liquidationCollateralInDollars ?? this.liquidationCollateralInDollars,
      collateralInDollars: collateralInDollars ?? this.collateralInDollars,
      borrowedInDollars: borrowedInDollars ?? this.borrowedInDollars,
      collateralInEgld: collateralInEgld ?? this.collateralInEgld,
      borrowedInEgld: borrowedInEgld ?? this.borrowedInEgld,
      totalApy: totalApy ?? this.totalApy,
      healthFactor: healthFactor ?? this.healthFactor,
    );
  }

  LendingAccountSummary copyWithWrapped({
    Wrapped<List<String>>? supplied,
    Wrapped<List<String>>? borrowed,
    Wrapped<String>? liquidationCollateralInDollars,
    Wrapped<String>? collateralInDollars,
    Wrapped<String>? borrowedInDollars,
    Wrapped<String>? collateralInEgld,
    Wrapped<String>? borrowedInEgld,
    Wrapped<String>? totalApy,
    Wrapped<String>? healthFactor,
  }) {
    return LendingAccountSummary(
      supplied: (supplied != null ? supplied.value : this.supplied),
      borrowed: (borrowed != null ? borrowed.value : this.borrowed),
      liquidationCollateralInDollars: (liquidationCollateralInDollars != null
          ? liquidationCollateralInDollars.value
          : this.liquidationCollateralInDollars),
      collateralInDollars: (collateralInDollars != null
          ? collateralInDollars.value
          : this.collateralInDollars),
      borrowedInDollars: (borrowedInDollars != null
          ? borrowedInDollars.value
          : this.borrowedInDollars),
      collateralInEgld: (collateralInEgld != null
          ? collateralInEgld.value
          : this.collateralInEgld),
      borrowedInEgld: (borrowedInEgld != null
          ? borrowedInEgld.value
          : this.borrowedInEgld),
      totalApy: (totalApy != null ? totalApy.value : this.totalApy),
      healthFactor: (healthFactor != null
          ? healthFactor.value
          : this.healthFactor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortLendingTokenEModeProfileDoc {
  const ShortLendingTokenEModeProfileDoc({
    required this.token,
    required this.canBeCollateral,
    required this.canBeBorrowed,
    required this.eModeCategory,
  });

  factory ShortLendingTokenEModeProfileDoc.fromJson(
    Map<String, dynamic> json,
  ) => _$ShortLendingTokenEModeProfileDocFromJson(json);

  static const toJsonFactory = _$ShortLendingTokenEModeProfileDocToJson;
  Map<String, dynamic> toJson() =>
      _$ShortLendingTokenEModeProfileDocToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'canBeCollateral')
  final bool canBeCollateral;
  @JsonKey(name: 'canBeBorrowed')
  final bool canBeBorrowed;
  @JsonKey(name: 'eModeCategory')
  final String eModeCategory;
  static const fromJsonFactory = _$ShortLendingTokenEModeProfileDocFromJson;
}

extension $ShortLendingTokenEModeProfileDocExtension
    on ShortLendingTokenEModeProfileDoc {
  ShortLendingTokenEModeProfileDoc copyWith({
    String? token,
    bool? canBeCollateral,
    bool? canBeBorrowed,
    String? eModeCategory,
  }) {
    return ShortLendingTokenEModeProfileDoc(
      token: token ?? this.token,
      canBeCollateral: canBeCollateral ?? this.canBeCollateral,
      canBeBorrowed: canBeBorrowed ?? this.canBeBorrowed,
      eModeCategory: eModeCategory ?? this.eModeCategory,
    );
  }

  ShortLendingTokenEModeProfileDoc copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<bool>? canBeCollateral,
    Wrapped<bool>? canBeBorrowed,
    Wrapped<String>? eModeCategory,
  }) {
    return ShortLendingTokenEModeProfileDoc(
      token: (token != null ? token.value : this.token),
      canBeCollateral: (canBeCollateral != null
          ? canBeCollateral.value
          : this.canBeCollateral),
      canBeBorrowed: (canBeBorrowed != null
          ? canBeBorrowed.value
          : this.canBeBorrowed),
      eModeCategory: (eModeCategory != null
          ? eModeCategory.value
          : this.eModeCategory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingEModeCategoryProfile {
  const LendingEModeCategoryProfile({
    required this.dataType,
    required this.name,
    required this.ltv,
    required this.liquidationThreshold,
    required this.liquidationBonus,
    required this.isDeprecated,
    required this.id,
    required this.pk,
    this.ts,
    required this.eModeTokenProfiles,
  });

  factory LendingEModeCategoryProfile.fromJson(Map<String, dynamic> json) =>
      _$LendingEModeCategoryProfileFromJson(json);

  static const toJsonFactory = _$LendingEModeCategoryProfileToJson;
  Map<String, dynamic> toJson() => _$LendingEModeCategoryProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: lendingDataTypeToJson,
    fromJson: lendingDataTypeFromJson,
  )
  final enums.LendingDataType dataType;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ltv')
  final String ltv;
  @JsonKey(name: 'liquidationThreshold')
  final String liquidationThreshold;
  @JsonKey(name: 'liquidationBonus')
  final String liquidationBonus;
  @JsonKey(name: 'isDeprecated')
  final bool isDeprecated;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(
    name: 'eModeTokenProfiles',
    defaultValue: <ShortLendingTokenEModeProfileDoc>[],
  )
  final List<ShortLendingTokenEModeProfileDoc> eModeTokenProfiles;
  static const fromJsonFactory = _$LendingEModeCategoryProfileFromJson;
}

extension $LendingEModeCategoryProfileExtension on LendingEModeCategoryProfile {
  LendingEModeCategoryProfile copyWith({
    enums.LendingDataType? dataType,
    String? name,
    String? ltv,
    String? liquidationThreshold,
    String? liquidationBonus,
    bool? isDeprecated,
    String? id,
    String? pk,
    double? ts,
    List<ShortLendingTokenEModeProfileDoc>? eModeTokenProfiles,
  }) {
    return LendingEModeCategoryProfile(
      dataType: dataType ?? this.dataType,
      name: name ?? this.name,
      ltv: ltv ?? this.ltv,
      liquidationThreshold: liquidationThreshold ?? this.liquidationThreshold,
      liquidationBonus: liquidationBonus ?? this.liquidationBonus,
      isDeprecated: isDeprecated ?? this.isDeprecated,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      eModeTokenProfiles: eModeTokenProfiles ?? this.eModeTokenProfiles,
    );
  }

  LendingEModeCategoryProfile copyWithWrapped({
    Wrapped<enums.LendingDataType>? dataType,
    Wrapped<String>? name,
    Wrapped<String>? ltv,
    Wrapped<String>? liquidationThreshold,
    Wrapped<String>? liquidationBonus,
    Wrapped<bool>? isDeprecated,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
    Wrapped<List<ShortLendingTokenEModeProfileDoc>>? eModeTokenProfiles,
  }) {
    return LendingEModeCategoryProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      name: (name != null ? name.value : this.name),
      ltv: (ltv != null ? ltv.value : this.ltv),
      liquidationThreshold: (liquidationThreshold != null
          ? liquidationThreshold.value
          : this.liquidationThreshold),
      liquidationBonus: (liquidationBonus != null
          ? liquidationBonus.value
          : this.liquidationBonus),
      isDeprecated: (isDeprecated != null
          ? isDeprecated.value
          : this.isDeprecated),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      eModeTokenProfiles: (eModeTokenProfiles != null
          ? eModeTokenProfiles.value
          : this.eModeTokenProfiles),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketAnalyticsGraph {
  const LendingMarketAnalyticsGraph({
    required this.token,
    required this.timestamp,
    required this.minSupplyApy,
    required this.maxSupplyApy,
    required this.avgSupplyApy,
    required this.minBorrowApy,
    required this.maxBorrowApy,
    required this.avgBorrowApy,
    required this.minUtilizationRate,
    required this.maxUtilizationRate,
    required this.avgUtilizationRate,
    required this.minSupplyAmount,
    required this.maxSupplyAmount,
    required this.avgSupplyAmount,
    required this.minBorrowAmount,
    required this.maxBorrowAmount,
    required this.avgBorrowAmount,
    required this.twapSupplyApy,
    required this.twapBorrowApy,
    required this.twapUtilizationRate,
    required this.twapSupplyAmount,
    required this.twapBorrowAmount,
  });

  factory LendingMarketAnalyticsGraph.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketAnalyticsGraphFromJson(json);

  static const toJsonFactory = _$LendingMarketAnalyticsGraphToJson;
  Map<String, dynamic> toJson() => _$LendingMarketAnalyticsGraphToJson(this);

  @JsonKey(name: 'token')
  final String token;
  @JsonKey(name: 'timestamp', defaultValue: <List<Object?>>[])
  final List<List<Object?>> timestamp;
  @JsonKey(name: 'minSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minSupplyApy;
  @JsonKey(name: 'maxSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxSupplyApy;
  @JsonKey(name: 'avgSupplyApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgSupplyApy;
  @JsonKey(name: 'minBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minBorrowApy;
  @JsonKey(name: 'maxBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxBorrowApy;
  @JsonKey(name: 'avgBorrowApy', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgBorrowApy;
  @JsonKey(name: 'minUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minUtilizationRate;
  @JsonKey(name: 'maxUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxUtilizationRate;
  @JsonKey(name: 'avgUtilizationRate', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgUtilizationRate;
  @JsonKey(name: 'minSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minSupplyAmount;
  @JsonKey(name: 'maxSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxSupplyAmount;
  @JsonKey(name: 'avgSupplyAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgSupplyAmount;
  @JsonKey(name: 'minBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> minBorrowAmount;
  @JsonKey(name: 'maxBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> maxBorrowAmount;
  @JsonKey(name: 'avgBorrowAmount', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgBorrowAmount;
  @JsonKey(name: 'twapSupplyApy')
  final double twapSupplyApy;
  @JsonKey(name: 'twapBorrowApy')
  final double twapBorrowApy;
  @JsonKey(name: 'twapUtilizationRate')
  final double twapUtilizationRate;
  @JsonKey(name: 'twapSupplyAmount')
  final double twapSupplyAmount;
  @JsonKey(name: 'twapBorrowAmount')
  final double twapBorrowAmount;
  static const fromJsonFactory = _$LendingMarketAnalyticsGraphFromJson;
}

extension $LendingMarketAnalyticsGraphExtension on LendingMarketAnalyticsGraph {
  LendingMarketAnalyticsGraph copyWith({
    String? token,
    List<List<Object?>>? timestamp,
    List<List<Object?>>? minSupplyApy,
    List<List<Object?>>? maxSupplyApy,
    List<List<Object?>>? avgSupplyApy,
    List<List<Object?>>? minBorrowApy,
    List<List<Object?>>? maxBorrowApy,
    List<List<Object?>>? avgBorrowApy,
    List<List<Object?>>? minUtilizationRate,
    List<List<Object?>>? maxUtilizationRate,
    List<List<Object?>>? avgUtilizationRate,
    List<List<Object?>>? minSupplyAmount,
    List<List<Object?>>? maxSupplyAmount,
    List<List<Object?>>? avgSupplyAmount,
    List<List<Object?>>? minBorrowAmount,
    List<List<Object?>>? maxBorrowAmount,
    List<List<Object?>>? avgBorrowAmount,
    double? twapSupplyApy,
    double? twapBorrowApy,
    double? twapUtilizationRate,
    double? twapSupplyAmount,
    double? twapBorrowAmount,
  }) {
    return LendingMarketAnalyticsGraph(
      token: token ?? this.token,
      timestamp: timestamp ?? this.timestamp,
      minSupplyApy: minSupplyApy ?? this.minSupplyApy,
      maxSupplyApy: maxSupplyApy ?? this.maxSupplyApy,
      avgSupplyApy: avgSupplyApy ?? this.avgSupplyApy,
      minBorrowApy: minBorrowApy ?? this.minBorrowApy,
      maxBorrowApy: maxBorrowApy ?? this.maxBorrowApy,
      avgBorrowApy: avgBorrowApy ?? this.avgBorrowApy,
      minUtilizationRate: minUtilizationRate ?? this.minUtilizationRate,
      maxUtilizationRate: maxUtilizationRate ?? this.maxUtilizationRate,
      avgUtilizationRate: avgUtilizationRate ?? this.avgUtilizationRate,
      minSupplyAmount: minSupplyAmount ?? this.minSupplyAmount,
      maxSupplyAmount: maxSupplyAmount ?? this.maxSupplyAmount,
      avgSupplyAmount: avgSupplyAmount ?? this.avgSupplyAmount,
      minBorrowAmount: minBorrowAmount ?? this.minBorrowAmount,
      maxBorrowAmount: maxBorrowAmount ?? this.maxBorrowAmount,
      avgBorrowAmount: avgBorrowAmount ?? this.avgBorrowAmount,
      twapSupplyApy: twapSupplyApy ?? this.twapSupplyApy,
      twapBorrowApy: twapBorrowApy ?? this.twapBorrowApy,
      twapUtilizationRate: twapUtilizationRate ?? this.twapUtilizationRate,
      twapSupplyAmount: twapSupplyAmount ?? this.twapSupplyAmount,
      twapBorrowAmount: twapBorrowAmount ?? this.twapBorrowAmount,
    );
  }

  LendingMarketAnalyticsGraph copyWithWrapped({
    Wrapped<String>? token,
    Wrapped<List<List<Object?>>>? timestamp,
    Wrapped<List<List<Object?>>>? minSupplyApy,
    Wrapped<List<List<Object?>>>? maxSupplyApy,
    Wrapped<List<List<Object?>>>? avgSupplyApy,
    Wrapped<List<List<Object?>>>? minBorrowApy,
    Wrapped<List<List<Object?>>>? maxBorrowApy,
    Wrapped<List<List<Object?>>>? avgBorrowApy,
    Wrapped<List<List<Object?>>>? minUtilizationRate,
    Wrapped<List<List<Object?>>>? maxUtilizationRate,
    Wrapped<List<List<Object?>>>? avgUtilizationRate,
    Wrapped<List<List<Object?>>>? minSupplyAmount,
    Wrapped<List<List<Object?>>>? maxSupplyAmount,
    Wrapped<List<List<Object?>>>? avgSupplyAmount,
    Wrapped<List<List<Object?>>>? minBorrowAmount,
    Wrapped<List<List<Object?>>>? maxBorrowAmount,
    Wrapped<List<List<Object?>>>? avgBorrowAmount,
    Wrapped<double>? twapSupplyApy,
    Wrapped<double>? twapBorrowApy,
    Wrapped<double>? twapUtilizationRate,
    Wrapped<double>? twapSupplyAmount,
    Wrapped<double>? twapBorrowAmount,
  }) {
    return LendingMarketAnalyticsGraph(
      token: (token != null ? token.value : this.token),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minSupplyApy: (minSupplyApy != null
          ? minSupplyApy.value
          : this.minSupplyApy),
      maxSupplyApy: (maxSupplyApy != null
          ? maxSupplyApy.value
          : this.maxSupplyApy),
      avgSupplyApy: (avgSupplyApy != null
          ? avgSupplyApy.value
          : this.avgSupplyApy),
      minBorrowApy: (minBorrowApy != null
          ? minBorrowApy.value
          : this.minBorrowApy),
      maxBorrowApy: (maxBorrowApy != null
          ? maxBorrowApy.value
          : this.maxBorrowApy),
      avgBorrowApy: (avgBorrowApy != null
          ? avgBorrowApy.value
          : this.avgBorrowApy),
      minUtilizationRate: (minUtilizationRate != null
          ? minUtilizationRate.value
          : this.minUtilizationRate),
      maxUtilizationRate: (maxUtilizationRate != null
          ? maxUtilizationRate.value
          : this.maxUtilizationRate),
      avgUtilizationRate: (avgUtilizationRate != null
          ? avgUtilizationRate.value
          : this.avgUtilizationRate),
      minSupplyAmount: (minSupplyAmount != null
          ? minSupplyAmount.value
          : this.minSupplyAmount),
      maxSupplyAmount: (maxSupplyAmount != null
          ? maxSupplyAmount.value
          : this.maxSupplyAmount),
      avgSupplyAmount: (avgSupplyAmount != null
          ? avgSupplyAmount.value
          : this.avgSupplyAmount),
      minBorrowAmount: (minBorrowAmount != null
          ? minBorrowAmount.value
          : this.minBorrowAmount),
      maxBorrowAmount: (maxBorrowAmount != null
          ? maxBorrowAmount.value
          : this.maxBorrowAmount),
      avgBorrowAmount: (avgBorrowAmount != null
          ? avgBorrowAmount.value
          : this.avgBorrowAmount),
      twapSupplyApy: (twapSupplyApy != null
          ? twapSupplyApy.value
          : this.twapSupplyApy),
      twapBorrowApy: (twapBorrowApy != null
          ? twapBorrowApy.value
          : this.twapBorrowApy),
      twapUtilizationRate: (twapUtilizationRate != null
          ? twapUtilizationRate.value
          : this.twapUtilizationRate),
      twapSupplyAmount: (twapSupplyAmount != null
          ? twapSupplyAmount.value
          : this.twapSupplyAmount),
      twapBorrowAmount: (twapBorrowAmount != null
          ? twapBorrowAmount.value
          : this.twapBorrowAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingMarketAverageGraph {
  const LendingMarketAverageGraph();

  factory LendingMarketAverageGraph.fromJson(Map<String, dynamic> json) =>
      _$LendingMarketAverageGraphFromJson(json);

  static const toJsonFactory = _$LendingMarketAverageGraphToJson;
  Map<String, dynamic> toJson() => _$LendingMarketAverageGraphToJson(this);

  static const fromJsonFactory = _$LendingMarketAverageGraphFromJson;
}

@JsonSerializable(explicitToJson: true)
class OwnerDto {
  const OwnerDto({
    required this.username,
    required this.address,
    required this.profile,
  });

  factory OwnerDto.fromJson(Map<String, dynamic> json) =>
      _$OwnerDtoFromJson(json);

  static const toJsonFactory = _$OwnerDtoToJson;
  Map<String, dynamic> toJson() => _$OwnerDtoToJson(this);

  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String profile;
  static const fromJsonFactory = _$OwnerDtoFromJson;
}

extension $OwnerDtoExtension on OwnerDto {
  OwnerDto copyWith({String? username, String? address, String? profile}) {
    return OwnerDto(
      username: username ?? this.username,
      address: address ?? this.address,
      profile: profile ?? this.profile,
    );
  }

  OwnerDto copyWithWrapped({
    Wrapped<String>? username,
    Wrapped<String>? address,
    Wrapped<String>? profile,
  }) {
    return OwnerDto(
      username: (username != null ? username.value : this.username),
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingPositionStatus {
  const LendingPositionStatus({
    required this.position,
    required this.identifier,
    required this.supplied,
    required this.borrowed,
    required this.healthFactor,
    required this.wallet,
    required this.isEMode,
    required this.positionMode,
  });

  factory LendingPositionStatus.fromJson(Map<String, dynamic> json) =>
      _$LendingPositionStatusFromJson(json);

  static const toJsonFactory = _$LendingPositionStatusToJson;
  Map<String, dynamic> toJson() => _$LendingPositionStatusToJson(this);

  @JsonKey(name: 'position')
  final double position;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'supplied')
  final double supplied;
  @JsonKey(name: 'borrowed')
  final double borrowed;
  @JsonKey(name: 'healthFactor')
  final double healthFactor;
  @JsonKey(name: 'wallet')
  final OwnerDto wallet;
  @JsonKey(name: 'isEMode')
  final bool isEMode;
  @JsonKey(
    name: 'positionMode',
    toJson: lendingPositionStatusPositionModeToJson,
    fromJson: lendingPositionStatusPositionModeFromJson,
  )
  final enums.LendingPositionStatusPositionMode positionMode;
  static const fromJsonFactory = _$LendingPositionStatusFromJson;
}

extension $LendingPositionStatusExtension on LendingPositionStatus {
  LendingPositionStatus copyWith({
    double? position,
    String? identifier,
    double? supplied,
    double? borrowed,
    double? healthFactor,
    OwnerDto? wallet,
    bool? isEMode,
    enums.LendingPositionStatusPositionMode? positionMode,
  }) {
    return LendingPositionStatus(
      position: position ?? this.position,
      identifier: identifier ?? this.identifier,
      supplied: supplied ?? this.supplied,
      borrowed: borrowed ?? this.borrowed,
      healthFactor: healthFactor ?? this.healthFactor,
      wallet: wallet ?? this.wallet,
      isEMode: isEMode ?? this.isEMode,
      positionMode: positionMode ?? this.positionMode,
    );
  }

  LendingPositionStatus copyWithWrapped({
    Wrapped<double>? position,
    Wrapped<String>? identifier,
    Wrapped<double>? supplied,
    Wrapped<double>? borrowed,
    Wrapped<double>? healthFactor,
    Wrapped<OwnerDto>? wallet,
    Wrapped<bool>? isEMode,
    Wrapped<enums.LendingPositionStatusPositionMode>? positionMode,
  }) {
    return LendingPositionStatus(
      position: (position != null ? position.value : this.position),
      identifier: (identifier != null ? identifier.value : this.identifier),
      supplied: (supplied != null ? supplied.value : this.supplied),
      borrowed: (borrowed != null ? borrowed.value : this.borrowed),
      healthFactor: (healthFactor != null
          ? healthFactor.value
          : this.healthFactor),
      wallet: (wallet != null ? wallet.value : this.wallet),
      isEMode: (isEMode != null ? isEMode.value : this.isEMode),
      positionMode: (positionMode != null
          ? positionMode.value
          : this.positionMode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingOverallStats {
  const LendingOverallStats({
    required this.topMarkets,
    required this.marketCount,
    required this.supplied,
    required this.participantsCount,
    required this.bestApy,
    required this.borrowed,
    required this.suppliedMargin,
    required this.borrowedMargin,
  });

  factory LendingOverallStats.fromJson(Map<String, dynamic> json) =>
      _$LendingOverallStatsFromJson(json);

  static const toJsonFactory = _$LendingOverallStatsToJson;
  Map<String, dynamic> toJson() => _$LendingOverallStatsToJson(this);

  @JsonKey(name: 'topMarkets', defaultValue: <String>[])
  final List<String> topMarkets;
  @JsonKey(name: 'marketCount')
  final double marketCount;
  @JsonKey(name: 'supplied')
  final double supplied;
  @JsonKey(name: 'participantsCount')
  final double participantsCount;
  @JsonKey(name: 'bestApy')
  final double bestApy;
  @JsonKey(name: 'borrowed')
  final double borrowed;
  @JsonKey(name: 'suppliedMargin')
  final double suppliedMargin;
  @JsonKey(name: 'borrowedMargin')
  final double borrowedMargin;
  static const fromJsonFactory = _$LendingOverallStatsFromJson;
}

extension $LendingOverallStatsExtension on LendingOverallStats {
  LendingOverallStats copyWith({
    List<String>? topMarkets,
    double? marketCount,
    double? supplied,
    double? participantsCount,
    double? bestApy,
    double? borrowed,
    double? suppliedMargin,
    double? borrowedMargin,
  }) {
    return LendingOverallStats(
      topMarkets: topMarkets ?? this.topMarkets,
      marketCount: marketCount ?? this.marketCount,
      supplied: supplied ?? this.supplied,
      participantsCount: participantsCount ?? this.participantsCount,
      bestApy: bestApy ?? this.bestApy,
      borrowed: borrowed ?? this.borrowed,
      suppliedMargin: suppliedMargin ?? this.suppliedMargin,
      borrowedMargin: borrowedMargin ?? this.borrowedMargin,
    );
  }

  LendingOverallStats copyWithWrapped({
    Wrapped<List<String>>? topMarkets,
    Wrapped<double>? marketCount,
    Wrapped<double>? supplied,
    Wrapped<double>? participantsCount,
    Wrapped<double>? bestApy,
    Wrapped<double>? borrowed,
    Wrapped<double>? suppliedMargin,
    Wrapped<double>? borrowedMargin,
  }) {
    return LendingOverallStats(
      topMarkets: (topMarkets != null ? topMarkets.value : this.topMarkets),
      marketCount: (marketCount != null ? marketCount.value : this.marketCount),
      supplied: (supplied != null ? supplied.value : this.supplied),
      participantsCount: (participantsCount != null
          ? participantsCount.value
          : this.participantsCount),
      bestApy: (bestApy != null ? bestApy.value : this.bestApy),
      borrowed: (borrowed != null ? borrowed.value : this.borrowed),
      suppliedMargin: (suppliedMargin != null
          ? suppliedMargin.value
          : this.suppliedMargin),
      borrowedMargin: (borrowedMargin != null
          ? borrowedMargin.value
          : this.borrowedMargin),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SaleInfoFilterDto {
  const SaleInfoFilterDto({
    this.seller,
    this.paymentToken,
    this.marketplace,
    this.auctionType,
  });

  factory SaleInfoFilterDto.fromJson(Map<String, dynamic> json) =>
      _$SaleInfoFilterDtoFromJson(json);

  static const toJsonFactory = _$SaleInfoFilterDtoToJson;
  Map<String, dynamic> toJson() => _$SaleInfoFilterDtoToJson(this);

  @JsonKey(name: 'seller', defaultValue: <String>[])
  final List<String>? seller;
  @JsonKey(name: 'paymentToken', defaultValue: <String>[])
  final List<String>? paymentToken;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'auctionType', defaultValue: <String>[])
  final List<String>? auctionType;
  static const fromJsonFactory = _$SaleInfoFilterDtoFromJson;
}

extension $SaleInfoFilterDtoExtension on SaleInfoFilterDto {
  SaleInfoFilterDto copyWith({
    List<String>? seller,
    List<String>? paymentToken,
    List<String>? marketplace,
    List<String>? auctionType,
  }) {
    return SaleInfoFilterDto(
      seller: seller ?? this.seller,
      paymentToken: paymentToken ?? this.paymentToken,
      marketplace: marketplace ?? this.marketplace,
      auctionType: auctionType ?? this.auctionType,
    );
  }

  SaleInfoFilterDto copyWithWrapped({
    Wrapped<List<String>?>? seller,
    Wrapped<List<String>?>? paymentToken,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<String>?>? auctionType,
  }) {
    return SaleInfoFilterDto(
      seller: (seller != null ? seller.value : this.seller),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Rarity {
  const Rarity({required this.rank, this.rarityScore});

  factory Rarity.fromJson(Map<String, dynamic> json) => _$RarityFromJson(json);

  static const toJsonFactory = _$RarityToJson;
  Map<String, dynamic> toJson() => _$RarityToJson(this);

  @JsonKey(name: 'rank')
  final int rank;
  @JsonKey(name: 'rarityScore')
  final double? rarityScore;
  static const fromJsonFactory = _$RarityFromJson;
}

extension $RarityExtension on Rarity {
  Rarity copyWith({int? rank, double? rarityScore}) {
    return Rarity(
      rank: rank ?? this.rank,
      rarityScore: rarityScore ?? this.rarityScore,
    );
  }

  Rarity copyWithWrapped({Wrapped<int>? rank, Wrapped<double?>? rarityScore}) {
    return Rarity(
      rank: (rank != null ? rank.value : this.rank),
      rarityScore: (rarityScore != null ? rarityScore.value : this.rarityScore),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataAttributes {
  const NftMetadataAttributes({required this.traitType, required this.$value});

  factory NftMetadataAttributes.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataAttributesFromJson(json);

  static const toJsonFactory = _$NftMetadataAttributesToJson;
  Map<String, dynamic> toJson() => _$NftMetadataAttributesToJson(this);

  @JsonKey(name: 'trait_type')
  final String traitType;
  @JsonKey(name: 'value')
  final String $value;
  static const fromJsonFactory = _$NftMetadataAttributesFromJson;
}

extension $NftMetadataAttributesExtension on NftMetadataAttributes {
  NftMetadataAttributes copyWith({String? traitType, String? $value}) {
    return NftMetadataAttributes(
      traitType: traitType ?? this.traitType,
      $value: $value ?? this.$value,
    );
  }

  NftMetadataAttributes copyWithWrapped({
    Wrapped<String>? traitType,
    Wrapped<String>? $value,
  }) {
    return NftMetadataAttributes(
      traitType: (traitType != null ? traitType.value : this.traitType),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadata {
  const NftMetadata({
    this.description,
    this.rarity,
    this.extraAttributes,
    this.attributes,
  });

  factory NftMetadata.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataFromJson(json);

  static const toJsonFactory = _$NftMetadataToJson;
  Map<String, dynamic> toJson() => _$NftMetadataToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'rarity')
  final Rarity? rarity;
  @JsonKey(name: 'extraAttributes', defaultValue: <Object>[])
  final List<Object>? extraAttributes;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes>? attributes;
  static const fromJsonFactory = _$NftMetadataFromJson;
}

extension $NftMetadataExtension on NftMetadata {
  NftMetadata copyWith({
    String? description,
    Rarity? rarity,
    List<Object>? extraAttributes,
    List<NftMetadataAttributes>? attributes,
  }) {
    return NftMetadata(
      description: description ?? this.description,
      rarity: rarity ?? this.rarity,
      extraAttributes: extraAttributes ?? this.extraAttributes,
      attributes: attributes ?? this.attributes,
    );
  }

  NftMetadata copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<Rarity?>? rarity,
    Wrapped<List<Object>?>? extraAttributes,
    Wrapped<List<NftMetadataAttributes>?>? attributes,
  }) {
    return NftMetadata(
      description: (description != null ? description.value : this.description),
      rarity: (rarity != null ? rarity.value : this.rarity),
      extraAttributes: (extraAttributes != null
          ? extraAttributes.value
          : this.extraAttributes),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFilterCriteriaDto {
  const NftDocFilterCriteriaDto({
    this.dataType,
    this.identifier,
    this.collection,
    this.nonce,
    this.type,
    this.onSale,
    this.owner,
    this.currentOwner,
    this.saleInfo,
    this.range,
    this.metadata,
    this.wasProcessed,
    this.cpStaked,
    this.activeAuction,
    this.verifiedOnly,
    this.sftOriginalDoc,
  });

  factory NftDocFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$NftDocFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$NftDocFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$NftDocFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'dataType', defaultValue: <String>[])
  final List<String>? dataType;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'nonce', defaultValue: <int>[])
  final List<int>? nonce;
  @JsonKey(name: 'type', defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'onSale')
  final bool? onSale;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'currentOwner', defaultValue: <String>[])
  final List<String>? currentOwner;
  @JsonKey(name: 'saleInfo')
  final SaleInfoFilterDto? saleInfo;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'metadata')
  final NftMetadata? metadata;
  @JsonKey(name: 'wasProcessed')
  final bool? wasProcessed;
  @JsonKey(name: 'cp_staked')
  final bool? cpStaked;
  @JsonKey(name: 'activeAuction')
  final bool? activeAuction;
  @JsonKey(name: 'verifiedOnly')
  final bool? verifiedOnly;
  @JsonKey(name: 'sftOriginalDoc')
  final bool? sftOriginalDoc;
  static const fromJsonFactory = _$NftDocFilterCriteriaDtoFromJson;
}

extension $NftDocFilterCriteriaDtoExtension on NftDocFilterCriteriaDto {
  NftDocFilterCriteriaDto copyWith({
    List<String>? dataType,
    List<String>? identifier,
    List<String>? collection,
    List<int>? nonce,
    List<String>? type,
    bool? onSale,
    List<String>? owner,
    List<String>? currentOwner,
    SaleInfoFilterDto? saleInfo,
    List<RangeFilter>? range,
    NftMetadata? metadata,
    bool? wasProcessed,
    bool? cpStaked,
    bool? activeAuction,
    bool? verifiedOnly,
    bool? sftOriginalDoc,
  }) {
    return NftDocFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      onSale: onSale ?? this.onSale,
      owner: owner ?? this.owner,
      currentOwner: currentOwner ?? this.currentOwner,
      saleInfo: saleInfo ?? this.saleInfo,
      range: range ?? this.range,
      metadata: metadata ?? this.metadata,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      cpStaked: cpStaked ?? this.cpStaked,
      activeAuction: activeAuction ?? this.activeAuction,
      verifiedOnly: verifiedOnly ?? this.verifiedOnly,
      sftOriginalDoc: sftOriginalDoc ?? this.sftOriginalDoc,
    );
  }

  NftDocFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? dataType,
    Wrapped<List<String>?>? identifier,
    Wrapped<List<String>?>? collection,
    Wrapped<List<int>?>? nonce,
    Wrapped<List<String>?>? type,
    Wrapped<bool?>? onSale,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? currentOwner,
    Wrapped<SaleInfoFilterDto?>? saleInfo,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<NftMetadata?>? metadata,
    Wrapped<bool?>? wasProcessed,
    Wrapped<bool?>? cpStaked,
    Wrapped<bool?>? activeAuction,
    Wrapped<bool?>? verifiedOnly,
    Wrapped<bool?>? sftOriginalDoc,
  }) {
    return NftDocFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      onSale: (onSale != null ? onSale.value : this.onSale),
      owner: (owner != null ? owner.value : this.owner),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      range: (range != null ? range.value : this.range),
      metadata: (metadata != null ? metadata.value : this.metadata),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      cpStaked: (cpStaked != null ? cpStaked.value : this.cpStaked),
      activeAuction: (activeAuction != null
          ? activeAuction.value
          : this.activeAuction),
      verifiedOnly: (verifiedOnly != null
          ? verifiedOnly.value
          : this.verifiedOnly),
      sftOriginalDoc: (sftOriginalDoc != null
          ? sftOriginalDoc.value
          : this.sftOriginalDoc),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFilter {
  const NftDocFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
    this.applyNftExtraDetails,
  });

  factory NftDocFilter.fromJson(Map<String, dynamic> json) =>
      _$NftDocFilterFromJson(json);

  static const toJsonFactory = _$NftDocFilterToJson;
  Map<String, dynamic> toJson() => _$NftDocFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftDocFilterCriteriaDto? filters;
  @JsonKey(name: 'applyNftExtraDetails')
  final bool? applyNftExtraDetails;
  static const fromJsonFactory = _$NftDocFilterFromJson;
}

extension $NftDocFilterExtension on NftDocFilter {
  NftDocFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftDocFilterCriteriaDto? filters,
    bool? applyNftExtraDetails,
  }) {
    return NftDocFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      applyNftExtraDetails: applyNftExtraDetails ?? this.applyNftExtraDetails,
    );
  }

  NftDocFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftDocFilterCriteriaDto?>? filters,
    Wrapped<bool?>? applyNftExtraDetails,
  }) {
    return NftDocFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      applyNftExtraDetails: (applyNftExtraDetails != null
          ? applyNftExtraDetails.value
          : this.applyNftExtraDetails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OriginalMedia {
  const OriginalMedia({required this.contentType, required this.contentLength});

  factory OriginalMedia.fromJson(Map<String, dynamic> json) =>
      _$OriginalMediaFromJson(json);

  static const toJsonFactory = _$OriginalMediaToJson;
  Map<String, dynamic> toJson() => _$OriginalMediaToJson(this);

  @JsonKey(name: 'contentType')
  final String contentType;
  @JsonKey(name: 'contentLength')
  final double contentLength;
  static const fromJsonFactory = _$OriginalMediaFromJson;
}

extension $OriginalMediaExtension on OriginalMedia {
  OriginalMedia copyWith({String? contentType, double? contentLength}) {
    return OriginalMedia(
      contentType: contentType ?? this.contentType,
      contentLength: contentLength ?? this.contentLength,
    );
  }

  OriginalMedia copyWithWrapped({
    Wrapped<String>? contentType,
    Wrapped<double>? contentLength,
  }) {
    return OriginalMedia(
      contentType: (contentType != null ? contentType.value : this.contentType),
      contentLength: (contentLength != null
          ? contentLength.value
          : this.contentLength),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMedia {
  const NftMedia({
    required this.avifUrl,
    required this.webpUrl,
    required this.retries,
    required this.originalMedia,
  });

  factory NftMedia.fromJson(Map<String, dynamic> json) =>
      _$NftMediaFromJson(json);

  static const toJsonFactory = _$NftMediaToJson;
  Map<String, dynamic> toJson() => _$NftMediaToJson(this);

  @JsonKey(name: 'avifUrl')
  final String avifUrl;
  @JsonKey(name: 'webpUrl')
  final String webpUrl;
  @JsonKey(name: 'retries')
  final double retries;
  @JsonKey(name: 'originalMedia')
  final OriginalMedia originalMedia;
  static const fromJsonFactory = _$NftMediaFromJson;
}

extension $NftMediaExtension on NftMedia {
  NftMedia copyWith({
    String? avifUrl,
    String? webpUrl,
    double? retries,
    OriginalMedia? originalMedia,
  }) {
    return NftMedia(
      avifUrl: avifUrl ?? this.avifUrl,
      webpUrl: webpUrl ?? this.webpUrl,
      retries: retries ?? this.retries,
      originalMedia: originalMedia ?? this.originalMedia,
    );
  }

  NftMedia copyWithWrapped({
    Wrapped<String>? avifUrl,
    Wrapped<String>? webpUrl,
    Wrapped<double>? retries,
    Wrapped<OriginalMedia>? originalMedia,
  }) {
    return NftMedia(
      avifUrl: (avifUrl != null ? avifUrl.value : this.avifUrl),
      webpUrl: (webpUrl != null ? webpUrl.value : this.webpUrl),
      retries: (retries != null ? retries.value : this.retries),
      originalMedia: (originalMedia != null
          ? originalMedia.value
          : this.originalMedia),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftStats {
  const NftStats({this.likeCount});

  factory NftStats.fromJson(Map<String, dynamic> json) =>
      _$NftStatsFromJson(json);

  static const toJsonFactory = _$NftStatsToJson;
  Map<String, dynamic> toJson() => _$NftStatsToJson(this);

  @JsonKey(name: 'likeCount')
  final int? likeCount;
  static const fromJsonFactory = _$NftStatsFromJson;
}

extension $NftStatsExtension on NftStats {
  NftStats copyWith({int? likeCount}) {
    return NftStats(likeCount: likeCount ?? this.likeCount);
  }

  NftStats copyWithWrapped({Wrapped<int?>? likeCount}) {
    return NftStats(
      likeCount: (likeCount != null ? likeCount.value : this.likeCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NFTEventData {
  const NFTEventData({
    required this.eventId,
    required this.ticketId,
    required this.checkInStatus,
  });

  factory NFTEventData.fromJson(Map<String, dynamic> json) =>
      _$NFTEventDataFromJson(json);

  static const toJsonFactory = _$NFTEventDataToJson;
  Map<String, dynamic> toJson() => _$NFTEventDataToJson(this);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'checkInStatus')
  final Object checkInStatus;
  static const fromJsonFactory = _$NFTEventDataFromJson;
}

extension $NFTEventDataExtension on NFTEventData {
  NFTEventData copyWith({
    String? eventId,
    String? ticketId,
    Object? checkInStatus,
  }) {
    return NFTEventData(
      eventId: eventId ?? this.eventId,
      ticketId: ticketId ?? this.ticketId,
      checkInStatus: checkInStatus ?? this.checkInStatus,
    );
  }

  NFTEventData copyWithWrapped({
    Wrapped<String>? eventId,
    Wrapped<String>? ticketId,
    Wrapped<Object>? checkInStatus,
  }) {
    return NFTEventData(
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      checkInStatus: (checkInStatus != null
          ? checkInStatus.value
          : this.checkInStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftSaleInfoHydrated {
  const NftSaleInfoHydrated({
    required this.auctionId,
    required this.seller,
    required this.minBid,
    required this.maxBid,
    this.currentBid,
    required this.startTime,
    required this.deadline,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.auctionType,
    required this.timestamp,
    required this.minBidShort,
    this.minBidUsdValue,
    required this.maxBidShort,
    this.maxBidUsdValue,
    this.currentBidShort,
    required this.quantity,
    required this.marketplace,
    this.royalties,
    this.currentWinner,
  });

  factory NftSaleInfoHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftSaleInfoHydratedFromJson(json);

  static const toJsonFactory = _$NftSaleInfoHydratedToJson;
  Map<String, dynamic> toJson() => _$NftSaleInfoHydratedToJson(this);

  @JsonKey(name: 'auctionId')
  final double auctionId;
  @JsonKey(name: 'seller')
  final String seller;
  @JsonKey(name: 'minBid')
  final String minBid;
  @JsonKey(name: 'maxBid')
  final String maxBid;
  @JsonKey(name: 'currentBid')
  final String? currentBid;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'deadline')
  final int deadline;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final int paymentTokenNonce;
  @JsonKey(
    name: 'auctionType',
    toJson: xoxnoAuctionTypeStringToJson,
    fromJson: xoxnoAuctionTypeStringFromJson,
  )
  final enums.XoxnoAuctionTypeString auctionType;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'minBidUsdValue')
  final double? minBidUsdValue;
  @JsonKey(name: 'maxBidShort')
  final double maxBidShort;
  @JsonKey(name: 'maxBidUsdValue')
  final double? maxBidUsdValue;
  @JsonKey(name: 'currentBidShort')
  final double? currentBidShort;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(
    name: 'marketplace',
    toJson: marketplacesOnSaleNamesToJson,
    fromJson: marketplacesOnSaleNamesFromJson,
  )
  final enums.MarketplacesOnSaleNames marketplace;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'currentWinner')
  final OwnerDto? currentWinner;
  static const fromJsonFactory = _$NftSaleInfoHydratedFromJson;
}

extension $NftSaleInfoHydratedExtension on NftSaleInfoHydrated {
  NftSaleInfoHydrated copyWith({
    double? auctionId,
    String? seller,
    String? minBid,
    String? maxBid,
    String? currentBid,
    int? startTime,
    int? deadline,
    String? paymentToken,
    int? paymentTokenNonce,
    enums.XoxnoAuctionTypeString? auctionType,
    int? timestamp,
    double? minBidShort,
    double? minBidUsdValue,
    double? maxBidShort,
    double? maxBidUsdValue,
    double? currentBidShort,
    double? quantity,
    enums.MarketplacesOnSaleNames? marketplace,
    double? royalties,
    OwnerDto? currentWinner,
  }) {
    return NftSaleInfoHydrated(
      auctionId: auctionId ?? this.auctionId,
      seller: seller ?? this.seller,
      minBid: minBid ?? this.minBid,
      maxBid: maxBid ?? this.maxBid,
      currentBid: currentBid ?? this.currentBid,
      startTime: startTime ?? this.startTime,
      deadline: deadline ?? this.deadline,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      auctionType: auctionType ?? this.auctionType,
      timestamp: timestamp ?? this.timestamp,
      minBidShort: minBidShort ?? this.minBidShort,
      minBidUsdValue: minBidUsdValue ?? this.minBidUsdValue,
      maxBidShort: maxBidShort ?? this.maxBidShort,
      maxBidUsdValue: maxBidUsdValue ?? this.maxBidUsdValue,
      currentBidShort: currentBidShort ?? this.currentBidShort,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      royalties: royalties ?? this.royalties,
      currentWinner: currentWinner ?? this.currentWinner,
    );
  }

  NftSaleInfoHydrated copyWithWrapped({
    Wrapped<double>? auctionId,
    Wrapped<String>? seller,
    Wrapped<String>? minBid,
    Wrapped<String>? maxBid,
    Wrapped<String?>? currentBid,
    Wrapped<int>? startTime,
    Wrapped<int>? deadline,
    Wrapped<String>? paymentToken,
    Wrapped<int>? paymentTokenNonce,
    Wrapped<enums.XoxnoAuctionTypeString>? auctionType,
    Wrapped<int>? timestamp,
    Wrapped<double>? minBidShort,
    Wrapped<double?>? minBidUsdValue,
    Wrapped<double>? maxBidShort,
    Wrapped<double?>? maxBidUsdValue,
    Wrapped<double?>? currentBidShort,
    Wrapped<double>? quantity,
    Wrapped<enums.MarketplacesOnSaleNames>? marketplace,
    Wrapped<double?>? royalties,
    Wrapped<OwnerDto?>? currentWinner,
  }) {
    return NftSaleInfoHydrated(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      seller: (seller != null ? seller.value : this.seller),
      minBid: (minBid != null ? minBid.value : this.minBid),
      maxBid: (maxBid != null ? maxBid.value : this.maxBid),
      currentBid: (currentBid != null ? currentBid.value : this.currentBid),
      startTime: (startTime != null ? startTime.value : this.startTime),
      deadline: (deadline != null ? deadline.value : this.deadline),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      minBidUsdValue: (minBidUsdValue != null
          ? minBidUsdValue.value
          : this.minBidUsdValue),
      maxBidShort: (maxBidShort != null ? maxBidShort.value : this.maxBidShort),
      maxBidUsdValue: (maxBidUsdValue != null
          ? maxBidUsdValue.value
          : this.maxBidUsdValue),
      currentBidShort: (currentBidShort != null
          ? currentBidShort.value
          : this.currentBidShort),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      royalties: (royalties != null ? royalties.value : this.royalties),
      currentWinner: (currentWinner != null
          ? currentWinner.value
          : this.currentWinner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataAttributesHydrated {
  const NftMetadataAttributesHydrated({
    required this.traitType,
    required this.$value,
    required this.occurance,
    required this.frequency,
    required this.floorPrice,
    required this.onSaleCount,
    required this.usdValue,
  });

  factory NftMetadataAttributesHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataAttributesHydratedFromJson(json);

  static const toJsonFactory = _$NftMetadataAttributesHydratedToJson;
  Map<String, dynamic> toJson() => _$NftMetadataAttributesHydratedToJson(this);

  @JsonKey(name: 'trait_type')
  final String traitType;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'occurance')
  final int occurance;
  @JsonKey(name: 'frequency')
  final double frequency;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'onSaleCount')
  final int onSaleCount;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  static const fromJsonFactory = _$NftMetadataAttributesHydratedFromJson;
}

extension $NftMetadataAttributesHydratedExtension
    on NftMetadataAttributesHydrated {
  NftMetadataAttributesHydrated copyWith({
    String? traitType,
    String? $value,
    int? occurance,
    double? frequency,
    double? floorPrice,
    int? onSaleCount,
    double? usdValue,
  }) {
    return NftMetadataAttributesHydrated(
      traitType: traitType ?? this.traitType,
      $value: $value ?? this.$value,
      occurance: occurance ?? this.occurance,
      frequency: frequency ?? this.frequency,
      floorPrice: floorPrice ?? this.floorPrice,
      onSaleCount: onSaleCount ?? this.onSaleCount,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  NftMetadataAttributesHydrated copyWithWrapped({
    Wrapped<String>? traitType,
    Wrapped<String>? $value,
    Wrapped<int>? occurance,
    Wrapped<double>? frequency,
    Wrapped<double>? floorPrice,
    Wrapped<int>? onSaleCount,
    Wrapped<double>? usdValue,
  }) {
    return NftMetadataAttributesHydrated(
      traitType: (traitType != null ? traitType.value : this.traitType),
      $value: ($value != null ? $value.value : this.$value),
      occurance: (occurance != null ? occurance.value : this.occurance),
      frequency: (frequency != null ? frequency.value : this.frequency),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      onSaleCount: (onSaleCount != null ? onSaleCount.value : this.onSaleCount),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftMetadataHydrated {
  const NftMetadataHydrated({
    this.description,
    this.rarity,
    this.extraAttributes,
    this.attributes,
  });

  factory NftMetadataHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftMetadataHydratedFromJson(json);

  static const toJsonFactory = _$NftMetadataHydratedToJson;
  Map<String, dynamic> toJson() => _$NftMetadataHydratedToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'rarity')
  final Rarity? rarity;
  @JsonKey(name: 'extraAttributes', defaultValue: <Object>[])
  final List<Object>? extraAttributes;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributesHydrated>[])
  final List<NftMetadataAttributesHydrated>? attributes;
  static const fromJsonFactory = _$NftMetadataHydratedFromJson;
}

extension $NftMetadataHydratedExtension on NftMetadataHydrated {
  NftMetadataHydrated copyWith({
    String? description,
    Rarity? rarity,
    List<Object>? extraAttributes,
    List<NftMetadataAttributesHydrated>? attributes,
  }) {
    return NftMetadataHydrated(
      description: description ?? this.description,
      rarity: rarity ?? this.rarity,
      extraAttributes: extraAttributes ?? this.extraAttributes,
      attributes: attributes ?? this.attributes,
    );
  }

  NftMetadataHydrated copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<Rarity?>? rarity,
    Wrapped<List<Object>?>? extraAttributes,
    Wrapped<List<NftMetadataAttributesHydrated>?>? attributes,
  }) {
    return NftMetadataHydrated(
      description: (description != null ? description.value : this.description),
      rarity: (rarity != null ? rarity.value : this.rarity),
      extraAttributes: (extraAttributes != null
          ? extraAttributes.value
          : this.extraAttributes),
      attributes: (attributes != null ? attributes.value : this.attributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionExtraFeesConfig {
  const CollectionExtraFeesConfig({
    required this.amount,
    required this.address,
  });

  factory CollectionExtraFeesConfig.fromJson(Map<String, dynamic> json) =>
      _$CollectionExtraFeesConfigFromJson(json);

  static const toJsonFactory = _$CollectionExtraFeesConfigToJson;
  Map<String, dynamic> toJson() => _$CollectionExtraFeesConfigToJson(this);

  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$CollectionExtraFeesConfigFromJson;
}

extension $CollectionExtraFeesConfigExtension on CollectionExtraFeesConfig {
  CollectionExtraFeesConfig copyWith({double? amount, String? address}) {
    return CollectionExtraFeesConfig(
      amount: amount ?? this.amount,
      address: address ?? this.address,
    );
  }

  CollectionExtraFeesConfig copyWithWrapped({
    Wrapped<double>? amount,
    Wrapped<String>? address,
  }) {
    return CollectionExtraFeesConfig(
      amount: (amount != null ? amount.value : this.amount),
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoMarketplaceScCollectionConfig {
  const XoxnoMarketplaceScCollectionConfig({
    required this.reversedCutFees,
    required this.reversedRoyalties,
    required this.customRoyalties,
    required this.minRoyalties,
    required this.maxRoyalties,
    this.extraFees,
    this.adminAddress,
  });

  factory XoxnoMarketplaceScCollectionConfig.fromJson(
    Map<String, dynamic> json,
  ) => _$XoxnoMarketplaceScCollectionConfigFromJson(json);

  static const toJsonFactory = _$XoxnoMarketplaceScCollectionConfigToJson;
  Map<String, dynamic> toJson() =>
      _$XoxnoMarketplaceScCollectionConfigToJson(this);

  @JsonKey(name: 'reversedCutFees', defaultValue: false)
  final bool reversedCutFees;
  @JsonKey(name: 'reversedRoyalties', defaultValue: false)
  final bool reversedRoyalties;
  @JsonKey(name: 'customRoyalties', defaultValue: false)
  final bool customRoyalties;
  @JsonKey(name: 'minRoyalties')
  final double minRoyalties;
  @JsonKey(name: 'maxRoyalties')
  final double maxRoyalties;
  @JsonKey(name: 'extraFees')
  final CollectionExtraFeesConfig? extraFees;
  @JsonKey(name: 'adminAddress')
  final String? adminAddress;
  static const fromJsonFactory = _$XoxnoMarketplaceScCollectionConfigFromJson;
}

extension $XoxnoMarketplaceScCollectionConfigExtension
    on XoxnoMarketplaceScCollectionConfig {
  XoxnoMarketplaceScCollectionConfig copyWith({
    bool? reversedCutFees,
    bool? reversedRoyalties,
    bool? customRoyalties,
    double? minRoyalties,
    double? maxRoyalties,
    CollectionExtraFeesConfig? extraFees,
    String? adminAddress,
  }) {
    return XoxnoMarketplaceScCollectionConfig(
      reversedCutFees: reversedCutFees ?? this.reversedCutFees,
      reversedRoyalties: reversedRoyalties ?? this.reversedRoyalties,
      customRoyalties: customRoyalties ?? this.customRoyalties,
      minRoyalties: minRoyalties ?? this.minRoyalties,
      maxRoyalties: maxRoyalties ?? this.maxRoyalties,
      extraFees: extraFees ?? this.extraFees,
      adminAddress: adminAddress ?? this.adminAddress,
    );
  }

  XoxnoMarketplaceScCollectionConfig copyWithWrapped({
    Wrapped<bool>? reversedCutFees,
    Wrapped<bool>? reversedRoyalties,
    Wrapped<bool>? customRoyalties,
    Wrapped<double>? minRoyalties,
    Wrapped<double>? maxRoyalties,
    Wrapped<CollectionExtraFeesConfig?>? extraFees,
    Wrapped<String?>? adminAddress,
  }) {
    return XoxnoMarketplaceScCollectionConfig(
      reversedCutFees: (reversedCutFees != null
          ? reversedCutFees.value
          : this.reversedCutFees),
      reversedRoyalties: (reversedRoyalties != null
          ? reversedRoyalties.value
          : this.reversedRoyalties),
      customRoyalties: (customRoyalties != null
          ? customRoyalties.value
          : this.customRoyalties),
      minRoyalties: (minRoyalties != null
          ? minRoyalties.value
          : this.minRoyalties),
      maxRoyalties: (maxRoyalties != null
          ? maxRoyalties.value
          : this.maxRoyalties),
      extraFees: (extraFees != null ? extraFees.value : this.extraFees),
      adminAddress: (adminAddress != null
          ? adminAddress.value
          : this.adminAddress),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionFeatures {
  const CollectionFeatures({
    this.isCustomOffersDisabled,
    this.isGlobalOffersDisabled,
  });

  factory CollectionFeatures.fromJson(Map<String, dynamic> json) =>
      _$CollectionFeaturesFromJson(json);

  static const toJsonFactory = _$CollectionFeaturesToJson;
  Map<String, dynamic> toJson() => _$CollectionFeaturesToJson(this);

  @JsonKey(name: 'isCustomOffersDisabled')
  final bool? isCustomOffersDisabled;
  @JsonKey(name: 'isGlobalOffersDisabled')
  final bool? isGlobalOffersDisabled;
  static const fromJsonFactory = _$CollectionFeaturesFromJson;
}

extension $CollectionFeaturesExtension on CollectionFeatures {
  CollectionFeatures copyWith({
    bool? isCustomOffersDisabled,
    bool? isGlobalOffersDisabled,
  }) {
    return CollectionFeatures(
      isCustomOffersDisabled:
          isCustomOffersDisabled ?? this.isCustomOffersDisabled,
      isGlobalOffersDisabled:
          isGlobalOffersDisabled ?? this.isGlobalOffersDisabled,
    );
  }

  CollectionFeatures copyWithWrapped({
    Wrapped<bool?>? isCustomOffersDisabled,
    Wrapped<bool?>? isGlobalOffersDisabled,
  }) {
    return CollectionFeatures(
      isCustomOffersDisabled: (isCustomOffersDisabled != null
          ? isCustomOffersDisabled.value
          : this.isCustomOffersDisabled),
      isGlobalOffersDisabled: (isGlobalOffersDisabled != null
          ? isGlobalOffersDisabled.value
          : this.isGlobalOffersDisabled),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortNftCollectionInfoDoc {
  const ShortNftCollectionInfoDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.roles,
    this.customConfig,
    this.features,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
  });

  factory ShortNftCollectionInfoDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortNftCollectionInfoDocFromJson(json);

  static const toJsonFactory = _$ShortNftCollectionInfoDocToJson;
  Map<String, dynamic> toJson() => _$ShortNftCollectionInfoDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: shortNftCollectionInfoDocChainToJson,
    fromJson: shortNftCollectionInfoDocChainFromJson,
  )
  final enums.ShortNftCollectionInfoDocChain chain;
  @JsonKey(name: 'roles')
  final Map<String, dynamic> roles;
  @JsonKey(name: 'customConfig')
  final XoxnoMarketplaceScCollectionConfig? customConfig;
  @JsonKey(name: 'features')
  final CollectionFeatures? features;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  static const fromJsonFactory = _$ShortNftCollectionInfoDocFromJson;
}

extension $ShortNftCollectionInfoDocExtension on ShortNftCollectionInfoDoc {
  ShortNftCollectionInfoDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    String? banner,
    enums.ShortNftCollectionInfoDocChain? chain,
    Map<String, dynamic>? roles,
    XoxnoMarketplaceScCollectionConfig? customConfig,
    CollectionFeatures? features,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
  }) {
    return ShortNftCollectionInfoDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      roles: roles ?? this.roles,
      customConfig: customConfig ?? this.customConfig,
      features: features ?? this.features,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
    );
  }

  ShortNftCollectionInfoDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.ShortNftCollectionInfoDocChain>? chain,
    Wrapped<Map<String, dynamic>>? roles,
    Wrapped<XoxnoMarketplaceScCollectionConfig?>? customConfig,
    Wrapped<CollectionFeatures?>? features,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
  }) {
    return ShortNftCollectionInfoDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      roles: (roles != null ? roles.value : this.roles),
      customConfig: (customConfig != null
          ? customConfig.value
          : this.customConfig),
      features: (features != null ? features.value : this.features),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ExtraProperties {
  const ExtraProperties({this.currentEpoch, this.level});

  factory ExtraProperties.fromJson(Map<String, dynamic> json) =>
      _$ExtraPropertiesFromJson(json);

  static const toJsonFactory = _$ExtraPropertiesToJson;
  Map<String, dynamic> toJson() => _$ExtraPropertiesToJson(this);

  @JsonKey(name: 'currentEpoch')
  final double? currentEpoch;
  @JsonKey(name: 'level')
  final double? level;
  static const fromJsonFactory = _$ExtraPropertiesFromJson;
}

extension $ExtraPropertiesExtension on ExtraProperties {
  ExtraProperties copyWith({double? currentEpoch, double? level}) {
    return ExtraProperties(
      currentEpoch: currentEpoch ?? this.currentEpoch,
      level: level ?? this.level,
    );
  }

  ExtraProperties copyWithWrapped({
    Wrapped<double?>? currentEpoch,
    Wrapped<double?>? level,
  }) {
    return ExtraProperties(
      currentEpoch: (currentEpoch != null
          ? currentEpoch.value
          : this.currentEpoch),
      level: (level != null ? level.value : this.level),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocHydrated {
  const NftDocHydrated({
    required this.dataType,
    required this.identifier,
    required this.collection,
    this.originalCollection,
    this.attributes,
    required this.nonce,
    required this.type,
    this.subType,
    required this.supply,
    this.supplyLong,
    required this.name,
    required this.royalties,
    required this.url,
    this.uris,
    required this.wasProcessed,
    this.media,
    this.statistics,
    this.isTicket,
    this.eventData,
    required this.chain,
    this.tags,
    this.kiosk,
    required this.onSale,
    this.id,
    this.ts,
    this.creator,
    this.currentOwner,
    this.owner,
    this.saleInfo,
    this.metadata,
    required this.collectionInfo,
    this.balance,
    this.balanceLong,
    this.unboundDaysLeft,
    this.unboundEpoch,
    this.extraProperties,
  });

  factory NftDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftDocHydratedFromJson(json);

  static const toJsonFactory = _$NftDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.nft);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String? originalCollection;
  @JsonKey(name: 'attributes')
  final String? attributes;
  @JsonKey(name: 'nonce')
  final int nonce;
  @JsonKey(
    name: 'type',
    toJson: esdtTokenTypeToJson,
    fromJson: esdtTokenTypeFromJson,
  )
  final enums.EsdtTokenType type;
  @JsonKey(
    name: 'subType',
    toJson: esdtTokenSubTypeNullableToJson,
    fromJson: esdtTokenSubTypeNullableFromJson,
  )
  final enums.EsdtTokenSubType? subType;
  @JsonKey(name: 'supply')
  final int supply;
  @JsonKey(name: 'supplyLong')
  final String? supplyLong;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'uris')
  final String? uris;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'statistics')
  final NftStats? statistics;
  @JsonKey(name: 'isTicket')
  final bool? isTicket;
  @JsonKey(name: 'eventData')
  final NFTEventData? eventData;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  @JsonKey(name: 'tags')
  final String? tags;
  @JsonKey(name: 'kiosk')
  final String? kiosk;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'creator')
  final OwnerDto? creator;
  @JsonKey(name: 'currentOwner')
  final OwnerDto? currentOwner;
  @JsonKey(name: 'owner')
  final OwnerDto? owner;
  @JsonKey(name: 'saleInfo')
  final NftSaleInfoHydrated? saleInfo;
  @JsonKey(name: 'metadata')
  final NftMetadataHydrated? metadata;
  @JsonKey(name: 'collectionInfo')
  final ShortNftCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'balance')
  final double? balance;
  @JsonKey(name: 'balanceLong')
  final String? balanceLong;
  @JsonKey(name: 'unboundDaysLeft')
  final int? unboundDaysLeft;
  @JsonKey(name: 'unboundEpoch')
  final int? unboundEpoch;
  @JsonKey(name: 'extraProperties')
  final ExtraProperties? extraProperties;
  static const fromJsonFactory = _$NftDocHydratedFromJson;
}

extension $NftDocHydratedExtension on NftDocHydrated {
  NftDocHydrated copyWith({
    enums.TokenDataType? dataType,
    String? identifier,
    String? collection,
    String? originalCollection,
    String? attributes,
    int? nonce,
    enums.EsdtTokenType? type,
    enums.EsdtTokenSubType? subType,
    int? supply,
    String? supplyLong,
    String? name,
    double? royalties,
    String? url,
    String? uris,
    bool? wasProcessed,
    NftMedia? media,
    NftStats? statistics,
    bool? isTicket,
    NFTEventData? eventData,
    enums.ActivityChain? chain,
    String? tags,
    String? kiosk,
    bool? onSale,
    String? id,
    int? ts,
    OwnerDto? creator,
    OwnerDto? currentOwner,
    OwnerDto? owner,
    NftSaleInfoHydrated? saleInfo,
    NftMetadataHydrated? metadata,
    ShortNftCollectionInfoDoc? collectionInfo,
    double? balance,
    String? balanceLong,
    int? unboundDaysLeft,
    int? unboundEpoch,
    ExtraProperties? extraProperties,
  }) {
    return NftDocHydrated(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      attributes: attributes ?? this.attributes,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      supply: supply ?? this.supply,
      supplyLong: supplyLong ?? this.supplyLong,
      name: name ?? this.name,
      royalties: royalties ?? this.royalties,
      url: url ?? this.url,
      uris: uris ?? this.uris,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      statistics: statistics ?? this.statistics,
      isTicket: isTicket ?? this.isTicket,
      eventData: eventData ?? this.eventData,
      chain: chain ?? this.chain,
      tags: tags ?? this.tags,
      kiosk: kiosk ?? this.kiosk,
      onSale: onSale ?? this.onSale,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      creator: creator ?? this.creator,
      currentOwner: currentOwner ?? this.currentOwner,
      owner: owner ?? this.owner,
      saleInfo: saleInfo ?? this.saleInfo,
      metadata: metadata ?? this.metadata,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      balance: balance ?? this.balance,
      balanceLong: balanceLong ?? this.balanceLong,
      unboundDaysLeft: unboundDaysLeft ?? this.unboundDaysLeft,
      unboundEpoch: unboundEpoch ?? this.unboundEpoch,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  NftDocHydrated copyWithWrapped({
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String?>? originalCollection,
    Wrapped<String?>? attributes,
    Wrapped<int>? nonce,
    Wrapped<enums.EsdtTokenType>? type,
    Wrapped<enums.EsdtTokenSubType?>? subType,
    Wrapped<int>? supply,
    Wrapped<String?>? supplyLong,
    Wrapped<String>? name,
    Wrapped<double>? royalties,
    Wrapped<String>? url,
    Wrapped<String?>? uris,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftStats?>? statistics,
    Wrapped<bool?>? isTicket,
    Wrapped<NFTEventData?>? eventData,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String?>? tags,
    Wrapped<String?>? kiosk,
    Wrapped<bool>? onSale,
    Wrapped<String?>? id,
    Wrapped<int?>? ts,
    Wrapped<OwnerDto?>? creator,
    Wrapped<OwnerDto?>? currentOwner,
    Wrapped<OwnerDto?>? owner,
    Wrapped<NftSaleInfoHydrated?>? saleInfo,
    Wrapped<NftMetadataHydrated?>? metadata,
    Wrapped<ShortNftCollectionInfoDoc>? collectionInfo,
    Wrapped<double?>? balance,
    Wrapped<String?>? balanceLong,
    Wrapped<int?>? unboundDaysLeft,
    Wrapped<int?>? unboundEpoch,
    Wrapped<ExtraProperties?>? extraProperties,
  }) {
    return NftDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      attributes: (attributes != null ? attributes.value : this.attributes),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      supply: (supply != null ? supply.value : this.supply),
      supplyLong: (supplyLong != null ? supplyLong.value : this.supplyLong),
      name: (name != null ? name.value : this.name),
      royalties: (royalties != null ? royalties.value : this.royalties),
      url: (url != null ? url.value : this.url),
      uris: (uris != null ? uris.value : this.uris),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      statistics: (statistics != null ? statistics.value : this.statistics),
      isTicket: (isTicket != null ? isTicket.value : this.isTicket),
      eventData: (eventData != null ? eventData.value : this.eventData),
      chain: (chain != null ? chain.value : this.chain),
      tags: (tags != null ? tags.value : this.tags),
      kiosk: (kiosk != null ? kiosk.value : this.kiosk),
      onSale: (onSale != null ? onSale.value : this.onSale),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      creator: (creator != null ? creator.value : this.creator),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      owner: (owner != null ? owner.value : this.owner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      metadata: (metadata != null ? metadata.value : this.metadata),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      balance: (balance != null ? balance.value : this.balance),
      balanceLong: (balanceLong != null ? balanceLong.value : this.balanceLong),
      unboundDaysLeft: (unboundDaysLeft != null
          ? unboundDaysLeft.value
          : this.unboundDaysLeft),
      unboundEpoch: (unboundEpoch != null
          ? unboundEpoch.value
          : this.unboundEpoch),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftPaginated {
  const NftPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftPaginatedFromJson(json);

  static const toJsonFactory = _$NftPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated> resources;
  static const fromJsonFactory = _$NftPaginatedFromJson;
}

extension $NftPaginatedExtension on NftPaginated {
  NftPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftDocHydrated>? resources,
  }) {
    return NftPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftDocHydrated>>? resources,
  }) {
    return NftPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LikeNftDto {
  const LikeNftDto({
    required this.isFavorite,
    required this.collection,
    required this.identifier,
  });

  factory LikeNftDto.fromJson(Map<String, dynamic> json) =>
      _$LikeNftDtoFromJson(json);

  static const toJsonFactory = _$LikeNftDtoToJson;
  Map<String, dynamic> toJson() => _$LikeNftDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$LikeNftDtoFromJson;
}

extension $LikeNftDtoExtension on LikeNftDto {
  LikeNftDto copyWith({
    bool? isFavorite,
    String? collection,
    String? identifier,
  }) {
    return LikeNftDto(
      isFavorite: isFavorite ?? this.isFavorite,
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
    );
  }

  LikeNftDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String>? collection,
    Wrapped<String>? identifier,
  }) {
    return LikeNftDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class InventorySummaryDtoHydrated {
  const InventorySummaryDtoHydrated({
    required this.collection,
    required this.inventoryCount,
    required this.listedCount,
    required this.stakedCount,
    required this.floorPrice,
    required this.name,
    required this.isVerified,
    required this.isVisible,
    required this.profile,
    required this.banner,
    required this.$value,
    this.chain,
  });

  factory InventorySummaryDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$InventorySummaryDtoHydratedFromJson(json);

  static const toJsonFactory = _$InventorySummaryDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$InventorySummaryDtoHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'inventoryCount')
  final double inventoryCount;
  @JsonKey(name: 'listedCount')
  final double listedCount;
  @JsonKey(name: 'stakedCount')
  final double stakedCount;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'value')
  final double $value;
  @JsonKey(
    name: 'chain',
    toJson: inventorySummaryDtoHydratedChainNullableToJson,
    fromJson: inventorySummaryDtoHydratedChainNullableFromJson,
  )
  final enums.InventorySummaryDtoHydratedChain? chain;
  static const fromJsonFactory = _$InventorySummaryDtoHydratedFromJson;
}

extension $InventorySummaryDtoHydratedExtension on InventorySummaryDtoHydrated {
  InventorySummaryDtoHydrated copyWith({
    String? collection,
    double? inventoryCount,
    double? listedCount,
    double? stakedCount,
    double? floorPrice,
    String? name,
    bool? isVerified,
    bool? isVisible,
    String? profile,
    String? banner,
    double? $value,
    enums.InventorySummaryDtoHydratedChain? chain,
  }) {
    return InventorySummaryDtoHydrated(
      collection: collection ?? this.collection,
      inventoryCount: inventoryCount ?? this.inventoryCount,
      listedCount: listedCount ?? this.listedCount,
      stakedCount: stakedCount ?? this.stakedCount,
      floorPrice: floorPrice ?? this.floorPrice,
      name: name ?? this.name,
      isVerified: isVerified ?? this.isVerified,
      isVisible: isVisible ?? this.isVisible,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      $value: $value ?? this.$value,
      chain: chain ?? this.chain,
    );
  }

  InventorySummaryDtoHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? inventoryCount,
    Wrapped<double>? listedCount,
    Wrapped<double>? stakedCount,
    Wrapped<double>? floorPrice,
    Wrapped<String>? name,
    Wrapped<bool>? isVerified,
    Wrapped<bool>? isVisible,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double>? $value,
    Wrapped<enums.InventorySummaryDtoHydratedChain?>? chain,
  }) {
    return InventorySummaryDtoHydrated(
      collection: (collection != null ? collection.value : this.collection),
      inventoryCount: (inventoryCount != null
          ? inventoryCount.value
          : this.inventoryCount),
      listedCount: (listedCount != null ? listedCount.value : this.listedCount),
      stakedCount: (stakedCount != null ? stakedCount.value : this.stakedCount),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      name: (name != null ? name.value : this.name),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      $value: ($value != null ? $value.value : this.$value),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocHydrated {
  const NftOfferDocHydrated({
    required this.dataType,
    required this.identifier,
    required this.collection,
    required this.offerId,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.price,
    required this.priceShort,
    this.priceUsd,
    this.floorPriceMargin,
    required this.deadline,
    required this.timestamp,
    this.nftOwner,
    required this.quantity,
    required this.marketplace,
    this.auctionId,
    required this.isActive,
    required this.chain,
    required this.id,
    required this.ts,
    required this.owner,
    required this.usdValue,
    required this.floorPrice,
    required this.nftInfo,
  });

  factory NftOfferDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocHydratedFromJson(json);

  static const toJsonFactory = _$NftOfferDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: nftOfferDocHydratedDataTypeToJson,
    fromJson: nftOfferDocHydratedDataTypeFromJson,
  )
  final enums.NftOfferDocHydratedDataType dataType;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'offerId')
  final double offerId;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'price')
  final String price;
  @JsonKey(name: 'priceShort')
  final double priceShort;
  @JsonKey(name: 'priceUsd')
  final double? priceUsd;
  @JsonKey(name: 'floorPriceMargin')
  final double? floorPriceMargin;
  @JsonKey(name: 'deadline')
  final double deadline;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'nftOwner')
  final String? nftOwner;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'auctionId')
  final double? auctionId;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(
    name: 'chain',
    toJson: nftOfferDocHydratedChainToJson,
    fromJson: nftOfferDocHydratedChainFromJson,
  )
  final enums.NftOfferDocHydratedChain chain;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'owner')
  final OwnerDto owner;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(name: 'nftInfo')
  final NftDocHydrated nftInfo;
  static const fromJsonFactory = _$NftOfferDocHydratedFromJson;
}

extension $NftOfferDocHydratedExtension on NftOfferDocHydrated {
  NftOfferDocHydrated copyWith({
    enums.NftOfferDocHydratedDataType? dataType,
    String? identifier,
    String? collection,
    double? offerId,
    String? paymentToken,
    double? paymentTokenNonce,
    String? price,
    double? priceShort,
    double? priceUsd,
    double? floorPriceMargin,
    double? deadline,
    double? timestamp,
    String? nftOwner,
    double? quantity,
    String? marketplace,
    double? auctionId,
    bool? isActive,
    enums.NftOfferDocHydratedChain? chain,
    String? id,
    double? ts,
    OwnerDto? owner,
    double? usdValue,
    double? floorPrice,
    NftDocHydrated? nftInfo,
  }) {
    return NftOfferDocHydrated(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      offerId: offerId ?? this.offerId,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      price: price ?? this.price,
      priceShort: priceShort ?? this.priceShort,
      priceUsd: priceUsd ?? this.priceUsd,
      floorPriceMargin: floorPriceMargin ?? this.floorPriceMargin,
      deadline: deadline ?? this.deadline,
      timestamp: timestamp ?? this.timestamp,
      nftOwner: nftOwner ?? this.nftOwner,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      auctionId: auctionId ?? this.auctionId,
      isActive: isActive ?? this.isActive,
      chain: chain ?? this.chain,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      owner: owner ?? this.owner,
      usdValue: usdValue ?? this.usdValue,
      floorPrice: floorPrice ?? this.floorPrice,
      nftInfo: nftInfo ?? this.nftInfo,
    );
  }

  NftOfferDocHydrated copyWithWrapped({
    Wrapped<enums.NftOfferDocHydratedDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<double>? offerId,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<String>? price,
    Wrapped<double>? priceShort,
    Wrapped<double?>? priceUsd,
    Wrapped<double?>? floorPriceMargin,
    Wrapped<double>? deadline,
    Wrapped<double>? timestamp,
    Wrapped<String?>? nftOwner,
    Wrapped<double>? quantity,
    Wrapped<String>? marketplace,
    Wrapped<double?>? auctionId,
    Wrapped<bool>? isActive,
    Wrapped<enums.NftOfferDocHydratedChain>? chain,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? owner,
    Wrapped<double>? usdValue,
    Wrapped<double>? floorPrice,
    Wrapped<NftDocHydrated>? nftInfo,
  }) {
    return NftOfferDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      offerId: (offerId != null ? offerId.value : this.offerId),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      price: (price != null ? price.value : this.price),
      priceShort: (priceShort != null ? priceShort.value : this.priceShort),
      priceUsd: (priceUsd != null ? priceUsd.value : this.priceUsd),
      floorPriceMargin: (floorPriceMargin != null
          ? floorPriceMargin.value
          : this.floorPriceMargin),
      deadline: (deadline != null ? deadline.value : this.deadline),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      nftOwner: (nftOwner != null ? nftOwner.value : this.nftOwner),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      chain: (chain != null ? chain.value : this.chain),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      owner: (owner != null ? owner.value : this.owner),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferPaginated {
  const NftOfferPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftOfferPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftOfferPaginatedFromJson(json);

  static const toJsonFactory = _$NftOfferPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftOfferPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftOfferDocHydrated>[])
  final List<NftOfferDocHydrated> resources;
  static const fromJsonFactory = _$NftOfferPaginatedFromJson;
}

extension $NftOfferPaginatedExtension on NftOfferPaginated {
  NftOfferPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftOfferDocHydrated>? resources,
  }) {
    return NftOfferPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftOfferPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftOfferDocHydrated>>? resources,
  }) {
    return NftOfferPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocFilterCriteria {
  const NftOfferDocFilterCriteria({
    this.isActive,
    this.identifier,
    this.collection,
    this.owner,
    this.nftOwner,
    this.marketplace,
    this.range,
  });

  factory NftOfferDocFilterCriteria.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocFilterCriteriaFromJson(json);

  static const toJsonFactory = _$NftOfferDocFilterCriteriaToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocFilterCriteriaToJson(this);

  @JsonKey(name: 'isActive', defaultValue: <bool>[])
  final List<bool>? isActive;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'nftOwner', defaultValue: <String>[])
  final List<String>? nftOwner;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$NftOfferDocFilterCriteriaFromJson;
}

extension $NftOfferDocFilterCriteriaExtension on NftOfferDocFilterCriteria {
  NftOfferDocFilterCriteria copyWith({
    List<bool>? isActive,
    List<String>? identifier,
    List<String>? collection,
    List<String>? owner,
    List<String>? nftOwner,
    List<String>? marketplace,
    List<RangeFilter>? range,
  }) {
    return NftOfferDocFilterCriteria(
      isActive: isActive ?? this.isActive,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      owner: owner ?? this.owner,
      nftOwner: nftOwner ?? this.nftOwner,
      marketplace: marketplace ?? this.marketplace,
      range: range ?? this.range,
    );
  }

  NftOfferDocFilterCriteria copyWithWrapped({
    Wrapped<List<bool>?>? isActive,
    Wrapped<List<String>?>? identifier,
    Wrapped<List<String>?>? collection,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? nftOwner,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return NftOfferDocFilterCriteria(
      isActive: (isActive != null ? isActive.value : this.isActive),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      owner: (owner != null ? owner.value : this.owner),
      nftOwner: (nftOwner != null ? nftOwner.value : this.nftOwner),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftOfferDocFilter {
  const NftOfferDocFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory NftOfferDocFilter.fromJson(Map<String, dynamic> json) =>
      _$NftOfferDocFilterFromJson(json);

  static const toJsonFactory = _$NftOfferDocFilterToJson;
  Map<String, dynamic> toJson() => _$NftOfferDocFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftOfferDocFilterCriteria? filters;
  static const fromJsonFactory = _$NftOfferDocFilterFromJson;
}

extension $NftOfferDocFilterExtension on NftOfferDocFilter {
  NftOfferDocFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftOfferDocFilterCriteria? filters,
  }) {
    return NftOfferDocFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  NftOfferDocFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftOfferDocFilterCriteria?>? filters,
  }) {
    return NftOfferDocFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionRanksDTO {
  const CollectionRanksDTO({
    required this.identifier,
    required this.name,
    required this.rank,
  });

  factory CollectionRanksDTO.fromJson(Map<String, dynamic> json) =>
      _$CollectionRanksDTOFromJson(json);

  static const toJsonFactory = _$CollectionRanksDTOToJson;
  Map<String, dynamic> toJson() => _$CollectionRanksDTOToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'rank')
  final double rank;
  static const fromJsonFactory = _$CollectionRanksDTOFromJson;
}

extension $CollectionRanksDTOExtension on CollectionRanksDTO {
  CollectionRanksDTO copyWith({
    String? identifier,
    String? name,
    double? rank,
  }) {
    return CollectionRanksDTO(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      rank: rank ?? this.rank,
    );
  }

  CollectionRanksDTO copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<double>? rank,
  }) {
    return CollectionRanksDTO(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DensityDto {
  const DensityDto({
    required this.key,
    required this.intervalName,
    required this.intervalCount,
    required this.totalCount,
  });

  factory DensityDto.fromJson(Map<String, dynamic> json) =>
      _$DensityDtoFromJson(json);

  static const toJsonFactory = _$DensityDtoToJson;
  Map<String, dynamic> toJson() => _$DensityDtoToJson(this);

  @JsonKey(name: 'key')
  final String key;
  @JsonKey(name: 'intervalName')
  final String intervalName;
  @JsonKey(name: 'intervalCount')
  final double intervalCount;
  @JsonKey(name: 'totalCount')
  final double totalCount;
  static const fromJsonFactory = _$DensityDtoFromJson;
}

extension $DensityDtoExtension on DensityDto {
  DensityDto copyWith({
    String? key,
    String? intervalName,
    double? intervalCount,
    double? totalCount,
  }) {
    return DensityDto(
      key: key ?? this.key,
      intervalName: intervalName ?? this.intervalName,
      intervalCount: intervalCount ?? this.intervalCount,
      totalCount: totalCount ?? this.totalCount,
    );
  }

  DensityDto copyWithWrapped({
    Wrapped<String>? key,
    Wrapped<String>? intervalName,
    Wrapped<double>? intervalCount,
    Wrapped<double>? totalCount,
  }) {
    return DensityDto(
      key: (key != null ? key.value : this.key),
      intervalName: (intervalName != null
          ? intervalName.value
          : this.intervalName),
      intervalCount: (intervalCount != null
          ? intervalCount.value
          : this.intervalCount),
      totalCount: (totalCount != null ? totalCount.value : this.totalCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RarityDto {
  const RarityDto({required this.rank});

  factory RarityDto.fromJson(Map<String, dynamic> json) =>
      _$RarityDtoFromJson(json);

  static const toJsonFactory = _$RarityDtoToJson;
  Map<String, dynamic> toJson() => _$RarityDtoToJson(this);

  @JsonKey(name: 'rank')
  final double rank;
  static const fromJsonFactory = _$RarityDtoFromJson;
}

extension $RarityDtoExtension on RarityDto {
  RarityDto copyWith({double? rank}) {
    return RarityDto(rank: rank ?? this.rank);
  }

  RarityDto copyWithWrapped({Wrapped<double>? rank}) {
    return RarityDto(rank: (rank != null ? rank.value : this.rank));
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataDto {
  const MetadataDto({required this.rarity});

  factory MetadataDto.fromJson(Map<String, dynamic> json) =>
      _$MetadataDtoFromJson(json);

  static const toJsonFactory = _$MetadataDtoToJson;
  Map<String, dynamic> toJson() => _$MetadataDtoToJson(this);

  @JsonKey(name: 'rarity')
  final RarityDto rarity;
  static const fromJsonFactory = _$MetadataDtoFromJson;
}

extension $MetadataDtoExtension on MetadataDto {
  MetadataDto copyWith({RarityDto? rarity}) {
    return MetadataDto(rarity: rarity ?? this.rarity);
  }

  MetadataDto copyWithWrapped({Wrapped<RarityDto>? rarity}) {
    return MetadataDto(rarity: (rarity != null ? rarity.value : this.rarity));
  }
}

@JsonSerializable(explicitToJson: true)
class SaleInfoDto {
  const SaleInfoDto({required this.minBidShort, required this.marketplace});

  factory SaleInfoDto.fromJson(Map<String, dynamic> json) =>
      _$SaleInfoDtoFromJson(json);

  static const toJsonFactory = _$SaleInfoDtoToJson;
  Map<String, dynamic> toJson() => _$SaleInfoDtoToJson(this);

  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  static const fromJsonFactory = _$SaleInfoDtoFromJson;
}

extension $SaleInfoDtoExtension on SaleInfoDto {
  SaleInfoDto copyWith({double? minBidShort, String? marketplace}) {
    return SaleInfoDto(
      minBidShort: minBidShort ?? this.minBidShort,
      marketplace: marketplace ?? this.marketplace,
    );
  }

  SaleInfoDto copyWithWrapped({
    Wrapped<double>? minBidShort,
    Wrapped<String>? marketplace,
  }) {
    return SaleInfoDto(
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ListingDto {
  const ListingDto({
    required this.identifier,
    required this.name,
    required this.collection,
    required this.metadata,
    required this.url,
    required this.media,
    required this.wasProcessed,
    required this.saleInfo,
  });

  factory ListingDto.fromJson(Map<String, dynamic> json) =>
      _$ListingDtoFromJson(json);

  static const toJsonFactory = _$ListingDtoToJson;
  Map<String, dynamic> toJson() => _$ListingDtoToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'metadata')
  final MetadataDto metadata;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'media')
  final NftMedia media;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'saleInfo')
  final SaleInfoDto saleInfo;
  static const fromJsonFactory = _$ListingDtoFromJson;
}

extension $ListingDtoExtension on ListingDto {
  ListingDto copyWith({
    String? identifier,
    String? name,
    String? collection,
    MetadataDto? metadata,
    String? url,
    NftMedia? media,
    bool? wasProcessed,
    SaleInfoDto? saleInfo,
  }) {
    return ListingDto(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      collection: collection ?? this.collection,
      metadata: metadata ?? this.metadata,
      url: url ?? this.url,
      media: media ?? this.media,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      saleInfo: saleInfo ?? this.saleInfo,
    );
  }

  ListingDto copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<String>? collection,
    Wrapped<MetadataDto>? metadata,
    Wrapped<String>? url,
    Wrapped<NftMedia>? media,
    Wrapped<bool>? wasProcessed,
    Wrapped<SaleInfoDto>? saleInfo,
  }) {
    return ListingDto(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      collection: (collection != null ? collection.value : this.collection),
      metadata: (metadata != null ? metadata.value : this.metadata),
      url: (url != null ? url.value : this.url),
      media: (media != null ? media.value : this.media),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ListingsResponseDto {
  const ListingsResponseDto({required this.density, required this.listings});

  factory ListingsResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ListingsResponseDtoFromJson(json);

  static const toJsonFactory = _$ListingsResponseDtoToJson;
  Map<String, dynamic> toJson() => _$ListingsResponseDtoToJson(this);

  @JsonKey(name: 'density', defaultValue: <DensityDto>[])
  final List<DensityDto> density;
  @JsonKey(name: 'listings', defaultValue: <ListingDto>[])
  final List<ListingDto> listings;
  static const fromJsonFactory = _$ListingsResponseDtoFromJson;
}

extension $ListingsResponseDtoExtension on ListingsResponseDto {
  ListingsResponseDto copyWith({
    List<DensityDto>? density,
    List<ListingDto>? listings,
  }) {
    return ListingsResponseDto(
      density: density ?? this.density,
      listings: listings ?? this.listings,
    );
  }

  ListingsResponseDto copyWithWrapped({
    Wrapped<List<DensityDto>>? density,
    Wrapped<List<ListingDto>>? listings,
  }) {
    return ListingsResponseDto(
      density: (density != null ? density.value : this.density),
      listings: (listings != null ? listings.value : this.listings),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignWithdrawDto {
  const SignWithdrawDto({required this.auctionId});

  factory SignWithdrawDto.fromJson(Map<String, dynamic> json) =>
      _$SignWithdrawDtoFromJson(json);

  static const toJsonFactory = _$SignWithdrawDtoToJson;
  Map<String, dynamic> toJson() => _$SignWithdrawDtoToJson(this);

  @JsonKey(name: 'auctionId', defaultValue: <int>[])
  final List<int> auctionId;
  static const fromJsonFactory = _$SignWithdrawDtoFromJson;
}

extension $SignWithdrawDtoExtension on SignWithdrawDto {
  SignWithdrawDto copyWith({List<int>? auctionId}) {
    return SignWithdrawDto(auctionId: auctionId ?? this.auctionId);
  }

  SignWithdrawDto copyWithWrapped({Wrapped<List<int>>? auctionId}) {
    return SignWithdrawDto(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignDataDto {
  const SignDataDto({required this.data, required this.signature});

  factory SignDataDto.fromJson(Map<String, dynamic> json) =>
      _$SignDataDtoFromJson(json);

  static const toJsonFactory = _$SignDataDtoToJson;
  Map<String, dynamic> toJson() => _$SignDataDtoToJson(this);

  @JsonKey(name: 'data')
  final String data;
  @JsonKey(name: 'signature')
  final String signature;
  static const fromJsonFactory = _$SignDataDtoFromJson;
}

extension $SignDataDtoExtension on SignDataDto {
  SignDataDto copyWith({String? data, String? signature}) {
    return SignDataDto(
      data: data ?? this.data,
      signature: signature ?? this.signature,
    );
  }

  SignDataDto copyWithWrapped({
    Wrapped<String>? data,
    Wrapped<String>? signature,
  }) {
    return SignDataDto(
      data: (data != null ? data.value : this.data),
      signature: (signature != null ? signature.value : this.signature),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignAcceptGlobalOfferDto {
  const SignAcceptGlobalOfferDto({
    required this.offerId,
    required this.identifier,
  });

  factory SignAcceptGlobalOfferDto.fromJson(Map<String, dynamic> json) =>
      _$SignAcceptGlobalOfferDtoFromJson(json);

  static const toJsonFactory = _$SignAcceptGlobalOfferDtoToJson;
  Map<String, dynamic> toJson() => _$SignAcceptGlobalOfferDtoToJson(this);

  @JsonKey(name: 'offerId')
  final int offerId;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String> identifier;
  static const fromJsonFactory = _$SignAcceptGlobalOfferDtoFromJson;
}

extension $SignAcceptGlobalOfferDtoExtension on SignAcceptGlobalOfferDto {
  SignAcceptGlobalOfferDto copyWith({int? offerId, List<String>? identifier}) {
    return SignAcceptGlobalOfferDto(
      offerId: offerId ?? this.offerId,
      identifier: identifier ?? this.identifier,
    );
  }

  SignAcceptGlobalOfferDto copyWithWrapped({
    Wrapped<int>? offerId,
    Wrapped<List<String>>? identifier,
  }) {
    return SignAcceptGlobalOfferDto(
      offerId: (offerId != null ? offerId.value : this.offerId),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SignMintDto {
  const SignMintDto({required this.quantity, required this.stage});

  factory SignMintDto.fromJson(Map<String, dynamic> json) =>
      _$SignMintDtoFromJson(json);

  static const toJsonFactory = _$SignMintDtoToJson;
  Map<String, dynamic> toJson() => _$SignMintDtoToJson(this);

  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'stage')
  final String stage;
  static const fromJsonFactory = _$SignMintDtoFromJson;
}

extension $SignMintDtoExtension on SignMintDto {
  SignMintDto copyWith({int? quantity, String? stage}) {
    return SignMintDto(
      quantity: quantity ?? this.quantity,
      stage: stage ?? this.stage,
    );
  }

  SignMintDto copyWithWrapped({
    Wrapped<int>? quantity,
    Wrapped<String>? stage,
  }) {
    return SignMintDto(
      quantity: (quantity != null ? quantity.value : this.quantity),
      stage: (stage != null ? stage.value : this.stage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCollectionDoc {
  const ShortCollectionDoc({
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.chain,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
  });

  factory ShortCollectionDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCollectionDocFromJson(json);

  static const toJsonFactory = _$ShortCollectionDocToJson;
  Map<String, dynamic> toJson() => _$ShortCollectionDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(
    name: 'chain',
    toJson: shortCollectionDocChainToJson,
    fromJson: shortCollectionDocChainFromJson,
  )
  final enums.ShortCollectionDocChain chain;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  static const fromJsonFactory = _$ShortCollectionDocFromJson;
}

extension $ShortCollectionDocExtension on ShortCollectionDoc {
  ShortCollectionDoc copyWith({
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    enums.ShortCollectionDocChain? chain,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
  }) {
    return ShortCollectionDoc(
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      chain: chain ?? this.chain,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
    );
  }

  ShortCollectionDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<enums.ShortCollectionDocChain>? chain,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
  }) {
    return ShortCollectionDoc(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      chain: (chain != null ? chain.value : this.chain),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalOfferDocHydrated {
  const GlobalOfferDocHydrated({
    required this.dataType,
    required this.offerId,
    required this.collection,
    required this.price,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.quantity,
    required this.marketplace,
    required this.timestamp,
    required this.attributes,
    required this.priceShort,
    this.floorPriceMargin,
    this.floorPrice,
    required this.isActive,
    required this.chain,
    this.usdValue,
    required this.id,
    required this.ts,
    required this.owner,
    required this.collectionInfo,
  });

  factory GlobalOfferDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$GlobalOfferDocHydratedFromJson(json);

  static const toJsonFactory = _$GlobalOfferDocHydratedToJson;
  Map<String, dynamic> toJson() => _$GlobalOfferDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: globalOfferDocHydratedDataTypeToJson,
    fromJson: globalOfferDocHydratedDataTypeFromJson,
  )
  final enums.GlobalOfferDocHydratedDataType dataType;
  @JsonKey(name: 'offerId')
  final double offerId;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'price')
  final String price;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final double paymentTokenNonce;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes> attributes;
  @JsonKey(name: 'priceShort')
  final double priceShort;
  @JsonKey(name: 'floorPriceMargin')
  final double? floorPriceMargin;
  @JsonKey(name: 'floorPrice')
  final double? floorPrice;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(
    name: 'chain',
    toJson: globalOfferDocHydratedChainToJson,
    fromJson: globalOfferDocHydratedChainFromJson,
  )
  final enums.GlobalOfferDocHydratedChain chain;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'owner')
  final OwnerDto owner;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$GlobalOfferDocHydratedFromJson;
}

extension $GlobalOfferDocHydratedExtension on GlobalOfferDocHydrated {
  GlobalOfferDocHydrated copyWith({
    enums.GlobalOfferDocHydratedDataType? dataType,
    double? offerId,
    String? collection,
    String? price,
    String? paymentToken,
    double? paymentTokenNonce,
    double? quantity,
    String? marketplace,
    double? timestamp,
    List<NftMetadataAttributes>? attributes,
    double? priceShort,
    double? floorPriceMargin,
    double? floorPrice,
    bool? isActive,
    enums.GlobalOfferDocHydratedChain? chain,
    double? usdValue,
    String? id,
    double? ts,
    OwnerDto? owner,
    ShortCollectionDoc? collectionInfo,
  }) {
    return GlobalOfferDocHydrated(
      dataType: dataType ?? this.dataType,
      offerId: offerId ?? this.offerId,
      collection: collection ?? this.collection,
      price: price ?? this.price,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      attributes: attributes ?? this.attributes,
      priceShort: priceShort ?? this.priceShort,
      floorPriceMargin: floorPriceMargin ?? this.floorPriceMargin,
      floorPrice: floorPrice ?? this.floorPrice,
      isActive: isActive ?? this.isActive,
      chain: chain ?? this.chain,
      usdValue: usdValue ?? this.usdValue,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      owner: owner ?? this.owner,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  GlobalOfferDocHydrated copyWithWrapped({
    Wrapped<enums.GlobalOfferDocHydratedDataType>? dataType,
    Wrapped<double>? offerId,
    Wrapped<String>? collection,
    Wrapped<String>? price,
    Wrapped<String>? paymentToken,
    Wrapped<double>? paymentTokenNonce,
    Wrapped<double>? quantity,
    Wrapped<String>? marketplace,
    Wrapped<double>? timestamp,
    Wrapped<List<NftMetadataAttributes>>? attributes,
    Wrapped<double>? priceShort,
    Wrapped<double?>? floorPriceMargin,
    Wrapped<double?>? floorPrice,
    Wrapped<bool>? isActive,
    Wrapped<enums.GlobalOfferDocHydratedChain>? chain,
    Wrapped<double?>? usdValue,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? owner,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return GlobalOfferDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      offerId: (offerId != null ? offerId.value : this.offerId),
      collection: (collection != null ? collection.value : this.collection),
      price: (price != null ? price.value : this.price),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      attributes: (attributes != null ? attributes.value : this.attributes),
      priceShort: (priceShort != null ? priceShort.value : this.priceShort),
      floorPriceMargin: (floorPriceMargin != null
          ? floorPriceMargin.value
          : this.floorPriceMargin),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      isActive: (isActive != null ? isActive.value : this.isActive),
      chain: (chain != null ? chain.value : this.chain),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      owner: (owner != null ? owner.value : this.owner),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDocFull {
  const NftDocFull({
    required this.dataType,
    required this.identifier,
    required this.collection,
    this.originalCollection,
    this.attributes,
    required this.nonce,
    required this.type,
    this.subType,
    required this.supply,
    this.supplyLong,
    required this.name,
    required this.royalties,
    required this.url,
    this.uris,
    required this.wasProcessed,
    this.media,
    this.statistics,
    this.isTicket,
    this.eventData,
    required this.chain,
    this.tags,
    this.kiosk,
    required this.onSale,
    this.id,
    this.ts,
    this.creator,
    this.currentOwner,
    this.owner,
    this.saleInfo,
    this.metadata,
    required this.collectionInfo,
    this.balance,
    this.balanceLong,
    this.unboundDaysLeft,
    this.unboundEpoch,
    this.extraProperties,
    this.globalOffer,
  });

  factory NftDocFull.fromJson(Map<String, dynamic> json) =>
      _$NftDocFullFromJson(json);

  static const toJsonFactory = _$NftDocFullToJson;
  Map<String, dynamic> toJson() => _$NftDocFullToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: tokenDataTypeToJson,
    fromJson: tokenDataTypeDataTypeFromJson,
  )
  final enums.TokenDataType dataType;
  static enums.TokenDataType tokenDataTypeDataTypeFromJson(Object? value) =>
      tokenDataTypeFromJson(value, enums.TokenDataType.nft);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String? originalCollection;
  @JsonKey(name: 'attributes')
  final String? attributes;
  @JsonKey(name: 'nonce')
  final int nonce;
  @JsonKey(
    name: 'type',
    toJson: esdtTokenTypeToJson,
    fromJson: esdtTokenTypeFromJson,
  )
  final enums.EsdtTokenType type;
  @JsonKey(
    name: 'subType',
    toJson: esdtTokenSubTypeNullableToJson,
    fromJson: esdtTokenSubTypeNullableFromJson,
  )
  final enums.EsdtTokenSubType? subType;
  @JsonKey(name: 'supply')
  final int supply;
  @JsonKey(name: 'supplyLong')
  final String? supplyLong;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'uris')
  final String? uris;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'statistics')
  final NftStats? statistics;
  @JsonKey(name: 'isTicket')
  final bool? isTicket;
  @JsonKey(name: 'eventData')
  final NFTEventData? eventData;
  @JsonKey(
    name: 'chain',
    toJson: activityChainToJson,
    fromJson: activityChainFromJson,
  )
  final enums.ActivityChain chain;
  @JsonKey(name: 'tags')
  final String? tags;
  @JsonKey(name: 'kiosk')
  final String? kiosk;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'creator')
  final OwnerDto? creator;
  @JsonKey(name: 'currentOwner')
  final OwnerDto? currentOwner;
  @JsonKey(name: 'owner')
  final OwnerDto? owner;
  @JsonKey(name: 'saleInfo')
  final NftSaleInfoHydrated? saleInfo;
  @JsonKey(name: 'metadata')
  final NftMetadataHydrated? metadata;
  @JsonKey(name: 'collectionInfo')
  final ShortNftCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'balance')
  final double? balance;
  @JsonKey(name: 'balanceLong')
  final String? balanceLong;
  @JsonKey(name: 'unboundDaysLeft')
  final int? unboundDaysLeft;
  @JsonKey(name: 'unboundEpoch')
  final int? unboundEpoch;
  @JsonKey(name: 'extraProperties')
  final ExtraProperties? extraProperties;
  @JsonKey(name: 'globalOffer')
  final GlobalOfferDocHydrated? globalOffer;
  static const fromJsonFactory = _$NftDocFullFromJson;
}

extension $NftDocFullExtension on NftDocFull {
  NftDocFull copyWith({
    enums.TokenDataType? dataType,
    String? identifier,
    String? collection,
    String? originalCollection,
    String? attributes,
    int? nonce,
    enums.EsdtTokenType? type,
    enums.EsdtTokenSubType? subType,
    int? supply,
    String? supplyLong,
    String? name,
    double? royalties,
    String? url,
    String? uris,
    bool? wasProcessed,
    NftMedia? media,
    NftStats? statistics,
    bool? isTicket,
    NFTEventData? eventData,
    enums.ActivityChain? chain,
    String? tags,
    String? kiosk,
    bool? onSale,
    String? id,
    int? ts,
    OwnerDto? creator,
    OwnerDto? currentOwner,
    OwnerDto? owner,
    NftSaleInfoHydrated? saleInfo,
    NftMetadataHydrated? metadata,
    ShortNftCollectionInfoDoc? collectionInfo,
    double? balance,
    String? balanceLong,
    int? unboundDaysLeft,
    int? unboundEpoch,
    ExtraProperties? extraProperties,
    GlobalOfferDocHydrated? globalOffer,
  }) {
    return NftDocFull(
      dataType: dataType ?? this.dataType,
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      attributes: attributes ?? this.attributes,
      nonce: nonce ?? this.nonce,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      supply: supply ?? this.supply,
      supplyLong: supplyLong ?? this.supplyLong,
      name: name ?? this.name,
      royalties: royalties ?? this.royalties,
      url: url ?? this.url,
      uris: uris ?? this.uris,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      statistics: statistics ?? this.statistics,
      isTicket: isTicket ?? this.isTicket,
      eventData: eventData ?? this.eventData,
      chain: chain ?? this.chain,
      tags: tags ?? this.tags,
      kiosk: kiosk ?? this.kiosk,
      onSale: onSale ?? this.onSale,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      creator: creator ?? this.creator,
      currentOwner: currentOwner ?? this.currentOwner,
      owner: owner ?? this.owner,
      saleInfo: saleInfo ?? this.saleInfo,
      metadata: metadata ?? this.metadata,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      balance: balance ?? this.balance,
      balanceLong: balanceLong ?? this.balanceLong,
      unboundDaysLeft: unboundDaysLeft ?? this.unboundDaysLeft,
      unboundEpoch: unboundEpoch ?? this.unboundEpoch,
      extraProperties: extraProperties ?? this.extraProperties,
      globalOffer: globalOffer ?? this.globalOffer,
    );
  }

  NftDocFull copyWithWrapped({
    Wrapped<enums.TokenDataType>? dataType,
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String?>? originalCollection,
    Wrapped<String?>? attributes,
    Wrapped<int>? nonce,
    Wrapped<enums.EsdtTokenType>? type,
    Wrapped<enums.EsdtTokenSubType?>? subType,
    Wrapped<int>? supply,
    Wrapped<String?>? supplyLong,
    Wrapped<String>? name,
    Wrapped<double>? royalties,
    Wrapped<String>? url,
    Wrapped<String?>? uris,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftStats?>? statistics,
    Wrapped<bool?>? isTicket,
    Wrapped<NFTEventData?>? eventData,
    Wrapped<enums.ActivityChain>? chain,
    Wrapped<String?>? tags,
    Wrapped<String?>? kiosk,
    Wrapped<bool>? onSale,
    Wrapped<String?>? id,
    Wrapped<int?>? ts,
    Wrapped<OwnerDto?>? creator,
    Wrapped<OwnerDto?>? currentOwner,
    Wrapped<OwnerDto?>? owner,
    Wrapped<NftSaleInfoHydrated?>? saleInfo,
    Wrapped<NftMetadataHydrated?>? metadata,
    Wrapped<ShortNftCollectionInfoDoc>? collectionInfo,
    Wrapped<double?>? balance,
    Wrapped<String?>? balanceLong,
    Wrapped<int?>? unboundDaysLeft,
    Wrapped<int?>? unboundEpoch,
    Wrapped<ExtraProperties?>? extraProperties,
    Wrapped<GlobalOfferDocHydrated?>? globalOffer,
  }) {
    return NftDocFull(
      dataType: (dataType != null ? dataType.value : this.dataType),
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      attributes: (attributes != null ? attributes.value : this.attributes),
      nonce: (nonce != null ? nonce.value : this.nonce),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      supply: (supply != null ? supply.value : this.supply),
      supplyLong: (supplyLong != null ? supplyLong.value : this.supplyLong),
      name: (name != null ? name.value : this.name),
      royalties: (royalties != null ? royalties.value : this.royalties),
      url: (url != null ? url.value : this.url),
      uris: (uris != null ? uris.value : this.uris),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      statistics: (statistics != null ? statistics.value : this.statistics),
      isTicket: (isTicket != null ? isTicket.value : this.isTicket),
      eventData: (eventData != null ? eventData.value : this.eventData),
      chain: (chain != null ? chain.value : this.chain),
      tags: (tags != null ? tags.value : this.tags),
      kiosk: (kiosk != null ? kiosk.value : this.kiosk),
      onSale: (onSale != null ? onSale.value : this.onSale),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      creator: (creator != null ? creator.value : this.creator),
      currentOwner: (currentOwner != null
          ? currentOwner.value
          : this.currentOwner),
      owner: (owner != null ? owner.value : this.owner),
      saleInfo: (saleInfo != null ? saleInfo.value : this.saleInfo),
      metadata: (metadata != null ? metadata.value : this.metadata),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      balance: (balance != null ? balance.value : this.balance),
      balanceLong: (balanceLong != null ? balanceLong.value : this.balanceLong),
      unboundDaysLeft: (unboundDaysLeft != null
          ? unboundDaysLeft.value
          : this.unboundDaysLeft),
      unboundEpoch: (unboundEpoch != null
          ? unboundEpoch.value
          : this.unboundEpoch),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
      globalOffer: (globalOffer != null ? globalOffer.value : this.globalOffer),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsOtherDto {
  const StatisticsOtherDto({
    required this.followCount,
    required this.nftCount,
    this.holdersCount,
  });

  factory StatisticsOtherDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsOtherDtoFromJson(json);

  static const toJsonFactory = _$StatisticsOtherDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsOtherDtoToJson(this);

  @JsonKey(name: 'followCount')
  final double followCount;
  @JsonKey(name: 'nftCount')
  final double nftCount;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  static const fromJsonFactory = _$StatisticsOtherDtoFromJson;
}

extension $StatisticsOtherDtoExtension on StatisticsOtherDto {
  StatisticsOtherDto copyWith({
    double? followCount,
    double? nftCount,
    double? holdersCount,
  }) {
    return StatisticsOtherDto(
      followCount: followCount ?? this.followCount,
      nftCount: nftCount ?? this.nftCount,
      holdersCount: holdersCount ?? this.holdersCount,
    );
  }

  StatisticsOtherDto copyWithWrapped({
    Wrapped<double>? followCount,
    Wrapped<double>? nftCount,
    Wrapped<double?>? holdersCount,
  }) {
    return StatisticsOtherDto(
      followCount: (followCount != null ? followCount.value : this.followCount),
      nftCount: (nftCount != null ? nftCount.value : this.nftCount),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsTradeDataDto {
  const StatisticsTradeDataDto({
    required this.dayEgldVolume,
    required this.weekEgldVolume,
    required this.totalEgldVolume,
    required this.averageEgldPrice,
    required this.athEgldPrice,
    required this.athTxHash,
    required this.totalTrades,
  });

  factory StatisticsTradeDataDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsTradeDataDtoFromJson(json);

  static const toJsonFactory = _$StatisticsTradeDataDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsTradeDataDtoToJson(this);

  @JsonKey(name: 'dayEgldVolume')
  final double dayEgldVolume;
  @JsonKey(name: 'weekEgldVolume')
  final double weekEgldVolume;
  @JsonKey(name: 'totalEgldVolume')
  final double totalEgldVolume;
  @JsonKey(name: 'averageEgldPrice')
  final double averageEgldPrice;
  @JsonKey(name: 'athEgldPrice')
  final double athEgldPrice;
  @JsonKey(name: 'athTxHash')
  final String athTxHash;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  static const fromJsonFactory = _$StatisticsTradeDataDtoFromJson;
}

extension $StatisticsTradeDataDtoExtension on StatisticsTradeDataDto {
  StatisticsTradeDataDto copyWith({
    double? dayEgldVolume,
    double? weekEgldVolume,
    double? totalEgldVolume,
    double? averageEgldPrice,
    double? athEgldPrice,
    String? athTxHash,
    double? totalTrades,
  }) {
    return StatisticsTradeDataDto(
      dayEgldVolume: dayEgldVolume ?? this.dayEgldVolume,
      weekEgldVolume: weekEgldVolume ?? this.weekEgldVolume,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      averageEgldPrice: averageEgldPrice ?? this.averageEgldPrice,
      athEgldPrice: athEgldPrice ?? this.athEgldPrice,
      athTxHash: athTxHash ?? this.athTxHash,
      totalTrades: totalTrades ?? this.totalTrades,
    );
  }

  StatisticsTradeDataDto copyWithWrapped({
    Wrapped<double>? dayEgldVolume,
    Wrapped<double>? weekEgldVolume,
    Wrapped<double>? totalEgldVolume,
    Wrapped<double>? averageEgldPrice,
    Wrapped<double>? athEgldPrice,
    Wrapped<String>? athTxHash,
    Wrapped<double>? totalTrades,
  }) {
    return StatisticsTradeDataDto(
      dayEgldVolume: (dayEgldVolume != null
          ? dayEgldVolume.value
          : this.dayEgldVolume),
      weekEgldVolume: (weekEgldVolume != null
          ? weekEgldVolume.value
          : this.weekEgldVolume),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      averageEgldPrice: (averageEgldPrice != null
          ? averageEgldPrice.value
          : this.averageEgldPrice),
      athEgldPrice: (athEgldPrice != null
          ? athEgldPrice.value
          : this.athEgldPrice),
      athTxHash: (athTxHash != null ? athTxHash.value : this.athTxHash),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsMintDataDto {
  const StatisticsMintDataDto({
    required this.totalMintEgldVolume,
    required this.weekMintEgldVolume,
    required this.dayMintEgldVolume,
  });

  factory StatisticsMintDataDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsMintDataDtoFromJson(json);

  static const toJsonFactory = _$StatisticsMintDataDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsMintDataDtoToJson(this);

  @JsonKey(name: 'totalMintEgldVolume')
  final double totalMintEgldVolume;
  @JsonKey(name: 'weekMintEgldVolume')
  final double weekMintEgldVolume;
  @JsonKey(name: 'dayMintEgldVolume')
  final double dayMintEgldVolume;
  static const fromJsonFactory = _$StatisticsMintDataDtoFromJson;
}

extension $StatisticsMintDataDtoExtension on StatisticsMintDataDto {
  StatisticsMintDataDto copyWith({
    double? totalMintEgldVolume,
    double? weekMintEgldVolume,
    double? dayMintEgldVolume,
  }) {
    return StatisticsMintDataDto(
      totalMintEgldVolume: totalMintEgldVolume ?? this.totalMintEgldVolume,
      weekMintEgldVolume: weekMintEgldVolume ?? this.weekMintEgldVolume,
      dayMintEgldVolume: dayMintEgldVolume ?? this.dayMintEgldVolume,
    );
  }

  StatisticsMintDataDto copyWithWrapped({
    Wrapped<double>? totalMintEgldVolume,
    Wrapped<double>? weekMintEgldVolume,
    Wrapped<double>? dayMintEgldVolume,
  }) {
    return StatisticsMintDataDto(
      totalMintEgldVolume: (totalMintEgldVolume != null
          ? totalMintEgldVolume.value
          : this.totalMintEgldVolume),
      weekMintEgldVolume: (weekMintEgldVolume != null
          ? weekMintEgldVolume.value
          : this.weekMintEgldVolume),
      dayMintEgldVolume: (dayMintEgldVolume != null
          ? dayMintEgldVolume.value
          : this.dayMintEgldVolume),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StatisticsDto {
  const StatisticsDto({
    required this.other,
    required this.tradeData,
    this.mintData,
  });

  factory StatisticsDto.fromJson(Map<String, dynamic> json) =>
      _$StatisticsDtoFromJson(json);

  static const toJsonFactory = _$StatisticsDtoToJson;
  Map<String, dynamic> toJson() => _$StatisticsDtoToJson(this);

  @JsonKey(name: 'other')
  final StatisticsOtherDto other;
  @JsonKey(name: 'tradeData')
  final StatisticsTradeDataDto tradeData;
  @JsonKey(name: 'mintData')
  final StatisticsMintDataDto? mintData;
  static const fromJsonFactory = _$StatisticsDtoFromJson;
}

extension $StatisticsDtoExtension on StatisticsDto {
  StatisticsDto copyWith({
    StatisticsOtherDto? other,
    StatisticsTradeDataDto? tradeData,
    StatisticsMintDataDto? mintData,
  }) {
    return StatisticsDto(
      other: other ?? this.other,
      tradeData: tradeData ?? this.tradeData,
      mintData: mintData ?? this.mintData,
    );
  }

  StatisticsDto copyWithWrapped({
    Wrapped<StatisticsOtherDto>? other,
    Wrapped<StatisticsTradeDataDto>? tradeData,
    Wrapped<StatisticsMintDataDto?>? mintData,
  }) {
    return StatisticsDto(
      other: (other != null ? other.value : this.other),
      tradeData: (tradeData != null ? tradeData.value : this.tradeData),
      mintData: (mintData != null ? mintData.value : this.mintData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransferPolicy {
  const TransferPolicy({
    required this.id,
    required this.type,
    required this.rules,
    required this.isOriginByte,
  });

  factory TransferPolicy.fromJson(Map<String, dynamic> json) =>
      _$TransferPolicyFromJson(json);

  static const toJsonFactory = _$TransferPolicyToJson;
  Map<String, dynamic> toJson() => _$TransferPolicyToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'rules', defaultValue: <String>[])
  final List<String> rules;
  @JsonKey(name: 'is_origin_byte')
  final bool isOriginByte;
  static const fromJsonFactory = _$TransferPolicyFromJson;
}

extension $TransferPolicyExtension on TransferPolicy {
  TransferPolicy copyWith({
    String? id,
    String? type,
    List<String>? rules,
    bool? isOriginByte,
  }) {
    return TransferPolicy(
      id: id ?? this.id,
      type: type ?? this.type,
      rules: rules ?? this.rules,
      isOriginByte: isOriginByte ?? this.isOriginByte,
    );
  }

  TransferPolicy copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? type,
    Wrapped<List<String>>? rules,
    Wrapped<bool>? isOriginByte,
  }) {
    return TransferPolicy(
      id: (id != null ? id.value : this.id),
      type: (type != null ? type.value : this.type),
      rules: (rules != null ? rules.value : this.rules),
      isOriginByte: (isOriginByte != null
          ? isOriginByte.value
          : this.isOriginByte),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileDoc {
  const CollectionProfileDoc({
    required this.dataType,
    required this.collection,
    required this.originalCollection,
    required this.name,
    required this.description,
    required this.isVisible,
    required this.isVerified,
    required this.socials,
    required this.type,
    this.subType,
    required this.profile,
    required this.banner,
    required this.statistics,
    required this.chain,
    required this.transferPolicies,
    required this.owner,
    required this.creator,
    required this.isMintable,
    required this.hasStaking,
    required this.isEvent,
    required this.roles,
    this.eventId,
    this.pinnedAtDrops,
    this.pinnedAt,
    this.customConfig,
    this.features,
    this.royalty,
    this.collectionSize,
    this.holdersCount,
    this.followCount,
    this.minSalePrice,
    this.id,
    this.ts,
  });

  factory CollectionProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileDocFromJson(json);

  static const toJsonFactory = _$CollectionProfileDocToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionProfileDocDataTypeToJson,
    fromJson: collectionProfileDocDataTypeFromJson,
  )
  final enums.CollectionProfileDocDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'originalCollection')
  final String originalCollection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(
    name: 'type',
    toJson: collectionProfileDocTypeToJson,
    fromJson: collectionProfileDocTypeFromJson,
  )
  final enums.CollectionProfileDocType type;
  @JsonKey(
    name: 'subType',
    toJson: collectionProfileDocSubTypeNullableToJson,
    fromJson: collectionProfileDocSubTypeNullableFromJson,
  )
  final enums.CollectionProfileDocSubType? subType;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'statistics')
  final StatisticsDto statistics;
  @JsonKey(
    name: 'chain',
    toJson: collectionProfileDocChainToJson,
    fromJson: collectionProfileDocChainFromJson,
  )
  final enums.CollectionProfileDocChain chain;
  @JsonKey(name: 'transferPolicies', defaultValue: <TransferPolicy>[])
  final List<TransferPolicy> transferPolicies;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'creator')
  final String creator;
  @JsonKey(name: 'isMintable')
  final bool isMintable;
  @JsonKey(name: 'hasStaking')
  final bool hasStaking;
  @JsonKey(name: 'isEvent')
  final bool isEvent;
  @JsonKey(name: 'roles')
  final Map<String, dynamic> roles;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'pinnedAtDrops')
  final double? pinnedAtDrops;
  @JsonKey(name: 'pinnedAt')
  final double? pinnedAt;
  @JsonKey(name: 'customConfig')
  final XoxnoMarketplaceScCollectionConfig? customConfig;
  @JsonKey(name: 'features')
  final CollectionFeatures? features;
  @JsonKey(name: 'royalty')
  final double? royalty;
  @JsonKey(name: 'collectionSize')
  final double? collectionSize;
  @JsonKey(name: 'holdersCount')
  final double? holdersCount;
  @JsonKey(name: 'followCount')
  final double? followCount;
  @JsonKey(name: 'minSalePrice')
  final String? minSalePrice;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$CollectionProfileDocFromJson;
}

extension $CollectionProfileDocExtension on CollectionProfileDoc {
  CollectionProfileDoc copyWith({
    enums.CollectionProfileDocDataType? dataType,
    String? collection,
    String? originalCollection,
    String? name,
    String? description,
    bool? isVisible,
    bool? isVerified,
    SocialsDto? socials,
    enums.CollectionProfileDocType? type,
    enums.CollectionProfileDocSubType? subType,
    String? profile,
    String? banner,
    StatisticsDto? statistics,
    enums.CollectionProfileDocChain? chain,
    List<TransferPolicy>? transferPolicies,
    String? owner,
    String? creator,
    bool? isMintable,
    bool? hasStaking,
    bool? isEvent,
    Map<String, dynamic>? roles,
    String? eventId,
    double? pinnedAtDrops,
    double? pinnedAt,
    XoxnoMarketplaceScCollectionConfig? customConfig,
    CollectionFeatures? features,
    double? royalty,
    double? collectionSize,
    double? holdersCount,
    double? followCount,
    String? minSalePrice,
    String? id,
    double? ts,
  }) {
    return CollectionProfileDoc(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      originalCollection: originalCollection ?? this.originalCollection,
      name: name ?? this.name,
      description: description ?? this.description,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      socials: socials ?? this.socials,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      statistics: statistics ?? this.statistics,
      chain: chain ?? this.chain,
      transferPolicies: transferPolicies ?? this.transferPolicies,
      owner: owner ?? this.owner,
      creator: creator ?? this.creator,
      isMintable: isMintable ?? this.isMintable,
      hasStaking: hasStaking ?? this.hasStaking,
      isEvent: isEvent ?? this.isEvent,
      roles: roles ?? this.roles,
      eventId: eventId ?? this.eventId,
      pinnedAtDrops: pinnedAtDrops ?? this.pinnedAtDrops,
      pinnedAt: pinnedAt ?? this.pinnedAt,
      customConfig: customConfig ?? this.customConfig,
      features: features ?? this.features,
      royalty: royalty ?? this.royalty,
      collectionSize: collectionSize ?? this.collectionSize,
      holdersCount: holdersCount ?? this.holdersCount,
      followCount: followCount ?? this.followCount,
      minSalePrice: minSalePrice ?? this.minSalePrice,
      id: id ?? this.id,
      ts: ts ?? this.ts,
    );
  }

  CollectionProfileDoc copyWithWrapped({
    Wrapped<enums.CollectionProfileDocDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? originalCollection,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<SocialsDto>? socials,
    Wrapped<enums.CollectionProfileDocType>? type,
    Wrapped<enums.CollectionProfileDocSubType?>? subType,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<StatisticsDto>? statistics,
    Wrapped<enums.CollectionProfileDocChain>? chain,
    Wrapped<List<TransferPolicy>>? transferPolicies,
    Wrapped<String>? owner,
    Wrapped<String>? creator,
    Wrapped<bool>? isMintable,
    Wrapped<bool>? hasStaking,
    Wrapped<bool>? isEvent,
    Wrapped<Map<String, dynamic>>? roles,
    Wrapped<String?>? eventId,
    Wrapped<double?>? pinnedAtDrops,
    Wrapped<double?>? pinnedAt,
    Wrapped<XoxnoMarketplaceScCollectionConfig?>? customConfig,
    Wrapped<CollectionFeatures?>? features,
    Wrapped<double?>? royalty,
    Wrapped<double?>? collectionSize,
    Wrapped<double?>? holdersCount,
    Wrapped<double?>? followCount,
    Wrapped<String?>? minSalePrice,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
  }) {
    return CollectionProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      originalCollection: (originalCollection != null
          ? originalCollection.value
          : this.originalCollection),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      socials: (socials != null ? socials.value : this.socials),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      statistics: (statistics != null ? statistics.value : this.statistics),
      chain: (chain != null ? chain.value : this.chain),
      transferPolicies: (transferPolicies != null
          ? transferPolicies.value
          : this.transferPolicies),
      owner: (owner != null ? owner.value : this.owner),
      creator: (creator != null ? creator.value : this.creator),
      isMintable: (isMintable != null ? isMintable.value : this.isMintable),
      hasStaking: (hasStaking != null ? hasStaking.value : this.hasStaking),
      isEvent: (isEvent != null ? isEvent.value : this.isEvent),
      roles: (roles != null ? roles.value : this.roles),
      eventId: (eventId != null ? eventId.value : this.eventId),
      pinnedAtDrops: (pinnedAtDrops != null
          ? pinnedAtDrops.value
          : this.pinnedAtDrops),
      pinnedAt: (pinnedAt != null ? pinnedAt.value : this.pinnedAt),
      customConfig: (customConfig != null
          ? customConfig.value
          : this.customConfig),
      features: (features != null ? features.value : this.features),
      royalty: (royalty != null ? royalty.value : this.royalty),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      holdersCount: (holdersCount != null
          ? holdersCount.value
          : this.holdersCount),
      followCount: (followCount != null ? followCount.value : this.followCount),
      minSalePrice: (minSalePrice != null
          ? minSalePrice.value
          : this.minSalePrice),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FloorPriceDto {
  const FloorPriceDto({
    required this.collection,
    required this.price,
    required this.usdPrice,
  });

  factory FloorPriceDto.fromJson(Map<String, dynamic> json) =>
      _$FloorPriceDtoFromJson(json);

  static const toJsonFactory = _$FloorPriceDtoToJson;
  Map<String, dynamic> toJson() => _$FloorPriceDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'usdPrice')
  final double usdPrice;
  static const fromJsonFactory = _$FloorPriceDtoFromJson;
}

extension $FloorPriceDtoExtension on FloorPriceDto {
  FloorPriceDto copyWith({
    String? collection,
    double? price,
    double? usdPrice,
  }) {
    return FloorPriceDto(
      collection: collection ?? this.collection,
      price: price ?? this.price,
      usdPrice: usdPrice ?? this.usdPrice,
    );
  }

  FloorPriceDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? price,
    Wrapped<double>? usdPrice,
  }) {
    return FloorPriceDto(
      collection: (collection != null ? collection.value : this.collection),
      price: (price != null ? price.value : this.price),
      usdPrice: (usdPrice != null ? usdPrice.value : this.usdPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PinnedCollectionDto {
  const PinnedCollectionDto({
    required this.collection,
    required this.name,
    required this.description,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.chain,
    required this.creator,
    required this.isMintable,
  });

  factory PinnedCollectionDto.fromJson(Map<String, dynamic> json) =>
      _$PinnedCollectionDtoFromJson(json);

  static const toJsonFactory = _$PinnedCollectionDtoToJson;
  Map<String, dynamic> toJson() => _$PinnedCollectionDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(
    name: 'chain',
    toJson: pinnedCollectionDtoChainToJson,
    fromJson: pinnedCollectionDtoChainFromJson,
  )
  final enums.PinnedCollectionDtoChain chain;
  @JsonKey(name: 'creator')
  final String creator;
  @JsonKey(name: 'isMintable')
  final bool isMintable;
  static const fromJsonFactory = _$PinnedCollectionDtoFromJson;
}

extension $PinnedCollectionDtoExtension on PinnedCollectionDto {
  PinnedCollectionDto copyWith({
    String? collection,
    String? name,
    String? description,
    bool? isVerified,
    String? profile,
    String? banner,
    enums.PinnedCollectionDtoChain? chain,
    String? creator,
    bool? isMintable,
  }) {
    return PinnedCollectionDto(
      collection: collection ?? this.collection,
      name: name ?? this.name,
      description: description ?? this.description,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      chain: chain ?? this.chain,
      creator: creator ?? this.creator,
      isMintable: isMintable ?? this.isMintable,
    );
  }

  PinnedCollectionDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<enums.PinnedCollectionDtoChain>? chain,
    Wrapped<String>? creator,
    Wrapped<bool>? isMintable,
  }) {
    return PinnedCollectionDto(
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      chain: (chain != null ? chain.value : this.chain),
      creator: (creator != null ? creator.value : this.creator),
      isMintable: (isMintable != null ? isMintable.value : this.isMintable),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EgldOrEsdtTokenPayment {
  const EgldOrEsdtTokenPayment({
    required this.tokenIdentifier,
    required this.tokenNonce,
    required this.amount,
    this.amountShort,
    this.usdValue,
    this.decimals,
  });

  factory EgldOrEsdtTokenPayment.fromJson(Map<String, dynamic> json) =>
      _$EgldOrEsdtTokenPaymentFromJson(json);

  static const toJsonFactory = _$EgldOrEsdtTokenPaymentToJson;
  Map<String, dynamic> toJson() => _$EgldOrEsdtTokenPaymentToJson(this);

  @JsonKey(name: 'tokenIdentifier')
  final String tokenIdentifier;
  @JsonKey(name: 'tokenNonce')
  final double tokenNonce;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'amountShort')
  final double? amountShort;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  @JsonKey(name: 'decimals')
  final double? decimals;
  static const fromJsonFactory = _$EgldOrEsdtTokenPaymentFromJson;
}

extension $EgldOrEsdtTokenPaymentExtension on EgldOrEsdtTokenPayment {
  EgldOrEsdtTokenPayment copyWith({
    String? tokenIdentifier,
    double? tokenNonce,
    String? amount,
    double? amountShort,
    double? usdValue,
    double? decimals,
  }) {
    return EgldOrEsdtTokenPayment(
      tokenIdentifier: tokenIdentifier ?? this.tokenIdentifier,
      tokenNonce: tokenNonce ?? this.tokenNonce,
      amount: amount ?? this.amount,
      amountShort: amountShort ?? this.amountShort,
      usdValue: usdValue ?? this.usdValue,
      decimals: decimals ?? this.decimals,
    );
  }

  EgldOrEsdtTokenPayment copyWithWrapped({
    Wrapped<String>? tokenIdentifier,
    Wrapped<double>? tokenNonce,
    Wrapped<String>? amount,
    Wrapped<double?>? amountShort,
    Wrapped<double?>? usdValue,
    Wrapped<double?>? decimals,
  }) {
    return EgldOrEsdtTokenPayment(
      tokenIdentifier: (tokenIdentifier != null
          ? tokenIdentifier.value
          : this.tokenIdentifier),
      tokenNonce: (tokenNonce != null ? tokenNonce.value : this.tokenNonce),
      amount: (amount != null ? amount.value : this.amount),
      amountShort: (amountShort != null ? amountShort.value : this.amountShort),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      decimals: (decimals != null ? decimals.value : this.decimals),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortCreatorDoc {
  const ShortCreatorDoc({
    required this.name,
    this.contractAddress,
    required this.profile,
  });

  factory ShortCreatorDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortCreatorDocFromJson(json);

  static const toJsonFactory = _$ShortCreatorDocToJson;
  Map<String, dynamic> toJson() => _$ShortCreatorDocToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  static const fromJsonFactory = _$ShortCreatorDocFromJson;
}

extension $ShortCreatorDocExtension on ShortCreatorDoc {
  ShortCreatorDoc copyWith({
    String? name,
    String? contractAddress,
    String? profile,
  }) {
    return ShortCreatorDoc(
      name: name ?? this.name,
      contractAddress: contractAddress ?? this.contractAddress,
      profile: profile ?? this.profile,
    );
  }

  ShortCreatorDoc copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String?>? contractAddress,
    Wrapped<String>? profile,
  }) {
    return ShortCreatorDoc(
      name: (name != null ? name.value : this.name),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      profile: (profile != null ? profile.value : this.profile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileDocHydrated {
  const CollectionMintProfileDocHydrated({
    required this.dataType,
    required this.collection,
    required this.creatorTag,
    required this.creatorName,
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.baseNftName,
    required this.hasAttributes,
    required this.ownerTransferred,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.royalties,
    required this.oldVersion,
    required this.nameShuffle,
    required this.nftTransferLimited,
    this.allowsPublicBurn,
    required this.kycRequired,
    required this.allowsRefund,
    required this.hasBotProtection,
    required this.hasReveal,
    required this.tags,
    required this.prices,
    required this.startTime,
    required this.endTime,
    required this.isSoldOut,
    required this.id,
    this.ts,
    required this.collectionInfo,
    required this.creatorInfo,
  });

  factory CollectionMintProfileDocHydrated.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionMintProfileDocHydratedFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileDocHydratedToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionMintProfileDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionMintProfileDocHydratedDataTypeToJson,
    fromJson: collectionMintProfileDocHydratedDataTypeFromJson,
  )
  final enums.CollectionMintProfileDocHydratedDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'creatorName')
  final String creatorName;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'baseNftName')
  final String baseNftName;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'ownerTransferred')
  final bool ownerTransferred;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'oldVersion')
  final bool oldVersion;
  @JsonKey(name: 'nameShuffle')
  final bool nameShuffle;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'allowsPublicBurn')
  final bool? allowsPublicBurn;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'allowsRefund')
  final bool allowsRefund;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'hasReveal')
  final bool hasReveal;
  @JsonKey(name: 'tags')
  final Object tags;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'isSoldOut')
  final bool isSoldOut;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'creatorInfo')
  final ShortCreatorDoc creatorInfo;
  static const fromJsonFactory = _$CollectionMintProfileDocHydratedFromJson;
}

extension $CollectionMintProfileDocHydratedExtension
    on CollectionMintProfileDocHydrated {
  CollectionMintProfileDocHydrated copyWith({
    enums.CollectionMintProfileDocHydratedDataType? dataType,
    String? collection,
    String? creatorTag,
    String? creatorName,
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    String? baseNftName,
    bool? hasAttributes,
    bool? ownerTransferred,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    double? royalties,
    bool? oldVersion,
    bool? nameShuffle,
    bool? nftTransferLimited,
    bool? allowsPublicBurn,
    bool? kycRequired,
    bool? allowsRefund,
    bool? hasBotProtection,
    bool? hasReveal,
    Object? tags,
    List<EgldOrEsdtTokenPayment>? prices,
    double? startTime,
    double? endTime,
    bool? isSoldOut,
    String? id,
    double? ts,
    ShortCollectionInfoDoc? collectionInfo,
    ShortCreatorDoc? creatorInfo,
  }) {
    return CollectionMintProfileDocHydrated(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      creatorTag: creatorTag ?? this.creatorTag,
      creatorName: creatorName ?? this.creatorName,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      baseNftName: baseNftName ?? this.baseNftName,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      ownerTransferred: ownerTransferred ?? this.ownerTransferred,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      royalties: royalties ?? this.royalties,
      oldVersion: oldVersion ?? this.oldVersion,
      nameShuffle: nameShuffle ?? this.nameShuffle,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      allowsPublicBurn: allowsPublicBurn ?? this.allowsPublicBurn,
      kycRequired: kycRequired ?? this.kycRequired,
      allowsRefund: allowsRefund ?? this.allowsRefund,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      hasReveal: hasReveal ?? this.hasReveal,
      tags: tags ?? this.tags,
      prices: prices ?? this.prices,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isSoldOut: isSoldOut ?? this.isSoldOut,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      creatorInfo: creatorInfo ?? this.creatorInfo,
    );
  }

  CollectionMintProfileDocHydrated copyWithWrapped({
    Wrapped<enums.CollectionMintProfileDocHydratedDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? creatorTag,
    Wrapped<String>? creatorName,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<String>? baseNftName,
    Wrapped<bool>? hasAttributes,
    Wrapped<bool>? ownerTransferred,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<double>? royalties,
    Wrapped<bool>? oldVersion,
    Wrapped<bool>? nameShuffle,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool?>? allowsPublicBurn,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? allowsRefund,
    Wrapped<bool>? hasBotProtection,
    Wrapped<bool>? hasReveal,
    Wrapped<Object>? tags,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<bool>? isSoldOut,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
    Wrapped<ShortCreatorDoc>? creatorInfo,
  }) {
    return CollectionMintProfileDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      baseNftName: (baseNftName != null ? baseNftName.value : this.baseNftName),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      ownerTransferred: (ownerTransferred != null
          ? ownerTransferred.value
          : this.ownerTransferred),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      royalties: (royalties != null ? royalties.value : this.royalties),
      oldVersion: (oldVersion != null ? oldVersion.value : this.oldVersion),
      nameShuffle: (nameShuffle != null ? nameShuffle.value : this.nameShuffle),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      allowsPublicBurn: (allowsPublicBurn != null
          ? allowsPublicBurn.value
          : this.allowsPublicBurn),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      allowsRefund: (allowsRefund != null
          ? allowsRefund.value
          : this.allowsRefund),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      hasReveal: (hasReveal != null ? hasReveal.value : this.hasReveal),
      tags: (tags != null ? tags.value : this.tags),
      prices: (prices != null ? prices.value : this.prices),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      isSoldOut: (isSoldOut != null ? isSoldOut.value : this.isSoldOut),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      creatorInfo: (creatorInfo != null ? creatorInfo.value : this.creatorInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionPinnedStatusDto {
  const CollectionPinnedStatusDto({
    required this.collection,
    required this.status,
  });

  factory CollectionPinnedStatusDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionPinnedStatusDtoFromJson(json);

  static const toJsonFactory = _$CollectionPinnedStatusDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionPinnedStatusDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'status')
  final bool status;
  static const fromJsonFactory = _$CollectionPinnedStatusDtoFromJson;
}

extension $CollectionPinnedStatusDtoExtension on CollectionPinnedStatusDto {
  CollectionPinnedStatusDto copyWith({String? collection, bool? status}) {
    return CollectionPinnedStatusDto(
      collection: collection ?? this.collection,
      status: status ?? this.status,
    );
  }

  CollectionPinnedStatusDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<bool>? status,
  }) {
    return CollectionPinnedStatusDto(
      collection: (collection != null ? collection.value : this.collection),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileEditDto {
  const CollectionProfileEditDto({this.name, this.description, this.socials});

  factory CollectionProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileEditDtoFromJson(json);

  static const toJsonFactory = _$CollectionProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  static const fromJsonFactory = _$CollectionProfileEditDtoFromJson;
}

extension $CollectionProfileEditDtoExtension on CollectionProfileEditDto {
  CollectionProfileEditDto copyWith({
    String? name,
    String? description,
    SocialsDto? socials,
  }) {
    return CollectionProfileEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
      socials: socials ?? this.socials,
    );
  }

  CollectionProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
  }) {
    return CollectionProfileEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FollowCollectionDto {
  const FollowCollectionDto({required this.isFavorite, this.collection});

  factory FollowCollectionDto.fromJson(Map<String, dynamic> json) =>
      _$FollowCollectionDtoFromJson(json);

  static const toJsonFactory = _$FollowCollectionDtoToJson;
  Map<String, dynamic> toJson() => _$FollowCollectionDtoToJson(this);

  @JsonKey(name: 'isFavorite')
  final bool isFavorite;
  @JsonKey(name: 'collection')
  final String? collection;
  static const fromJsonFactory = _$FollowCollectionDtoFromJson;
}

extension $FollowCollectionDtoExtension on FollowCollectionDto {
  FollowCollectionDto copyWith({bool? isFavorite, String? collection}) {
    return FollowCollectionDto(
      isFavorite: isFavorite ?? this.isFavorite,
      collection: collection ?? this.collection,
    );
  }

  FollowCollectionDto copyWithWrapped({
    Wrapped<bool>? isFavorite,
    Wrapped<String?>? collection,
  }) {
    return FollowCollectionDto(
      isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
      collection: (collection != null ? collection.value : this.collection),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfileFilter {
  const CollectionProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
  });

  factory CollectionProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfileFilterFromJson(json);

  static const toJsonFactory = _$CollectionProfileFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  static const fromJsonFactory = _$CollectionProfileFilterFromJson;
}

extension $CollectionProfileFilterExtension on CollectionProfileFilter {
  CollectionProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
  }) {
    return CollectionProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
    );
  }

  CollectionProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
  }) {
    return CollectionProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionProfilePaginated {
  const CollectionProfilePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionProfilePaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionProfilePaginatedFromJson(json);

  static const toJsonFactory = _$CollectionProfilePaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionProfilePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <CollectionProfileDoc>[])
  final List<CollectionProfileDoc> resources;
  static const fromJsonFactory = _$CollectionProfilePaginatedFromJson;
}

extension $CollectionProfilePaginatedExtension on CollectionProfilePaginated {
  CollectionProfilePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionProfileDoc>? resources,
  }) {
    return CollectionProfilePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionProfilePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionProfileDoc>>? resources,
  }) {
    return CollectionProfilePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileFilter {
  const CollectionMintProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
  });

  factory CollectionMintProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionMintProfileFilterFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionMintProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  static const fromJsonFactory = _$CollectionMintProfileFilterFromJson;
}

extension $CollectionMintProfileFilterExtension on CollectionMintProfileFilter {
  CollectionMintProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
  }) {
    return CollectionMintProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
    );
  }

  CollectionMintProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
  }) {
    return CollectionMintProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfilePaginated {
  const CollectionMintProfilePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory CollectionMintProfilePaginated.fromJson(Map<String, dynamic> json) =>
      _$CollectionMintProfilePaginatedFromJson(json);

  static const toJsonFactory = _$CollectionMintProfilePaginatedToJson;
  Map<String, dynamic> toJson() => _$CollectionMintProfilePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(
    name: 'resources',
    defaultValue: <CollectionMintProfileDocHydrated>[],
  )
  final List<CollectionMintProfileDocHydrated> resources;
  static const fromJsonFactory = _$CollectionMintProfilePaginatedFromJson;
}

extension $CollectionMintProfilePaginatedExtension
    on CollectionMintProfilePaginated {
  CollectionMintProfilePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<CollectionMintProfileDocHydrated>? resources,
  }) {
    return CollectionMintProfilePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  CollectionMintProfilePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<CollectionMintProfileDocHydrated>>? resources,
  }) {
    return CollectionMintProfilePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MintStageDto {
  const MintStageDto({
    required this.dataType,
    required this.collection,
    required this.contractAddress,
    required this.collectionTag,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.mintCount,
    required this.mintLimit,
    required this.mintEnabled,
    required this.isWhitelist,
    required this.walletLimit,
    required this.prices,
    required this.id,
    required this.ts,
    required this.walletLimitReached,
    this.maxBuyable,
    this.userMintsPerStage,
  });

  factory MintStageDto.fromJson(Map<String, dynamic> json) =>
      _$MintStageDtoFromJson(json);

  static const toJsonFactory = _$MintStageDtoToJson;
  Map<String, dynamic> toJson() => _$MintStageDtoToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'mintCount')
  final double mintCount;
  @JsonKey(name: 'mintLimit')
  final double mintLimit;
  @JsonKey(name: 'mintEnabled')
  final bool mintEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'walletLimit')
  final double walletLimit;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'walletLimitReached')
  final bool walletLimitReached;
  @JsonKey(name: 'maxBuyable')
  final Object? maxBuyable;
  @JsonKey(name: 'userMintsPerStage')
  final double? userMintsPerStage;
  static const fromJsonFactory = _$MintStageDtoFromJson;
}

extension $MintStageDtoExtension on MintStageDto {
  MintStageDto copyWith({
    Object? dataType,
    String? collection,
    String? contractAddress,
    String? collectionTag,
    String? name,
    double? startTime,
    double? endTime,
    double? mintCount,
    double? mintLimit,
    bool? mintEnabled,
    bool? isWhitelist,
    double? walletLimit,
    List<EgldOrEsdtTokenPayment>? prices,
    String? id,
    double? ts,
    bool? walletLimitReached,
    Object? maxBuyable,
    double? userMintsPerStage,
  }) {
    return MintStageDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      mintCount: mintCount ?? this.mintCount,
      mintLimit: mintLimit ?? this.mintLimit,
      mintEnabled: mintEnabled ?? this.mintEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      walletLimit: walletLimit ?? this.walletLimit,
      prices: prices ?? this.prices,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      walletLimitReached: walletLimitReached ?? this.walletLimitReached,
      maxBuyable: maxBuyable ?? this.maxBuyable,
      userMintsPerStage: userMintsPerStage ?? this.userMintsPerStage,
    );
  }

  MintStageDto copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? name,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<double>? mintCount,
    Wrapped<double>? mintLimit,
    Wrapped<bool>? mintEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<double>? walletLimit,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<String>? id,
    Wrapped<double>? ts,
    Wrapped<bool>? walletLimitReached,
    Wrapped<Object?>? maxBuyable,
    Wrapped<double?>? userMintsPerStage,
  }) {
    return MintStageDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      mintCount: (mintCount != null ? mintCount.value : this.mintCount),
      mintLimit: (mintLimit != null ? mintLimit.value : this.mintLimit),
      mintEnabled: (mintEnabled != null ? mintEnabled.value : this.mintEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      walletLimit: (walletLimit != null ? walletLimit.value : this.walletLimit),
      prices: (prices != null ? prices.value : this.prices),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      walletLimitReached: (walletLimitReached != null
          ? walletLimitReached.value
          : this.walletLimitReached),
      maxBuyable: (maxBuyable != null ? maxBuyable.value : this.maxBuyable),
      userMintsPerStage: (userMintsPerStage != null
          ? userMintsPerStage.value
          : this.userMintsPerStage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionMintProfileDocWithStages {
  const CollectionMintProfileDocWithStages({
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.hasAttributes,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.nftTransferLimited,
    required this.kycRequired,
    required this.hasBotProtection,
    required this.collectionInfo,
    required this.collection,
    required this.isExcludedFromMint,
    required this.userMintsGlobal,
    required this.mintStages,
    required this.creatorInfo,
  });

  factory CollectionMintProfileDocWithStages.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionMintProfileDocWithStagesFromJson(json);

  static const toJsonFactory = _$CollectionMintProfileDocWithStagesToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionMintProfileDocWithStagesToJson(this);

  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'isExcludedFromMint')
  final bool isExcludedFromMint;
  @JsonKey(name: 'userMintsGlobal')
  final double userMintsGlobal;
  @JsonKey(name: 'mintStages', defaultValue: <MintStageDto>[])
  final List<MintStageDto> mintStages;
  @JsonKey(name: 'creatorInfo')
  final CreatorProfileDoc creatorInfo;
  static const fromJsonFactory = _$CollectionMintProfileDocWithStagesFromJson;
}

extension $CollectionMintProfileDocWithStagesExtension
    on CollectionMintProfileDocWithStages {
  CollectionMintProfileDocWithStages copyWith({
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    bool? hasAttributes,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    bool? nftTransferLimited,
    bool? kycRequired,
    bool? hasBotProtection,
    ShortCollectionInfoDoc? collectionInfo,
    String? collection,
    bool? isExcludedFromMint,
    double? userMintsGlobal,
    List<MintStageDto>? mintStages,
    CreatorProfileDoc? creatorInfo,
  }) {
    return CollectionMintProfileDocWithStages(
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      kycRequired: kycRequired ?? this.kycRequired,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      collectionInfo: collectionInfo ?? this.collectionInfo,
      collection: collection ?? this.collection,
      isExcludedFromMint: isExcludedFromMint ?? this.isExcludedFromMint,
      userMintsGlobal: userMintsGlobal ?? this.userMintsGlobal,
      mintStages: mintStages ?? this.mintStages,
      creatorInfo: creatorInfo ?? this.creatorInfo,
    );
  }

  CollectionMintProfileDocWithStages copyWithWrapped({
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<bool>? hasAttributes,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? hasBotProtection,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
    Wrapped<String>? collection,
    Wrapped<bool>? isExcludedFromMint,
    Wrapped<double>? userMintsGlobal,
    Wrapped<List<MintStageDto>>? mintStages,
    Wrapped<CreatorProfileDoc>? creatorInfo,
  }) {
    return CollectionMintProfileDocWithStages(
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
      collection: (collection != null ? collection.value : this.collection),
      isExcludedFromMint: (isExcludedFromMint != null
          ? isExcludedFromMint.value
          : this.isExcludedFromMint),
      userMintsGlobal: (userMintsGlobal != null
          ? userMintsGlobal.value
          : this.userMintsGlobal),
      mintStages: (mintStages != null ? mintStages.value : this.mintStages),
      creatorInfo: (creatorInfo != null ? creatorInfo.value : this.creatorInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WalletDetailDto {
  const WalletDetailDto({
    required this.count,
    required this.weight,
    required this.address,
    required this.username,
    required this.type,
  });

  factory WalletDetailDto.fromJson(Map<String, dynamic> json) =>
      _$WalletDetailDtoFromJson(json);

  static const toJsonFactory = _$WalletDetailDtoToJson;
  Map<String, dynamic> toJson() => _$WalletDetailDtoToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'weight')
  final double weight;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$WalletDetailDtoFromJson;
}

extension $WalletDetailDtoExtension on WalletDetailDto {
  WalletDetailDto copyWith({
    double? count,
    double? weight,
    String? address,
    String? username,
    String? type,
  }) {
    return WalletDetailDto(
      count: count ?? this.count,
      weight: weight ?? this.weight,
      address: address ?? this.address,
      username: username ?? this.username,
      type: type ?? this.type,
    );
  }

  WalletDetailDto copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<double>? weight,
    Wrapped<String>? address,
    Wrapped<String>? username,
    Wrapped<String>? type,
  }) {
    return WalletDetailDto(
      count: (count != null ? count.value : this.count),
      weight: (weight != null ? weight.value : this.weight),
      address: (address != null ? address.value : this.address),
      username: (username != null ? username.value : this.username),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionHoldersDto {
  const CollectionHoldersDto({
    required this.totalSupply,
    required this.walletDetails,
    required this.onMarket,
    required this.staked,
    required this.otherSCs,
    required this.burnWallet,
    required this.uniqueHolders,
    required this.holded,
  });

  factory CollectionHoldersDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionHoldersDtoFromJson(json);

  static const toJsonFactory = _$CollectionHoldersDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionHoldersDtoToJson(this);

  @JsonKey(name: 'totalSupply')
  final double totalSupply;
  @JsonKey(name: 'walletDetails', defaultValue: <WalletDetailDto>[])
  final List<WalletDetailDto> walletDetails;
  @JsonKey(name: 'onMarket')
  final Object onMarket;
  @JsonKey(name: 'staked')
  final Object staked;
  @JsonKey(name: 'otherSCs')
  final Object otherSCs;
  @JsonKey(name: 'burnWallet')
  final Object burnWallet;
  @JsonKey(name: 'uniqueHolders')
  final Object uniqueHolders;
  @JsonKey(name: 'holded')
  final Object holded;
  static const fromJsonFactory = _$CollectionHoldersDtoFromJson;
}

extension $CollectionHoldersDtoExtension on CollectionHoldersDto {
  CollectionHoldersDto copyWith({
    double? totalSupply,
    List<WalletDetailDto>? walletDetails,
    Object? onMarket,
    Object? staked,
    Object? otherSCs,
    Object? burnWallet,
    Object? uniqueHolders,
    Object? holded,
  }) {
    return CollectionHoldersDto(
      totalSupply: totalSupply ?? this.totalSupply,
      walletDetails: walletDetails ?? this.walletDetails,
      onMarket: onMarket ?? this.onMarket,
      staked: staked ?? this.staked,
      otherSCs: otherSCs ?? this.otherSCs,
      burnWallet: burnWallet ?? this.burnWallet,
      uniqueHolders: uniqueHolders ?? this.uniqueHolders,
      holded: holded ?? this.holded,
    );
  }

  CollectionHoldersDto copyWithWrapped({
    Wrapped<double>? totalSupply,
    Wrapped<List<WalletDetailDto>>? walletDetails,
    Wrapped<Object>? onMarket,
    Wrapped<Object>? staked,
    Wrapped<Object>? otherSCs,
    Wrapped<Object>? burnWallet,
    Wrapped<Object>? uniqueHolders,
    Wrapped<Object>? holded,
  }) {
    return CollectionHoldersDto(
      totalSupply: (totalSupply != null ? totalSupply.value : this.totalSupply),
      walletDetails: (walletDetails != null
          ? walletDetails.value
          : this.walletDetails),
      onMarket: (onMarket != null ? onMarket.value : this.onMarket),
      staked: (staked != null ? staked.value : this.staked),
      otherSCs: (otherSCs != null ? otherSCs.value : this.otherSCs),
      burnWallet: (burnWallet != null ? burnWallet.value : this.burnWallet),
      uniqueHolders: (uniqueHolders != null
          ? uniqueHolders.value
          : this.uniqueHolders),
      holded: (holded != null ? holded.value : this.holded),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionHoldersExportDto {
  const CollectionHoldersExportDto();

  factory CollectionHoldersExportDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionHoldersExportDtoFromJson(json);

  static const toJsonFactory = _$CollectionHoldersExportDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionHoldersExportDtoToJson(this);

  static const fromJsonFactory = _$CollectionHoldersExportDtoFromJson;
}

@JsonSerializable(explicitToJson: true)
class CollectionOwnerDto {
  const CollectionOwnerDto({required this.owner});

  factory CollectionOwnerDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionOwnerDtoFromJson(json);

  static const toJsonFactory = _$CollectionOwnerDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionOwnerDtoToJson(this);

  @JsonKey(name: 'owner')
  final String owner;
  static const fromJsonFactory = _$CollectionOwnerDtoFromJson;
}

extension $CollectionOwnerDtoExtension on CollectionOwnerDto {
  CollectionOwnerDto copyWith({String? owner}) {
    return CollectionOwnerDto(owner: owner ?? this.owner);
  }

  CollectionOwnerDto copyWithWrapped({Wrapped<String>? owner}) {
    return CollectionOwnerDto(
      owner: (owner != null ? owner.value : this.owner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionOffersFilterCriteriaDto {
  const CollectionOffersFilterCriteriaDto({
    this.dataType,
    this.collection,
    this.offerId,
    this.owner,
    this.marketplace,
    this.range,
    this.attributes,
    this.isActive,
    this.withAttributes,
  });

  factory CollectionOffersFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionOffersFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$CollectionOffersFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionOffersFilterCriteriaDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: collectionDataTypeNullableToJson,
    fromJson: collectionDataTypeNullableFromJson,
  )
  final enums.CollectionDataType? dataType;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'offerId', defaultValue: <int>[])
  final List<int>? offerId;
  @JsonKey(name: 'owner', defaultValue: <String>[])
  final List<String>? owner;
  @JsonKey(name: 'marketplace', defaultValue: <String>[])
  final List<String>? marketplace;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'attributes', defaultValue: <NftMetadataAttributes>[])
  final List<NftMetadataAttributes>? attributes;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'withAttributes')
  final bool? withAttributes;
  static const fromJsonFactory = _$CollectionOffersFilterCriteriaDtoFromJson;
}

extension $CollectionOffersFilterCriteriaDtoExtension
    on CollectionOffersFilterCriteriaDto {
  CollectionOffersFilterCriteriaDto copyWith({
    enums.CollectionDataType? dataType,
    List<String>? collection,
    List<int>? offerId,
    List<String>? owner,
    List<String>? marketplace,
    List<RangeFilter>? range,
    List<NftMetadataAttributes>? attributes,
    bool? isActive,
    bool? withAttributes,
  }) {
    return CollectionOffersFilterCriteriaDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      offerId: offerId ?? this.offerId,
      owner: owner ?? this.owner,
      marketplace: marketplace ?? this.marketplace,
      range: range ?? this.range,
      attributes: attributes ?? this.attributes,
      isActive: isActive ?? this.isActive,
      withAttributes: withAttributes ?? this.withAttributes,
    );
  }

  CollectionOffersFilterCriteriaDto copyWithWrapped({
    Wrapped<enums.CollectionDataType?>? dataType,
    Wrapped<List<String>?>? collection,
    Wrapped<List<int>?>? offerId,
    Wrapped<List<String>?>? owner,
    Wrapped<List<String>?>? marketplace,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<List<NftMetadataAttributes>?>? attributes,
    Wrapped<bool?>? isActive,
    Wrapped<bool?>? withAttributes,
  }) {
    return CollectionOffersFilterCriteriaDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      offerId: (offerId != null ? offerId.value : this.offerId),
      owner: (owner != null ? owner.value : this.owner),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      range: (range != null ? range.value : this.range),
      attributes: (attributes != null ? attributes.value : this.attributes),
      isActive: (isActive != null ? isActive.value : this.isActive),
      withAttributes: (withAttributes != null
          ? withAttributes.value
          : this.withAttributes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionOffersFilter {
  const CollectionOffersFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory CollectionOffersFilter.fromJson(Map<String, dynamic> json) =>
      _$CollectionOffersFilterFromJson(json);

  static const toJsonFactory = _$CollectionOffersFilterToJson;
  Map<String, dynamic> toJson() => _$CollectionOffersFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final CollectionOffersFilterCriteriaDto? filters;
  static const fromJsonFactory = _$CollectionOffersFilterFromJson;
}

extension $CollectionOffersFilterExtension on CollectionOffersFilter {
  CollectionOffersFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    CollectionOffersFilterCriteriaDto? filters,
  }) {
    return CollectionOffersFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  CollectionOffersFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<CollectionOffersFilterCriteriaDto?>? filters,
  }) {
    return CollectionOffersFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalOfferPaginated {
  const GlobalOfferPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory GlobalOfferPaginated.fromJson(Map<String, dynamic> json) =>
      _$GlobalOfferPaginatedFromJson(json);

  static const toJsonFactory = _$GlobalOfferPaginatedToJson;
  Map<String, dynamic> toJson() => _$GlobalOfferPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <GlobalOfferDocHydrated>[])
  final List<GlobalOfferDocHydrated> resources;
  static const fromJsonFactory = _$GlobalOfferPaginatedFromJson;
}

extension $GlobalOfferPaginatedExtension on GlobalOfferPaginated {
  GlobalOfferPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<GlobalOfferDocHydrated>? resources,
  }) {
    return GlobalOfferPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  GlobalOfferPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<GlobalOfferDocHydrated>>? resources,
  }) {
    return GlobalOfferPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MintingListingDto {
  const MintingListingDto({
    required this.dataType,
    required this.collection,
    required this.creatorTag,
    required this.creatorName,
    required this.contractAddress,
    required this.collectionTag,
    required this.cid,
    required this.mediaType,
    required this.baseNftName,
    required this.hasAttributes,
    required this.ownerTransferred,
    required this.collectionSize,
    required this.totalNftMinted,
    required this.globalWalletLimit,
    required this.royalties,
    required this.oldVersion,
    required this.nameShuffle,
    required this.nftTransferLimited,
    this.allowsPublicBurn,
    required this.kycRequired,
    required this.allowsRefund,
    required this.hasBotProtection,
    required this.hasReveal,
    required this.tags,
    required this.prices,
    required this.startTime,
    required this.endTime,
    required this.isSoldOut,
    required this.id,
    this.ts,
    required this.collectionInfo,
  });

  factory MintingListingDto.fromJson(Map<String, dynamic> json) =>
      _$MintingListingDtoFromJson(json);

  static const toJsonFactory = _$MintingListingDtoToJson;
  Map<String, dynamic> toJson() => _$MintingListingDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: mintingListingDtoDataTypeToJson,
    fromJson: mintingListingDtoDataTypeFromJson,
  )
  final enums.MintingListingDtoDataType dataType;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'creatorName')
  final String creatorName;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'collectionTag')
  final String collectionTag;
  @JsonKey(name: 'cid')
  final String cid;
  @JsonKey(name: 'mediaType')
  final String mediaType;
  @JsonKey(name: 'baseNftName')
  final String baseNftName;
  @JsonKey(name: 'hasAttributes')
  final bool hasAttributes;
  @JsonKey(name: 'ownerTransferred')
  final bool ownerTransferred;
  @JsonKey(name: 'collectionSize')
  final double collectionSize;
  @JsonKey(name: 'totalNftMinted')
  final double totalNftMinted;
  @JsonKey(name: 'globalWalletLimit')
  final double globalWalletLimit;
  @JsonKey(name: 'royalties')
  final double royalties;
  @JsonKey(name: 'oldVersion')
  final bool oldVersion;
  @JsonKey(name: 'nameShuffle')
  final bool nameShuffle;
  @JsonKey(name: 'nftTransferLimited')
  final bool nftTransferLimited;
  @JsonKey(name: 'allowsPublicBurn')
  final bool? allowsPublicBurn;
  @JsonKey(name: 'kycRequired')
  final bool kycRequired;
  @JsonKey(name: 'allowsRefund')
  final bool allowsRefund;
  @JsonKey(name: 'hasBotProtection')
  final bool hasBotProtection;
  @JsonKey(name: 'hasReveal')
  final bool hasReveal;
  @JsonKey(name: 'tags')
  final Object tags;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'startTime')
  final double startTime;
  @JsonKey(name: 'endTime')
  final double endTime;
  @JsonKey(name: 'isSoldOut')
  final bool isSoldOut;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionInfoDoc collectionInfo;
  static const fromJsonFactory = _$MintingListingDtoFromJson;
}

extension $MintingListingDtoExtension on MintingListingDto {
  MintingListingDto copyWith({
    enums.MintingListingDtoDataType? dataType,
    String? collection,
    String? creatorTag,
    String? creatorName,
    String? contractAddress,
    String? collectionTag,
    String? cid,
    String? mediaType,
    String? baseNftName,
    bool? hasAttributes,
    bool? ownerTransferred,
    double? collectionSize,
    double? totalNftMinted,
    double? globalWalletLimit,
    double? royalties,
    bool? oldVersion,
    bool? nameShuffle,
    bool? nftTransferLimited,
    bool? allowsPublicBurn,
    bool? kycRequired,
    bool? allowsRefund,
    bool? hasBotProtection,
    bool? hasReveal,
    Object? tags,
    List<EgldOrEsdtTokenPayment>? prices,
    double? startTime,
    double? endTime,
    bool? isSoldOut,
    String? id,
    double? ts,
    ShortCollectionInfoDoc? collectionInfo,
  }) {
    return MintingListingDto(
      dataType: dataType ?? this.dataType,
      collection: collection ?? this.collection,
      creatorTag: creatorTag ?? this.creatorTag,
      creatorName: creatorName ?? this.creatorName,
      contractAddress: contractAddress ?? this.contractAddress,
      collectionTag: collectionTag ?? this.collectionTag,
      cid: cid ?? this.cid,
      mediaType: mediaType ?? this.mediaType,
      baseNftName: baseNftName ?? this.baseNftName,
      hasAttributes: hasAttributes ?? this.hasAttributes,
      ownerTransferred: ownerTransferred ?? this.ownerTransferred,
      collectionSize: collectionSize ?? this.collectionSize,
      totalNftMinted: totalNftMinted ?? this.totalNftMinted,
      globalWalletLimit: globalWalletLimit ?? this.globalWalletLimit,
      royalties: royalties ?? this.royalties,
      oldVersion: oldVersion ?? this.oldVersion,
      nameShuffle: nameShuffle ?? this.nameShuffle,
      nftTransferLimited: nftTransferLimited ?? this.nftTransferLimited,
      allowsPublicBurn: allowsPublicBurn ?? this.allowsPublicBurn,
      kycRequired: kycRequired ?? this.kycRequired,
      allowsRefund: allowsRefund ?? this.allowsRefund,
      hasBotProtection: hasBotProtection ?? this.hasBotProtection,
      hasReveal: hasReveal ?? this.hasReveal,
      tags: tags ?? this.tags,
      prices: prices ?? this.prices,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isSoldOut: isSoldOut ?? this.isSoldOut,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  MintingListingDto copyWithWrapped({
    Wrapped<enums.MintingListingDtoDataType>? dataType,
    Wrapped<String>? collection,
    Wrapped<String>? creatorTag,
    Wrapped<String>? creatorName,
    Wrapped<String>? contractAddress,
    Wrapped<String>? collectionTag,
    Wrapped<String>? cid,
    Wrapped<String>? mediaType,
    Wrapped<String>? baseNftName,
    Wrapped<bool>? hasAttributes,
    Wrapped<bool>? ownerTransferred,
    Wrapped<double>? collectionSize,
    Wrapped<double>? totalNftMinted,
    Wrapped<double>? globalWalletLimit,
    Wrapped<double>? royalties,
    Wrapped<bool>? oldVersion,
    Wrapped<bool>? nameShuffle,
    Wrapped<bool>? nftTransferLimited,
    Wrapped<bool?>? allowsPublicBurn,
    Wrapped<bool>? kycRequired,
    Wrapped<bool>? allowsRefund,
    Wrapped<bool>? hasBotProtection,
    Wrapped<bool>? hasReveal,
    Wrapped<Object>? tags,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<double>? startTime,
    Wrapped<double>? endTime,
    Wrapped<bool>? isSoldOut,
    Wrapped<String>? id,
    Wrapped<double?>? ts,
    Wrapped<ShortCollectionInfoDoc>? collectionInfo,
  }) {
    return MintingListingDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      collection: (collection != null ? collection.value : this.collection),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collectionTag: (collectionTag != null
          ? collectionTag.value
          : this.collectionTag),
      cid: (cid != null ? cid.value : this.cid),
      mediaType: (mediaType != null ? mediaType.value : this.mediaType),
      baseNftName: (baseNftName != null ? baseNftName.value : this.baseNftName),
      hasAttributes: (hasAttributes != null
          ? hasAttributes.value
          : this.hasAttributes),
      ownerTransferred: (ownerTransferred != null
          ? ownerTransferred.value
          : this.ownerTransferred),
      collectionSize: (collectionSize != null
          ? collectionSize.value
          : this.collectionSize),
      totalNftMinted: (totalNftMinted != null
          ? totalNftMinted.value
          : this.totalNftMinted),
      globalWalletLimit: (globalWalletLimit != null
          ? globalWalletLimit.value
          : this.globalWalletLimit),
      royalties: (royalties != null ? royalties.value : this.royalties),
      oldVersion: (oldVersion != null ? oldVersion.value : this.oldVersion),
      nameShuffle: (nameShuffle != null ? nameShuffle.value : this.nameShuffle),
      nftTransferLimited: (nftTransferLimited != null
          ? nftTransferLimited.value
          : this.nftTransferLimited),
      allowsPublicBurn: (allowsPublicBurn != null
          ? allowsPublicBurn.value
          : this.allowsPublicBurn),
      kycRequired: (kycRequired != null ? kycRequired.value : this.kycRequired),
      allowsRefund: (allowsRefund != null
          ? allowsRefund.value
          : this.allowsRefund),
      hasBotProtection: (hasBotProtection != null
          ? hasBotProtection.value
          : this.hasBotProtection),
      hasReveal: (hasReveal != null ? hasReveal.value : this.hasReveal),
      tags: (tags != null ? tags.value : this.tags),
      prices: (prices != null ? prices.value : this.prices),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      isSoldOut: (isSoldOut != null ? isSoldOut.value : this.isSoldOut),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GeoPointDto {
  const GeoPointDto({this.type, this.coordinates});

  factory GeoPointDto.fromJson(Map<String, dynamic> json) =>
      _$GeoPointDtoFromJson(json);

  static const toJsonFactory = _$GeoPointDtoToJson;
  Map<String, dynamic> toJson() => _$GeoPointDtoToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'coordinates', defaultValue: <String>[])
  final List<String>? coordinates;
  static const fromJsonFactory = _$GeoPointDtoFromJson;
}

extension $GeoPointDtoExtension on GeoPointDto {
  GeoPointDto copyWith({String? type, List<String>? coordinates}) {
    return GeoPointDto(
      type: type ?? this.type,
      coordinates: coordinates ?? this.coordinates,
    );
  }

  GeoPointDto copyWithWrapped({
    Wrapped<String?>? type,
    Wrapped<List<String>?>? coordinates,
  }) {
    return GeoPointDto(
      type: (type != null ? type.value : this.type),
      coordinates: (coordinates != null ? coordinates.value : this.coordinates),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventLocationDto {
  const EventLocationDto({
    this.address,
    this.placeId,
    this.lat,
    this.long,
    this.geo,
    this.instructions,
    this.onlineLink,
    this.city,
    this.country,
  });

  factory EventLocationDto.fromJson(Map<String, dynamic> json) =>
      _$EventLocationDtoFromJson(json);

  static const toJsonFactory = _$EventLocationDtoToJson;
  Map<String, dynamic> toJson() => _$EventLocationDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'placeId')
  final String? placeId;
  @JsonKey(name: 'lat')
  final double? lat;
  @JsonKey(name: 'long')
  final double? long;
  @JsonKey(name: 'geo')
  final GeoPointDto? geo;
  @JsonKey(name: 'instructions')
  final String? instructions;
  @JsonKey(name: 'onlineLink')
  final String? onlineLink;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$EventLocationDtoFromJson;
}

extension $EventLocationDtoExtension on EventLocationDto {
  EventLocationDto copyWith({
    String? address,
    String? placeId,
    double? lat,
    double? long,
    GeoPointDto? geo,
    String? instructions,
    String? onlineLink,
    String? city,
    String? country,
  }) {
    return EventLocationDto(
      address: address ?? this.address,
      placeId: placeId ?? this.placeId,
      lat: lat ?? this.lat,
      long: long ?? this.long,
      geo: geo ?? this.geo,
      instructions: instructions ?? this.instructions,
      onlineLink: onlineLink ?? this.onlineLink,
      city: city ?? this.city,
      country: country ?? this.country,
    );
  }

  EventLocationDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String?>? placeId,
    Wrapped<double?>? lat,
    Wrapped<double?>? long,
    Wrapped<GeoPointDto?>? geo,
    Wrapped<String?>? instructions,
    Wrapped<String?>? onlineLink,
    Wrapped<String?>? city,
    Wrapped<String?>? country,
  }) {
    return EventLocationDto(
      address: (address != null ? address.value : this.address),
      placeId: (placeId != null ? placeId.value : this.placeId),
      lat: (lat != null ? lat.value : this.lat),
      long: (long != null ? long.value : this.long),
      geo: (geo != null ? geo.value : this.geo),
      instructions: (instructions != null
          ? instructions.value
          : this.instructions),
      onlineLink: (onlineLink != null ? onlineLink.value : this.onlineLink),
      city: (city != null ? city.value : this.city),
      country: (country != null ? country.value : this.country),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RegistrationDetailsDto {
  const RegistrationDetailsDto({
    required this.visibility,
    required this.maxLimit,
    required this.userLimit,
    required this.requireKYC,
    required this.requireName,
    required this.requireEmail,
    required this.requirePhoneNumber,
    required this.isPublished,
    required this.hasSideEvents,
    required this.hasWaitlist,
    required this.showGuestCount,
    required this.refundable,
    required this.nameWithNumber,
    required this.botProtection,
    this.acceptCrypto,
    this.soldCount,
    this.hasCustomQuestions,
    this.emailSender,
  });

  factory RegistrationDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$RegistrationDetailsDtoFromJson(json);

  static const toJsonFactory = _$RegistrationDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$RegistrationDetailsDtoToJson(this);

  @JsonKey(
    name: 'visibility',
    toJson: visibilityToJson,
    fromJson: visibilityFromJson,
  )
  final enums.Visibility visibility;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'requireKYC')
  final bool requireKYC;
  @JsonKey(name: 'requireName')
  final bool requireName;
  @JsonKey(name: 'requireEmail')
  final bool requireEmail;
  @JsonKey(name: 'requirePhoneNumber')
  final bool requirePhoneNumber;
  @JsonKey(name: 'isPublished')
  final bool isPublished;
  @JsonKey(name: 'hasSideEvents')
  final bool hasSideEvents;
  @JsonKey(name: 'hasWaitlist')
  final bool hasWaitlist;
  @JsonKey(name: 'showGuestCount')
  final bool showGuestCount;
  @JsonKey(name: 'refundable')
  final bool refundable;
  @JsonKey(name: 'nameWithNumber')
  final bool nameWithNumber;
  @JsonKey(name: 'botProtection')
  final bool botProtection;
  @JsonKey(name: 'acceptCrypto')
  final bool? acceptCrypto;
  @JsonKey(name: 'soldCount')
  final int? soldCount;
  @JsonKey(name: 'hasCustomQuestions')
  final bool? hasCustomQuestions;
  @JsonKey(name: 'emailSender')
  final String? emailSender;
  static const fromJsonFactory = _$RegistrationDetailsDtoFromJson;
}

extension $RegistrationDetailsDtoExtension on RegistrationDetailsDto {
  RegistrationDetailsDto copyWith({
    enums.Visibility? visibility,
    int? maxLimit,
    int? userLimit,
    bool? requireKYC,
    bool? requireName,
    bool? requireEmail,
    bool? requirePhoneNumber,
    bool? isPublished,
    bool? hasSideEvents,
    bool? hasWaitlist,
    bool? showGuestCount,
    bool? refundable,
    bool? nameWithNumber,
    bool? botProtection,
    bool? acceptCrypto,
    int? soldCount,
    bool? hasCustomQuestions,
    String? emailSender,
  }) {
    return RegistrationDetailsDto(
      visibility: visibility ?? this.visibility,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      requireKYC: requireKYC ?? this.requireKYC,
      requireName: requireName ?? this.requireName,
      requireEmail: requireEmail ?? this.requireEmail,
      requirePhoneNumber: requirePhoneNumber ?? this.requirePhoneNumber,
      isPublished: isPublished ?? this.isPublished,
      hasSideEvents: hasSideEvents ?? this.hasSideEvents,
      hasWaitlist: hasWaitlist ?? this.hasWaitlist,
      showGuestCount: showGuestCount ?? this.showGuestCount,
      refundable: refundable ?? this.refundable,
      nameWithNumber: nameWithNumber ?? this.nameWithNumber,
      botProtection: botProtection ?? this.botProtection,
      acceptCrypto: acceptCrypto ?? this.acceptCrypto,
      soldCount: soldCount ?? this.soldCount,
      hasCustomQuestions: hasCustomQuestions ?? this.hasCustomQuestions,
      emailSender: emailSender ?? this.emailSender,
    );
  }

  RegistrationDetailsDto copyWithWrapped({
    Wrapped<enums.Visibility>? visibility,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? requireKYC,
    Wrapped<bool>? requireName,
    Wrapped<bool>? requireEmail,
    Wrapped<bool>? requirePhoneNumber,
    Wrapped<bool>? isPublished,
    Wrapped<bool>? hasSideEvents,
    Wrapped<bool>? hasWaitlist,
    Wrapped<bool>? showGuestCount,
    Wrapped<bool>? refundable,
    Wrapped<bool>? nameWithNumber,
    Wrapped<bool>? botProtection,
    Wrapped<bool?>? acceptCrypto,
    Wrapped<int?>? soldCount,
    Wrapped<bool?>? hasCustomQuestions,
    Wrapped<String?>? emailSender,
  }) {
    return RegistrationDetailsDto(
      visibility: (visibility != null ? visibility.value : this.visibility),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      requireKYC: (requireKYC != null ? requireKYC.value : this.requireKYC),
      requireName: (requireName != null ? requireName.value : this.requireName),
      requireEmail: (requireEmail != null
          ? requireEmail.value
          : this.requireEmail),
      requirePhoneNumber: (requirePhoneNumber != null
          ? requirePhoneNumber.value
          : this.requirePhoneNumber),
      isPublished: (isPublished != null ? isPublished.value : this.isPublished),
      hasSideEvents: (hasSideEvents != null
          ? hasSideEvents.value
          : this.hasSideEvents),
      hasWaitlist: (hasWaitlist != null ? hasWaitlist.value : this.hasWaitlist),
      showGuestCount: (showGuestCount != null
          ? showGuestCount.value
          : this.showGuestCount),
      refundable: (refundable != null ? refundable.value : this.refundable),
      nameWithNumber: (nameWithNumber != null
          ? nameWithNumber.value
          : this.nameWithNumber),
      botProtection: (botProtection != null
          ? botProtection.value
          : this.botProtection),
      acceptCrypto: (acceptCrypto != null
          ? acceptCrypto.value
          : this.acceptCrypto),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      hasCustomQuestions: (hasCustomQuestions != null
          ? hasCustomQuestions.value
          : this.hasCustomQuestions),
      emailSender: (emailSender != null ? emailSender.value : this.emailSender),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PremiumType {
  const PremiumType({required this.searchable});

  factory PremiumType.fromJson(Map<String, dynamic> json) =>
      _$PremiumTypeFromJson(json);

  static const toJsonFactory = _$PremiumTypeToJson;
  Map<String, dynamic> toJson() => _$PremiumTypeToJson(this);

  @JsonKey(name: 'searchable')
  final bool searchable;
  static const fromJsonFactory = _$PremiumTypeFromJson;
}

extension $PremiumTypeExtension on PremiumType {
  PremiumType copyWith({bool? searchable}) {
    return PremiumType(searchable: searchable ?? this.searchable);
  }

  PremiumType copyWithWrapped({Wrapped<bool>? searchable}) {
    return PremiumType(
      searchable: (searchable != null ? searchable.value : this.searchable),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventSeoDto {
  const EventSeoDto({this.description, this.tags, this.alternativeTitle});

  factory EventSeoDto.fromJson(Map<String, dynamic> json) =>
      _$EventSeoDtoFromJson(json);

  static const toJsonFactory = _$EventSeoDtoToJson;
  Map<String, dynamic> toJson() => _$EventSeoDtoToJson(this);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'tags', defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'alternativeTitle')
  final String? alternativeTitle;
  static const fromJsonFactory = _$EventSeoDtoFromJson;
}

extension $EventSeoDtoExtension on EventSeoDto {
  EventSeoDto copyWith({
    String? description,
    List<String>? tags,
    String? alternativeTitle,
  }) {
    return EventSeoDto(
      description: description ?? this.description,
      tags: tags ?? this.tags,
      alternativeTitle: alternativeTitle ?? this.alternativeTitle,
    );
  }

  EventSeoDto copyWithWrapped({
    Wrapped<String?>? description,
    Wrapped<List<String>?>? tags,
    Wrapped<String?>? alternativeTitle,
  }) {
    return EventSeoDto(
      description: (description != null ? description.value : this.description),
      tags: (tags != null ? tags.value : this.tags),
      alternativeTitle: (alternativeTitle != null
          ? alternativeTitle.value
          : this.alternativeTitle),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleDoc {
  const EventUserRoleDoc({
    required this.dataType,
    this.eventId,
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.createdAt,
    this.endTime,
    this.id,
    this.status,
    this.pk,
    this.ts,
  });

  factory EventUserRoleDoc.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleDocFromJson(json);

  static const toJsonFactory = _$EventUserRoleDocToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'createdAt')
  final int? createdAt;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
    name: 'status',
    toJson: roleStatusNullableToJson,
    fromJson: roleStatusNullableFromJson,
  )
  final enums.RoleStatus? status;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  static const fromJsonFactory = _$EventUserRoleDocFromJson;
}

extension $EventUserRoleDocExtension on EventUserRoleDoc {
  EventUserRoleDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? createdAt,
    int? endTime,
    String? id,
    enums.RoleStatus? status,
    String? pk,
    int? ts,
  }) {
    return EventUserRoleDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      createdAt: createdAt ?? this.createdAt,
      endTime: endTime ?? this.endTime,
      id: id ?? this.id,
      status: status ?? this.status,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventUserRoleDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String?>? eventId,
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? createdAt,
    Wrapped<int?>? endTime,
    Wrapped<String?>? id,
    Wrapped<enums.RoleStatus?>? status,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
  }) {
    return EventUserRoleDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      endTime: (endTime != null ? endTime.value : this.endTime),
      id: (id != null ? id.value : this.id),
      status: (status != null ? status.value : this.status),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfileSummary {
  const EventGuestProfileSummary({
    required this.address,
    required this.profile,
    this.name,
    this.herotag,
  });

  factory EventGuestProfileSummary.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileSummaryFromJson(json);

  static const toJsonFactory = _$EventGuestProfileSummaryToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileSummaryToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'herotag')
  final String? herotag;
  static const fromJsonFactory = _$EventGuestProfileSummaryFromJson;
}

extension $EventGuestProfileSummaryExtension on EventGuestProfileSummary {
  EventGuestProfileSummary copyWith({
    String? address,
    String? profile,
    String? name,
    String? herotag,
  }) {
    return EventGuestProfileSummary(
      address: address ?? this.address,
      profile: profile ?? this.profile,
      name: name ?? this.name,
      herotag: herotag ?? this.herotag,
    );
  }

  EventGuestProfileSummary copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? profile,
    Wrapped<String?>? name,
    Wrapped<String?>? herotag,
  }) {
    return EventGuestProfileSummary(
      address: (address != null ? address.value : this.address),
      profile: (profile != null ? profile.value : this.profile),
      name: (name != null ? name.value : this.name),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestSummary {
  const EventGuestSummary({required this.count, required this.guests});

  factory EventGuestSummary.fromJson(Map<String, dynamic> json) =>
      _$EventGuestSummaryFromJson(json);

  static const toJsonFactory = _$EventGuestSummaryToJson;
  Map<String, dynamic> toJson() => _$EventGuestSummaryToJson(this);

  @JsonKey(name: 'count')
  final int count;
  @JsonKey(name: 'guests', defaultValue: <EventGuestProfileSummary>[])
  final List<EventGuestProfileSummary> guests;
  static const fromJsonFactory = _$EventGuestSummaryFromJson;
}

extension $EventGuestSummaryExtension on EventGuestSummary {
  EventGuestSummary copyWith({
    int? count,
    List<EventGuestProfileSummary>? guests,
  }) {
    return EventGuestSummary(
      count: count ?? this.count,
      guests: guests ?? this.guests,
    );
  }

  EventGuestSummary copyWithWrapped({
    Wrapped<int>? count,
    Wrapped<List<EventGuestProfileSummary>>? guests,
  }) {
    return EventGuestSummary(
      count: (count != null ? count.value : this.count),
      guests: (guests != null ? guests.value : this.guests),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStartPrice {
  const EventStartPrice({required this.price, required this.currency});

  factory EventStartPrice.fromJson(Map<String, dynamic> json) =>
      _$EventStartPriceFromJson(json);

  static const toJsonFactory = _$EventStartPriceToJson;
  Map<String, dynamic> toJson() => _$EventStartPriceToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'currency')
  final String currency;
  static const fromJsonFactory = _$EventStartPriceFromJson;
}

extension $EventStartPriceExtension on EventStartPrice {
  EventStartPrice copyWith({double? price, String? currency}) {
    return EventStartPrice(
      price: price ?? this.price,
      currency: currency ?? this.currency,
    );
  }

  EventStartPrice copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<String>? currency,
  }) {
    return EventStartPrice(
      price: (price != null ? price.value : this.price),
      currency: (currency != null ? currency.value : this.currency),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestRegistration {
  const EventGuestRegistration({this.email, this.name, this.phone});

  factory EventGuestRegistration.fromJson(Map<String, dynamic> json) =>
      _$EventGuestRegistrationFromJson(json);

  static const toJsonFactory = _$EventGuestRegistrationToJson;
  Map<String, dynamic> toJson() => _$EventGuestRegistrationToJson(this);

  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  static const fromJsonFactory = _$EventGuestRegistrationFromJson;
}

extension $EventGuestRegistrationExtension on EventGuestRegistration {
  EventGuestRegistration copyWith({
    String? email,
    String? name,
    String? phone,
  }) {
    return EventGuestRegistration(
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
    );
  }

  EventGuestRegistration copyWithWrapped({
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
  }) {
    return EventGuestRegistration(
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestBilling {
  const EventGuestBilling({
    required this.isCompany,
    required this.name,
    this.companyRegistrationNumber,
    this.companyVatNumber,
    required this.email,
    required this.country,
    required this.city,
    required this.address1,
    this.address2,
    this.postalCode,
  });

  factory EventGuestBilling.fromJson(Map<String, dynamic> json) =>
      _$EventGuestBillingFromJson(json);

  static const toJsonFactory = _$EventGuestBillingToJson;
  Map<String, dynamic> toJson() => _$EventGuestBillingToJson(this);

  @JsonKey(name: 'isCompany')
  final bool isCompany;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'companyRegistrationNumber')
  final String? companyRegistrationNumber;
  @JsonKey(name: 'companyVatNumber')
  final String? companyVatNumber;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'address1')
  final String address1;
  @JsonKey(name: 'address2')
  final String? address2;
  @JsonKey(name: 'postalCode')
  final String? postalCode;
  static const fromJsonFactory = _$EventGuestBillingFromJson;
}

extension $EventGuestBillingExtension on EventGuestBilling {
  EventGuestBilling copyWith({
    bool? isCompany,
    String? name,
    String? companyRegistrationNumber,
    String? companyVatNumber,
    String? email,
    String? country,
    String? city,
    String? address1,
    String? address2,
    String? postalCode,
  }) {
    return EventGuestBilling(
      isCompany: isCompany ?? this.isCompany,
      name: name ?? this.name,
      companyRegistrationNumber:
          companyRegistrationNumber ?? this.companyRegistrationNumber,
      companyVatNumber: companyVatNumber ?? this.companyVatNumber,
      email: email ?? this.email,
      country: country ?? this.country,
      city: city ?? this.city,
      address1: address1 ?? this.address1,
      address2: address2 ?? this.address2,
      postalCode: postalCode ?? this.postalCode,
    );
  }

  EventGuestBilling copyWithWrapped({
    Wrapped<bool>? isCompany,
    Wrapped<String>? name,
    Wrapped<String?>? companyRegistrationNumber,
    Wrapped<String?>? companyVatNumber,
    Wrapped<String>? email,
    Wrapped<String>? country,
    Wrapped<String>? city,
    Wrapped<String>? address1,
    Wrapped<String?>? address2,
    Wrapped<String?>? postalCode,
  }) {
    return EventGuestBilling(
      isCompany: (isCompany != null ? isCompany.value : this.isCompany),
      name: (name != null ? name.value : this.name),
      companyRegistrationNumber: (companyRegistrationNumber != null
          ? companyRegistrationNumber.value
          : this.companyRegistrationNumber),
      companyVatNumber: (companyVatNumber != null
          ? companyVatNumber.value
          : this.companyVatNumber),
      email: (email != null ? email.value : this.email),
      country: (country != null ? country.value : this.country),
      city: (city != null ? city.value : this.city),
      address1: (address1 != null ? address1.value : this.address1),
      address2: (address2 != null ? address2.value : this.address2),
      postalCode: (postalCode != null ? postalCode.value : this.postalCode),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfile {
  const EventGuestProfile({
    required this.dataType,
    required this.wallet,
    required this.eventId,
    required this.ticket,
    required this.questionnaireFilled,
    this.registration,
    this.billing,
    required this.status,
    required this.createdAt,
    this.invitationId,
    this.metadata,
    this.id,
    this.pk,
    this.ts,
    this.ttl,
    required this.profile,
    required this.herotag,
  });

  factory EventGuestProfile.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileFromJson(json);

  static const toJsonFactory = _$EventGuestProfileToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventGuest);

  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticket')
  final Map<String, dynamic> ticket;
  @JsonKey(name: 'questionnaireFilled')
  final bool questionnaireFilled;
  @JsonKey(name: 'registration')
  final EventGuestRegistration? registration;
  @JsonKey(name: 'billing')
  final EventGuestBilling? billing;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusToJson,
    fromJson: eventGuestStatusFromJson,
  )
  final enums.EventGuestStatus status;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'invitationId')
  final String? invitationId;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'ttl')
  final int? ttl;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'herotag')
  final String herotag;
  static const fromJsonFactory = _$EventGuestProfileFromJson;
}

extension $EventGuestProfileExtension on EventGuestProfile {
  EventGuestProfile copyWith({
    enums.TicketingDataType? dataType,
    String? wallet,
    String? eventId,
    Map<String, dynamic>? ticket,
    bool? questionnaireFilled,
    EventGuestRegistration? registration,
    EventGuestBilling? billing,
    enums.EventGuestStatus? status,
    int? createdAt,
    String? invitationId,
    Object? metadata,
    String? id,
    String? pk,
    int? ts,
    int? ttl,
    String? profile,
    String? herotag,
  }) {
    return EventGuestProfile(
      dataType: dataType ?? this.dataType,
      wallet: wallet ?? this.wallet,
      eventId: eventId ?? this.eventId,
      ticket: ticket ?? this.ticket,
      questionnaireFilled: questionnaireFilled ?? this.questionnaireFilled,
      registration: registration ?? this.registration,
      billing: billing ?? this.billing,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      invitationId: invitationId ?? this.invitationId,
      metadata: metadata ?? this.metadata,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      ttl: ttl ?? this.ttl,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventGuestProfile copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? wallet,
    Wrapped<String>? eventId,
    Wrapped<Map<String, dynamic>>? ticket,
    Wrapped<bool>? questionnaireFilled,
    Wrapped<EventGuestRegistration?>? registration,
    Wrapped<EventGuestBilling?>? billing,
    Wrapped<enums.EventGuestStatus>? status,
    Wrapped<int>? createdAt,
    Wrapped<String?>? invitationId,
    Wrapped<Object?>? metadata,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<int?>? ttl,
    Wrapped<String>? profile,
    Wrapped<String>? herotag,
  }) {
    return EventGuestProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      wallet: (wallet != null ? wallet.value : this.wallet),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticket: (ticket != null ? ticket.value : this.ticket),
      questionnaireFilled: (questionnaireFilled != null
          ? questionnaireFilled.value
          : this.questionnaireFilled),
      registration: (registration != null
          ? registration.value
          : this.registration),
      billing: (billing != null ? billing.value : this.billing),
      status: (status != null ? status.value : this.status),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      invitationId: (invitationId != null
          ? invitationId.value
          : this.invitationId),
      metadata: (metadata != null ? metadata.value : this.metadata),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      ttl: (ttl != null ? ttl.value : this.ttl),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfile {
  const EventProfile({
    required this.dataType,
    required this.createdAt,
    required this.creatorAddress,
    required this.title,
    required this.startTime,
    required this.endTime,
    this.descriptionUrl,
    required this.location,
    required this.isVirtualEvent,
    this.slug,
    required this.profile,
    this.profileBlurhash,
    required this.category,
    this.subCategory,
    this.background,
    required this.registration,
    required this.premium,
    this.contractAddress,
    this.collection,
    this.seo,
    required this.id,
    this.eventPermissions,
    this.pk,
    this.ts,
    required this.creatorProfile,
    this.guestSummary,
    this.startsFrom,
    this.guestProfile,
    this.coHosts,
  });

  factory EventProfile.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFromJson(json);

  static const toJsonFactory = _$EventProfileToJson;
  Map<String, dynamic> toJson() => _$EventProfileToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventProfile);

  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'creatorAddress')
  final String creatorAddress;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'descriptionUrl')
  final String? descriptionUrl;
  @JsonKey(name: 'location')
  final EventLocationDto location;
  @JsonKey(name: 'isVirtualEvent')
  final bool isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'profileBlurhash')
  final String? profileBlurhash;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryToJson,
    fromJson: eventCategoryFromJson,
  )
  final enums.EventCategory category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'background')
  final String? background;
  @JsonKey(name: 'registration')
  final RegistrationDetailsDto registration;
  @JsonKey(name: 'premium')
  final PremiumType premium;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'collection')
  final String? collection;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventPermissions')
  final EventUserRoleDoc? eventPermissions;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'creatorProfile')
  final CreatorProfileDoc creatorProfile;
  @JsonKey(name: 'guestSummary')
  final EventGuestSummary? guestSummary;
  @JsonKey(name: 'startsFrom')
  final EventStartPrice? startsFrom;
  @JsonKey(name: 'guestProfile')
  final EventGuestProfile? guestProfile;
  @JsonKey(name: 'coHosts', defaultValue: <OwnerDto>[])
  final List<OwnerDto>? coHosts;
  static const fromJsonFactory = _$EventProfileFromJson;
}

extension $EventProfileExtension on EventProfile {
  EventProfile copyWith({
    enums.TicketingDataType? dataType,
    int? createdAt,
    String? creatorAddress,
    String? title,
    int? startTime,
    int? endTime,
    String? descriptionUrl,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    String? profile,
    String? profileBlurhash,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    String? background,
    RegistrationDetailsDto? registration,
    PremiumType? premium,
    String? contractAddress,
    String? collection,
    EventSeoDto? seo,
    String? id,
    EventUserRoleDoc? eventPermissions,
    String? pk,
    int? ts,
    CreatorProfileDoc? creatorProfile,
    EventGuestSummary? guestSummary,
    EventStartPrice? startsFrom,
    EventGuestProfile? guestProfile,
    List<OwnerDto>? coHosts,
  }) {
    return EventProfile(
      dataType: dataType ?? this.dataType,
      createdAt: createdAt ?? this.createdAt,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      descriptionUrl: descriptionUrl ?? this.descriptionUrl,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      profile: profile ?? this.profile,
      profileBlurhash: profileBlurhash ?? this.profileBlurhash,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      background: background ?? this.background,
      registration: registration ?? this.registration,
      premium: premium ?? this.premium,
      contractAddress: contractAddress ?? this.contractAddress,
      collection: collection ?? this.collection,
      seo: seo ?? this.seo,
      id: id ?? this.id,
      eventPermissions: eventPermissions ?? this.eventPermissions,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      creatorProfile: creatorProfile ?? this.creatorProfile,
      guestSummary: guestSummary ?? this.guestSummary,
      startsFrom: startsFrom ?? this.startsFrom,
      guestProfile: guestProfile ?? this.guestProfile,
      coHosts: coHosts ?? this.coHosts,
    );
  }

  EventProfile copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<int>? createdAt,
    Wrapped<String>? creatorAddress,
    Wrapped<String>? title,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<String?>? descriptionUrl,
    Wrapped<EventLocationDto>? location,
    Wrapped<bool>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<String>? profile,
    Wrapped<String?>? profileBlurhash,
    Wrapped<enums.EventCategory>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<String?>? background,
    Wrapped<RegistrationDetailsDto>? registration,
    Wrapped<PremiumType>? premium,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? collection,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<String>? id,
    Wrapped<EventUserRoleDoc?>? eventPermissions,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<CreatorProfileDoc>? creatorProfile,
    Wrapped<EventGuestSummary?>? guestSummary,
    Wrapped<EventStartPrice?>? startsFrom,
    Wrapped<EventGuestProfile?>? guestProfile,
    Wrapped<List<OwnerDto>?>? coHosts,
  }) {
    return EventProfile(
      dataType: (dataType != null ? dataType.value : this.dataType),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      descriptionUrl: (descriptionUrl != null
          ? descriptionUrl.value
          : this.descriptionUrl),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      profile: (profile != null ? profile.value : this.profile),
      profileBlurhash: (profileBlurhash != null
          ? profileBlurhash.value
          : this.profileBlurhash),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      background: (background != null ? background.value : this.background),
      registration: (registration != null
          ? registration.value
          : this.registration),
      premium: (premium != null ? premium.value : this.premium),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      collection: (collection != null ? collection.value : this.collection),
      seo: (seo != null ? seo.value : this.seo),
      id: (id != null ? id.value : this.id),
      eventPermissions: (eventPermissions != null
          ? eventPermissions.value
          : this.eventPermissions),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      guestSummary: (guestSummary != null
          ? guestSummary.value
          : this.guestSummary),
      startsFrom: (startsFrom != null ? startsFrom.value : this.startsFrom),
      guestProfile: (guestProfile != null
          ? guestProfile.value
          : this.guestProfile),
      coHosts: (coHosts != null ? coHosts.value : this.coHosts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorDetailsDto {
  const CreatorDetailsDto({
    required this.dataType,
    required this.address,
    required this.name,
    required this.creatorTag,
    this.contractAddress,
    this.ticketingContractAddress,
    required this.profile,
    required this.banner,
    this.joinedDate,
    this.description,
    required this.socials,
    this.id,
    this.ts,
    this.listing,
    this.events,
  });

  factory CreatorDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorDetailsDtoFromJson(json);

  static const toJsonFactory = _$CreatorDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorDetailsDtoToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: creatorDetailsDtoDataTypeToJson,
    fromJson: creatorDetailsDtoDataTypeFromJson,
  )
  final enums.CreatorDetailsDtoDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'contractAddress')
  final String? contractAddress;
  @JsonKey(name: 'ticketingContractAddress')
  final String? ticketingContractAddress;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'joinedDate')
  final double? joinedDate;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto socials;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: '_ts')
  final double? ts;
  @JsonKey(name: 'listing', defaultValue: <MintingListingDto>[])
  final List<MintingListingDto>? listing;
  @JsonKey(name: 'events', defaultValue: <EventProfile>[])
  final List<EventProfile>? events;
  static const fromJsonFactory = _$CreatorDetailsDtoFromJson;
}

extension $CreatorDetailsDtoExtension on CreatorDetailsDto {
  CreatorDetailsDto copyWith({
    enums.CreatorDetailsDtoDataType? dataType,
    String? address,
    String? name,
    String? creatorTag,
    String? contractAddress,
    String? ticketingContractAddress,
    String? profile,
    String? banner,
    double? joinedDate,
    String? description,
    SocialsDto? socials,
    String? id,
    double? ts,
    List<MintingListingDto>? listing,
    List<EventProfile>? events,
  }) {
    return CreatorDetailsDto(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      contractAddress: contractAddress ?? this.contractAddress,
      ticketingContractAddress:
          ticketingContractAddress ?? this.ticketingContractAddress,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      joinedDate: joinedDate ?? this.joinedDate,
      description: description ?? this.description,
      socials: socials ?? this.socials,
      id: id ?? this.id,
      ts: ts ?? this.ts,
      listing: listing ?? this.listing,
      events: events ?? this.events,
    );
  }

  CreatorDetailsDto copyWithWrapped({
    Wrapped<enums.CreatorDetailsDtoDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<String?>? contractAddress,
    Wrapped<String?>? ticketingContractAddress,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<double?>? joinedDate,
    Wrapped<String?>? description,
    Wrapped<SocialsDto>? socials,
    Wrapped<String?>? id,
    Wrapped<double?>? ts,
    Wrapped<List<MintingListingDto>?>? listing,
    Wrapped<List<EventProfile>?>? events,
  }) {
    return CreatorDetailsDto(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      ticketingContractAddress: (ticketingContractAddress != null
          ? ticketingContractAddress.value
          : this.ticketingContractAddress),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
      id: (id != null ? id.value : this.id),
      ts: (ts != null ? ts.value : this.ts),
      listing: (listing != null ? listing.value : this.listing),
      events: (events != null ? events.value : this.events),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorProfileEditDto {
  const CreatorProfileEditDto({this.name, this.description, this.socials});

  factory CreatorProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorProfileEditDtoFromJson(json);

  static const toJsonFactory = _$CreatorProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'socials')
  final SocialsDto? socials;
  static const fromJsonFactory = _$CreatorProfileEditDtoFromJson;
}

extension $CreatorProfileEditDtoExtension on CreatorProfileEditDto {
  CreatorProfileEditDto copyWith({
    String? name,
    String? description,
    SocialsDto? socials,
  }) {
    return CreatorProfileEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
      socials: socials ?? this.socials,
    );
  }

  CreatorProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<SocialsDto?>? socials,
  }) {
    return CreatorProfileEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      socials: (socials != null ? socials.value : this.socials),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShareholderDto {
  const ShareholderDto({required this.address, required this.share});

  factory ShareholderDto.fromJson(Map<String, dynamic> json) =>
      _$ShareholderDtoFromJson(json);

  static const toJsonFactory = _$ShareholderDtoToJson;
  Map<String, dynamic> toJson() => _$ShareholderDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'share')
  final double share;
  static const fromJsonFactory = _$ShareholderDtoFromJson;
}

extension $ShareholderDtoExtension on ShareholderDto {
  ShareholderDto copyWith({String? address, double? share}) {
    return ShareholderDto(
      address: address ?? this.address,
      share: share ?? this.share,
    );
  }

  ShareholderDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<double>? share,
  }) {
    return ShareholderDto(
      address: (address != null ? address.value : this.address),
      share: (share != null ? share.value : this.share),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserWallet {
  const Web2UserWallet({
    required this.type,
    required this.address,
    this.index,
    this.signature,
    required this.chain,
    required this.walletClientType,
    this.recoveryMethod,
    this.id,
  });

  factory Web2UserWallet.fromJson(Map<String, dynamic> json) =>
      _$Web2UserWalletFromJson(json);

  static const toJsonFactory = _$Web2UserWalletToJson;
  Map<String, dynamic> toJson() => _$Web2UserWalletToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'index')
  final double? index;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'chain')
  final String chain;
  @JsonKey(
    name: 'walletClientType',
    toJson: walletClientTypeToJson,
    fromJson: walletClientTypeFromJson,
  )
  final enums.WalletClientType walletClientType;
  @JsonKey(name: 'recoveryMethod')
  final String? recoveryMethod;
  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$Web2UserWalletFromJson;
}

extension $Web2UserWalletExtension on Web2UserWallet {
  Web2UserWallet copyWith({
    enums.LinkedAccountType? type,
    String? address,
    double? index,
    String? signature,
    String? chain,
    enums.WalletClientType? walletClientType,
    String? recoveryMethod,
    String? id,
  }) {
    return Web2UserWallet(
      type: type ?? this.type,
      address: address ?? this.address,
      index: index ?? this.index,
      signature: signature ?? this.signature,
      chain: chain ?? this.chain,
      walletClientType: walletClientType ?? this.walletClientType,
      recoveryMethod: recoveryMethod ?? this.recoveryMethod,
      id: id ?? this.id,
    );
  }

  Web2UserWallet copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? address,
    Wrapped<double?>? index,
    Wrapped<String?>? signature,
    Wrapped<String>? chain,
    Wrapped<enums.WalletClientType>? walletClientType,
    Wrapped<String?>? recoveryMethod,
    Wrapped<String?>? id,
  }) {
    return Web2UserWallet(
      type: (type != null ? type.value : this.type),
      address: (address != null ? address.value : this.address),
      index: (index != null ? index.value : this.index),
      signature: (signature != null ? signature.value : this.signature),
      chain: (chain != null ? chain.value : this.chain),
      walletClientType: (walletClientType != null
          ? walletClientType.value
          : this.walletClientType),
      recoveryMethod: (recoveryMethod != null
          ? recoveryMethod.value
          : this.recoveryMethod),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserAccount {
  const Web2UserAccount({
    required this.type,
    required this.subject,
    this.name,
    this.profilePicture,
    this.email,
    this.username,
  });

  factory Web2UserAccount.fromJson(Map<String, dynamic> json) =>
      _$Web2UserAccountFromJson(json);

  static const toJsonFactory = _$Web2UserAccountToJson;
  Map<String, dynamic> toJson() => _$Web2UserAccountToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'subject')
  final String subject;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'profilePicture')
  final String? profilePicture;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'username')
  final String? username;
  static const fromJsonFactory = _$Web2UserAccountFromJson;
}

extension $Web2UserAccountExtension on Web2UserAccount {
  Web2UserAccount copyWith({
    enums.LinkedAccountType? type,
    String? subject,
    String? name,
    String? profilePicture,
    String? email,
    String? username,
  }) {
    return Web2UserAccount(
      type: type ?? this.type,
      subject: subject ?? this.subject,
      name: name ?? this.name,
      profilePicture: profilePicture ?? this.profilePicture,
      email: email ?? this.email,
      username: username ?? this.username,
    );
  }

  Web2UserAccount copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? subject,
    Wrapped<String?>? name,
    Wrapped<String?>? profilePicture,
    Wrapped<String?>? email,
    Wrapped<String?>? username,
  }) {
    return Web2UserAccount(
      type: (type != null ? type.value : this.type),
      subject: (subject != null ? subject.value : this.subject),
      name: (name != null ? name.value : this.name),
      profilePicture: (profilePicture != null
          ? profilePicture.value
          : this.profilePicture),
      email: (email != null ? email.value : this.email),
      username: (username != null ? username.value : this.username),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserDoc {
  const Web2UserDoc({
    required this.createdOn,
    required this.id,
    required this.linkedAccounts,
    required this.shards,
    required this.hasNativeWallet,
    this.wallet,
    required this.salt,
    this.google,
    this.apple,
    required this.pk,
    this.ts,
  });

  factory Web2UserDoc.fromJson(Map<String, dynamic> json) =>
      _$Web2UserDocFromJson(json);

  static const toJsonFactory = _$Web2UserDocToJson;
  Map<String, dynamic> toJson() => _$Web2UserDocToJson(this);

  @JsonKey(name: 'createdOn')
  final double createdOn;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'linkedAccounts', defaultValue: <Object>[])
  final List<Object> linkedAccounts;
  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  @JsonKey(name: 'hasNativeWallet')
  final Object hasNativeWallet;
  @JsonKey(name: 'wallet')
  final Web2UserWallet? wallet;
  @JsonKey(name: 'salt')
  final String salt;
  @JsonKey(name: 'google')
  final Web2UserAccount? google;
  @JsonKey(name: 'apple')
  final Web2UserAccount? apple;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$Web2UserDocFromJson;
}

extension $Web2UserDocExtension on Web2UserDoc {
  Web2UserDoc copyWith({
    double? createdOn,
    String? id,
    List<Object>? linkedAccounts,
    List<String>? shards,
    Object? hasNativeWallet,
    Web2UserWallet? wallet,
    String? salt,
    Web2UserAccount? google,
    Web2UserAccount? apple,
    String? pk,
    double? ts,
  }) {
    return Web2UserDoc(
      createdOn: createdOn ?? this.createdOn,
      id: id ?? this.id,
      linkedAccounts: linkedAccounts ?? this.linkedAccounts,
      shards: shards ?? this.shards,
      hasNativeWallet: hasNativeWallet ?? this.hasNativeWallet,
      wallet: wallet ?? this.wallet,
      salt: salt ?? this.salt,
      google: google ?? this.google,
      apple: apple ?? this.apple,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  Web2UserDoc copyWithWrapped({
    Wrapped<double>? createdOn,
    Wrapped<String>? id,
    Wrapped<List<Object>>? linkedAccounts,
    Wrapped<List<String>>? shards,
    Wrapped<Object>? hasNativeWallet,
    Wrapped<Web2UserWallet?>? wallet,
    Wrapped<String>? salt,
    Wrapped<Web2UserAccount?>? google,
    Wrapped<Web2UserAccount?>? apple,
    Wrapped<String>? pk,
    Wrapped<double?>? ts,
  }) {
    return Web2UserDoc(
      createdOn: (createdOn != null ? createdOn.value : this.createdOn),
      id: (id != null ? id.value : this.id),
      linkedAccounts: (linkedAccounts != null
          ? linkedAccounts.value
          : this.linkedAccounts),
      shards: (shards != null ? shards.value : this.shards),
      hasNativeWallet: (hasNativeWallet != null
          ? hasNativeWallet.value
          : this.hasNativeWallet),
      wallet: (wallet != null ? wallet.value : this.wallet),
      salt: (salt != null ? salt.value : this.salt),
      google: (google != null ? google.value : this.google),
      apple: (apple != null ? apple.value : this.apple),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SuccessWithMessageDto {
  const SuccessWithMessageDto({required this.success, required this.message});

  factory SuccessWithMessageDto.fromJson(Map<String, dynamic> json) =>
      _$SuccessWithMessageDtoFromJson(json);

  static const toJsonFactory = _$SuccessWithMessageDtoToJson;
  Map<String, dynamic> toJson() => _$SuccessWithMessageDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  static const fromJsonFactory = _$SuccessWithMessageDtoFromJson;
}

extension $SuccessWithMessageDtoExtension on SuccessWithMessageDto {
  SuccessWithMessageDto copyWith({bool? success, String? message}) {
    return SuccessWithMessageDto(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }

  SuccessWithMessageDto copyWithWrapped({
    Wrapped<bool>? success,
    Wrapped<String>? message,
  }) {
    return SuccessWithMessageDto(
      success: (success != null ? success.value : this.success),
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2WalletDto {
  const Web2WalletDto({
    required this.type,
    required this.address,
    required this.chain,
    this.signature,
    this.authToken,
    required this.walletClientType,
    this.index,
    this.recoveryMethod,
  });

  factory Web2WalletDto.fromJson(Map<String, dynamic> json) =>
      _$Web2WalletDtoFromJson(json);

  static const toJsonFactory = _$Web2WalletDtoToJson;
  Map<String, dynamic> toJson() => _$Web2WalletDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: linkedAccountTypeToJson,
    fromJson: linkedAccountTypeFromJson,
  )
  final enums.LinkedAccountType type;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'chain')
  final String chain;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'authToken')
  final String? authToken;
  @JsonKey(
    name: 'walletClientType',
    toJson: walletClientTypeToJson,
    fromJson: walletClientTypeFromJson,
  )
  final enums.WalletClientType walletClientType;
  @JsonKey(name: 'index')
  final int? index;
  @JsonKey(name: 'recoveryMethod')
  final String? recoveryMethod;
  static const fromJsonFactory = _$Web2WalletDtoFromJson;
}

extension $Web2WalletDtoExtension on Web2WalletDto {
  Web2WalletDto copyWith({
    enums.LinkedAccountType? type,
    String? address,
    String? chain,
    String? signature,
    String? authToken,
    enums.WalletClientType? walletClientType,
    int? index,
    String? recoveryMethod,
  }) {
    return Web2WalletDto(
      type: type ?? this.type,
      address: address ?? this.address,
      chain: chain ?? this.chain,
      signature: signature ?? this.signature,
      authToken: authToken ?? this.authToken,
      walletClientType: walletClientType ?? this.walletClientType,
      index: index ?? this.index,
      recoveryMethod: recoveryMethod ?? this.recoveryMethod,
    );
  }

  Web2WalletDto copyWithWrapped({
    Wrapped<enums.LinkedAccountType>? type,
    Wrapped<String>? address,
    Wrapped<String>? chain,
    Wrapped<String?>? signature,
    Wrapped<String?>? authToken,
    Wrapped<enums.WalletClientType>? walletClientType,
    Wrapped<int?>? index,
    Wrapped<String?>? recoveryMethod,
  }) {
    return Web2WalletDto(
      type: (type != null ? type.value : this.type),
      address: (address != null ? address.value : this.address),
      chain: (chain != null ? chain.value : this.chain),
      signature: (signature != null ? signature.value : this.signature),
      authToken: (authToken != null ? authToken.value : this.authToken),
      walletClientType: (walletClientType != null
          ? walletClientType.value
          : this.walletClientType),
      index: (index != null ? index.value : this.index),
      recoveryMethod: (recoveryMethod != null
          ? recoveryMethod.value
          : this.recoveryMethod),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NativeWalletDto {
  const NativeWalletDto({
    required this.shards,
    required this.wallet,
    required this.isActive,
  });

  factory NativeWalletDto.fromJson(Map<String, dynamic> json) =>
      _$NativeWalletDtoFromJson(json);

  static const toJsonFactory = _$NativeWalletDtoToJson;
  Map<String, dynamic> toJson() => _$NativeWalletDtoToJson(this);

  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  @JsonKey(name: 'wallet')
  final Web2WalletDto wallet;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$NativeWalletDtoFromJson;
}

extension $NativeWalletDtoExtension on NativeWalletDto {
  NativeWalletDto copyWith({
    List<String>? shards,
    Web2WalletDto? wallet,
    bool? isActive,
  }) {
    return NativeWalletDto(
      shards: shards ?? this.shards,
      wallet: wallet ?? this.wallet,
      isActive: isActive ?? this.isActive,
    );
  }

  NativeWalletDto copyWithWrapped({
    Wrapped<List<String>>? shards,
    Wrapped<Web2WalletDto>? wallet,
    Wrapped<bool>? isActive,
  }) {
    return NativeWalletDto(
      shards: (shards != null ? shards.value : this.shards),
      wallet: (wallet != null ? wallet.value : this.wallet),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SwitchWalletDto {
  const SwitchWalletDto({required this.address});

  factory SwitchWalletDto.fromJson(Map<String, dynamic> json) =>
      _$SwitchWalletDtoFromJson(json);

  static const toJsonFactory = _$SwitchWalletDtoToJson;
  Map<String, dynamic> toJson() => _$SwitchWalletDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$SwitchWalletDtoFromJson;
}

extension $SwitchWalletDtoExtension on SwitchWalletDto {
  SwitchWalletDto copyWith({String? address}) {
    return SwitchWalletDto(address: address ?? this.address);
  }

  SwitchWalletDto copyWithWrapped({Wrapped<String>? address}) {
    return SwitchWalletDto(
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Web2UserShardsDto {
  const Web2UserShardsDto({required this.shards});

  factory Web2UserShardsDto.fromJson(Map<String, dynamic> json) =>
      _$Web2UserShardsDtoFromJson(json);

  static const toJsonFactory = _$Web2UserShardsDtoToJson;
  Map<String, dynamic> toJson() => _$Web2UserShardsDtoToJson(this);

  @JsonKey(name: 'shards', defaultValue: <String>[])
  final List<String> shards;
  static const fromJsonFactory = _$Web2UserShardsDtoFromJson;
}

extension $Web2UserShardsDtoExtension on Web2UserShardsDto {
  Web2UserShardsDto copyWith({List<String>? shards}) {
    return Web2UserShardsDto(shards: shards ?? this.shards);
  }

  Web2UserShardsDto copyWithWrapped({Wrapped<List<String>>? shards}) {
    return Web2UserShardsDto(
      shards: (shards != null ? shards.value : this.shards),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class XoxnoStakingReward {
  const XoxnoStakingReward({
    required this.tokenIdentifier,
    required this.tokenNonce,
    required this.rewardBalance,
    required this.shareRewardBalance,
    required this.rewardPerEpoch,
    this.rewardPerEpochShort,
    this.rewardPerDayPerNft,
    this.rewardBalanceShort,
    this.usdValue,
  });

  factory XoxnoStakingReward.fromJson(Map<String, dynamic> json) =>
      _$XoxnoStakingRewardFromJson(json);

  static const toJsonFactory = _$XoxnoStakingRewardToJson;
  Map<String, dynamic> toJson() => _$XoxnoStakingRewardToJson(this);

  @JsonKey(name: 'tokenIdentifier')
  final String tokenIdentifier;
  @JsonKey(name: 'tokenNonce')
  final double tokenNonce;
  @JsonKey(name: 'rewardBalance')
  final String rewardBalance;
  @JsonKey(name: 'shareRewardBalance')
  final String shareRewardBalance;
  @JsonKey(name: 'rewardPerEpoch')
  final String rewardPerEpoch;
  @JsonKey(name: 'rewardPerEpochShort')
  final double? rewardPerEpochShort;
  @JsonKey(name: 'rewardPerDayPerNft')
  final double? rewardPerDayPerNft;
  @JsonKey(name: 'rewardBalanceShort')
  final double? rewardBalanceShort;
  @JsonKey(name: 'usdValue')
  final double? usdValue;
  static const fromJsonFactory = _$XoxnoStakingRewardFromJson;
}

extension $XoxnoStakingRewardExtension on XoxnoStakingReward {
  XoxnoStakingReward copyWith({
    String? tokenIdentifier,
    double? tokenNonce,
    String? rewardBalance,
    String? shareRewardBalance,
    String? rewardPerEpoch,
    double? rewardPerEpochShort,
    double? rewardPerDayPerNft,
    double? rewardBalanceShort,
    double? usdValue,
  }) {
    return XoxnoStakingReward(
      tokenIdentifier: tokenIdentifier ?? this.tokenIdentifier,
      tokenNonce: tokenNonce ?? this.tokenNonce,
      rewardBalance: rewardBalance ?? this.rewardBalance,
      shareRewardBalance: shareRewardBalance ?? this.shareRewardBalance,
      rewardPerEpoch: rewardPerEpoch ?? this.rewardPerEpoch,
      rewardPerEpochShort: rewardPerEpochShort ?? this.rewardPerEpochShort,
      rewardPerDayPerNft: rewardPerDayPerNft ?? this.rewardPerDayPerNft,
      rewardBalanceShort: rewardBalanceShort ?? this.rewardBalanceShort,
      usdValue: usdValue ?? this.usdValue,
    );
  }

  XoxnoStakingReward copyWithWrapped({
    Wrapped<String>? tokenIdentifier,
    Wrapped<double>? tokenNonce,
    Wrapped<String>? rewardBalance,
    Wrapped<String>? shareRewardBalance,
    Wrapped<String>? rewardPerEpoch,
    Wrapped<double?>? rewardPerEpochShort,
    Wrapped<double?>? rewardPerDayPerNft,
    Wrapped<double?>? rewardBalanceShort,
    Wrapped<double?>? usdValue,
  }) {
    return XoxnoStakingReward(
      tokenIdentifier: (tokenIdentifier != null
          ? tokenIdentifier.value
          : this.tokenIdentifier),
      tokenNonce: (tokenNonce != null ? tokenNonce.value : this.tokenNonce),
      rewardBalance: (rewardBalance != null
          ? rewardBalance.value
          : this.rewardBalance),
      shareRewardBalance: (shareRewardBalance != null
          ? shareRewardBalance.value
          : this.shareRewardBalance),
      rewardPerEpoch: (rewardPerEpoch != null
          ? rewardPerEpoch.value
          : this.rewardPerEpoch),
      rewardPerEpochShort: (rewardPerEpochShort != null
          ? rewardPerEpochShort.value
          : this.rewardPerEpochShort),
      rewardPerDayPerNft: (rewardPerDayPerNft != null
          ? rewardPerDayPerNft.value
          : this.rewardPerDayPerNft),
      rewardBalanceShort: (rewardBalanceShort != null
          ? rewardBalanceShort.value
          : this.rewardBalanceShort),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingSummary {
  const StakingSummary({
    required this.poolId,
    required this.name,
    this.description,
    required this.stakingEnabled,
    required this.profile,
    required this.collection,
    required this.poolStakedCount,
    required this.userStakedCount,
    required this.delegatorCount,
    required this.rewardDuration,
    required this.poolReward,
    required this.userReward,
    required this.poolType,
    required this.issuingType,
    required this.unBoundPeriod,
    required this.hasUnboundPeriod,
    required this.userUnboundCount,
    required this.maxPoolLimit,
    required this.hasMaxWalletLimit,
    required this.maxWalletLimit,
    required this.startEpoch,
    required this.endEpoch,
    required this.owner,
    required this.currentEpoch,
    required this.isActive,
    required this.daysLeft,
    required this.cutFee,
    required this.percentageFilled,
  });

  factory StakingSummary.fromJson(Map<String, dynamic> json) =>
      _$StakingSummaryFromJson(json);

  static const toJsonFactory = _$StakingSummaryToJson;
  Map<String, dynamic> toJson() => _$StakingSummaryToJson(this);

  @JsonKey(name: 'poolId')
  final double poolId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'stakingEnabled')
  final bool stakingEnabled;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String> collection;
  @JsonKey(name: 'poolStakedCount')
  final double poolStakedCount;
  @JsonKey(name: 'userStakedCount')
  final double userStakedCount;
  @JsonKey(name: 'delegatorCount')
  final double delegatorCount;
  @JsonKey(name: 'rewardDuration')
  final double rewardDuration;
  @JsonKey(name: 'poolReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> poolReward;
  @JsonKey(name: 'userReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> userReward;
  @JsonKey(name: 'poolType')
  final String poolType;
  @JsonKey(name: 'issuingType')
  final String issuingType;
  @JsonKey(name: 'unBoundPeriod')
  final double unBoundPeriod;
  @JsonKey(name: 'hasUnboundPeriod')
  final bool hasUnboundPeriod;
  @JsonKey(name: 'userUnboundCount')
  final double userUnboundCount;
  @JsonKey(name: 'maxPoolLimit')
  final double maxPoolLimit;
  @JsonKey(name: 'hasMaxWalletLimit')
  final bool hasMaxWalletLimit;
  @JsonKey(name: 'maxWalletLimit')
  final double maxWalletLimit;
  @JsonKey(name: 'startEpoch')
  final double startEpoch;
  @JsonKey(name: 'endEpoch')
  final double endEpoch;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'currentEpoch')
  final double currentEpoch;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(name: 'daysLeft')
  final double daysLeft;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'percentageFilled')
  final double percentageFilled;
  static const fromJsonFactory = _$StakingSummaryFromJson;
}

extension $StakingSummaryExtension on StakingSummary {
  StakingSummary copyWith({
    double? poolId,
    String? name,
    String? description,
    bool? stakingEnabled,
    String? profile,
    List<String>? collection,
    double? poolStakedCount,
    double? userStakedCount,
    double? delegatorCount,
    double? rewardDuration,
    List<XoxnoStakingReward>? poolReward,
    List<XoxnoStakingReward>? userReward,
    String? poolType,
    String? issuingType,
    double? unBoundPeriod,
    bool? hasUnboundPeriod,
    double? userUnboundCount,
    double? maxPoolLimit,
    bool? hasMaxWalletLimit,
    double? maxWalletLimit,
    double? startEpoch,
    double? endEpoch,
    String? owner,
    double? currentEpoch,
    bool? isActive,
    double? daysLeft,
    double? cutFee,
    double? percentageFilled,
  }) {
    return StakingSummary(
      poolId: poolId ?? this.poolId,
      name: name ?? this.name,
      description: description ?? this.description,
      stakingEnabled: stakingEnabled ?? this.stakingEnabled,
      profile: profile ?? this.profile,
      collection: collection ?? this.collection,
      poolStakedCount: poolStakedCount ?? this.poolStakedCount,
      userStakedCount: userStakedCount ?? this.userStakedCount,
      delegatorCount: delegatorCount ?? this.delegatorCount,
      rewardDuration: rewardDuration ?? this.rewardDuration,
      poolReward: poolReward ?? this.poolReward,
      userReward: userReward ?? this.userReward,
      poolType: poolType ?? this.poolType,
      issuingType: issuingType ?? this.issuingType,
      unBoundPeriod: unBoundPeriod ?? this.unBoundPeriod,
      hasUnboundPeriod: hasUnboundPeriod ?? this.hasUnboundPeriod,
      userUnboundCount: userUnboundCount ?? this.userUnboundCount,
      maxPoolLimit: maxPoolLimit ?? this.maxPoolLimit,
      hasMaxWalletLimit: hasMaxWalletLimit ?? this.hasMaxWalletLimit,
      maxWalletLimit: maxWalletLimit ?? this.maxWalletLimit,
      startEpoch: startEpoch ?? this.startEpoch,
      endEpoch: endEpoch ?? this.endEpoch,
      owner: owner ?? this.owner,
      currentEpoch: currentEpoch ?? this.currentEpoch,
      isActive: isActive ?? this.isActive,
      daysLeft: daysLeft ?? this.daysLeft,
      cutFee: cutFee ?? this.cutFee,
      percentageFilled: percentageFilled ?? this.percentageFilled,
    );
  }

  StakingSummary copyWithWrapped({
    Wrapped<double>? poolId,
    Wrapped<String>? name,
    Wrapped<String?>? description,
    Wrapped<bool>? stakingEnabled,
    Wrapped<String>? profile,
    Wrapped<List<String>>? collection,
    Wrapped<double>? poolStakedCount,
    Wrapped<double>? userStakedCount,
    Wrapped<double>? delegatorCount,
    Wrapped<double>? rewardDuration,
    Wrapped<List<XoxnoStakingReward>>? poolReward,
    Wrapped<List<XoxnoStakingReward>>? userReward,
    Wrapped<String>? poolType,
    Wrapped<String>? issuingType,
    Wrapped<double>? unBoundPeriod,
    Wrapped<bool>? hasUnboundPeriod,
    Wrapped<double>? userUnboundCount,
    Wrapped<double>? maxPoolLimit,
    Wrapped<bool>? hasMaxWalletLimit,
    Wrapped<double>? maxWalletLimit,
    Wrapped<double>? startEpoch,
    Wrapped<double>? endEpoch,
    Wrapped<String>? owner,
    Wrapped<double>? currentEpoch,
    Wrapped<bool>? isActive,
    Wrapped<double>? daysLeft,
    Wrapped<double>? cutFee,
    Wrapped<double>? percentageFilled,
  }) {
    return StakingSummary(
      poolId: (poolId != null ? poolId.value : this.poolId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      stakingEnabled: (stakingEnabled != null
          ? stakingEnabled.value
          : this.stakingEnabled),
      profile: (profile != null ? profile.value : this.profile),
      collection: (collection != null ? collection.value : this.collection),
      poolStakedCount: (poolStakedCount != null
          ? poolStakedCount.value
          : this.poolStakedCount),
      userStakedCount: (userStakedCount != null
          ? userStakedCount.value
          : this.userStakedCount),
      delegatorCount: (delegatorCount != null
          ? delegatorCount.value
          : this.delegatorCount),
      rewardDuration: (rewardDuration != null
          ? rewardDuration.value
          : this.rewardDuration),
      poolReward: (poolReward != null ? poolReward.value : this.poolReward),
      userReward: (userReward != null ? userReward.value : this.userReward),
      poolType: (poolType != null ? poolType.value : this.poolType),
      issuingType: (issuingType != null ? issuingType.value : this.issuingType),
      unBoundPeriod: (unBoundPeriod != null
          ? unBoundPeriod.value
          : this.unBoundPeriod),
      hasUnboundPeriod: (hasUnboundPeriod != null
          ? hasUnboundPeriod.value
          : this.hasUnboundPeriod),
      userUnboundCount: (userUnboundCount != null
          ? userUnboundCount.value
          : this.userUnboundCount),
      maxPoolLimit: (maxPoolLimit != null
          ? maxPoolLimit.value
          : this.maxPoolLimit),
      hasMaxWalletLimit: (hasMaxWalletLimit != null
          ? hasMaxWalletLimit.value
          : this.hasMaxWalletLimit),
      maxWalletLimit: (maxWalletLimit != null
          ? maxWalletLimit.value
          : this.maxWalletLimit),
      startEpoch: (startEpoch != null ? startEpoch.value : this.startEpoch),
      endEpoch: (endEpoch != null ? endEpoch.value : this.endEpoch),
      owner: (owner != null ? owner.value : this.owner),
      currentEpoch: (currentEpoch != null
          ? currentEpoch.value
          : this.currentEpoch),
      isActive: (isActive != null ? isActive.value : this.isActive),
      daysLeft: (daysLeft != null ? daysLeft.value : this.daysLeft),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      percentageFilled: (percentageFilled != null
          ? percentageFilled.value
          : this.percentageFilled),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingPoolDoc {
  const StakingPoolDoc({
    required this.dataType,
    required this.poolId,
    required this.poolType,
    required this.stakingEnabled,
    required this.whitelistEnabled,
    required this.matchPairEnabled,
    required this.maxStakePerWallet,
    required this.maxStakePerPool,
    required this.issuingType,
    required this.issuingDeadline,
    required this.issuingStart,
    required this.unboundPeriod,
    required this.collection,
    required this.reward,
    required this.cutFee,
    required this.owner,
    this.name,
    this.profile,
    this.totalWhitelisted,
    this.delegatorCount,
    this.poolStakedCount,
    this.pk,
    this.id,
  });

  factory StakingPoolDoc.fromJson(Map<String, dynamic> json) =>
      _$StakingPoolDocFromJson(json);

  static const toJsonFactory = _$StakingPoolDocToJson;
  Map<String, dynamic> toJson() => _$StakingPoolDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: stakingDataTypeToJson,
    fromJson: stakingDataTypeFromJson,
  )
  final enums.StakingDataType dataType;
  @JsonKey(name: 'poolId')
  final int poolId;
  @JsonKey(
    name: 'poolType',
    toJson: stakingPoolTypeStringToJson,
    fromJson: stakingPoolTypeStringFromJson,
  )
  final enums.StakingPoolTypeString poolType;
  @JsonKey(name: 'stakingEnabled')
  final bool stakingEnabled;
  @JsonKey(name: 'whitelistEnabled')
  final bool whitelistEnabled;
  @JsonKey(name: 'matchPairEnabled')
  final bool matchPairEnabled;
  @JsonKey(name: 'maxStakePerWallet')
  final int maxStakePerWallet;
  @JsonKey(name: 'maxStakePerPool')
  final int maxStakePerPool;
  @JsonKey(
    name: 'issuingType',
    toJson: stakingIssuingTypeStringToJson,
    fromJson: stakingIssuingTypeStringFromJson,
  )
  final enums.StakingIssuingTypeString issuingType;
  @JsonKey(name: 'issuingDeadline')
  final int issuingDeadline;
  @JsonKey(name: 'issuingStart')
  final int issuingStart;
  @JsonKey(name: 'unboundPeriod')
  final int unboundPeriod;
  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String> collection;
  @JsonKey(name: 'reward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> reward;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'totalWhitelisted')
  final int? totalWhitelisted;
  @JsonKey(name: 'delegatorCount')
  final int? delegatorCount;
  @JsonKey(name: 'poolStakedCount')
  final int? poolStakedCount;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$StakingPoolDocFromJson;
}

extension $StakingPoolDocExtension on StakingPoolDoc {
  StakingPoolDoc copyWith({
    enums.StakingDataType? dataType,
    int? poolId,
    enums.StakingPoolTypeString? poolType,
    bool? stakingEnabled,
    bool? whitelistEnabled,
    bool? matchPairEnabled,
    int? maxStakePerWallet,
    int? maxStakePerPool,
    enums.StakingIssuingTypeString? issuingType,
    int? issuingDeadline,
    int? issuingStart,
    int? unboundPeriod,
    List<String>? collection,
    List<XoxnoStakingReward>? reward,
    double? cutFee,
    String? owner,
    String? name,
    String? profile,
    int? totalWhitelisted,
    int? delegatorCount,
    int? poolStakedCount,
    String? pk,
    String? id,
  }) {
    return StakingPoolDoc(
      dataType: dataType ?? this.dataType,
      poolId: poolId ?? this.poolId,
      poolType: poolType ?? this.poolType,
      stakingEnabled: stakingEnabled ?? this.stakingEnabled,
      whitelistEnabled: whitelistEnabled ?? this.whitelistEnabled,
      matchPairEnabled: matchPairEnabled ?? this.matchPairEnabled,
      maxStakePerWallet: maxStakePerWallet ?? this.maxStakePerWallet,
      maxStakePerPool: maxStakePerPool ?? this.maxStakePerPool,
      issuingType: issuingType ?? this.issuingType,
      issuingDeadline: issuingDeadline ?? this.issuingDeadline,
      issuingStart: issuingStart ?? this.issuingStart,
      unboundPeriod: unboundPeriod ?? this.unboundPeriod,
      collection: collection ?? this.collection,
      reward: reward ?? this.reward,
      cutFee: cutFee ?? this.cutFee,
      owner: owner ?? this.owner,
      name: name ?? this.name,
      profile: profile ?? this.profile,
      totalWhitelisted: totalWhitelisted ?? this.totalWhitelisted,
      delegatorCount: delegatorCount ?? this.delegatorCount,
      poolStakedCount: poolStakedCount ?? this.poolStakedCount,
      pk: pk ?? this.pk,
      id: id ?? this.id,
    );
  }

  StakingPoolDoc copyWithWrapped({
    Wrapped<enums.StakingDataType>? dataType,
    Wrapped<int>? poolId,
    Wrapped<enums.StakingPoolTypeString>? poolType,
    Wrapped<bool>? stakingEnabled,
    Wrapped<bool>? whitelistEnabled,
    Wrapped<bool>? matchPairEnabled,
    Wrapped<int>? maxStakePerWallet,
    Wrapped<int>? maxStakePerPool,
    Wrapped<enums.StakingIssuingTypeString>? issuingType,
    Wrapped<int>? issuingDeadline,
    Wrapped<int>? issuingStart,
    Wrapped<int>? unboundPeriod,
    Wrapped<List<String>>? collection,
    Wrapped<List<XoxnoStakingReward>>? reward,
    Wrapped<double>? cutFee,
    Wrapped<String>? owner,
    Wrapped<String?>? name,
    Wrapped<String?>? profile,
    Wrapped<int?>? totalWhitelisted,
    Wrapped<int?>? delegatorCount,
    Wrapped<int?>? poolStakedCount,
    Wrapped<String?>? pk,
    Wrapped<String?>? id,
  }) {
    return StakingPoolDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      poolId: (poolId != null ? poolId.value : this.poolId),
      poolType: (poolType != null ? poolType.value : this.poolType),
      stakingEnabled: (stakingEnabled != null
          ? stakingEnabled.value
          : this.stakingEnabled),
      whitelistEnabled: (whitelistEnabled != null
          ? whitelistEnabled.value
          : this.whitelistEnabled),
      matchPairEnabled: (matchPairEnabled != null
          ? matchPairEnabled.value
          : this.matchPairEnabled),
      maxStakePerWallet: (maxStakePerWallet != null
          ? maxStakePerWallet.value
          : this.maxStakePerWallet),
      maxStakePerPool: (maxStakePerPool != null
          ? maxStakePerPool.value
          : this.maxStakePerPool),
      issuingType: (issuingType != null ? issuingType.value : this.issuingType),
      issuingDeadline: (issuingDeadline != null
          ? issuingDeadline.value
          : this.issuingDeadline),
      issuingStart: (issuingStart != null
          ? issuingStart.value
          : this.issuingStart),
      unboundPeriod: (unboundPeriod != null
          ? unboundPeriod.value
          : this.unboundPeriod),
      collection: (collection != null ? collection.value : this.collection),
      reward: (reward != null ? reward.value : this.reward),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      owner: (owner != null ? owner.value : this.owner),
      name: (name != null ? name.value : this.name),
      profile: (profile != null ? profile.value : this.profile),
      totalWhitelisted: (totalWhitelisted != null
          ? totalWhitelisted.value
          : this.totalWhitelisted),
      delegatorCount: (delegatorCount != null
          ? delegatorCount.value
          : this.delegatorCount),
      poolStakedCount: (poolStakedCount != null
          ? poolStakedCount.value
          : this.poolStakedCount),
      pk: (pk != null ? pk.value : this.pk),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingEditDto {
  const StakingEditDto({this.name, this.description});

  factory StakingEditDto.fromJson(Map<String, dynamic> json) =>
      _$StakingEditDtoFromJson(json);

  static const toJsonFactory = _$StakingEditDtoToJson;
  Map<String, dynamic> toJson() => _$StakingEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$StakingEditDtoFromJson;
}

extension $StakingEditDtoExtension on StakingEditDto {
  StakingEditDto copyWith({String? name, String? description}) {
    return StakingEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }

  StakingEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
  }) {
    return StakingEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OwnedCollectionsDto {
  const OwnedCollectionsDto({
    required this.registered,
    required this.availableForRegister,
  });

  factory OwnedCollectionsDto.fromJson(Map<String, dynamic> json) =>
      _$OwnedCollectionsDtoFromJson(json);

  static const toJsonFactory = _$OwnedCollectionsDtoToJson;
  Map<String, dynamic> toJson() => _$OwnedCollectionsDtoToJson(this);

  @JsonKey(name: 'registered', defaultValue: <String>[])
  final List<String> registered;
  @JsonKey(name: 'availableForRegister', defaultValue: <String>[])
  final List<String> availableForRegister;
  static const fromJsonFactory = _$OwnedCollectionsDtoFromJson;
}

extension $OwnedCollectionsDtoExtension on OwnedCollectionsDto {
  OwnedCollectionsDto copyWith({
    List<String>? registered,
    List<String>? availableForRegister,
  }) {
    return OwnedCollectionsDto(
      registered: registered ?? this.registered,
      availableForRegister: availableForRegister ?? this.availableForRegister,
    );
  }

  OwnedCollectionsDto copyWithWrapped({
    Wrapped<List<String>>? registered,
    Wrapped<List<String>>? availableForRegister,
  }) {
    return OwnedCollectionsDto(
      registered: (registered != null ? registered.value : this.registered),
      availableForRegister: (availableForRegister != null
          ? availableForRegister.value
          : this.availableForRegister),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserStakingSummaryDto {
  const UserStakingSummaryDto({
    required this.collection,
    required this.stakedCount,
    required this.name,
    required this.isVerified,
    required this.profile,
    required this.banner,
    required this.poolIds,
    required this.userReward,
  });

  factory UserStakingSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$UserStakingSummaryDtoFromJson(json);

  static const toJsonFactory = _$UserStakingSummaryDtoToJson;
  Map<String, dynamic> toJson() => _$UserStakingSummaryDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'stakedCount')
  final double stakedCount;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'banner')
  final String banner;
  @JsonKey(name: 'poolIds', defaultValue: <double>[])
  final List<double> poolIds;
  @JsonKey(name: 'userReward', defaultValue: <XoxnoStakingReward>[])
  final List<XoxnoStakingReward> userReward;
  static const fromJsonFactory = _$UserStakingSummaryDtoFromJson;
}

extension $UserStakingSummaryDtoExtension on UserStakingSummaryDto {
  UserStakingSummaryDto copyWith({
    String? collection,
    double? stakedCount,
    String? name,
    bool? isVerified,
    String? profile,
    String? banner,
    List<double>? poolIds,
    List<XoxnoStakingReward>? userReward,
  }) {
    return UserStakingSummaryDto(
      collection: collection ?? this.collection,
      stakedCount: stakedCount ?? this.stakedCount,
      name: name ?? this.name,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      banner: banner ?? this.banner,
      poolIds: poolIds ?? this.poolIds,
      userReward: userReward ?? this.userReward,
    );
  }

  UserStakingSummaryDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? stakedCount,
    Wrapped<String>? name,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? banner,
    Wrapped<List<double>>? poolIds,
    Wrapped<List<XoxnoStakingReward>>? userReward,
  }) {
    return UserStakingSummaryDto(
      collection: (collection != null ? collection.value : this.collection),
      stakedCount: (stakedCount != null ? stakedCount.value : this.stakedCount),
      name: (name != null ? name.value : this.name),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      banner: (banner != null ? banner.value : this.banner),
      poolIds: (poolIds != null ? poolIds.value : this.poolIds),
      userReward: (userReward != null ? userReward.value : this.userReward),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingCreatorDoc {
  const StakingCreatorDoc({
    required this.dataType,
    required this.address,
    required this.ownedPools,
    required this.ownedCollections,
    required this.cutFee,
    this.id,
    this.pk,
  });

  factory StakingCreatorDoc.fromJson(Map<String, dynamic> json) =>
      _$StakingCreatorDocFromJson(json);

  static const toJsonFactory = _$StakingCreatorDocToJson;
  Map<String, dynamic> toJson() => _$StakingCreatorDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: stakingDataTypeToJson,
    fromJson: stakingDataTypeFromJson,
  )
  final enums.StakingDataType dataType;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'ownedPools', defaultValue: <double>[])
  final List<double> ownedPools;
  @JsonKey(name: 'ownedCollections', defaultValue: <String>[])
  final List<String> ownedCollections;
  @JsonKey(name: 'cutFee')
  final double cutFee;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$StakingCreatorDocFromJson;
}

extension $StakingCreatorDocExtension on StakingCreatorDoc {
  StakingCreatorDoc copyWith({
    enums.StakingDataType? dataType,
    String? address,
    List<double>? ownedPools,
    List<String>? ownedCollections,
    double? cutFee,
    String? id,
    String? pk,
  }) {
    return StakingCreatorDoc(
      dataType: dataType ?? this.dataType,
      address: address ?? this.address,
      ownedPools: ownedPools ?? this.ownedPools,
      ownedCollections: ownedCollections ?? this.ownedCollections,
      cutFee: cutFee ?? this.cutFee,
      id: id ?? this.id,
      pk: pk ?? this.pk,
    );
  }

  StakingCreatorDoc copyWithWrapped({
    Wrapped<enums.StakingDataType>? dataType,
    Wrapped<String>? address,
    Wrapped<List<double>>? ownedPools,
    Wrapped<List<String>>? ownedCollections,
    Wrapped<double>? cutFee,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
  }) {
    return StakingCreatorDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      address: (address != null ? address.value : this.address),
      ownedPools: (ownedPools != null ? ownedPools.value : this.ownedPools),
      ownedCollections: (ownedCollections != null
          ? ownedCollections.value
          : this.ownedCollections),
      cutFee: (cutFee != null ? cutFee.value : this.cutFee),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingUserPoolNfts {
  const StakingUserPoolNfts({
    required this.poolInfo,
    required this.nftDocs,
    required this.count,
  });

  factory StakingUserPoolNfts.fromJson(Map<String, dynamic> json) =>
      _$StakingUserPoolNftsFromJson(json);

  static const toJsonFactory = _$StakingUserPoolNftsToJson;
  Map<String, dynamic> toJson() => _$StakingUserPoolNftsToJson(this);

  @JsonKey(name: 'poolInfo')
  final StakingSummary poolInfo;
  @JsonKey(name: 'nftDocs', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated> nftDocs;
  @JsonKey(name: 'count')
  final int count;
  static const fromJsonFactory = _$StakingUserPoolNftsFromJson;
}

extension $StakingUserPoolNftsExtension on StakingUserPoolNfts {
  StakingUserPoolNfts copyWith({
    StakingSummary? poolInfo,
    List<NftDocHydrated>? nftDocs,
    int? count,
  }) {
    return StakingUserPoolNfts(
      poolInfo: poolInfo ?? this.poolInfo,
      nftDocs: nftDocs ?? this.nftDocs,
      count: count ?? this.count,
    );
  }

  StakingUserPoolNfts copyWithWrapped({
    Wrapped<StakingSummary>? poolInfo,
    Wrapped<List<NftDocHydrated>>? nftDocs,
    Wrapped<int>? count,
  }) {
    return StakingUserPoolNfts(
      poolInfo: (poolInfo != null ? poolInfo.value : this.poolInfo),
      nftDocs: (nftDocs != null ? nftDocs.value : this.nftDocs),
      count: (count != null ? count.value : this.count),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StakingExploreDtoHydrated {
  const StakingExploreDtoHydrated({
    required this.collection,
    required this.activePools,
    required this.totalPoolStakedCount,
    required this.totalDelegatorCount,
    required this.rewardTickers,
    required this.collectionInfo,
  });

  factory StakingExploreDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$StakingExploreDtoHydratedFromJson(json);

  static const toJsonFactory = _$StakingExploreDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$StakingExploreDtoHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'activePools')
  final double activePools;
  @JsonKey(name: 'totalPoolStakedCount')
  final double totalPoolStakedCount;
  @JsonKey(name: 'totalDelegatorCount')
  final double totalDelegatorCount;
  @JsonKey(name: 'rewardTickers', defaultValue: <String>[])
  final List<String> rewardTickers;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$StakingExploreDtoHydratedFromJson;
}

extension $StakingExploreDtoHydratedExtension on StakingExploreDtoHydrated {
  StakingExploreDtoHydrated copyWith({
    String? collection,
    double? activePools,
    double? totalPoolStakedCount,
    double? totalDelegatorCount,
    List<String>? rewardTickers,
    ShortCollectionDoc? collectionInfo,
  }) {
    return StakingExploreDtoHydrated(
      collection: collection ?? this.collection,
      activePools: activePools ?? this.activePools,
      totalPoolStakedCount: totalPoolStakedCount ?? this.totalPoolStakedCount,
      totalDelegatorCount: totalDelegatorCount ?? this.totalDelegatorCount,
      rewardTickers: rewardTickers ?? this.rewardTickers,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  StakingExploreDtoHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<double>? activePools,
    Wrapped<double>? totalPoolStakedCount,
    Wrapped<double>? totalDelegatorCount,
    Wrapped<List<String>>? rewardTickers,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return StakingExploreDtoHydrated(
      collection: (collection != null ? collection.value : this.collection),
      activePools: (activePools != null ? activePools.value : this.activePools),
      totalPoolStakedCount: (totalPoolStakedCount != null
          ? totalPoolStakedCount.value
          : this.totalPoolStakedCount),
      totalDelegatorCount: (totalDelegatorCount != null
          ? totalDelegatorCount.value
          : this.totalDelegatorCount),
      rewardTickers: (rewardTickers != null
          ? rewardTickers.value
          : this.rewardTickers),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class OwnedServicesDto {
  const OwnedServicesDto({
    required this.mintProfiles,
    required this.stakingPools,
    required this.events,
    required this.creatorProfile,
    required this.address,
  });

  factory OwnedServicesDto.fromJson(Map<String, dynamic> json) =>
      _$OwnedServicesDtoFromJson(json);

  static const toJsonFactory = _$OwnedServicesDtoToJson;
  Map<String, dynamic> toJson() => _$OwnedServicesDtoToJson(this);

  @JsonKey(
    name: 'mintProfiles',
    defaultValue: <CollectionMintProfileDocHydrated>[],
  )
  final List<CollectionMintProfileDocHydrated> mintProfiles;
  @JsonKey(name: 'stakingPools', defaultValue: <StakingSummary>[])
  final List<StakingSummary> stakingPools;
  @JsonKey(name: 'events', defaultValue: <EventProfile>[])
  final List<EventProfile> events;
  @JsonKey(name: 'creatorProfile')
  final CreatorProfileDoc creatorProfile;
  @JsonKey(name: 'address')
  final String address;
  static const fromJsonFactory = _$OwnedServicesDtoFromJson;
}

extension $OwnedServicesDtoExtension on OwnedServicesDto {
  OwnedServicesDto copyWith({
    List<CollectionMintProfileDocHydrated>? mintProfiles,
    List<StakingSummary>? stakingPools,
    List<EventProfile>? events,
    CreatorProfileDoc? creatorProfile,
    String? address,
  }) {
    return OwnedServicesDto(
      mintProfiles: mintProfiles ?? this.mintProfiles,
      stakingPools: stakingPools ?? this.stakingPools,
      events: events ?? this.events,
      creatorProfile: creatorProfile ?? this.creatorProfile,
      address: address ?? this.address,
    );
  }

  OwnedServicesDto copyWithWrapped({
    Wrapped<List<CollectionMintProfileDocHydrated>>? mintProfiles,
    Wrapped<List<StakingSummary>>? stakingPools,
    Wrapped<List<EventProfile>>? events,
    Wrapped<CreatorProfileDoc>? creatorProfile,
    Wrapped<String>? address,
  }) {
    return OwnedServicesDto(
      mintProfiles: (mintProfiles != null
          ? mintProfiles.value
          : this.mintProfiles),
      stakingPools: (stakingPools != null
          ? stakingPools.value
          : this.stakingPools),
      events: (events != null ? events.value : this.events),
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      address: (address != null ? address.value : this.address),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FilterQueryDto {
  const FilterQueryDto({
    required this.name,
    this.top,
    this.skip,
    this.chain,
    this.orderBy,
    this.select,
  });

  factory FilterQueryDto.fromJson(Map<String, dynamic> json) =>
      _$FilterQueryDtoFromJson(json);

  static const toJsonFactory = _$FilterQueryDtoToJson;
  Map<String, dynamic> toJson() => _$FilterQueryDtoToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(
    name: 'chain',
    toJson: activityChainListToJson,
    fromJson: activityChainListFromJson,
  )
  final List<enums.ActivityChain>? chain;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  static const fromJsonFactory = _$FilterQueryDtoFromJson;
}

extension $FilterQueryDtoExtension on FilterQueryDto {
  FilterQueryDto copyWith({
    String? name,
    int? top,
    int? skip,
    List<enums.ActivityChain>? chain,
    List<String>? orderBy,
    List<String>? select,
  }) {
    return FilterQueryDto(
      name: name ?? this.name,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      chain: chain ?? this.chain,
      orderBy: orderBy ?? this.orderBy,
      select: select ?? this.select,
    );
  }

  FilterQueryDto copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<List<enums.ActivityChain>?>? chain,
    Wrapped<List<String>?>? orderBy,
    Wrapped<List<String>?>? select,
  }) {
    return FilterQueryDto(
      name: (name != null ? name.value : this.name),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      chain: (chain != null ? chain.value : this.chain),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      select: (select != null ? select.value : this.select),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionDto {
  const CollectionDto({
    required this.collection,
    required this.name,
    required this.isVisible,
    required this.isVerified,
    required this.profile,
    required this.type,
    required this.statistics,
    required this.floorPrice,
    this.chain,
  });

  factory CollectionDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionDtoFromJson(json);

  static const toJsonFactory = _$CollectionDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionDtoToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'isVisible')
  final bool isVisible;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'statistics')
  final StatisticsDto statistics;
  @JsonKey(name: 'floorPrice')
  final double floorPrice;
  @JsonKey(
    name: 'chain',
    toJson: collectionDtoChainNullableToJson,
    fromJson: collectionDtoChainNullableFromJson,
  )
  final enums.CollectionDtoChain? chain;
  static const fromJsonFactory = _$CollectionDtoFromJson;
}

extension $CollectionDtoExtension on CollectionDto {
  CollectionDto copyWith({
    String? collection,
    String? name,
    bool? isVisible,
    bool? isVerified,
    String? profile,
    String? type,
    StatisticsDto? statistics,
    double? floorPrice,
    enums.CollectionDtoChain? chain,
  }) {
    return CollectionDto(
      collection: collection ?? this.collection,
      name: name ?? this.name,
      isVisible: isVisible ?? this.isVisible,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      type: type ?? this.type,
      statistics: statistics ?? this.statistics,
      floorPrice: floorPrice ?? this.floorPrice,
      chain: chain ?? this.chain,
    );
  }

  CollectionDto copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<bool>? isVisible,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<String>? type,
    Wrapped<StatisticsDto>? statistics,
    Wrapped<double>? floorPrice,
    Wrapped<enums.CollectionDtoChain?>? chain,
  }) {
    return CollectionDto(
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      isVisible: (isVisible != null ? isVisible.value : this.isVisible),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      type: (type != null ? type.value : this.type),
      statistics: (statistics != null ? statistics.value : this.statistics),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserDto {
  const UserDto({
    required this.address,
    required this.herotag,
    required this.isVerified,
    required this.profile,
    this.isCreator,
    required this.addressTrimmed,
    this.chain,
  });

  factory UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  static const toJsonFactory = _$UserDtoToJson;
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'isVerified')
  final bool isVerified;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'isCreator')
  final bool? isCreator;
  @JsonKey(name: 'addressTrimmed')
  final String addressTrimmed;
  @JsonKey(
    name: 'chain',
    toJson: userDtoChainNullableToJson,
    fromJson: userDtoChainNullableFromJson,
  )
  final enums.UserDtoChain? chain;
  static const fromJsonFactory = _$UserDtoFromJson;
}

extension $UserDtoExtension on UserDto {
  UserDto copyWith({
    String? address,
    String? herotag,
    bool? isVerified,
    String? profile,
    bool? isCreator,
    String? addressTrimmed,
    enums.UserDtoChain? chain,
  }) {
    return UserDto(
      address: address ?? this.address,
      herotag: herotag ?? this.herotag,
      isVerified: isVerified ?? this.isVerified,
      profile: profile ?? this.profile,
      isCreator: isCreator ?? this.isCreator,
      addressTrimmed: addressTrimmed ?? this.addressTrimmed,
      chain: chain ?? this.chain,
    );
  }

  UserDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? herotag,
    Wrapped<bool>? isVerified,
    Wrapped<String>? profile,
    Wrapped<bool?>? isCreator,
    Wrapped<String>? addressTrimmed,
    Wrapped<enums.UserDtoChain?>? chain,
  }) {
    return UserDto(
      address: (address != null ? address.value : this.address),
      herotag: (herotag != null ? herotag.value : this.herotag),
      isVerified: (isVerified != null ? isVerified.value : this.isVerified),
      profile: (profile != null ? profile.value : this.profile),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      addressTrimmed: (addressTrimmed != null
          ? addressTrimmed.value
          : this.addressTrimmed),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorDto {
  const CreatorDto({
    required this.address,
    required this.herotag,
    required this.addressTrimmed,
    required this.isCreator,
    required this.contractAddress,
    required this.name,
    required this.creatorTag,
    this.joinedDate,
    required this.profile,
    this.chain,
  });

  factory CreatorDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorDtoFromJson(json);

  static const toJsonFactory = _$CreatorDtoToJson;
  Map<String, dynamic> toJson() => _$CreatorDtoToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'herotag')
  final String herotag;
  @JsonKey(name: 'addressTrimmed')
  final String addressTrimmed;
  @JsonKey(name: 'isCreator')
  final bool isCreator;
  @JsonKey(name: 'contractAddress')
  final String contractAddress;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'creatorTag')
  final String creatorTag;
  @JsonKey(name: 'joinedDate')
  final double? joinedDate;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(
    name: 'chain',
    toJson: creatorDtoChainNullableToJson,
    fromJson: creatorDtoChainNullableFromJson,
  )
  final enums.CreatorDtoChain? chain;
  static const fromJsonFactory = _$CreatorDtoFromJson;
}

extension $CreatorDtoExtension on CreatorDto {
  CreatorDto copyWith({
    String? address,
    String? herotag,
    String? addressTrimmed,
    bool? isCreator,
    String? contractAddress,
    String? name,
    String? creatorTag,
    double? joinedDate,
    String? profile,
    enums.CreatorDtoChain? chain,
  }) {
    return CreatorDto(
      address: address ?? this.address,
      herotag: herotag ?? this.herotag,
      addressTrimmed: addressTrimmed ?? this.addressTrimmed,
      isCreator: isCreator ?? this.isCreator,
      contractAddress: contractAddress ?? this.contractAddress,
      name: name ?? this.name,
      creatorTag: creatorTag ?? this.creatorTag,
      joinedDate: joinedDate ?? this.joinedDate,
      profile: profile ?? this.profile,
      chain: chain ?? this.chain,
    );
  }

  CreatorDto copyWithWrapped({
    Wrapped<String>? address,
    Wrapped<String>? herotag,
    Wrapped<String>? addressTrimmed,
    Wrapped<bool>? isCreator,
    Wrapped<String>? contractAddress,
    Wrapped<String>? name,
    Wrapped<String>? creatorTag,
    Wrapped<double?>? joinedDate,
    Wrapped<String>? profile,
    Wrapped<enums.CreatorDtoChain?>? chain,
  }) {
    return CreatorDto(
      address: (address != null ? address.value : this.address),
      herotag: (herotag != null ? herotag.value : this.herotag),
      addressTrimmed: (addressTrimmed != null
          ? addressTrimmed.value
          : this.addressTrimmed),
      isCreator: (isCreator != null ? isCreator.value : this.isCreator),
      contractAddress: (contractAddress != null
          ? contractAddress.value
          : this.contractAddress),
      name: (name != null ? name.value : this.name),
      creatorTag: (creatorTag != null ? creatorTag.value : this.creatorTag),
      joinedDate: (joinedDate != null ? joinedDate.value : this.joinedDate),
      profile: (profile != null ? profile.value : this.profile),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftDto {
  const NftDto({
    required this.identifier,
    required this.name,
    required this.collection,
    required this.onSale,
    required this.url,
    required this.media,
    required this.wasProcessed,
    required this.metadata,
    this.chain,
  });

  factory NftDto.fromJson(Map<String, dynamic> json) => _$NftDtoFromJson(json);

  static const toJsonFactory = _$NftDtoToJson;
  Map<String, dynamic> toJson() => _$NftDtoToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'onSale')
  final bool onSale;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'media')
  final NftMedia media;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'metadata')
  final MetadataDto metadata;
  @JsonKey(
    name: 'chain',
    toJson: nftDtoChainNullableToJson,
    fromJson: nftDtoChainNullableFromJson,
  )
  final enums.NftDtoChain? chain;
  static const fromJsonFactory = _$NftDtoFromJson;
}

extension $NftDtoExtension on NftDto {
  NftDto copyWith({
    String? identifier,
    String? name,
    String? collection,
    bool? onSale,
    String? url,
    NftMedia? media,
    bool? wasProcessed,
    MetadataDto? metadata,
    enums.NftDtoChain? chain,
  }) {
    return NftDto(
      identifier: identifier ?? this.identifier,
      name: name ?? this.name,
      collection: collection ?? this.collection,
      onSale: onSale ?? this.onSale,
      url: url ?? this.url,
      media: media ?? this.media,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      metadata: metadata ?? this.metadata,
      chain: chain ?? this.chain,
    );
  }

  NftDto copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? name,
    Wrapped<String>? collection,
    Wrapped<bool>? onSale,
    Wrapped<String>? url,
    Wrapped<NftMedia>? media,
    Wrapped<bool>? wasProcessed,
    Wrapped<MetadataDto>? metadata,
    Wrapped<enums.NftDtoChain?>? chain,
  }) {
    return NftDto(
      identifier: (identifier != null ? identifier.value : this.identifier),
      name: (name != null ? name.value : this.name),
      collection: (collection != null ? collection.value : this.collection),
      onSale: (onSale != null ? onSale.value : this.onSale),
      url: (url != null ? url.value : this.url),
      media: (media != null ? media.value : this.media),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      metadata: (metadata != null ? metadata.value : this.metadata),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalSearchResourcesDto {
  const GlobalSearchResourcesDto({
    required this.collections,
    required this.users,
    required this.creators,
    required this.nft,
  });

  factory GlobalSearchResourcesDto.fromJson(Map<String, dynamic> json) =>
      _$GlobalSearchResourcesDtoFromJson(json);

  static const toJsonFactory = _$GlobalSearchResourcesDtoToJson;
  Map<String, dynamic> toJson() => _$GlobalSearchResourcesDtoToJson(this);

  @JsonKey(name: 'collections', defaultValue: <CollectionDto>[])
  final List<CollectionDto> collections;
  @JsonKey(name: 'users', defaultValue: <UserDto>[])
  final List<UserDto> users;
  @JsonKey(name: 'creators', defaultValue: <CreatorDto>[])
  final List<CreatorDto> creators;
  @JsonKey(name: 'nft', defaultValue: <NftDto>[])
  final List<NftDto> nft;
  static const fromJsonFactory = _$GlobalSearchResourcesDtoFromJson;
}

extension $GlobalSearchResourcesDtoExtension on GlobalSearchResourcesDto {
  GlobalSearchResourcesDto copyWith({
    List<CollectionDto>? collections,
    List<UserDto>? users,
    List<CreatorDto>? creators,
    List<NftDto>? nft,
  }) {
    return GlobalSearchResourcesDto(
      collections: collections ?? this.collections,
      users: users ?? this.users,
      creators: creators ?? this.creators,
      nft: nft ?? this.nft,
    );
  }

  GlobalSearchResourcesDto copyWithWrapped({
    Wrapped<List<CollectionDto>>? collections,
    Wrapped<List<UserDto>>? users,
    Wrapped<List<CreatorDto>>? creators,
    Wrapped<List<NftDto>>? nft,
  }) {
    return GlobalSearchResourcesDto(
      collections: (collections != null ? collections.value : this.collections),
      users: (users != null ? users.value : this.users),
      creators: (creators != null ? creators.value : this.creators),
      nft: (nft != null ? nft.value : this.nft),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalSearchResourcesPaginated {
  const GlobalSearchResourcesPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory GlobalSearchResourcesPaginated.fromJson(Map<String, dynamic> json) =>
      _$GlobalSearchResourcesPaginatedFromJson(json);

  static const toJsonFactory = _$GlobalSearchResourcesPaginatedToJson;
  Map<String, dynamic> toJson() => _$GlobalSearchResourcesPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources')
  final GlobalSearchResourcesDto resources;
  static const fromJsonFactory = _$GlobalSearchResourcesPaginatedFromJson;
}

extension $GlobalSearchResourcesPaginatedExtension
    on GlobalSearchResourcesPaginated {
  GlobalSearchResourcesPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    GlobalSearchResourcesDto? resources,
  }) {
    return GlobalSearchResourcesPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  GlobalSearchResourcesPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<GlobalSearchResourcesDto>? resources,
  }) {
    return GlobalSearchResourcesPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingNftAttributes {
  const LendingNftAttributes({
    required this.isolated,
    required this.eModeCategory,
    required this.positionMode,
    this.isolatedToken,
  });

  factory LendingNftAttributes.fromJson(Map<String, dynamic> json) =>
      _$LendingNftAttributesFromJson(json);

  static const toJsonFactory = _$LendingNftAttributesToJson;
  Map<String, dynamic> toJson() => _$LendingNftAttributesToJson(this);

  @JsonKey(name: 'isolated')
  final bool isolated;
  @JsonKey(name: 'eModeCategory')
  final String eModeCategory;
  @JsonKey(
    name: 'positionMode',
    toJson: positionModeToJson,
    fromJson: positionModeFromJson,
  )
  final enums.PositionMode positionMode;
  @JsonKey(name: 'isolatedToken')
  final String? isolatedToken;
  static const fromJsonFactory = _$LendingNftAttributesFromJson;
}

extension $LendingNftAttributesExtension on LendingNftAttributes {
  LendingNftAttributes copyWith({
    bool? isolated,
    String? eModeCategory,
    enums.PositionMode? positionMode,
    String? isolatedToken,
  }) {
    return LendingNftAttributes(
      isolated: isolated ?? this.isolated,
      eModeCategory: eModeCategory ?? this.eModeCategory,
      positionMode: positionMode ?? this.positionMode,
      isolatedToken: isolatedToken ?? this.isolatedToken,
    );
  }

  LendingNftAttributes copyWithWrapped({
    Wrapped<bool>? isolated,
    Wrapped<String>? eModeCategory,
    Wrapped<enums.PositionMode>? positionMode,
    Wrapped<String?>? isolatedToken,
  }) {
    return LendingNftAttributes(
      isolated: (isolated != null ? isolated.value : this.isolated),
      eModeCategory: (eModeCategory != null
          ? eModeCategory.value
          : this.eModeCategory),
      positionMode: (positionMode != null
          ? positionMode.value
          : this.positionMode),
      isolatedToken: (isolatedToken != null
          ? isolatedToken.value
          : this.isolatedToken),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LendingTokenPriceDto {
  const LendingTokenPriceDto({required this.price});

  factory LendingTokenPriceDto.fromJson(Map<String, dynamic> json) =>
      _$LendingTokenPriceDtoFromJson(json);

  static const toJsonFactory = _$LendingTokenPriceDtoToJson;
  Map<String, dynamic> toJson() => _$LendingTokenPriceDtoToJson(this);

  @JsonKey(name: 'price')
  final String price;
  static const fromJsonFactory = _$LendingTokenPriceDtoFromJson;
}

extension $LendingTokenPriceDtoExtension on LendingTokenPriceDto {
  LendingTokenPriceDto copyWith({String? price}) {
    return LendingTokenPriceDto(price: price ?? this.price);
  }

  LendingTokenPriceDto copyWithWrapped({Wrapped<String>? price}) {
    return LendingTokenPriceDto(
      price: (price != null ? price.value : this.price),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationDoc {
  const NotificationDoc({
    required this.dataType,
    required this.txHash,
    required this.source,
    required this.activityType,
    required this.owner,
    this.message,
    required this.asset,
    required this.activity,
    required this.isRead,
    required this.timestamp,
    this.id,
    this.pk,
    this.ts,
  });

  factory NotificationDoc.fromJson(Map<String, dynamic> json) =>
      _$NotificationDocFromJson(json);

  static const toJsonFactory = _$NotificationDocToJson;
  Map<String, dynamic> toJson() => _$NotificationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: notificationDocDataTypeToJson,
    fromJson: notificationDocDataTypeDataTypeFromJson,
  )
  final enums.NotificationDocDataType dataType;
  static enums.NotificationDocDataType notificationDocDataTypeDataTypeFromJson(
    Object? value,
  ) => notificationDocDataTypeFromJson(
    value,
    enums.NotificationDocDataType.notification,
  );

  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'source')
  final String source;
  @JsonKey(
    name: 'activityType',
    toJson: notificationDocActivityTypeToJson,
    fromJson: notificationDocActivityTypeFromJson,
  )
  final enums.NotificationDocActivityType activityType;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'message')
  final String? message;
  @JsonKey(name: 'asset')
  final Object asset;
  @JsonKey(name: 'activity')
  final Object activity;
  @JsonKey(name: 'isRead', defaultValue: false)
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$NotificationDocFromJson;
}

extension $NotificationDocExtension on NotificationDoc {
  NotificationDoc copyWith({
    enums.NotificationDocDataType? dataType,
    String? txHash,
    String? source,
    enums.NotificationDocActivityType? activityType,
    String? owner,
    String? message,
    Object? asset,
    Object? activity,
    bool? isRead,
    double? timestamp,
    String? id,
    String? pk,
    double? ts,
  }) {
    return NotificationDoc(
      dataType: dataType ?? this.dataType,
      txHash: txHash ?? this.txHash,
      source: source ?? this.source,
      activityType: activityType ?? this.activityType,
      owner: owner ?? this.owner,
      message: message ?? this.message,
      asset: asset ?? this.asset,
      activity: activity ?? this.activity,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  NotificationDoc copyWithWrapped({
    Wrapped<enums.NotificationDocDataType>? dataType,
    Wrapped<String>? txHash,
    Wrapped<String>? source,
    Wrapped<enums.NotificationDocActivityType>? activityType,
    Wrapped<String>? owner,
    Wrapped<String?>? message,
    Wrapped<Object>? asset,
    Wrapped<Object>? activity,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return NotificationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      txHash: (txHash != null ? txHash.value : this.txHash),
      source: (source != null ? source.value : this.source),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      owner: (owner != null ? owner.value : this.owner),
      message: (message != null ? message.value : this.message),
      asset: (asset != null ? asset.value : this.asset),
      activity: (activity != null ? activity.value : this.activity),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationPaginated {
  const NotificationPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NotificationPaginated.fromJson(Map<String, dynamic> json) =>
      _$NotificationPaginatedFromJson(json);

  static const toJsonFactory = _$NotificationPaginatedToJson;
  Map<String, dynamic> toJson() => _$NotificationPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NotificationDoc>[])
  final List<NotificationDoc> resources;
  static const fromJsonFactory = _$NotificationPaginatedFromJson;
}

extension $NotificationPaginatedExtension on NotificationPaginated {
  NotificationPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NotificationDoc>? resources,
  }) {
    return NotificationPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NotificationPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NotificationDoc>>? resources,
  }) {
    return NotificationPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationCountResponse {
  const PushNotificationCountResponse({required this.count});

  factory PushNotificationCountResponse.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationCountResponseFromJson(json);

  static const toJsonFactory = _$PushNotificationCountResponseToJson;
  Map<String, dynamic> toJson() => _$PushNotificationCountResponseToJson(this);

  @JsonKey(name: 'count')
  final double count;
  static const fromJsonFactory = _$PushNotificationCountResponseFromJson;
}

extension $PushNotificationCountResponseExtension
    on PushNotificationCountResponse {
  PushNotificationCountResponse copyWith({double? count}) {
    return PushNotificationCountResponse(count: count ?? this.count);
  }

  PushNotificationCountResponse copyWithWrapped({Wrapped<double>? count}) {
    return PushNotificationCountResponse(
      count: (count != null ? count.value : this.count),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MobileDeviceRegistrationDto {
  const MobileDeviceRegistrationDto({
    required this.deviceUUID,
    required this.platform,
    required this.pushChannel,
    required this.appVersion,
    this.deviceModel,
    this.osVersion,
  });

  factory MobileDeviceRegistrationDto.fromJson(Map<String, dynamic> json) =>
      _$MobileDeviceRegistrationDtoFromJson(json);

  static const toJsonFactory = _$MobileDeviceRegistrationDtoToJson;
  Map<String, dynamic> toJson() => _$MobileDeviceRegistrationDtoToJson(this);

  @JsonKey(name: 'deviceUUID')
  final String deviceUUID;
  @JsonKey(
    name: 'platform',
    toJson: devicePlatformToJson,
    fromJson: devicePlatformFromJson,
  )
  final enums.DevicePlatform platform;
  @JsonKey(name: 'pushChannel')
  final String pushChannel;
  @JsonKey(name: 'appVersion')
  final String appVersion;
  @JsonKey(name: 'deviceModel')
  final String? deviceModel;
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  static const fromJsonFactory = _$MobileDeviceRegistrationDtoFromJson;
}

extension $MobileDeviceRegistrationDtoExtension on MobileDeviceRegistrationDto {
  MobileDeviceRegistrationDto copyWith({
    String? deviceUUID,
    enums.DevicePlatform? platform,
    String? pushChannel,
    String? appVersion,
    String? deviceModel,
    String? osVersion,
  }) {
    return MobileDeviceRegistrationDto(
      deviceUUID: deviceUUID ?? this.deviceUUID,
      platform: platform ?? this.platform,
      pushChannel: pushChannel ?? this.pushChannel,
      appVersion: appVersion ?? this.appVersion,
      deviceModel: deviceModel ?? this.deviceModel,
      osVersion: osVersion ?? this.osVersion,
    );
  }

  MobileDeviceRegistrationDto copyWithWrapped({
    Wrapped<String>? deviceUUID,
    Wrapped<enums.DevicePlatform>? platform,
    Wrapped<String>? pushChannel,
    Wrapped<String>? appVersion,
    Wrapped<String?>? deviceModel,
    Wrapped<String?>? osVersion,
  }) {
    return MobileDeviceRegistrationDto(
      deviceUUID: (deviceUUID != null ? deviceUUID.value : this.deviceUUID),
      platform: (platform != null ? platform.value : this.platform),
      pushChannel: (pushChannel != null ? pushChannel.value : this.pushChannel),
      appVersion: (appVersion != null ? appVersion.value : this.appVersion),
      deviceModel: (deviceModel != null ? deviceModel.value : this.deviceModel),
      osVersion: (osVersion != null ? osVersion.value : this.osVersion),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MobileDeviceDoc {
  const MobileDeviceDoc({
    required this.dataType,
    required this.deviceUUID,
    required this.installationId,
    required this.platform,
    required this.pushChannel,
    required this.web2UserId,
    required this.linkedAddresses,
    required this.appVersion,
    this.deviceModel,
    this.osVersion,
    required this.registeredAt,
    required this.lastActiveAt,
    required this.isActive,
    this.id,
    this.pk,
    this.ts,
  });

  factory MobileDeviceDoc.fromJson(Map<String, dynamic> json) =>
      _$MobileDeviceDocFromJson(json);

  static const toJsonFactory = _$MobileDeviceDocToJson;
  Map<String, dynamic> toJson() => _$MobileDeviceDocToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'deviceUUID')
  final String deviceUUID;
  @JsonKey(name: 'installationId')
  final String installationId;
  @JsonKey(
    name: 'platform',
    toJson: devicePlatformToJson,
    fromJson: devicePlatformFromJson,
  )
  final enums.DevicePlatform platform;
  @JsonKey(name: 'pushChannel')
  final String pushChannel;
  @JsonKey(name: 'web2UserId')
  final String web2UserId;
  @JsonKey(name: 'linkedAddresses', defaultValue: <String>[])
  final List<String> linkedAddresses;
  @JsonKey(name: 'appVersion')
  final String appVersion;
  @JsonKey(name: 'deviceModel')
  final String? deviceModel;
  @JsonKey(name: 'osVersion')
  final String? osVersion;
  @JsonKey(name: 'registeredAt')
  final double registeredAt;
  @JsonKey(name: 'lastActiveAt')
  final double lastActiveAt;
  @JsonKey(name: 'isActive')
  final Object isActive;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$MobileDeviceDocFromJson;
}

extension $MobileDeviceDocExtension on MobileDeviceDoc {
  MobileDeviceDoc copyWith({
    Object? dataType,
    String? deviceUUID,
    String? installationId,
    enums.DevicePlatform? platform,
    String? pushChannel,
    String? web2UserId,
    List<String>? linkedAddresses,
    String? appVersion,
    String? deviceModel,
    String? osVersion,
    double? registeredAt,
    double? lastActiveAt,
    Object? isActive,
    String? id,
    String? pk,
    double? ts,
  }) {
    return MobileDeviceDoc(
      dataType: dataType ?? this.dataType,
      deviceUUID: deviceUUID ?? this.deviceUUID,
      installationId: installationId ?? this.installationId,
      platform: platform ?? this.platform,
      pushChannel: pushChannel ?? this.pushChannel,
      web2UserId: web2UserId ?? this.web2UserId,
      linkedAddresses: linkedAddresses ?? this.linkedAddresses,
      appVersion: appVersion ?? this.appVersion,
      deviceModel: deviceModel ?? this.deviceModel,
      osVersion: osVersion ?? this.osVersion,
      registeredAt: registeredAt ?? this.registeredAt,
      lastActiveAt: lastActiveAt ?? this.lastActiveAt,
      isActive: isActive ?? this.isActive,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  MobileDeviceDoc copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? deviceUUID,
    Wrapped<String>? installationId,
    Wrapped<enums.DevicePlatform>? platform,
    Wrapped<String>? pushChannel,
    Wrapped<String>? web2UserId,
    Wrapped<List<String>>? linkedAddresses,
    Wrapped<String>? appVersion,
    Wrapped<String?>? deviceModel,
    Wrapped<String?>? osVersion,
    Wrapped<double>? registeredAt,
    Wrapped<double>? lastActiveAt,
    Wrapped<Object>? isActive,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return MobileDeviceDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      deviceUUID: (deviceUUID != null ? deviceUUID.value : this.deviceUUID),
      installationId: (installationId != null
          ? installationId.value
          : this.installationId),
      platform: (platform != null ? platform.value : this.platform),
      pushChannel: (pushChannel != null ? pushChannel.value : this.pushChannel),
      web2UserId: (web2UserId != null ? web2UserId.value : this.web2UserId),
      linkedAddresses: (linkedAddresses != null
          ? linkedAddresses.value
          : this.linkedAddresses),
      appVersion: (appVersion != null ? appVersion.value : this.appVersion),
      deviceModel: (deviceModel != null ? deviceModel.value : this.deviceModel),
      osVersion: (osVersion != null ? osVersion.value : this.osVersion),
      registeredAt: (registeredAt != null
          ? registeredAt.value
          : this.registeredAt),
      lastActiveAt: (lastActiveAt != null
          ? lastActiveAt.value
          : this.lastActiveAt),
      isActive: (isActive != null ? isActive.value : this.isActive),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationEventDto {
  const PushNotificationEventDto({
    this.eventId,
    this.eventTitle,
    this.eventProfile,
    this.creatorAddress,
    this.creatorName,
  });

  factory PushNotificationEventDto.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationEventDtoFromJson(json);

  static const toJsonFactory = _$PushNotificationEventDtoToJson;
  Map<String, dynamic> toJson() => _$PushNotificationEventDtoToJson(this);

  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'eventTitle')
  final String? eventTitle;
  @JsonKey(name: 'eventProfile')
  final String? eventProfile;
  @JsonKey(name: 'creatorAddress')
  final String? creatorAddress;
  @JsonKey(name: 'creatorName')
  final String? creatorName;
  static const fromJsonFactory = _$PushNotificationEventDtoFromJson;
}

extension $PushNotificationEventDtoExtension on PushNotificationEventDto {
  PushNotificationEventDto copyWith({
    String? eventId,
    String? eventTitle,
    String? eventProfile,
    String? creatorAddress,
    String? creatorName,
  }) {
    return PushNotificationEventDto(
      eventId: eventId ?? this.eventId,
      eventTitle: eventTitle ?? this.eventTitle,
      eventProfile: eventProfile ?? this.eventProfile,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      creatorName: creatorName ?? this.creatorName,
    );
  }

  PushNotificationEventDto copyWithWrapped({
    Wrapped<String?>? eventId,
    Wrapped<String?>? eventTitle,
    Wrapped<String?>? eventProfile,
    Wrapped<String?>? creatorAddress,
    Wrapped<String?>? creatorName,
  }) {
    return PushNotificationEventDto(
      eventId: (eventId != null ? eventId.value : this.eventId),
      eventTitle: (eventTitle != null ? eventTitle.value : this.eventTitle),
      eventProfile: (eventProfile != null
          ? eventProfile.value
          : this.eventProfile),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      creatorName: (creatorName != null ? creatorName.value : this.creatorName),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationTargetingDto {
  const PushNotificationTargetingDto({
    required this.type,
    this.tagExpression,
    this.targetUsers,
    this.targetAddresses,
    this.recipientCount,
  });

  factory PushNotificationTargetingDto.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationTargetingDtoFromJson(json);

  static const toJsonFactory = _$PushNotificationTargetingDtoToJson;
  Map<String, dynamic> toJson() => _$PushNotificationTargetingDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: pushNotificationTypeToJson,
    fromJson: pushNotificationTypeFromJson,
  )
  final enums.PushNotificationType type;
  @JsonKey(name: 'tagExpression')
  final String? tagExpression;
  @JsonKey(name: 'targetUsers', defaultValue: <String>[])
  final List<String>? targetUsers;
  @JsonKey(name: 'targetAddresses', defaultValue: <String>[])
  final List<String>? targetAddresses;
  @JsonKey(name: 'recipientCount')
  final double? recipientCount;
  static const fromJsonFactory = _$PushNotificationTargetingDtoFromJson;
}

extension $PushNotificationTargetingDtoExtension
    on PushNotificationTargetingDto {
  PushNotificationTargetingDto copyWith({
    enums.PushNotificationType? type,
    String? tagExpression,
    List<String>? targetUsers,
    List<String>? targetAddresses,
    double? recipientCount,
  }) {
    return PushNotificationTargetingDto(
      type: type ?? this.type,
      tagExpression: tagExpression ?? this.tagExpression,
      targetUsers: targetUsers ?? this.targetUsers,
      targetAddresses: targetAddresses ?? this.targetAddresses,
      recipientCount: recipientCount ?? this.recipientCount,
    );
  }

  PushNotificationTargetingDto copyWithWrapped({
    Wrapped<enums.PushNotificationType>? type,
    Wrapped<String?>? tagExpression,
    Wrapped<List<String>?>? targetUsers,
    Wrapped<List<String>?>? targetAddresses,
    Wrapped<double?>? recipientCount,
  }) {
    return PushNotificationTargetingDto(
      type: (type != null ? type.value : this.type),
      tagExpression: (tagExpression != null
          ? tagExpression.value
          : this.tagExpression),
      targetUsers: (targetUsers != null ? targetUsers.value : this.targetUsers),
      targetAddresses: (targetAddresses != null
          ? targetAddresses.value
          : this.targetAddresses),
      recipientCount: (recipientCount != null
          ? recipientCount.value
          : this.recipientCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationDoc {
  const PushNotificationDoc({
    required this.dataType,
    required this.title,
    required this.message,
    this.imageUrl,
    required this.notificationType,
    required this.status,
    required this.owner,
    required this.senderAddress,
    this.senderName,
    this.event,
    required this.targeting,
    required this.isRead,
    required this.timestamp,
    this.deliveredAt,
    this.clickedAt,
    this.sound,
    this.badge,
    this.appMetadata,
    this.id,
    this.pk,
    this.ts,
  });

  factory PushNotificationDoc.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationDocFromJson(json);

  static const toJsonFactory = _$PushNotificationDocToJson;
  Map<String, dynamic> toJson() => _$PushNotificationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: notificationDataTypeToJson,
    fromJson: notificationDataTypeFromJson,
  )
  final enums.NotificationDataType dataType;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(
    name: 'notificationType',
    toJson: pushNotificationTypeToJson,
    fromJson: pushNotificationTypeFromJson,
  )
  final enums.PushNotificationType notificationType;
  @JsonKey(
    name: 'status',
    toJson: pushNotificationStatusToJson,
    fromJson: pushNotificationStatusFromJson,
  )
  final enums.PushNotificationStatus status;
  @JsonKey(name: 'owner')
  final String owner;
  @JsonKey(name: 'senderAddress')
  final String senderAddress;
  @JsonKey(name: 'senderName')
  final String? senderName;
  @JsonKey(name: 'event')
  final PushNotificationEventDto? event;
  @JsonKey(name: 'targeting')
  final PushNotificationTargetingDto targeting;
  @JsonKey(name: 'isRead', defaultValue: false)
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'deliveredAt')
  final double? deliveredAt;
  @JsonKey(name: 'clickedAt')
  final double? clickedAt;
  @JsonKey(name: 'sound')
  final String? sound;
  @JsonKey(name: 'badge')
  final double? badge;
  @JsonKey(name: 'appMetadata')
  final Object? appMetadata;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final double? ts;
  static const fromJsonFactory = _$PushNotificationDocFromJson;
}

extension $PushNotificationDocExtension on PushNotificationDoc {
  PushNotificationDoc copyWith({
    enums.NotificationDataType? dataType,
    String? title,
    String? message,
    String? imageUrl,
    enums.PushNotificationType? notificationType,
    enums.PushNotificationStatus? status,
    String? owner,
    String? senderAddress,
    String? senderName,
    PushNotificationEventDto? event,
    PushNotificationTargetingDto? targeting,
    bool? isRead,
    double? timestamp,
    double? deliveredAt,
    double? clickedAt,
    String? sound,
    double? badge,
    Object? appMetadata,
    String? id,
    String? pk,
    double? ts,
  }) {
    return PushNotificationDoc(
      dataType: dataType ?? this.dataType,
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      notificationType: notificationType ?? this.notificationType,
      status: status ?? this.status,
      owner: owner ?? this.owner,
      senderAddress: senderAddress ?? this.senderAddress,
      senderName: senderName ?? this.senderName,
      event: event ?? this.event,
      targeting: targeting ?? this.targeting,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      deliveredAt: deliveredAt ?? this.deliveredAt,
      clickedAt: clickedAt ?? this.clickedAt,
      sound: sound ?? this.sound,
      badge: badge ?? this.badge,
      appMetadata: appMetadata ?? this.appMetadata,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  PushNotificationDoc copyWithWrapped({
    Wrapped<enums.NotificationDataType>? dataType,
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<enums.PushNotificationType>? notificationType,
    Wrapped<enums.PushNotificationStatus>? status,
    Wrapped<String>? owner,
    Wrapped<String>? senderAddress,
    Wrapped<String?>? senderName,
    Wrapped<PushNotificationEventDto?>? event,
    Wrapped<PushNotificationTargetingDto>? targeting,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<double?>? deliveredAt,
    Wrapped<double?>? clickedAt,
    Wrapped<String?>? sound,
    Wrapped<double?>? badge,
    Wrapped<Object?>? appMetadata,
    Wrapped<String?>? id,
    Wrapped<String?>? pk,
    Wrapped<double?>? ts,
  }) {
    return PushNotificationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      notificationType: (notificationType != null
          ? notificationType.value
          : this.notificationType),
      status: (status != null ? status.value : this.status),
      owner: (owner != null ? owner.value : this.owner),
      senderAddress: (senderAddress != null
          ? senderAddress.value
          : this.senderAddress),
      senderName: (senderName != null ? senderName.value : this.senderName),
      event: (event != null ? event.value : this.event),
      targeting: (targeting != null ? targeting.value : this.targeting),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      deliveredAt: (deliveredAt != null ? deliveredAt.value : this.deliveredAt),
      clickedAt: (clickedAt != null ? clickedAt.value : this.clickedAt),
      sound: (sound != null ? sound.value : this.sound),
      badge: (badge != null ? badge.value : this.badge),
      appMetadata: (appMetadata != null ? appMetadata.value : this.appMetadata),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PushNotificationResponse {
  const PushNotificationResponse({
    required this.resources,
    required this.hasMoreResults,
  });

  factory PushNotificationResponse.fromJson(Map<String, dynamic> json) =>
      _$PushNotificationResponseFromJson(json);

  static const toJsonFactory = _$PushNotificationResponseToJson;
  Map<String, dynamic> toJson() => _$PushNotificationResponseToJson(this);

  @JsonKey(name: 'resources', defaultValue: <PushNotificationDoc>[])
  final List<PushNotificationDoc> resources;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  static const fromJsonFactory = _$PushNotificationResponseFromJson;
}

extension $PushNotificationResponseExtension on PushNotificationResponse {
  PushNotificationResponse copyWith({
    List<PushNotificationDoc>? resources,
    bool? hasMoreResults,
  }) {
    return PushNotificationResponse(
      resources: resources ?? this.resources,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
    );
  }

  PushNotificationResponse copyWithWrapped({
    Wrapped<List<PushNotificationDoc>>? resources,
    Wrapped<bool>? hasMoreResults,
  }) {
    return PushNotificationResponse(
      resources: (resources != null ? resources.value : this.resources),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationSuccessResponseDto {
  const NotificationSuccessResponseDto({
    required this.success,
    required this.message,
  });

  factory NotificationSuccessResponseDto.fromJson(Map<String, dynamic> json) =>
      _$NotificationSuccessResponseDtoFromJson(json);

  static const toJsonFactory = _$NotificationSuccessResponseDtoToJson;
  Map<String, dynamic> toJson() => _$NotificationSuccessResponseDtoToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  static const fromJsonFactory = _$NotificationSuccessResponseDtoFromJson;
}

extension $NotificationSuccessResponseDtoExtension
    on NotificationSuccessResponseDto {
  NotificationSuccessResponseDto copyWith({bool? success, String? message}) {
    return NotificationSuccessResponseDto(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }

  NotificationSuccessResponseDto copyWithWrapped({
    Wrapped<bool>? success,
    Wrapped<String>? message,
  }) {
    return NotificationSuccessResponseDto(
      success: (success != null ? success.value : this.success),
      message: (message != null ? message.value : this.message),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventNotificationDto {
  const EventNotificationDto({
    required this.title,
    required this.message,
    this.imageUrl,
    this.eventId,
    this.targetUsers,
    this.targetAddresses,
    this.metadata,
  });

  factory EventNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$EventNotificationDtoFromJson(json);

  static const toJsonFactory = _$EventNotificationDtoToJson;
  Map<String, dynamic> toJson() => _$EventNotificationDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'targetUsers', defaultValue: <String>[])
  final List<String>? targetUsers;
  @JsonKey(name: 'targetAddresses', defaultValue: <String>[])
  final List<String>? targetAddresses;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  static const fromJsonFactory = _$EventNotificationDtoFromJson;
}

extension $EventNotificationDtoExtension on EventNotificationDto {
  EventNotificationDto copyWith({
    String? title,
    String? message,
    String? imageUrl,
    String? eventId,
    List<String>? targetUsers,
    List<String>? targetAddresses,
    Object? metadata,
  }) {
    return EventNotificationDto(
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      eventId: eventId ?? this.eventId,
      targetUsers: targetUsers ?? this.targetUsers,
      targetAddresses: targetAddresses ?? this.targetAddresses,
      metadata: metadata ?? this.metadata,
    );
  }

  EventNotificationDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<String?>? eventId,
    Wrapped<List<String>?>? targetUsers,
    Wrapped<List<String>?>? targetAddresses,
    Wrapped<Object?>? metadata,
  }) {
    return EventNotificationDto(
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      eventId: (eventId != null ? eventId.value : this.eventId),
      targetUsers: (targetUsers != null ? targetUsers.value : this.targetUsers),
      targetAddresses: (targetAddresses != null
          ? targetAddresses.value
          : this.targetAddresses),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CreatorMarketingNotificationDto {
  const CreatorMarketingNotificationDto({
    required this.title,
    required this.message,
    this.imageUrl,
    required this.creatorAddress,
    this.metadata,
  });

  factory CreatorMarketingNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$CreatorMarketingNotificationDtoFromJson(json);

  static const toJsonFactory = _$CreatorMarketingNotificationDtoToJson;
  Map<String, dynamic> toJson() =>
      _$CreatorMarketingNotificationDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  @JsonKey(name: 'creatorAddress')
  final String creatorAddress;
  @JsonKey(name: 'metadata')
  final Object? metadata;
  static const fromJsonFactory = _$CreatorMarketingNotificationDtoFromJson;
}

extension $CreatorMarketingNotificationDtoExtension
    on CreatorMarketingNotificationDto {
  CreatorMarketingNotificationDto copyWith({
    String? title,
    String? message,
    String? imageUrl,
    String? creatorAddress,
    Object? metadata,
  }) {
    return CreatorMarketingNotificationDto(
      title: title ?? this.title,
      message: message ?? this.message,
      imageUrl: imageUrl ?? this.imageUrl,
      creatorAddress: creatorAddress ?? this.creatorAddress,
      metadata: metadata ?? this.metadata,
    );
  }

  CreatorMarketingNotificationDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? message,
    Wrapped<String?>? imageUrl,
    Wrapped<String>? creatorAddress,
    Wrapped<Object?>? metadata,
  }) {
    return CreatorMarketingNotificationDto(
      title: (title != null ? title.value : this.title),
      message: (message != null ? message.value : this.message),
      imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
      creatorAddress: (creatorAddress != null
          ? creatorAddress.value
          : this.creatorAddress),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpOrderResponse {
  const PerpOrderResponse({required this.type, required this.statuses});

  factory PerpOrderResponse.fromJson(Map<String, dynamic> json) =>
      _$PerpOrderResponseFromJson(json);

  static const toJsonFactory = _$PerpOrderResponseToJson;
  Map<String, dynamic> toJson() => _$PerpOrderResponseToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'statuses', defaultValue: <String>[])
  final List<String> statuses;
  static const fromJsonFactory = _$PerpOrderResponseFromJson;
}

extension $PerpOrderResponseExtension on PerpOrderResponse {
  PerpOrderResponse copyWith({String? type, List<String>? statuses}) {
    return PerpOrderResponse(
      type: type ?? this.type,
      statuses: statuses ?? this.statuses,
    );
  }

  PerpOrderResponse copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<List<String>>? statuses,
  }) {
    return PerpOrderResponse(
      type: (type != null ? type.value : this.type),
      statuses: (statuses != null ? statuses.value : this.statuses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BarDto {
  const BarDto({
    required this.time,
    required this.open,
    required this.high,
    required this.low,
    required this.close,
    required this.volume,
  });

  factory BarDto.fromJson(Map<String, dynamic> json) => _$BarDtoFromJson(json);

  static const toJsonFactory = _$BarDtoToJson;
  Map<String, dynamic> toJson() => _$BarDtoToJson(this);

  @JsonKey(name: 'time')
  final double time;
  @JsonKey(name: 'open')
  final double open;
  @JsonKey(name: 'high')
  final double high;
  @JsonKey(name: 'low')
  final double low;
  @JsonKey(name: 'close')
  final double close;
  @JsonKey(name: 'volume')
  final double volume;
  static const fromJsonFactory = _$BarDtoFromJson;
}

extension $BarDtoExtension on BarDto {
  BarDto copyWith({
    double? time,
    double? open,
    double? high,
    double? low,
    double? close,
    double? volume,
  }) {
    return BarDto(
      time: time ?? this.time,
      open: open ?? this.open,
      high: high ?? this.high,
      low: low ?? this.low,
      close: close ?? this.close,
      volume: volume ?? this.volume,
    );
  }

  BarDto copyWithWrapped({
    Wrapped<double>? time,
    Wrapped<double>? open,
    Wrapped<double>? high,
    Wrapped<double>? low,
    Wrapped<double>? close,
    Wrapped<double>? volume,
  }) {
    return BarDto(
      time: (time != null ? time.value : this.time),
      open: (open != null ? open.value : this.open),
      high: (high != null ? high.value : this.high),
      low: (low != null ? low.value : this.low),
      close: (close != null ? close.value : this.close),
      volume: (volume != null ? volume.value : this.volume),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SymbolInfoDto {
  const SymbolInfoDto({
    required this.name,
    required this.ticker,
    required this.description,
    required this.type,
    required this.session,
    required this.timezone,
    required this.exchange,
    required this.minmov,
    required this.pricescale,
    required this.hasIntraday,
    required this.supportedResolutions,
    required this.volumePrecision,
    required this.dataStatus,
  });

  factory SymbolInfoDto.fromJson(Map<String, dynamic> json) =>
      _$SymbolInfoDtoFromJson(json);

  static const toJsonFactory = _$SymbolInfoDtoToJson;
  Map<String, dynamic> toJson() => _$SymbolInfoDtoToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ticker')
  final String ticker;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'session')
  final String session;
  @JsonKey(name: 'timezone')
  final String timezone;
  @JsonKey(name: 'exchange')
  final String exchange;
  @JsonKey(name: 'minmov')
  final double minmov;
  @JsonKey(name: 'pricescale')
  final double pricescale;
  @JsonKey(name: 'has_intraday')
  final bool hasIntraday;
  @JsonKey(name: 'supported_resolutions', defaultValue: <List<Object?>>[])
  final List<List<Object?>> supportedResolutions;
  @JsonKey(name: 'volume_precision')
  final double volumePrecision;
  @JsonKey(
    name: 'data_status',
    toJson: symbolInfoDtoDataStatusToJson,
    fromJson: symbolInfoDtoDataStatusFromJson,
  )
  final enums.SymbolInfoDtoDataStatus dataStatus;
  static const fromJsonFactory = _$SymbolInfoDtoFromJson;
}

extension $SymbolInfoDtoExtension on SymbolInfoDto {
  SymbolInfoDto copyWith({
    String? name,
    String? ticker,
    String? description,
    String? type,
    String? session,
    String? timezone,
    String? exchange,
    double? minmov,
    double? pricescale,
    bool? hasIntraday,
    List<List<Object?>>? supportedResolutions,
    double? volumePrecision,
    enums.SymbolInfoDtoDataStatus? dataStatus,
  }) {
    return SymbolInfoDto(
      name: name ?? this.name,
      ticker: ticker ?? this.ticker,
      description: description ?? this.description,
      type: type ?? this.type,
      session: session ?? this.session,
      timezone: timezone ?? this.timezone,
      exchange: exchange ?? this.exchange,
      minmov: minmov ?? this.minmov,
      pricescale: pricescale ?? this.pricescale,
      hasIntraday: hasIntraday ?? this.hasIntraday,
      supportedResolutions: supportedResolutions ?? this.supportedResolutions,
      volumePrecision: volumePrecision ?? this.volumePrecision,
      dataStatus: dataStatus ?? this.dataStatus,
    );
  }

  SymbolInfoDto copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? ticker,
    Wrapped<String>? description,
    Wrapped<String>? type,
    Wrapped<String>? session,
    Wrapped<String>? timezone,
    Wrapped<String>? exchange,
    Wrapped<double>? minmov,
    Wrapped<double>? pricescale,
    Wrapped<bool>? hasIntraday,
    Wrapped<List<List<Object?>>>? supportedResolutions,
    Wrapped<double>? volumePrecision,
    Wrapped<enums.SymbolInfoDtoDataStatus>? dataStatus,
  }) {
    return SymbolInfoDto(
      name: (name != null ? name.value : this.name),
      ticker: (ticker != null ? ticker.value : this.ticker),
      description: (description != null ? description.value : this.description),
      type: (type != null ? type.value : this.type),
      session: (session != null ? session.value : this.session),
      timezone: (timezone != null ? timezone.value : this.timezone),
      exchange: (exchange != null ? exchange.value : this.exchange),
      minmov: (minmov != null ? minmov.value : this.minmov),
      pricescale: (pricescale != null ? pricescale.value : this.pricescale),
      hasIntraday: (hasIntraday != null ? hasIntraday.value : this.hasIntraday),
      supportedResolutions: (supportedResolutions != null
          ? supportedResolutions.value
          : this.supportedResolutions),
      volumePrecision: (volumePrecision != null
          ? volumePrecision.value
          : this.volumePrecision),
      dataStatus: (dataStatus != null ? dataStatus.value : this.dataStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpSingleCoin {
  const PerpSingleCoin({
    required this.identifier,
    required this.decimals,
    required this.symbol,
  });

  factory PerpSingleCoin.fromJson(Map<String, dynamic> json) =>
      _$PerpSingleCoinFromJson(json);

  static const toJsonFactory = _$PerpSingleCoinToJson;
  Map<String, dynamic> toJson() => _$PerpSingleCoinToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$PerpSingleCoinFromJson;
}

extension $PerpSingleCoinExtension on PerpSingleCoin {
  PerpSingleCoin copyWith({
    String? identifier,
    double? decimals,
    String? symbol,
  }) {
    return PerpSingleCoin(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      symbol: symbol ?? this.symbol,
    );
  }

  PerpSingleCoin copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<double>? decimals,
    Wrapped<String>? symbol,
  }) {
    return PerpSingleCoin(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpSingleAgainstCoin {
  const PerpSingleAgainstCoin({
    required this.identifier,
    required this.decimals,
    required this.symbol,
  });

  factory PerpSingleAgainstCoin.fromJson(Map<String, dynamic> json) =>
      _$PerpSingleAgainstCoinFromJson(json);

  static const toJsonFactory = _$PerpSingleAgainstCoinToJson;
  Map<String, dynamic> toJson() => _$PerpSingleAgainstCoinToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'decimals')
  final double decimals;
  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$PerpSingleAgainstCoinFromJson;
}

extension $PerpSingleAgainstCoinExtension on PerpSingleAgainstCoin {
  PerpSingleAgainstCoin copyWith({
    String? identifier,
    double? decimals,
    String? symbol,
  }) {
    return PerpSingleAgainstCoin(
      identifier: identifier ?? this.identifier,
      decimals: decimals ?? this.decimals,
      symbol: symbol ?? this.symbol,
    );
  }

  PerpSingleAgainstCoin copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<double>? decimals,
    Wrapped<String>? symbol,
  }) {
    return PerpSingleAgainstCoin(
      identifier: (identifier != null ? identifier.value : this.identifier),
      decimals: (decimals != null ? decimals.value : this.decimals),
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpCoinExtended {
  const PerpCoinExtended({
    required this.symbol,
    required this.coin,
    required this.againstCoin,
    required this.config,
  });

  factory PerpCoinExtended.fromJson(Map<String, dynamic> json) =>
      _$PerpCoinExtendedFromJson(json);

  static const toJsonFactory = _$PerpCoinExtendedToJson;
  Map<String, dynamic> toJson() => _$PerpCoinExtendedToJson(this);

  @JsonKey(name: 'symbol')
  final String symbol;
  @JsonKey(name: 'coin')
  final PerpSingleCoin coin;
  @JsonKey(name: 'againstCoin')
  final PerpSingleAgainstCoin againstCoin;
  @JsonKey(name: 'config', defaultValue: <String>[])
  final List<String> config;
  static const fromJsonFactory = _$PerpCoinExtendedFromJson;
}

extension $PerpCoinExtendedExtension on PerpCoinExtended {
  PerpCoinExtended copyWith({
    String? symbol,
    PerpSingleCoin? coin,
    PerpSingleAgainstCoin? againstCoin,
    List<String>? config,
  }) {
    return PerpCoinExtended(
      symbol: symbol ?? this.symbol,
      coin: coin ?? this.coin,
      againstCoin: againstCoin ?? this.againstCoin,
      config: config ?? this.config,
    );
  }

  PerpCoinExtended copyWithWrapped({
    Wrapped<String>? symbol,
    Wrapped<PerpSingleCoin>? coin,
    Wrapped<PerpSingleAgainstCoin>? againstCoin,
    Wrapped<List<String>>? config,
  }) {
    return PerpCoinExtended(
      symbol: (symbol != null ? symbol.value : this.symbol),
      coin: (coin != null ? coin.value : this.coin),
      againstCoin: (againstCoin != null ? againstCoin.value : this.againstCoin),
      config: (config != null ? config.value : this.config),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpSpotCoinExtended {
  const PerpSpotCoinExtended({
    required this.symbol,
    required this.coin,
    required this.againstCoin,
    required this.config,
  });

  factory PerpSpotCoinExtended.fromJson(Map<String, dynamic> json) =>
      _$PerpSpotCoinExtendedFromJson(json);

  static const toJsonFactory = _$PerpSpotCoinExtendedToJson;
  Map<String, dynamic> toJson() => _$PerpSpotCoinExtendedToJson(this);

  @JsonKey(name: 'symbol')
  final String symbol;
  @JsonKey(name: 'coin')
  final PerpSingleCoin coin;
  @JsonKey(name: 'againstCoin')
  final PerpSingleAgainstCoin againstCoin;
  @JsonKey(name: 'config', defaultValue: <String>[])
  final List<String> config;
  static const fromJsonFactory = _$PerpSpotCoinExtendedFromJson;
}

extension $PerpSpotCoinExtendedExtension on PerpSpotCoinExtended {
  PerpSpotCoinExtended copyWith({
    String? symbol,
    PerpSingleCoin? coin,
    PerpSingleAgainstCoin? againstCoin,
    List<String>? config,
  }) {
    return PerpSpotCoinExtended(
      symbol: symbol ?? this.symbol,
      coin: coin ?? this.coin,
      againstCoin: againstCoin ?? this.againstCoin,
      config: config ?? this.config,
    );
  }

  PerpSpotCoinExtended copyWithWrapped({
    Wrapped<String>? symbol,
    Wrapped<PerpSingleCoin>? coin,
    Wrapped<PerpSingleAgainstCoin>? againstCoin,
    Wrapped<List<String>>? config,
  }) {
    return PerpSpotCoinExtended(
      symbol: (symbol != null ? symbol.value : this.symbol),
      coin: (coin != null ? coin.value : this.coin),
      againstCoin: (againstCoin != null ? againstCoin.value : this.againstCoin),
      config: (config != null ? config.value : this.config),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpCoinExtendedSlim {
  const PerpCoinExtendedSlim({required this.symbol});

  factory PerpCoinExtendedSlim.fromJson(Map<String, dynamic> json) =>
      _$PerpCoinExtendedSlimFromJson(json);

  static const toJsonFactory = _$PerpCoinExtendedSlimToJson;
  Map<String, dynamic> toJson() => _$PerpCoinExtendedSlimToJson(this);

  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$PerpCoinExtendedSlimFromJson;
}

extension $PerpCoinExtendedSlimExtension on PerpCoinExtendedSlim {
  PerpCoinExtendedSlim copyWith({String? symbol}) {
    return PerpCoinExtendedSlim(symbol: symbol ?? this.symbol);
  }

  PerpCoinExtendedSlim copyWithWrapped({Wrapped<String>? symbol}) {
    return PerpCoinExtendedSlim(
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpLegalCheck {
  const PerpLegalCheck({
    required this.ipAllowed,
    required this.acceptedTerms,
    required this.userAllowed,
  });

  factory PerpLegalCheck.fromJson(Map<String, dynamic> json) =>
      _$PerpLegalCheckFromJson(json);

  static const toJsonFactory = _$PerpLegalCheckToJson;
  Map<String, dynamic> toJson() => _$PerpLegalCheckToJson(this);

  @JsonKey(name: 'ipAllowed')
  final bool ipAllowed;
  @JsonKey(name: 'acceptedTerms')
  final bool acceptedTerms;
  @JsonKey(name: 'userAllowed')
  final bool userAllowed;
  static const fromJsonFactory = _$PerpLegalCheckFromJson;
}

extension $PerpLegalCheckExtension on PerpLegalCheck {
  PerpLegalCheck copyWith({
    bool? ipAllowed,
    bool? acceptedTerms,
    bool? userAllowed,
  }) {
    return PerpLegalCheck(
      ipAllowed: ipAllowed ?? this.ipAllowed,
      acceptedTerms: acceptedTerms ?? this.acceptedTerms,
      userAllowed: userAllowed ?? this.userAllowed,
    );
  }

  PerpLegalCheck copyWithWrapped({
    Wrapped<bool>? ipAllowed,
    Wrapped<bool>? acceptedTerms,
    Wrapped<bool>? userAllowed,
  }) {
    return PerpLegalCheck(
      ipAllowed: (ipAllowed != null ? ipAllowed.value : this.ipAllowed),
      acceptedTerms: (acceptedTerms != null
          ? acceptedTerms.value
          : this.acceptedTerms),
      userAllowed: (userAllowed != null ? userAllowed.value : this.userAllowed),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PerpSpotCoinExtendedSlim {
  const PerpSpotCoinExtendedSlim({required this.symbol});

  factory PerpSpotCoinExtendedSlim.fromJson(Map<String, dynamic> json) =>
      _$PerpSpotCoinExtendedSlimFromJson(json);

  static const toJsonFactory = _$PerpSpotCoinExtendedSlimToJson;
  Map<String, dynamic> toJson() => _$PerpSpotCoinExtendedSlimToJson(this);

  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$PerpSpotCoinExtendedSlimFromJson;
}

extension $PerpSpotCoinExtendedSlimExtension on PerpSpotCoinExtendedSlim {
  PerpSpotCoinExtendedSlim copyWith({String? symbol}) {
    return PerpSpotCoinExtendedSlim(symbol: symbol ?? this.symbol);
  }

  PerpSpotCoinExtendedSlim copyWithWrapped({Wrapped<String>? symbol}) {
    return PerpSpotCoinExtendedSlim(
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class L2BookPerpResponseSingle {
  const L2BookPerpResponseSingle({
    required this.px,
    required this.sz,
    required this.n,
  });

  factory L2BookPerpResponseSingle.fromJson(Map<String, dynamic> json) =>
      _$L2BookPerpResponseSingleFromJson(json);

  static const toJsonFactory = _$L2BookPerpResponseSingleToJson;
  Map<String, dynamic> toJson() => _$L2BookPerpResponseSingleToJson(this);

  @JsonKey(name: 'px')
  final String px;
  @JsonKey(name: 'sz')
  final String sz;
  @JsonKey(name: 'n')
  final double n;
  static const fromJsonFactory = _$L2BookPerpResponseSingleFromJson;
}

extension $L2BookPerpResponseSingleExtension on L2BookPerpResponseSingle {
  L2BookPerpResponseSingle copyWith({String? px, String? sz, double? n}) {
    return L2BookPerpResponseSingle(
      px: px ?? this.px,
      sz: sz ?? this.sz,
      n: n ?? this.n,
    );
  }

  L2BookPerpResponseSingle copyWithWrapped({
    Wrapped<String>? px,
    Wrapped<String>? sz,
    Wrapped<double>? n,
  }) {
    return L2BookPerpResponseSingle(
      px: (px != null ? px.value : this.px),
      sz: (sz != null ? sz.value : this.sz),
      n: (n != null ? n.value : this.n),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradesPerpResponseSingle {
  const TradesPerpResponseSingle({
    required this.side,
    required this.px,
    required this.sz,
    required this.time,
    required this.hash,
    required this.users,
  });

  factory TradesPerpResponseSingle.fromJson(Map<String, dynamic> json) =>
      _$TradesPerpResponseSingleFromJson(json);

  static const toJsonFactory = _$TradesPerpResponseSingleToJson;
  Map<String, dynamic> toJson() => _$TradesPerpResponseSingleToJson(this);

  @JsonKey(name: 'side')
  final String side;
  @JsonKey(name: 'px')
  final String px;
  @JsonKey(name: 'sz')
  final String sz;
  @JsonKey(name: 'time')
  final double time;
  @JsonKey(name: 'hash')
  final String hash;
  @JsonKey(name: 'users', defaultValue: <String>[])
  final List<String> users;
  static const fromJsonFactory = _$TradesPerpResponseSingleFromJson;
}

extension $TradesPerpResponseSingleExtension on TradesPerpResponseSingle {
  TradesPerpResponseSingle copyWith({
    String? side,
    String? px,
    String? sz,
    double? time,
    String? hash,
    List<String>? users,
  }) {
    return TradesPerpResponseSingle(
      side: side ?? this.side,
      px: px ?? this.px,
      sz: sz ?? this.sz,
      time: time ?? this.time,
      hash: hash ?? this.hash,
      users: users ?? this.users,
    );
  }

  TradesPerpResponseSingle copyWithWrapped({
    Wrapped<String>? side,
    Wrapped<String>? px,
    Wrapped<String>? sz,
    Wrapped<double>? time,
    Wrapped<String>? hash,
    Wrapped<List<String>>? users,
  }) {
    return TradesPerpResponseSingle(
      side: (side != null ? side.value : this.side),
      px: (px != null ? px.value : this.px),
      sz: (sz != null ? sz.value : this.sz),
      time: (time != null ? time.value : this.time),
      hash: (hash != null ? hash.value : this.hash),
      users: (users != null ? users.value : this.users),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveSpotAssetCtx {
  const ActiveSpotAssetCtx({
    required this.prevDayPx,
    required this.dayNtlVlm,
    required this.markPx,
    required this.midPx,
    required this.dayBaseVlm,
    required this.circulatingSupply,
    required this.totalSupply,
  });

  factory ActiveSpotAssetCtx.fromJson(Map<String, dynamic> json) =>
      _$ActiveSpotAssetCtxFromJson(json);

  static const toJsonFactory = _$ActiveSpotAssetCtxToJson;
  Map<String, dynamic> toJson() => _$ActiveSpotAssetCtxToJson(this);

  @JsonKey(name: 'prevDayPx')
  final String prevDayPx;
  @JsonKey(name: 'dayNtlVlm')
  final String dayNtlVlm;
  @JsonKey(name: 'markPx')
  final String markPx;
  @JsonKey(name: 'midPx')
  final String midPx;
  @JsonKey(name: 'dayBaseVlm')
  final String dayBaseVlm;
  @JsonKey(name: 'circulatingSupply')
  final String circulatingSupply;
  @JsonKey(name: 'totalSupply')
  final String totalSupply;
  static const fromJsonFactory = _$ActiveSpotAssetCtxFromJson;
}

extension $ActiveSpotAssetCtxExtension on ActiveSpotAssetCtx {
  ActiveSpotAssetCtx copyWith({
    String? prevDayPx,
    String? dayNtlVlm,
    String? markPx,
    String? midPx,
    String? dayBaseVlm,
    String? circulatingSupply,
    String? totalSupply,
  }) {
    return ActiveSpotAssetCtx(
      prevDayPx: prevDayPx ?? this.prevDayPx,
      dayNtlVlm: dayNtlVlm ?? this.dayNtlVlm,
      markPx: markPx ?? this.markPx,
      midPx: midPx ?? this.midPx,
      dayBaseVlm: dayBaseVlm ?? this.dayBaseVlm,
      circulatingSupply: circulatingSupply ?? this.circulatingSupply,
      totalSupply: totalSupply ?? this.totalSupply,
    );
  }

  ActiveSpotAssetCtx copyWithWrapped({
    Wrapped<String>? prevDayPx,
    Wrapped<String>? dayNtlVlm,
    Wrapped<String>? markPx,
    Wrapped<String>? midPx,
    Wrapped<String>? dayBaseVlm,
    Wrapped<String>? circulatingSupply,
    Wrapped<String>? totalSupply,
  }) {
    return ActiveSpotAssetCtx(
      prevDayPx: (prevDayPx != null ? prevDayPx.value : this.prevDayPx),
      dayNtlVlm: (dayNtlVlm != null ? dayNtlVlm.value : this.dayNtlVlm),
      markPx: (markPx != null ? markPx.value : this.markPx),
      midPx: (midPx != null ? midPx.value : this.midPx),
      dayBaseVlm: (dayBaseVlm != null ? dayBaseVlm.value : this.dayBaseVlm),
      circulatingSupply: (circulatingSupply != null
          ? circulatingSupply.value
          : this.circulatingSupply),
      totalSupply: (totalSupply != null ? totalSupply.value : this.totalSupply),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActivePerpAssetCtx {
  const ActivePerpAssetCtx({
    required this.prevDayPx,
    required this.dayNtlVlm,
    required this.markPx,
    required this.midPx,
    required this.dayBaseVlm,
    required this.funding,
    required this.openInterest,
    required this.premium,
    required this.oraclePx,
    required this.impactTxs,
  });

  factory ActivePerpAssetCtx.fromJson(Map<String, dynamic> json) =>
      _$ActivePerpAssetCtxFromJson(json);

  static const toJsonFactory = _$ActivePerpAssetCtxToJson;
  Map<String, dynamic> toJson() => _$ActivePerpAssetCtxToJson(this);

  @JsonKey(name: 'prevDayPx')
  final String prevDayPx;
  @JsonKey(name: 'dayNtlVlm')
  final String dayNtlVlm;
  @JsonKey(name: 'markPx')
  final String markPx;
  @JsonKey(name: 'midPx')
  final String midPx;
  @JsonKey(name: 'dayBaseVlm')
  final String dayBaseVlm;
  @JsonKey(name: 'funding')
  final String funding;
  @JsonKey(name: 'openInterest')
  final String openInterest;
  @JsonKey(name: 'premium')
  final String premium;
  @JsonKey(name: 'oraclePx')
  final String oraclePx;
  @JsonKey(name: 'impactTxs', defaultValue: <String>[])
  final List<String> impactTxs;
  static const fromJsonFactory = _$ActivePerpAssetCtxFromJson;
}

extension $ActivePerpAssetCtxExtension on ActivePerpAssetCtx {
  ActivePerpAssetCtx copyWith({
    String? prevDayPx,
    String? dayNtlVlm,
    String? markPx,
    String? midPx,
    String? dayBaseVlm,
    String? funding,
    String? openInterest,
    String? premium,
    String? oraclePx,
    List<String>? impactTxs,
  }) {
    return ActivePerpAssetCtx(
      prevDayPx: prevDayPx ?? this.prevDayPx,
      dayNtlVlm: dayNtlVlm ?? this.dayNtlVlm,
      markPx: markPx ?? this.markPx,
      midPx: midPx ?? this.midPx,
      dayBaseVlm: dayBaseVlm ?? this.dayBaseVlm,
      funding: funding ?? this.funding,
      openInterest: openInterest ?? this.openInterest,
      premium: premium ?? this.premium,
      oraclePx: oraclePx ?? this.oraclePx,
      impactTxs: impactTxs ?? this.impactTxs,
    );
  }

  ActivePerpAssetCtx copyWithWrapped({
    Wrapped<String>? prevDayPx,
    Wrapped<String>? dayNtlVlm,
    Wrapped<String>? markPx,
    Wrapped<String>? midPx,
    Wrapped<String>? dayBaseVlm,
    Wrapped<String>? funding,
    Wrapped<String>? openInterest,
    Wrapped<String>? premium,
    Wrapped<String>? oraclePx,
    Wrapped<List<String>>? impactTxs,
  }) {
    return ActivePerpAssetCtx(
      prevDayPx: (prevDayPx != null ? prevDayPx.value : this.prevDayPx),
      dayNtlVlm: (dayNtlVlm != null ? dayNtlVlm.value : this.dayNtlVlm),
      markPx: (markPx != null ? markPx.value : this.markPx),
      midPx: (midPx != null ? midPx.value : this.midPx),
      dayBaseVlm: (dayBaseVlm != null ? dayBaseVlm.value : this.dayBaseVlm),
      funding: (funding != null ? funding.value : this.funding),
      openInterest: (openInterest != null
          ? openInterest.value
          : this.openInterest),
      premium: (premium != null ? premium.value : this.premium),
      oraclePx: (oraclePx != null ? oraclePx.value : this.oraclePx),
      impactTxs: (impactTxs != null ? impactTxs.value : this.impactTxs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class L2BookPerpEvent {
  const L2BookPerpEvent({
    required this.type,
    required this.symbol,
    required this.sigFigs,
    required this.mantissa,
  });

  factory L2BookPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$L2BookPerpEventFromJson(json);

  static const toJsonFactory = _$L2BookPerpEventToJson;
  Map<String, dynamic> toJson() => _$L2BookPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'symbol')
  final String symbol;
  @JsonKey(name: 'sigFigs')
  final double sigFigs;
  @JsonKey(name: 'mantissa')
  final Object mantissa;
  static const fromJsonFactory = _$L2BookPerpEventFromJson;
}

extension $L2BookPerpEventExtension on L2BookPerpEvent {
  L2BookPerpEvent copyWith({
    String? type,
    String? symbol,
    double? sigFigs,
    Object? mantissa,
  }) {
    return L2BookPerpEvent(
      type: type ?? this.type,
      symbol: symbol ?? this.symbol,
      sigFigs: sigFigs ?? this.sigFigs,
      mantissa: mantissa ?? this.mantissa,
    );
  }

  L2BookPerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? symbol,
    Wrapped<double>? sigFigs,
    Wrapped<Object>? mantissa,
  }) {
    return L2BookPerpEvent(
      type: (type != null ? type.value : this.type),
      symbol: (symbol != null ? symbol.value : this.symbol),
      sigFigs: (sigFigs != null ? sigFigs.value : this.sigFigs),
      mantissa: (mantissa != null ? mantissa.value : this.mantissa),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradesPerpEvent {
  const TradesPerpEvent({required this.type, required this.symbol});

  factory TradesPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$TradesPerpEventFromJson(json);

  static const toJsonFactory = _$TradesPerpEventToJson;
  Map<String, dynamic> toJson() => _$TradesPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$TradesPerpEventFromJson;
}

extension $TradesPerpEventExtension on TradesPerpEvent {
  TradesPerpEvent copyWith({String? type, String? symbol}) {
    return TradesPerpEvent(
      type: type ?? this.type,
      symbol: symbol ?? this.symbol,
    );
  }

  TradesPerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? symbol,
  }) {
    return TradesPerpEvent(
      type: (type != null ? type.value : this.type),
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveSpotAssetPerpEvent {
  const ActiveSpotAssetPerpEvent({required this.type, required this.symbol});

  factory ActiveSpotAssetPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$ActiveSpotAssetPerpEventFromJson(json);

  static const toJsonFactory = _$ActiveSpotAssetPerpEventToJson;
  Map<String, dynamic> toJson() => _$ActiveSpotAssetPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$ActiveSpotAssetPerpEventFromJson;
}

extension $ActiveSpotAssetPerpEventExtension on ActiveSpotAssetPerpEvent {
  ActiveSpotAssetPerpEvent copyWith({String? type, String? symbol}) {
    return ActiveSpotAssetPerpEvent(
      type: type ?? this.type,
      symbol: symbol ?? this.symbol,
    );
  }

  ActiveSpotAssetPerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? symbol,
  }) {
    return ActiveSpotAssetPerpEvent(
      type: (type != null ? type.value : this.type),
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveAssetPerpEvent {
  const ActiveAssetPerpEvent({required this.type, required this.symbol});

  factory ActiveAssetPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$ActiveAssetPerpEventFromJson(json);

  static const toJsonFactory = _$ActiveAssetPerpEventToJson;
  Map<String, dynamic> toJson() => _$ActiveAssetPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'symbol')
  final String symbol;
  static const fromJsonFactory = _$ActiveAssetPerpEventFromJson;
}

extension $ActiveAssetPerpEventExtension on ActiveAssetPerpEvent {
  ActiveAssetPerpEvent copyWith({String? type, String? symbol}) {
    return ActiveAssetPerpEvent(
      type: type ?? this.type,
      symbol: symbol ?? this.symbol,
    );
  }

  ActiveAssetPerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? symbol,
  }) {
    return ActiveAssetPerpEvent(
      type: (type != null ? type.value : this.type),
      symbol: (symbol != null ? symbol.value : this.symbol),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveSpotAssetsPerpEvent {
  const ActiveSpotAssetsPerpEvent({required this.type});

  factory ActiveSpotAssetsPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$ActiveSpotAssetsPerpEventFromJson(json);

  static const toJsonFactory = _$ActiveSpotAssetsPerpEventToJson;
  Map<String, dynamic> toJson() => _$ActiveSpotAssetsPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$ActiveSpotAssetsPerpEventFromJson;
}

extension $ActiveSpotAssetsPerpEventExtension on ActiveSpotAssetsPerpEvent {
  ActiveSpotAssetsPerpEvent copyWith({String? type}) {
    return ActiveSpotAssetsPerpEvent(type: type ?? this.type);
  }

  ActiveSpotAssetsPerpEvent copyWithWrapped({Wrapped<String>? type}) {
    return ActiveSpotAssetsPerpEvent(
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ActiveAssetsPerpEvent {
  const ActiveAssetsPerpEvent({required this.type});

  factory ActiveAssetsPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$ActiveAssetsPerpEventFromJson(json);

  static const toJsonFactory = _$ActiveAssetsPerpEventToJson;
  Map<String, dynamic> toJson() => _$ActiveAssetsPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$ActiveAssetsPerpEventFromJson;
}

extension $ActiveAssetsPerpEventExtension on ActiveAssetsPerpEvent {
  ActiveAssetsPerpEvent copyWith({String? type}) {
    return ActiveAssetsPerpEvent(type: type ?? this.type);
  }

  ActiveAssetsPerpEvent copyWithWrapped({Wrapped<String>? type}) {
    return ActiveAssetsPerpEvent(type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class WebData3PerpEvent {
  const WebData3PerpEvent({required this.type, required this.user});

  factory WebData3PerpEvent.fromJson(Map<String, dynamic> json) =>
      _$WebData3PerpEventFromJson(json);

  static const toJsonFactory = _$WebData3PerpEventToJson;
  Map<String, dynamic> toJson() => _$WebData3PerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'user')
  final String user;
  static const fromJsonFactory = _$WebData3PerpEventFromJson;
}

extension $WebData3PerpEventExtension on WebData3PerpEvent {
  WebData3PerpEvent copyWith({String? type, String? user}) {
    return WebData3PerpEvent(type: type ?? this.type, user: user ?? this.user);
  }

  WebData3PerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? user,
  }) {
    return WebData3PerpEvent(
      type: (type != null ? type.value : this.type),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SpotStatePerpEvent {
  const SpotStatePerpEvent({required this.type, required this.user});

  factory SpotStatePerpEvent.fromJson(Map<String, dynamic> json) =>
      _$SpotStatePerpEventFromJson(json);

  static const toJsonFactory = _$SpotStatePerpEventToJson;
  Map<String, dynamic> toJson() => _$SpotStatePerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'user')
  final String user;
  static const fromJsonFactory = _$SpotStatePerpEventFromJson;
}

extension $SpotStatePerpEventExtension on SpotStatePerpEvent {
  SpotStatePerpEvent copyWith({String? type, String? user}) {
    return SpotStatePerpEvent(type: type ?? this.type, user: user ?? this.user);
  }

  SpotStatePerpEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? user,
  }) {
    return SpotStatePerpEvent(
      type: (type != null ? type.value : this.type),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserOpenOrderEvent {
  const UserOpenOrderEvent({required this.type, required this.user});

  factory UserOpenOrderEvent.fromJson(Map<String, dynamic> json) =>
      _$UserOpenOrderEventFromJson(json);

  static const toJsonFactory = _$UserOpenOrderEventToJson;
  Map<String, dynamic> toJson() => _$UserOpenOrderEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'user')
  final String user;
  static const fromJsonFactory = _$UserOpenOrderEventFromJson;
}

extension $UserOpenOrderEventExtension on UserOpenOrderEvent {
  UserOpenOrderEvent copyWith({String? type, String? user}) {
    return UserOpenOrderEvent(type: type ?? this.type, user: user ?? this.user);
  }

  UserOpenOrderEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? user,
  }) {
    return UserOpenOrderEvent(
      type: (type != null ? type.value : this.type),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserFilledOrderEvent {
  const UserFilledOrderEvent({
    required this.type,
    required this.user,
    required this.aggregateByTime,
  });

  factory UserFilledOrderEvent.fromJson(Map<String, dynamic> json) =>
      _$UserFilledOrderEventFromJson(json);

  static const toJsonFactory = _$UserFilledOrderEventToJson;
  Map<String, dynamic> toJson() => _$UserFilledOrderEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'user')
  final String user;
  @JsonKey(name: 'aggregateByTime')
  final bool aggregateByTime;
  static const fromJsonFactory = _$UserFilledOrderEventFromJson;
}

extension $UserFilledOrderEventExtension on UserFilledOrderEvent {
  UserFilledOrderEvent copyWith({
    String? type,
    String? user,
    bool? aggregateByTime,
  }) {
    return UserFilledOrderEvent(
      type: type ?? this.type,
      user: user ?? this.user,
      aggregateByTime: aggregateByTime ?? this.aggregateByTime,
    );
  }

  UserFilledOrderEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? user,
    Wrapped<bool>? aggregateByTime,
  }) {
    return UserFilledOrderEvent(
      type: (type != null ? type.value : this.type),
      user: (user != null ? user.value : this.user),
      aggregateByTime: (aggregateByTime != null
          ? aggregateByTime.value
          : this.aggregateByTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserHistoricalOrderEvent {
  const UserHistoricalOrderEvent({required this.type, required this.user});

  factory UserHistoricalOrderEvent.fromJson(Map<String, dynamic> json) =>
      _$UserHistoricalOrderEventFromJson(json);

  static const toJsonFactory = _$UserHistoricalOrderEventToJson;
  Map<String, dynamic> toJson() => _$UserHistoricalOrderEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'user')
  final String user;
  static const fromJsonFactory = _$UserHistoricalOrderEventFromJson;
}

extension $UserHistoricalOrderEventExtension on UserHistoricalOrderEvent {
  UserHistoricalOrderEvent copyWith({String? type, String? user}) {
    return UserHistoricalOrderEvent(
      type: type ?? this.type,
      user: user ?? this.user,
    );
  }

  UserHistoricalOrderEvent copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? user,
  }) {
    return UserHistoricalOrderEvent(
      type: (type != null ? type.value : this.type),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AllMidsPerpEvent {
  const AllMidsPerpEvent({required this.type});

  factory AllMidsPerpEvent.fromJson(Map<String, dynamic> json) =>
      _$AllMidsPerpEventFromJson(json);

  static const toJsonFactory = _$AllMidsPerpEventToJson;
  Map<String, dynamic> toJson() => _$AllMidsPerpEventToJson(this);

  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$AllMidsPerpEventFromJson;
}

extension $AllMidsPerpEventExtension on AllMidsPerpEvent {
  AllMidsPerpEvent copyWith({String? type}) {
    return AllMidsPerpEvent(type: type ?? this.type);
  }

  AllMidsPerpEvent copyWithWrapped({Wrapped<String>? type}) {
    return AllMidsPerpEvent(type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class PerpEvent {
  const PerpEvent({required this.event});

  factory PerpEvent.fromJson(Map<String, dynamic> json) =>
      _$PerpEventFromJson(json);

  static const toJsonFactory = _$PerpEventToJson;
  Map<String, dynamic> toJson() => _$PerpEventToJson(this);

  @JsonKey(name: 'event')
  final dynamic event;
  static const fromJsonFactory = _$PerpEventFromJson;
}

extension $PerpEventExtension on PerpEvent {
  PerpEvent copyWith({dynamic event}) {
    return PerpEvent(event: event ?? this.event);
  }

  PerpEvent copyWithWrapped({Wrapped<dynamic>? event}) {
    return PerpEvent(event: (event != null ? event.value : this.event));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityDataDto {
  const ActivityDataDto({this.collection, this.identifier});

  factory ActivityDataDto.fromJson(Map<String, dynamic> json) =>
      _$ActivityDataDtoFromJson(json);

  static const toJsonFactory = _$ActivityDataDtoToJson;
  Map<String, dynamic> toJson() => _$ActivityDataDtoToJson(this);

  @JsonKey(name: 'collection', defaultValue: <String>[])
  final List<String>? collection;
  @JsonKey(name: 'identifier', defaultValue: <String>[])
  final List<String>? identifier;
  static const fromJsonFactory = _$ActivityDataDtoFromJson;
}

extension $ActivityDataDtoExtension on ActivityDataDto {
  ActivityDataDto copyWith({
    List<String>? collection,
    List<String>? identifier,
  }) {
    return ActivityDataDto(
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
    );
  }

  ActivityDataDto copyWithWrapped({
    Wrapped<List<String>?>? collection,
    Wrapped<List<String>?>? identifier,
  }) {
    return ActivityDataDto(
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityFilterCriteriaDto {
  const NftActivityFilterCriteriaDto({
    this.txHash,
    this.activityAddress,
    this.from,
    this.to,
    this.activityType,
    this.source,
    this.range,
    this.activityData,
  });

  factory NftActivityFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$NftActivityFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$NftActivityFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$NftActivityFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'txHash', defaultValue: <String>[])
  final List<String>? txHash;
  @JsonKey(name: 'activityAddress', defaultValue: <String>[])
  final List<String>? activityAddress;
  @JsonKey(name: 'from', defaultValue: <String>[])
  final List<String>? from;
  @JsonKey(name: 'to', defaultValue: <String>[])
  final List<String>? to;
  @JsonKey(
    name: 'activityType',
    toJson: nftActivityTypeListToJson,
    fromJson: nftActivityTypeListFromJson,
  )
  final List<enums.NftActivityType>? activityType;
  @JsonKey(
    name: 'source',
    toJson: nftActivityEventSourceListToJson,
    fromJson: nftActivityEventSourceListFromJson,
  )
  final List<enums.NftActivityEventSource>? source;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'activityData')
  final ActivityDataDto? activityData;
  static const fromJsonFactory = _$NftActivityFilterCriteriaDtoFromJson;
}

extension $NftActivityFilterCriteriaDtoExtension
    on NftActivityFilterCriteriaDto {
  NftActivityFilterCriteriaDto copyWith({
    List<String>? txHash,
    List<String>? activityAddress,
    List<String>? from,
    List<String>? to,
    List<enums.NftActivityType>? activityType,
    List<enums.NftActivityEventSource>? source,
    List<RangeFilter>? range,
    ActivityDataDto? activityData,
  }) {
    return NftActivityFilterCriteriaDto(
      txHash: txHash ?? this.txHash,
      activityAddress: activityAddress ?? this.activityAddress,
      from: from ?? this.from,
      to: to ?? this.to,
      activityType: activityType ?? this.activityType,
      source: source ?? this.source,
      range: range ?? this.range,
      activityData: activityData ?? this.activityData,
    );
  }

  NftActivityFilterCriteriaDto copyWithWrapped({
    Wrapped<List<String>?>? txHash,
    Wrapped<List<String>?>? activityAddress,
    Wrapped<List<String>?>? from,
    Wrapped<List<String>?>? to,
    Wrapped<List<enums.NftActivityType>?>? activityType,
    Wrapped<List<enums.NftActivityEventSource>?>? source,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<ActivityDataDto?>? activityData,
  }) {
    return NftActivityFilterCriteriaDto(
      txHash: (txHash != null ? txHash.value : this.txHash),
      activityAddress: (activityAddress != null
          ? activityAddress.value
          : this.activityAddress),
      from: (from != null ? from.value : this.from),
      to: (to != null ? to.value : this.to),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      source: (source != null ? source.value : this.source),
      range: (range != null ? range.value : this.range),
      activityData: (activityData != null
          ? activityData.value
          : this.activityData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityFilter {
  const NftActivityFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    this.filters,
  });

  factory NftActivityFilter.fromJson(Map<String, dynamic> json) =>
      _$NftActivityFilterFromJson(json);

  static const toJsonFactory = _$NftActivityFilterToJson;
  Map<String, dynamic> toJson() => _$NftActivityFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount')
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final NftActivityFilterCriteriaDto? filters;
  static const fromJsonFactory = _$NftActivityFilterFromJson;
}

extension $NftActivityFilterExtension on NftActivityFilter {
  NftActivityFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    NftActivityFilterCriteriaDto? filters,
  }) {
    return NftActivityFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  NftActivityFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<NftActivityFilterCriteriaDto?>? filters,
  }) {
    return NftActivityFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortNftDoc {
  const ShortNftDoc({
    required this.identifier,
    required this.collection,
    required this.name,
    required this.url,
    required this.wasProcessed,
    this.media,
    this.metadata,
  });

  factory ShortNftDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortNftDocFromJson(json);

  static const toJsonFactory = _$ShortNftDocToJson;
  Map<String, dynamic> toJson() => _$ShortNftDocToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'wasProcessed')
  final bool wasProcessed;
  @JsonKey(name: 'media')
  final NftMedia? media;
  @JsonKey(name: 'metadata')
  final NftMetadata? metadata;
  static const fromJsonFactory = _$ShortNftDocFromJson;
}

extension $ShortNftDocExtension on ShortNftDoc {
  ShortNftDoc copyWith({
    String? identifier,
    String? collection,
    String? name,
    String? url,
    bool? wasProcessed,
    NftMedia? media,
    NftMetadata? metadata,
  }) {
    return ShortNftDoc(
      identifier: identifier ?? this.identifier,
      collection: collection ?? this.collection,
      name: name ?? this.name,
      url: url ?? this.url,
      wasProcessed: wasProcessed ?? this.wasProcessed,
      media: media ?? this.media,
      metadata: metadata ?? this.metadata,
    );
  }

  ShortNftDoc copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? collection,
    Wrapped<String>? name,
    Wrapped<String>? url,
    Wrapped<bool>? wasProcessed,
    Wrapped<NftMedia?>? media,
    Wrapped<NftMetadata?>? metadata,
  }) {
    return ShortNftDoc(
      identifier: (identifier != null ? identifier.value : this.identifier),
      collection: (collection != null ? collection.value : this.collection),
      name: (name != null ? name.value : this.name),
      url: (url != null ? url.value : this.url),
      wasProcessed: (wasProcessed != null
          ? wasProcessed.value
          : this.wasProcessed),
      media: (media != null ? media.value : this.media),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDataHydrated {
  const NftActivityDataHydrated({
    required this.collection,
    this.identifier,
    required this.price,
    required this.paymentToken,
    required this.quantity,
    required this.scId,
    required this.usdValue,
    required this.egldValue,
    this.auctionType,
    this.deadline,
    this.originalPayment,
    this.originalTokenAmount,
    this.originalTokenAmountShort,
    this.originalTokenEgldValue,
    this.originalTokenUsdValue,
    this.originalTokenIdentifier,
    required this.nftInfo,
    required this.collectionInfo,
  });

  factory NftActivityDataHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityDataHydratedFromJson(json);

  static const toJsonFactory = _$NftActivityDataHydratedToJson;
  Map<String, dynamic> toJson() => _$NftActivityDataHydratedToJson(this);

  @JsonKey(name: 'collection')
  final String collection;
  @JsonKey(name: 'identifier')
  final String? identifier;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'scId')
  final int scId;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'egldValue')
  final double egldValue;
  @JsonKey(
    name: 'auctionType',
    toJson: nftActivityDataHydratedAuctionTypeNullableToJson,
    fromJson: nftActivityDataHydratedAuctionTypeNullableFromJson,
  )
  final enums.NftActivityDataHydratedAuctionType? auctionType;
  @JsonKey(name: 'deadline')
  final int? deadline;
  @JsonKey(name: 'originalPayment')
  final NftActivityDataHydrated$OriginalPayment? originalPayment;
  @JsonKey(name: 'originalTokenAmount')
  final String? originalTokenAmount;
  @JsonKey(name: 'originalTokenAmountShort')
  final double? originalTokenAmountShort;
  @JsonKey(name: 'originalTokenEgldValue')
  final double? originalTokenEgldValue;
  @JsonKey(name: 'originalTokenUsdValue')
  final double? originalTokenUsdValue;
  @JsonKey(name: 'originalTokenIdentifier')
  final String? originalTokenIdentifier;
  @JsonKey(name: 'nftInfo')
  final ShortNftDoc nftInfo;
  @JsonKey(name: 'collectionInfo')
  final ShortCollectionDoc collectionInfo;
  static const fromJsonFactory = _$NftActivityDataHydratedFromJson;
}

extension $NftActivityDataHydratedExtension on NftActivityDataHydrated {
  NftActivityDataHydrated copyWith({
    String? collection,
    String? identifier,
    double? price,
    String? paymentToken,
    int? quantity,
    int? scId,
    double? usdValue,
    double? egldValue,
    enums.NftActivityDataHydratedAuctionType? auctionType,
    int? deadline,
    NftActivityDataHydrated$OriginalPayment? originalPayment,
    String? originalTokenAmount,
    double? originalTokenAmountShort,
    double? originalTokenEgldValue,
    double? originalTokenUsdValue,
    String? originalTokenIdentifier,
    ShortNftDoc? nftInfo,
    ShortCollectionDoc? collectionInfo,
  }) {
    return NftActivityDataHydrated(
      collection: collection ?? this.collection,
      identifier: identifier ?? this.identifier,
      price: price ?? this.price,
      paymentToken: paymentToken ?? this.paymentToken,
      quantity: quantity ?? this.quantity,
      scId: scId ?? this.scId,
      usdValue: usdValue ?? this.usdValue,
      egldValue: egldValue ?? this.egldValue,
      auctionType: auctionType ?? this.auctionType,
      deadline: deadline ?? this.deadline,
      originalPayment: originalPayment ?? this.originalPayment,
      originalTokenAmount: originalTokenAmount ?? this.originalTokenAmount,
      originalTokenAmountShort:
          originalTokenAmountShort ?? this.originalTokenAmountShort,
      originalTokenEgldValue:
          originalTokenEgldValue ?? this.originalTokenEgldValue,
      originalTokenUsdValue:
          originalTokenUsdValue ?? this.originalTokenUsdValue,
      originalTokenIdentifier:
          originalTokenIdentifier ?? this.originalTokenIdentifier,
      nftInfo: nftInfo ?? this.nftInfo,
      collectionInfo: collectionInfo ?? this.collectionInfo,
    );
  }

  NftActivityDataHydrated copyWithWrapped({
    Wrapped<String>? collection,
    Wrapped<String?>? identifier,
    Wrapped<double>? price,
    Wrapped<String>? paymentToken,
    Wrapped<int>? quantity,
    Wrapped<int>? scId,
    Wrapped<double>? usdValue,
    Wrapped<double>? egldValue,
    Wrapped<enums.NftActivityDataHydratedAuctionType?>? auctionType,
    Wrapped<int?>? deadline,
    Wrapped<NftActivityDataHydrated$OriginalPayment?>? originalPayment,
    Wrapped<String?>? originalTokenAmount,
    Wrapped<double?>? originalTokenAmountShort,
    Wrapped<double?>? originalTokenEgldValue,
    Wrapped<double?>? originalTokenUsdValue,
    Wrapped<String?>? originalTokenIdentifier,
    Wrapped<ShortNftDoc>? nftInfo,
    Wrapped<ShortCollectionDoc>? collectionInfo,
  }) {
    return NftActivityDataHydrated(
      collection: (collection != null ? collection.value : this.collection),
      identifier: (identifier != null ? identifier.value : this.identifier),
      price: (price != null ? price.value : this.price),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      quantity: (quantity != null ? quantity.value : this.quantity),
      scId: (scId != null ? scId.value : this.scId),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      egldValue: (egldValue != null ? egldValue.value : this.egldValue),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      deadline: (deadline != null ? deadline.value : this.deadline),
      originalPayment: (originalPayment != null
          ? originalPayment.value
          : this.originalPayment),
      originalTokenAmount: (originalTokenAmount != null
          ? originalTokenAmount.value
          : this.originalTokenAmount),
      originalTokenAmountShort: (originalTokenAmountShort != null
          ? originalTokenAmountShort.value
          : this.originalTokenAmountShort),
      originalTokenEgldValue: (originalTokenEgldValue != null
          ? originalTokenEgldValue.value
          : this.originalTokenEgldValue),
      originalTokenUsdValue: (originalTokenUsdValue != null
          ? originalTokenUsdValue.value
          : this.originalTokenUsdValue),
      originalTokenIdentifier: (originalTokenIdentifier != null
          ? originalTokenIdentifier.value
          : this.originalTokenIdentifier),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
      collectionInfo: (collectionInfo != null
          ? collectionInfo.value
          : this.collectionInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDocHydrated {
  const NftActivityDocHydrated({
    required this.timestamp,
    required this.txHash,
    required this.eventIdentifier,
    this.eventOrder,
    required this.chain,
    required this.source,
    required this.activityType,
    required this.id,
    required this.pk,
    required this.ts,
    required this.from,
    required this.to,
    required this.activityData,
  });

  factory NftActivityDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityDocHydratedFromJson(json);

  static const toJsonFactory = _$NftActivityDocHydratedToJson;
  Map<String, dynamic> toJson() => _$NftActivityDocHydratedToJson(this);

  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'eventIdentifier')
  final String eventIdentifier;
  @JsonKey(name: 'eventOrder')
  final double? eventOrder;
  @JsonKey(
    name: 'chain',
    toJson: nftActivityDocHydratedChainToJson,
    fromJson: nftActivityDocHydratedChainFromJson,
  )
  final enums.NftActivityDocHydratedChain chain;
  @JsonKey(
    name: 'source',
    toJson: nftActivityDocHydratedSourceToJson,
    fromJson: nftActivityDocHydratedSourceFromJson,
  )
  final enums.NftActivityDocHydratedSource source;
  @JsonKey(
    name: 'activityType',
    toJson: nftActivityDocHydratedActivityTypeToJson,
    fromJson: nftActivityDocHydratedActivityTypeFromJson,
  )
  final enums.NftActivityDocHydratedActivityType activityType;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'from')
  final OwnerDto from;
  @JsonKey(name: 'to')
  final OwnerDto to;
  @JsonKey(name: 'activityData')
  final NftActivityDataHydrated activityData;
  static const fromJsonFactory = _$NftActivityDocHydratedFromJson;
}

extension $NftActivityDocHydratedExtension on NftActivityDocHydrated {
  NftActivityDocHydrated copyWith({
    double? timestamp,
    String? txHash,
    String? eventIdentifier,
    double? eventOrder,
    enums.NftActivityDocHydratedChain? chain,
    enums.NftActivityDocHydratedSource? source,
    enums.NftActivityDocHydratedActivityType? activityType,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? from,
    OwnerDto? to,
    NftActivityDataHydrated? activityData,
  }) {
    return NftActivityDocHydrated(
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      eventIdentifier: eventIdentifier ?? this.eventIdentifier,
      eventOrder: eventOrder ?? this.eventOrder,
      chain: chain ?? this.chain,
      source: source ?? this.source,
      activityType: activityType ?? this.activityType,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      from: from ?? this.from,
      to: to ?? this.to,
      activityData: activityData ?? this.activityData,
    );
  }

  NftActivityDocHydrated copyWithWrapped({
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? eventIdentifier,
    Wrapped<double?>? eventOrder,
    Wrapped<enums.NftActivityDocHydratedChain>? chain,
    Wrapped<enums.NftActivityDocHydratedSource>? source,
    Wrapped<enums.NftActivityDocHydratedActivityType>? activityType,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? from,
    Wrapped<OwnerDto>? to,
    Wrapped<NftActivityDataHydrated>? activityData,
  }) {
    return NftActivityDocHydrated(
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      eventIdentifier: (eventIdentifier != null
          ? eventIdentifier.value
          : this.eventIdentifier),
      eventOrder: (eventOrder != null ? eventOrder.value : this.eventOrder),
      chain: (chain != null ? chain.value : this.chain),
      source: (source != null ? source.value : this.source),
      activityType: (activityType != null
          ? activityType.value
          : this.activityType),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      from: (from != null ? from.value : this.from),
      to: (to != null ? to.value : this.to),
      activityData: (activityData != null
          ? activityData.value
          : this.activityData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityPaginated {
  const NftActivityPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory NftActivityPaginated.fromJson(Map<String, dynamic> json) =>
      _$NftActivityPaginatedFromJson(json);

  static const toJsonFactory = _$NftActivityPaginatedToJson;
  Map<String, dynamic> toJson() => _$NftActivityPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <NftActivityDocHydrated>[])
  final List<NftActivityDocHydrated> resources;
  static const fromJsonFactory = _$NftActivityPaginatedFromJson;
}

extension $NftActivityPaginatedExtension on NftActivityPaginated {
  NftActivityPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<NftActivityDocHydrated>? resources,
  }) {
    return NftActivityPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  NftActivityPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<NftActivityDocHydrated>>? resources,
  }) {
    return NftActivityPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class VolumeGraph {
  const VolumeGraph({
    required this.marketplace,
    required this.timestamp,
    required this.totalEgldVolume,
    required this.totalUsdVolume,
    required this.totalTrades,
    required this.floorPrice,
    required this.athPrice,
    required this.avgPrice,
  });

  factory VolumeGraph.fromJson(Map<String, dynamic> json) =>
      _$VolumeGraphFromJson(json);

  static const toJsonFactory = _$VolumeGraphToJson;
  Map<String, dynamic> toJson() => _$VolumeGraphToJson(this);

  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp', defaultValue: <List<Object?>>[])
  final List<List<Object?>> timestamp;
  @JsonKey(name: 'totalEgldVolume', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalEgldVolume;
  @JsonKey(name: 'totalUsdVolume', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalUsdVolume;
  @JsonKey(name: 'totalTrades', defaultValue: <List<Object?>>[])
  final List<List<Object?>> totalTrades;
  @JsonKey(name: 'floorPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> floorPrice;
  @JsonKey(name: 'athPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> athPrice;
  @JsonKey(name: 'avgPrice', defaultValue: <List<Object?>>[])
  final List<List<Object?>> avgPrice;
  static const fromJsonFactory = _$VolumeGraphFromJson;
}

extension $VolumeGraphExtension on VolumeGraph {
  VolumeGraph copyWith({
    String? marketplace,
    List<List<Object?>>? timestamp,
    List<List<Object?>>? totalEgldVolume,
    List<List<Object?>>? totalUsdVolume,
    List<List<Object?>>? totalTrades,
    List<List<Object?>>? floorPrice,
    List<List<Object?>>? athPrice,
    List<List<Object?>>? avgPrice,
  }) {
    return VolumeGraph(
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      totalUsdVolume: totalUsdVolume ?? this.totalUsdVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      floorPrice: floorPrice ?? this.floorPrice,
      athPrice: athPrice ?? this.athPrice,
      avgPrice: avgPrice ?? this.avgPrice,
    );
  }

  VolumeGraph copyWithWrapped({
    Wrapped<String>? marketplace,
    Wrapped<List<List<Object?>>>? timestamp,
    Wrapped<List<List<Object?>>>? totalEgldVolume,
    Wrapped<List<List<Object?>>>? totalUsdVolume,
    Wrapped<List<List<Object?>>>? totalTrades,
    Wrapped<List<List<Object?>>>? floorPrice,
    Wrapped<List<List<Object?>>>? athPrice,
    Wrapped<List<List<Object?>>>? avgPrice,
  }) {
    return VolumeGraph(
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      totalUsdVolume: (totalUsdVolume != null
          ? totalUsdVolume.value
          : this.totalUsdVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      athPrice: (athPrice != null ? athPrice.value : this.athPrice),
      avgPrice: (avgPrice != null ? avgPrice.value : this.avgPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsVolumeDto {
  const AnalyticsVolumeDto({
    required this.marketplace,
    required this.timestamp,
    required this.totalEgldVolume,
    required this.totalUsdVolume,
    required this.totalTrades,
    required this.floorPrice,
    required this.athPrice,
    required this.avgPrice,
  });

  factory AnalyticsVolumeDto.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsVolumeDtoFromJson(json);

  static const toJsonFactory = _$AnalyticsVolumeDtoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsVolumeDtoToJson(this);

  @JsonKey(name: 'marketplace')
  final String marketplace;
  @JsonKey(name: 'timestamp', defaultValue: <String>[])
  final List<String> timestamp;
  @JsonKey(name: 'totalEgldVolume', defaultValue: <String>[])
  final List<String> totalEgldVolume;
  @JsonKey(name: 'totalUsdVolume', defaultValue: <String>[])
  final List<String> totalUsdVolume;
  @JsonKey(name: 'totalTrades', defaultValue: <String>[])
  final List<String> totalTrades;
  @JsonKey(name: 'floorPrice', defaultValue: <String>[])
  final List<String> floorPrice;
  @JsonKey(name: 'athPrice', defaultValue: <String>[])
  final List<String> athPrice;
  @JsonKey(name: 'avgPrice', defaultValue: <String>[])
  final List<String> avgPrice;
  static const fromJsonFactory = _$AnalyticsVolumeDtoFromJson;
}

extension $AnalyticsVolumeDtoExtension on AnalyticsVolumeDto {
  AnalyticsVolumeDto copyWith({
    String? marketplace,
    List<String>? timestamp,
    List<String>? totalEgldVolume,
    List<String>? totalUsdVolume,
    List<String>? totalTrades,
    List<String>? floorPrice,
    List<String>? athPrice,
    List<String>? avgPrice,
  }) {
    return AnalyticsVolumeDto(
      marketplace: marketplace ?? this.marketplace,
      timestamp: timestamp ?? this.timestamp,
      totalEgldVolume: totalEgldVolume ?? this.totalEgldVolume,
      totalUsdVolume: totalUsdVolume ?? this.totalUsdVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      floorPrice: floorPrice ?? this.floorPrice,
      athPrice: athPrice ?? this.athPrice,
      avgPrice: avgPrice ?? this.avgPrice,
    );
  }

  AnalyticsVolumeDto copyWithWrapped({
    Wrapped<String>? marketplace,
    Wrapped<List<String>>? timestamp,
    Wrapped<List<String>>? totalEgldVolume,
    Wrapped<List<String>>? totalUsdVolume,
    Wrapped<List<String>>? totalTrades,
    Wrapped<List<String>>? floorPrice,
    Wrapped<List<String>>? athPrice,
    Wrapped<List<String>>? avgPrice,
  }) {
    return AnalyticsVolumeDto(
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      totalEgldVolume: (totalEgldVolume != null
          ? totalEgldVolume.value
          : this.totalEgldVolume),
      totalUsdVolume: (totalUsdVolume != null
          ? totalUsdVolume.value
          : this.totalUsdVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      floorPrice: (floorPrice != null ? floorPrice.value : this.floorPrice),
      athPrice: (athPrice != null ? athPrice.value : this.athPrice),
      avgPrice: (avgPrice != null ? avgPrice.value : this.avgPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionDetailsDto {
  const TransactionDetailsDto({
    required this.price,
    required this.txHash,
    required this.timestamp,
    required this.identifier,
  });

  factory TransactionDetailsDto.fromJson(Map<String, dynamic> json) =>
      _$TransactionDetailsDtoFromJson(json);

  static const toJsonFactory = _$TransactionDetailsDtoToJson;
  Map<String, dynamic> toJson() => _$TransactionDetailsDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$TransactionDetailsDtoFromJson;
}

extension $TransactionDetailsDtoExtension on TransactionDetailsDto {
  TransactionDetailsDto copyWith({
    double? price,
    String? txHash,
    double? timestamp,
    String? identifier,
  }) {
    return TransactionDetailsDto(
      price: price ?? this.price,
      txHash: txHash ?? this.txHash,
      timestamp: timestamp ?? this.timestamp,
      identifier: identifier ?? this.identifier,
    );
  }

  TransactionDetailsDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<String>? txHash,
    Wrapped<double>? timestamp,
    Wrapped<String>? identifier,
  }) {
    return TransactionDetailsDto(
      price: (price != null ? price.value : this.price),
      txHash: (txHash != null ? txHash.value : this.txHash),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AveragePriceDto {
  const AveragePriceDto({required this.price});

  factory AveragePriceDto.fromJson(Map<String, dynamic> json) =>
      _$AveragePriceDtoFromJson(json);

  static const toJsonFactory = _$AveragePriceDtoToJson;
  Map<String, dynamic> toJson() => _$AveragePriceDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  static const fromJsonFactory = _$AveragePriceDtoFromJson;
}

extension $AveragePriceDtoExtension on AveragePriceDto {
  AveragePriceDto copyWith({double? price}) {
    return AveragePriceDto(price: price ?? this.price);
  }

  AveragePriceDto copyWithWrapped({Wrapped<double>? price}) {
    return AveragePriceDto(price: (price != null ? price.value : this.price));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsDto {
  const AnalyticsDto({
    required this.count,
    required this.volume,
    required this.min,
    required this.max,
    required this.avg,
  });

  factory AnalyticsDto.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsDtoFromJson(json);

  static const toJsonFactory = _$AnalyticsDtoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsDtoToJson(this);

  @JsonKey(name: 'count')
  final double count;
  @JsonKey(name: 'volume')
  final double volume;
  @JsonKey(name: 'min')
  final TransactionDetailsDto min;
  @JsonKey(name: 'max')
  final TransactionDetailsDto max;
  @JsonKey(name: 'avg')
  final AveragePriceDto avg;
  static const fromJsonFactory = _$AnalyticsDtoFromJson;
}

extension $AnalyticsDtoExtension on AnalyticsDto {
  AnalyticsDto copyWith({
    double? count,
    double? volume,
    TransactionDetailsDto? min,
    TransactionDetailsDto? max,
    AveragePriceDto? avg,
  }) {
    return AnalyticsDto(
      count: count ?? this.count,
      volume: volume ?? this.volume,
      min: min ?? this.min,
      max: max ?? this.max,
      avg: avg ?? this.avg,
    );
  }

  AnalyticsDto copyWithWrapped({
    Wrapped<double>? count,
    Wrapped<double>? volume,
    Wrapped<TransactionDetailsDto>? min,
    Wrapped<TransactionDetailsDto>? max,
    Wrapped<AveragePriceDto>? avg,
  }) {
    return AnalyticsDto(
      count: (count != null ? count.value : this.count),
      volume: (volume != null ? volume.value : this.volume),
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
      avg: (avg != null ? avg.value : this.avg),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAnalyticsDto {
  const UserAnalyticsDto({required this.purchase, required this.sale});

  factory UserAnalyticsDto.fromJson(Map<String, dynamic> json) =>
      _$UserAnalyticsDtoFromJson(json);

  static const toJsonFactory = _$UserAnalyticsDtoToJson;
  Map<String, dynamic> toJson() => _$UserAnalyticsDtoToJson(this);

  @JsonKey(name: 'Purchase')
  final AnalyticsDto purchase;
  @JsonKey(name: 'Sale')
  final AnalyticsDto sale;
  static const fromJsonFactory = _$UserAnalyticsDtoFromJson;
}

extension $UserAnalyticsDtoExtension on UserAnalyticsDto {
  UserAnalyticsDto copyWith({AnalyticsDto? purchase, AnalyticsDto? sale}) {
    return UserAnalyticsDto(
      purchase: purchase ?? this.purchase,
      sale: sale ?? this.sale,
    );
  }

  UserAnalyticsDto copyWithWrapped({
    Wrapped<AnalyticsDto>? purchase,
    Wrapped<AnalyticsDto>? sale,
  }) {
    return UserAnalyticsDto(
      purchase: (purchase != null ? purchase.value : this.purchase),
      sale: (sale != null ? sale.value : this.sale),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AllTimeHighDto {
  const AllTimeHighDto({
    required this.price,
    required this.timestamp,
    required this.txHash,
    required this.identifier,
  });

  factory AllTimeHighDto.fromJson(Map<String, dynamic> json) =>
      _$AllTimeHighDtoFromJson(json);

  static const toJsonFactory = _$AllTimeHighDtoToJson;
  Map<String, dynamic> toJson() => _$AllTimeHighDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'identifier')
  final String identifier;
  static const fromJsonFactory = _$AllTimeHighDtoFromJson;
}

extension $AllTimeHighDtoExtension on AllTimeHighDto {
  AllTimeHighDto copyWith({
    double? price,
    double? timestamp,
    String? txHash,
    String? identifier,
  }) {
    return AllTimeHighDto(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
      identifier: identifier ?? this.identifier,
    );
  }

  AllTimeHighDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? txHash,
    Wrapped<String>? identifier,
  }) {
    return AllTimeHighDto(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
      identifier: (identifier != null ? identifier.value : this.identifier),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TradingStatsDto {
  const TradingStatsDto({
    required this.totalVolume,
    required this.totalTrades,
    required this.averagePrice,
    required this.allTimeHigh,
    required this.day,
    required this.week,
    required this.month,
    required this.quarter,
    required this.halfYear,
    required this.year,
  });

  factory TradingStatsDto.fromJson(Map<String, dynamic> json) =>
      _$TradingStatsDtoFromJson(json);

  static const toJsonFactory = _$TradingStatsDtoToJson;
  Map<String, dynamic> toJson() => _$TradingStatsDtoToJson(this);

  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'averagePrice')
  final double averagePrice;
  @JsonKey(name: 'allTimeHigh')
  final AllTimeHighDto allTimeHigh;
  @JsonKey(name: 'day')
  final Object day;
  @JsonKey(name: 'week')
  final Object week;
  @JsonKey(name: 'month')
  final Object month;
  @JsonKey(name: 'quarter')
  final Object quarter;
  @JsonKey(name: 'halfYear')
  final Object halfYear;
  @JsonKey(name: 'year')
  final Object year;
  static const fromJsonFactory = _$TradingStatsDtoFromJson;
}

extension $TradingStatsDtoExtension on TradingStatsDto {
  TradingStatsDto copyWith({
    double? totalVolume,
    double? totalTrades,
    double? averagePrice,
    AllTimeHighDto? allTimeHigh,
    Object? day,
    Object? week,
    Object? month,
    Object? quarter,
    Object? halfYear,
    Object? year,
  }) {
    return TradingStatsDto(
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      averagePrice: averagePrice ?? this.averagePrice,
      allTimeHigh: allTimeHigh ?? this.allTimeHigh,
      day: day ?? this.day,
      week: week ?? this.week,
      month: month ?? this.month,
      quarter: quarter ?? this.quarter,
      halfYear: halfYear ?? this.halfYear,
      year: year ?? this.year,
    );
  }

  TradingStatsDto copyWithWrapped({
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double>? averagePrice,
    Wrapped<AllTimeHighDto>? allTimeHigh,
    Wrapped<Object>? day,
    Wrapped<Object>? week,
    Wrapped<Object>? month,
    Wrapped<Object>? quarter,
    Wrapped<Object>? halfYear,
    Wrapped<Object>? year,
  }) {
    return TradingStatsDto(
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      averagePrice: (averagePrice != null
          ? averagePrice.value
          : this.averagePrice),
      allTimeHigh: (allTimeHigh != null ? allTimeHigh.value : this.allTimeHigh),
      day: (day != null ? day.value : this.day),
      week: (week != null ? week.value : this.week),
      month: (month != null ? month.value : this.month),
      quarter: (quarter != null ? quarter.value : this.quarter),
      halfYear: (halfYear != null ? halfYear.value : this.halfYear),
      year: (year != null ? year.value : this.year),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalAnalyticsOverviewResponseDto {
  const GlobalAnalyticsOverviewResponseDto({
    required this.userCount,
    required this.listingsCount,
    required this.tradingStats,
  });

  factory GlobalAnalyticsOverviewResponseDto.fromJson(
    Map<String, dynamic> json,
  ) => _$GlobalAnalyticsOverviewResponseDtoFromJson(json);

  static const toJsonFactory = _$GlobalAnalyticsOverviewResponseDtoToJson;
  Map<String, dynamic> toJson() =>
      _$GlobalAnalyticsOverviewResponseDtoToJson(this);

  @JsonKey(name: 'userCount')
  final double userCount;
  @JsonKey(name: 'listingsCount')
  final double listingsCount;
  @JsonKey(name: 'tradingStats')
  final TradingStatsDto tradingStats;
  static const fromJsonFactory = _$GlobalAnalyticsOverviewResponseDtoFromJson;
}

extension $GlobalAnalyticsOverviewResponseDtoExtension
    on GlobalAnalyticsOverviewResponseDto {
  GlobalAnalyticsOverviewResponseDto copyWith({
    double? userCount,
    double? listingsCount,
    TradingStatsDto? tradingStats,
  }) {
    return GlobalAnalyticsOverviewResponseDto(
      userCount: userCount ?? this.userCount,
      listingsCount: listingsCount ?? this.listingsCount,
      tradingStats: tradingStats ?? this.tradingStats,
    );
  }

  GlobalAnalyticsOverviewResponseDto copyWithWrapped({
    Wrapped<double>? userCount,
    Wrapped<double>? listingsCount,
    Wrapped<TradingStatsDto>? tradingStats,
  }) {
    return GlobalAnalyticsOverviewResponseDto(
      userCount: (userCount != null ? userCount.value : this.userCount),
      listingsCount: (listingsCount != null
          ? listingsCount.value
          : this.listingsCount),
      tradingStats: (tradingStats != null
          ? tradingStats.value
          : this.tradingStats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PriceDataDto {
  const PriceDataDto({
    required this.price,
    required this.timestamp,
    required this.identifier,
    required this.txHash,
    required this.usdValue,
    this.nftInfo,
  });

  factory PriceDataDto.fromJson(Map<String, dynamic> json) =>
      _$PriceDataDtoFromJson(json);

  static const toJsonFactory = _$PriceDataDtoToJson;
  Map<String, dynamic> toJson() => _$PriceDataDtoToJson(this);

  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'usdValue')
  final double usdValue;
  @JsonKey(name: 'nftInfo')
  final ShortNftDoc? nftInfo;
  static const fromJsonFactory = _$PriceDataDtoFromJson;
}

extension $PriceDataDtoExtension on PriceDataDto {
  PriceDataDto copyWith({
    double? price,
    double? timestamp,
    String? identifier,
    String? txHash,
    double? usdValue,
    ShortNftDoc? nftInfo,
  }) {
    return PriceDataDto(
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      identifier: identifier ?? this.identifier,
      txHash: txHash ?? this.txHash,
      usdValue: usdValue ?? this.usdValue,
      nftInfo: nftInfo ?? this.nftInfo,
    );
  }

  PriceDataDto copyWithWrapped({
    Wrapped<double>? price,
    Wrapped<double>? timestamp,
    Wrapped<String>? identifier,
    Wrapped<String>? txHash,
    Wrapped<double>? usdValue,
    Wrapped<ShortNftDoc?>? nftInfo,
  }) {
    return PriceDataDto(
      price: (price != null ? price.value : this.price),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      identifier: (identifier != null ? identifier.value : this.identifier),
      txHash: (txHash != null ? txHash.value : this.txHash),
      usdValue: (usdValue != null ? usdValue.value : this.usdValue),
      nftInfo: (nftInfo != null ? nftInfo.value : this.nftInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserStatsDto {
  const UserStatsDto({
    required this.wallet,
    required this.totalVolume,
    required this.totalTrades,
    required this.totalCollections,
    required this.totalNfts,
    required this.totalPartners,
    required this.buyerVolume,
    required this.buyerTrades,
    required this.buyerNfts,
    required this.buyerCollections,
    required this.buyerPartners,
    required this.buyerMaxPriceData,
    required this.buyerMinPriceData,
    required this.sellerVolume,
    required this.sellerTrades,
    required this.sellerNfts,
    required this.sellerCollections,
    required this.sellerPartners,
    required this.sellerMaxPriceData,
    required this.sellerMinPriceData,
  });

  factory UserStatsDto.fromJson(Map<String, dynamic> json) =>
      _$UserStatsDtoFromJson(json);

  static const toJsonFactory = _$UserStatsDtoToJson;
  Map<String, dynamic> toJson() => _$UserStatsDtoToJson(this);

  @JsonKey(name: 'wallet')
  final WalletDto wallet;
  @JsonKey(name: 'totalVolume')
  final double totalVolume;
  @JsonKey(name: 'totalTrades')
  final double totalTrades;
  @JsonKey(name: 'totalCollections')
  final double totalCollections;
  @JsonKey(name: 'totalNfts')
  final double totalNfts;
  @JsonKey(name: 'totalPartners')
  final double totalPartners;
  @JsonKey(name: 'buyerVolume')
  final double buyerVolume;
  @JsonKey(name: 'buyerTrades')
  final double buyerTrades;
  @JsonKey(name: 'buyerNfts')
  final double buyerNfts;
  @JsonKey(name: 'buyerCollections')
  final double buyerCollections;
  @JsonKey(name: 'buyerPartners')
  final double buyerPartners;
  @JsonKey(name: 'buyerMaxPriceData')
  final PriceDataDto buyerMaxPriceData;
  @JsonKey(name: 'buyerMinPriceData')
  final PriceDataDto buyerMinPriceData;
  @JsonKey(name: 'sellerVolume')
  final double sellerVolume;
  @JsonKey(name: 'sellerTrades')
  final double sellerTrades;
  @JsonKey(name: 'sellerNfts')
  final double sellerNfts;
  @JsonKey(name: 'sellerCollections')
  final double sellerCollections;
  @JsonKey(name: 'sellerPartners')
  final double sellerPartners;
  @JsonKey(name: 'sellerMaxPriceData')
  final PriceDataDto sellerMaxPriceData;
  @JsonKey(name: 'sellerMinPriceData')
  final PriceDataDto sellerMinPriceData;
  static const fromJsonFactory = _$UserStatsDtoFromJson;
}

extension $UserStatsDtoExtension on UserStatsDto {
  UserStatsDto copyWith({
    WalletDto? wallet,
    double? totalVolume,
    double? totalTrades,
    double? totalCollections,
    double? totalNfts,
    double? totalPartners,
    double? buyerVolume,
    double? buyerTrades,
    double? buyerNfts,
    double? buyerCollections,
    double? buyerPartners,
    PriceDataDto? buyerMaxPriceData,
    PriceDataDto? buyerMinPriceData,
    double? sellerVolume,
    double? sellerTrades,
    double? sellerNfts,
    double? sellerCollections,
    double? sellerPartners,
    PriceDataDto? sellerMaxPriceData,
    PriceDataDto? sellerMinPriceData,
  }) {
    return UserStatsDto(
      wallet: wallet ?? this.wallet,
      totalVolume: totalVolume ?? this.totalVolume,
      totalTrades: totalTrades ?? this.totalTrades,
      totalCollections: totalCollections ?? this.totalCollections,
      totalNfts: totalNfts ?? this.totalNfts,
      totalPartners: totalPartners ?? this.totalPartners,
      buyerVolume: buyerVolume ?? this.buyerVolume,
      buyerTrades: buyerTrades ?? this.buyerTrades,
      buyerNfts: buyerNfts ?? this.buyerNfts,
      buyerCollections: buyerCollections ?? this.buyerCollections,
      buyerPartners: buyerPartners ?? this.buyerPartners,
      buyerMaxPriceData: buyerMaxPriceData ?? this.buyerMaxPriceData,
      buyerMinPriceData: buyerMinPriceData ?? this.buyerMinPriceData,
      sellerVolume: sellerVolume ?? this.sellerVolume,
      sellerTrades: sellerTrades ?? this.sellerTrades,
      sellerNfts: sellerNfts ?? this.sellerNfts,
      sellerCollections: sellerCollections ?? this.sellerCollections,
      sellerPartners: sellerPartners ?? this.sellerPartners,
      sellerMaxPriceData: sellerMaxPriceData ?? this.sellerMaxPriceData,
      sellerMinPriceData: sellerMinPriceData ?? this.sellerMinPriceData,
    );
  }

  UserStatsDto copyWithWrapped({
    Wrapped<WalletDto>? wallet,
    Wrapped<double>? totalVolume,
    Wrapped<double>? totalTrades,
    Wrapped<double>? totalCollections,
    Wrapped<double>? totalNfts,
    Wrapped<double>? totalPartners,
    Wrapped<double>? buyerVolume,
    Wrapped<double>? buyerTrades,
    Wrapped<double>? buyerNfts,
    Wrapped<double>? buyerCollections,
    Wrapped<double>? buyerPartners,
    Wrapped<PriceDataDto>? buyerMaxPriceData,
    Wrapped<PriceDataDto>? buyerMinPriceData,
    Wrapped<double>? sellerVolume,
    Wrapped<double>? sellerTrades,
    Wrapped<double>? sellerNfts,
    Wrapped<double>? sellerCollections,
    Wrapped<double>? sellerPartners,
    Wrapped<PriceDataDto>? sellerMaxPriceData,
    Wrapped<PriceDataDto>? sellerMinPriceData,
  }) {
    return UserStatsDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      totalVolume: (totalVolume != null ? totalVolume.value : this.totalVolume),
      totalTrades: (totalTrades != null ? totalTrades.value : this.totalTrades),
      totalCollections: (totalCollections != null
          ? totalCollections.value
          : this.totalCollections),
      totalNfts: (totalNfts != null ? totalNfts.value : this.totalNfts),
      totalPartners: (totalPartners != null
          ? totalPartners.value
          : this.totalPartners),
      buyerVolume: (buyerVolume != null ? buyerVolume.value : this.buyerVolume),
      buyerTrades: (buyerTrades != null ? buyerTrades.value : this.buyerTrades),
      buyerNfts: (buyerNfts != null ? buyerNfts.value : this.buyerNfts),
      buyerCollections: (buyerCollections != null
          ? buyerCollections.value
          : this.buyerCollections),
      buyerPartners: (buyerPartners != null
          ? buyerPartners.value
          : this.buyerPartners),
      buyerMaxPriceData: (buyerMaxPriceData != null
          ? buyerMaxPriceData.value
          : this.buyerMaxPriceData),
      buyerMinPriceData: (buyerMinPriceData != null
          ? buyerMinPriceData.value
          : this.buyerMinPriceData),
      sellerVolume: (sellerVolume != null
          ? sellerVolume.value
          : this.sellerVolume),
      sellerTrades: (sellerTrades != null
          ? sellerTrades.value
          : this.sellerTrades),
      sellerNfts: (sellerNfts != null ? sellerNfts.value : this.sellerNfts),
      sellerCollections: (sellerCollections != null
          ? sellerCollections.value
          : this.sellerCollections),
      sellerPartners: (sellerPartners != null
          ? sellerPartners.value
          : this.sellerPartners),
      sellerMaxPriceData: (sellerMaxPriceData != null
          ? sellerMaxPriceData.value
          : this.sellerMaxPriceData),
      sellerMinPriceData: (sellerMinPriceData != null
          ? sellerMinPriceData.value
          : this.sellerMinPriceData),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AirdropDtoHydrated {
  const AirdropDtoHydrated({
    required this.tokenAllocation,
    required this.totalScore,
    required this.rank,
    required this.wallet,
    this.signature,
    this.isClaimed,
    this.amount,
  });

  factory AirdropDtoHydrated.fromJson(Map<String, dynamic> json) =>
      _$AirdropDtoHydratedFromJson(json);

  static const toJsonFactory = _$AirdropDtoHydratedToJson;
  Map<String, dynamic> toJson() => _$AirdropDtoHydratedToJson(this);

  @JsonKey(name: 'tokenAllocation')
  final double tokenAllocation;
  @JsonKey(name: 'totalScore')
  final double totalScore;
  @JsonKey(name: 'rank')
  final double rank;
  @JsonKey(name: 'wallet')
  final Object wallet;
  @JsonKey(name: 'signature')
  final Object? signature;
  @JsonKey(name: 'isClaimed')
  final bool? isClaimed;
  @JsonKey(name: 'amount')
  final String? amount;
  static const fromJsonFactory = _$AirdropDtoHydratedFromJson;
}

extension $AirdropDtoHydratedExtension on AirdropDtoHydrated {
  AirdropDtoHydrated copyWith({
    double? tokenAllocation,
    double? totalScore,
    double? rank,
    Object? wallet,
    Object? signature,
    bool? isClaimed,
    String? amount,
  }) {
    return AirdropDtoHydrated(
      tokenAllocation: tokenAllocation ?? this.tokenAllocation,
      totalScore: totalScore ?? this.totalScore,
      rank: rank ?? this.rank,
      wallet: wallet ?? this.wallet,
      signature: signature ?? this.signature,
      isClaimed: isClaimed ?? this.isClaimed,
      amount: amount ?? this.amount,
    );
  }

  AirdropDtoHydrated copyWithWrapped({
    Wrapped<double>? tokenAllocation,
    Wrapped<double>? totalScore,
    Wrapped<double>? rank,
    Wrapped<Object>? wallet,
    Wrapped<Object?>? signature,
    Wrapped<bool?>? isClaimed,
    Wrapped<String?>? amount,
  }) {
    return AirdropDtoHydrated(
      tokenAllocation: (tokenAllocation != null
          ? tokenAllocation.value
          : this.tokenAllocation),
      totalScore: (totalScore != null ? totalScore.value : this.totalScore),
      rank: (rank != null ? rank.value : this.rank),
      wallet: (wallet != null ? wallet.value : this.wallet),
      signature: (signature != null ? signature.value : this.signature),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginRequestDto {
  const LoginRequestDto({
    this.address,
    required this.loginToken,
    this.signature,
    this.data,
    this.service,
  });

  factory LoginRequestDto.fromJson(Map<String, dynamic> json) =>
      _$LoginRequestDtoFromJson(json);

  static const toJsonFactory = _$LoginRequestDtoToJson;
  Map<String, dynamic> toJson() => _$LoginRequestDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'loginToken')
  final String loginToken;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'data')
  final Object? data;
  @JsonKey(
    name: 'service',
    toJson: loginRequestDtoServiceNullableToJson,
    fromJson: loginRequestDtoServiceServiceNullableFromJson,
  )
  final enums.LoginRequestDtoService? service;
  static enums.LoginRequestDtoService?
  loginRequestDtoServiceServiceNullableFromJson(Object? value) =>
      loginRequestDtoServiceNullableFromJson(
        value,
        enums.LoginRequestDtoService.xoxno,
      );

  static const fromJsonFactory = _$LoginRequestDtoFromJson;
}

extension $LoginRequestDtoExtension on LoginRequestDto {
  LoginRequestDto copyWith({
    String? address,
    String? loginToken,
    String? signature,
    Object? data,
    enums.LoginRequestDtoService? service,
  }) {
    return LoginRequestDto(
      address: address ?? this.address,
      loginToken: loginToken ?? this.loginToken,
      signature: signature ?? this.signature,
      data: data ?? this.data,
      service: service ?? this.service,
    );
  }

  LoginRequestDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<String>? loginToken,
    Wrapped<String?>? signature,
    Wrapped<Object?>? data,
    Wrapped<enums.LoginRequestDtoService?>? service,
  }) {
    return LoginRequestDto(
      address: (address != null ? address.value : this.address),
      loginToken: (loginToken != null ? loginToken.value : this.loginToken),
      signature: (signature != null ? signature.value : this.signature),
      data: (data != null ? data.value : this.data),
      service: (service != null ? service.value : this.service),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class LoginAccessDto {
  const LoginAccessDto({required this.accessToken, required this.expires});

  factory LoginAccessDto.fromJson(Map<String, dynamic> json) =>
      _$LoginAccessDtoFromJson(json);

  static const toJsonFactory = _$LoginAccessDtoToJson;
  Map<String, dynamic> toJson() => _$LoginAccessDtoToJson(this);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'expires')
  final double expires;
  static const fromJsonFactory = _$LoginAccessDtoFromJson;
}

extension $LoginAccessDtoExtension on LoginAccessDto {
  LoginAccessDto copyWith({String? accessToken, double? expires}) {
    return LoginAccessDto(
      accessToken: accessToken ?? this.accessToken,
      expires: expires ?? this.expires,
    );
  }

  LoginAccessDto copyWithWrapped({
    Wrapped<String>? accessToken,
    Wrapped<double>? expires,
  }) {
    return LoginAccessDto(
      accessToken: (accessToken != null ? accessToken.value : this.accessToken),
      expires: (expires != null ? expires.value : this.expires),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionLog {
  const TransactionLog({
    this.id,
    required this.address,
    required this.events,
    required this.timestamp,
    required this.txHash,
  });

  factory TransactionLog.fromJson(Map<String, dynamic> json) =>
      _$TransactionLogFromJson(json);

  static const toJsonFactory = _$TransactionLogToJson;
  Map<String, dynamic> toJson() => _$TransactionLogToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'events', defaultValue: <List<Object?>>[])
  final List<List<Object?>> events;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'txHash')
  final String txHash;
  static const fromJsonFactory = _$TransactionLogFromJson;
}

extension $TransactionLogExtension on TransactionLog {
  TransactionLog copyWith({
    String? id,
    String? address,
    List<List<Object?>>? events,
    int? timestamp,
    String? txHash,
  }) {
    return TransactionLog(
      id: id ?? this.id,
      address: address ?? this.address,
      events: events ?? this.events,
      timestamp: timestamp ?? this.timestamp,
      txHash: txHash ?? this.txHash,
    );
  }

  TransactionLog copyWithWrapped({
    Wrapped<String?>? id,
    Wrapped<String>? address,
    Wrapped<List<List<Object?>>>? events,
    Wrapped<int>? timestamp,
    Wrapped<String>? txHash,
  }) {
    return TransactionLog(
      id: (id != null ? id.value : this.id),
      address: (address != null ? address.value : this.address),
      events: (events != null ? events.value : this.events),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      txHash: (txHash != null ? txHash.value : this.txHash),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionDetailed {
  const TransactionDetailed({
    required this.txHash,
    this.gasLimit,
    this.gasPrice,
    this.gasUsed,
    this.miniBlockHash,
    this.nonce,
    required this.receiver,
    required this.receiverShard,
    this.round,
    required this.sender,
    required this.senderShard,
    this.signature,
    required this.status,
    required this.$value,
    this.fee,
    required this.timestamp,
    this.data,
    this.function,
    this.action,
    this.scamInfo,
    this.type,
    this.originalTxHash,
    this.pendingResults,
    required this.results,
    this.price,
    this.logs,
    required this.operations,
  });

  factory TransactionDetailed.fromJson(Map<String, dynamic> json) =>
      _$TransactionDetailedFromJson(json);

  static const toJsonFactory = _$TransactionDetailedToJson;
  Map<String, dynamic> toJson() => _$TransactionDetailedToJson(this);

  @JsonKey(name: 'txHash')
  final String txHash;
  @JsonKey(name: 'gasLimit')
  final int? gasLimit;
  @JsonKey(name: 'gasPrice')
  final int? gasPrice;
  @JsonKey(name: 'gasUsed')
  final int? gasUsed;
  @JsonKey(name: 'miniBlockHash')
  final String? miniBlockHash;
  @JsonKey(name: 'nonce')
  final int? nonce;
  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverShard')
  final int receiverShard;
  @JsonKey(name: 'round')
  final int? round;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderShard')
  final int senderShard;
  @JsonKey(name: 'signature')
  final String? signature;
  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'fee')
  final String? fee;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'data')
  final String? data;
  @JsonKey(name: 'function')
  final String? function;
  @JsonKey(name: 'action')
  final Object? action;
  @JsonKey(name: 'scamInfo')
  final Object? scamInfo;
  @JsonKey(
    name: 'type',
    toJson: transactionTypeNullableToJson,
    fromJson: transactionTypeNullableFromJson,
  )
  final enums.TransactionType? type;
  @JsonKey(name: 'originalTxHash')
  final String? originalTxHash;
  @JsonKey(name: 'pendingResults')
  final bool? pendingResults;
  @JsonKey(name: 'results', defaultValue: <List<Object?>>[])
  final List<List<Object?>> results;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'logs')
  final TransactionLog? logs;
  @JsonKey(name: 'operations', defaultValue: <List<Object?>>[])
  final List<List<Object?>> operations;
  static const fromJsonFactory = _$TransactionDetailedFromJson;
}

extension $TransactionDetailedExtension on TransactionDetailed {
  TransactionDetailed copyWith({
    String? txHash,
    int? gasLimit,
    int? gasPrice,
    int? gasUsed,
    String? miniBlockHash,
    int? nonce,
    String? receiver,
    int? receiverShard,
    int? round,
    String? sender,
    int? senderShard,
    String? signature,
    String? status,
    String? $value,
    String? fee,
    int? timestamp,
    String? data,
    String? function,
    Object? action,
    Object? scamInfo,
    enums.TransactionType? type,
    String? originalTxHash,
    bool? pendingResults,
    List<List<Object?>>? results,
    double? price,
    TransactionLog? logs,
    List<List<Object?>>? operations,
  }) {
    return TransactionDetailed(
      txHash: txHash ?? this.txHash,
      gasLimit: gasLimit ?? this.gasLimit,
      gasPrice: gasPrice ?? this.gasPrice,
      gasUsed: gasUsed ?? this.gasUsed,
      miniBlockHash: miniBlockHash ?? this.miniBlockHash,
      nonce: nonce ?? this.nonce,
      receiver: receiver ?? this.receiver,
      receiverShard: receiverShard ?? this.receiverShard,
      round: round ?? this.round,
      sender: sender ?? this.sender,
      senderShard: senderShard ?? this.senderShard,
      signature: signature ?? this.signature,
      status: status ?? this.status,
      $value: $value ?? this.$value,
      fee: fee ?? this.fee,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
      function: function ?? this.function,
      action: action ?? this.action,
      scamInfo: scamInfo ?? this.scamInfo,
      type: type ?? this.type,
      originalTxHash: originalTxHash ?? this.originalTxHash,
      pendingResults: pendingResults ?? this.pendingResults,
      results: results ?? this.results,
      price: price ?? this.price,
      logs: logs ?? this.logs,
      operations: operations ?? this.operations,
    );
  }

  TransactionDetailed copyWithWrapped({
    Wrapped<String>? txHash,
    Wrapped<int?>? gasLimit,
    Wrapped<int?>? gasPrice,
    Wrapped<int?>? gasUsed,
    Wrapped<String?>? miniBlockHash,
    Wrapped<int?>? nonce,
    Wrapped<String>? receiver,
    Wrapped<int>? receiverShard,
    Wrapped<int?>? round,
    Wrapped<String>? sender,
    Wrapped<int>? senderShard,
    Wrapped<String?>? signature,
    Wrapped<String>? status,
    Wrapped<String>? $value,
    Wrapped<String?>? fee,
    Wrapped<int>? timestamp,
    Wrapped<String?>? data,
    Wrapped<String?>? function,
    Wrapped<Object?>? action,
    Wrapped<Object?>? scamInfo,
    Wrapped<enums.TransactionType?>? type,
    Wrapped<String?>? originalTxHash,
    Wrapped<bool?>? pendingResults,
    Wrapped<List<List<Object?>>>? results,
    Wrapped<double?>? price,
    Wrapped<TransactionLog?>? logs,
    Wrapped<List<List<Object?>>>? operations,
  }) {
    return TransactionDetailed(
      txHash: (txHash != null ? txHash.value : this.txHash),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
      gasPrice: (gasPrice != null ? gasPrice.value : this.gasPrice),
      gasUsed: (gasUsed != null ? gasUsed.value : this.gasUsed),
      miniBlockHash: (miniBlockHash != null
          ? miniBlockHash.value
          : this.miniBlockHash),
      nonce: (nonce != null ? nonce.value : this.nonce),
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverShard: (receiverShard != null
          ? receiverShard.value
          : this.receiverShard),
      round: (round != null ? round.value : this.round),
      sender: (sender != null ? sender.value : this.sender),
      senderShard: (senderShard != null ? senderShard.value : this.senderShard),
      signature: (signature != null ? signature.value : this.signature),
      status: (status != null ? status.value : this.status),
      $value: ($value != null ? $value.value : this.$value),
      fee: (fee != null ? fee.value : this.fee),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      data: (data != null ? data.value : this.data),
      function: (function != null ? function.value : this.function),
      action: (action != null ? action.value : this.action),
      scamInfo: (scamInfo != null ? scamInfo.value : this.scamInfo),
      type: (type != null ? type.value : this.type),
      originalTxHash: (originalTxHash != null
          ? originalTxHash.value
          : this.originalTxHash),
      pendingResults: (pendingResults != null
          ? pendingResults.value
          : this.pendingResults),
      results: (results != null ? results.value : this.results),
      price: (price != null ? price.value : this.price),
      logs: (logs != null ? logs.value : this.logs),
      operations: (operations != null ? operations.value : this.operations),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionProcessStatus {
  const TransactionProcessStatus({required this.reason, required this.status});

  factory TransactionProcessStatus.fromJson(Map<String, dynamic> json) =>
      _$TransactionProcessStatusFromJson(json);

  static const toJsonFactory = _$TransactionProcessStatusToJson;
  Map<String, dynamic> toJson() => _$TransactionProcessStatusToJson(this);

  @JsonKey(name: 'reason')
  final Object reason;
  @JsonKey(
    name: 'status',
    toJson: transactionStatusToJson,
    fromJson: transactionStatusFromJson,
  )
  final enums.TransactionStatus status;
  static const fromJsonFactory = _$TransactionProcessStatusFromJson;
}

extension $TransactionProcessStatusExtension on TransactionProcessStatus {
  TransactionProcessStatus copyWith({
    Object? reason,
    enums.TransactionStatus? status,
  }) {
    return TransactionProcessStatus(
      reason: reason ?? this.reason,
      status: status ?? this.status,
    );
  }

  TransactionProcessStatus copyWithWrapped({
    Wrapped<Object>? reason,
    Wrapped<enums.TransactionStatus>? status,
  }) {
    return TransactionProcessStatus(
      reason: (reason != null ? reason.value : this.reason),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionCreate {
  const TransactionCreate({
    required this.chainID,
    this.data,
    required this.gasLimit,
    required this.gasPrice,
    required this.nonce,
    required this.receiver,
    this.receiverUsername,
    required this.sender,
    this.senderUsername,
    required this.signature,
    required this.$value,
    required this.version,
    this.options,
    this.guardian,
    this.guardianSignature,
  });

  factory TransactionCreate.fromJson(Map<String, dynamic> json) =>
      _$TransactionCreateFromJson(json);

  static const toJsonFactory = _$TransactionCreateToJson;
  Map<String, dynamic> toJson() => _$TransactionCreateToJson(this);

  @JsonKey(name: 'chainID')
  final String chainID;
  @JsonKey(name: 'data')
  final Object? data;
  @JsonKey(name: 'gasLimit')
  final double gasLimit;
  @JsonKey(name: 'gasPrice')
  final double gasPrice;
  @JsonKey(name: 'nonce')
  final double nonce;
  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverUsername')
  final String? receiverUsername;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderUsername')
  final String? senderUsername;
  @JsonKey(name: 'signature')
  final String signature;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'version')
  final double version;
  @JsonKey(name: 'options')
  final double? options;
  @JsonKey(name: 'guardian')
  final String? guardian;
  @JsonKey(name: 'guardianSignature')
  final String? guardianSignature;
  static const fromJsonFactory = _$TransactionCreateFromJson;
}

extension $TransactionCreateExtension on TransactionCreate {
  TransactionCreate copyWith({
    String? chainID,
    Object? data,
    double? gasLimit,
    double? gasPrice,
    double? nonce,
    String? receiver,
    String? receiverUsername,
    String? sender,
    String? senderUsername,
    String? signature,
    String? $value,
    double? version,
    double? options,
    String? guardian,
    String? guardianSignature,
  }) {
    return TransactionCreate(
      chainID: chainID ?? this.chainID,
      data: data ?? this.data,
      gasLimit: gasLimit ?? this.gasLimit,
      gasPrice: gasPrice ?? this.gasPrice,
      nonce: nonce ?? this.nonce,
      receiver: receiver ?? this.receiver,
      receiverUsername: receiverUsername ?? this.receiverUsername,
      sender: sender ?? this.sender,
      senderUsername: senderUsername ?? this.senderUsername,
      signature: signature ?? this.signature,
      $value: $value ?? this.$value,
      version: version ?? this.version,
      options: options ?? this.options,
      guardian: guardian ?? this.guardian,
      guardianSignature: guardianSignature ?? this.guardianSignature,
    );
  }

  TransactionCreate copyWithWrapped({
    Wrapped<String>? chainID,
    Wrapped<Object?>? data,
    Wrapped<double>? gasLimit,
    Wrapped<double>? gasPrice,
    Wrapped<double>? nonce,
    Wrapped<String>? receiver,
    Wrapped<String?>? receiverUsername,
    Wrapped<String>? sender,
    Wrapped<String?>? senderUsername,
    Wrapped<String>? signature,
    Wrapped<String>? $value,
    Wrapped<double>? version,
    Wrapped<double?>? options,
    Wrapped<String?>? guardian,
    Wrapped<String?>? guardianSignature,
  }) {
    return TransactionCreate(
      chainID: (chainID != null ? chainID.value : this.chainID),
      data: (data != null ? data.value : this.data),
      gasLimit: (gasLimit != null ? gasLimit.value : this.gasLimit),
      gasPrice: (gasPrice != null ? gasPrice.value : this.gasPrice),
      nonce: (nonce != null ? nonce.value : this.nonce),
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverUsername: (receiverUsername != null
          ? receiverUsername.value
          : this.receiverUsername),
      sender: (sender != null ? sender.value : this.sender),
      senderUsername: (senderUsername != null
          ? senderUsername.value
          : this.senderUsername),
      signature: (signature != null ? signature.value : this.signature),
      $value: ($value != null ? $value.value : this.$value),
      version: (version != null ? version.value : this.version),
      options: (options != null ? options.value : this.options),
      guardian: (guardian != null ? guardian.value : this.guardian),
      guardianSignature: (guardianSignature != null
          ? guardianSignature.value
          : this.guardianSignature),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionCostData {
  const TransactionCostData({required this.txGasUnits});

  factory TransactionCostData.fromJson(Map<String, dynamic> json) =>
      _$TransactionCostDataFromJson(json);

  static const toJsonFactory = _$TransactionCostDataToJson;
  Map<String, dynamic> toJson() => _$TransactionCostDataToJson(this);

  @JsonKey(name: 'txGasUnits')
  final double txGasUnits;
  static const fromJsonFactory = _$TransactionCostDataFromJson;
}

extension $TransactionCostDataExtension on TransactionCostData {
  TransactionCostData copyWith({double? txGasUnits}) {
    return TransactionCostData(txGasUnits: txGasUnits ?? this.txGasUnits);
  }

  TransactionCostData copyWithWrapped({Wrapped<double>? txGasUnits}) {
    return TransactionCostData(
      txGasUnits: (txGasUnits != null ? txGasUnits.value : this.txGasUnits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionSendResult {
  const TransactionSendResult({
    required this.receiver,
    required this.receiverShard,
    required this.sender,
    required this.senderShard,
    required this.status,
    required this.txHash,
  });

  factory TransactionSendResult.fromJson(Map<String, dynamic> json) =>
      _$TransactionSendResultFromJson(json);

  static const toJsonFactory = _$TransactionSendResultToJson;
  Map<String, dynamic> toJson() => _$TransactionSendResultToJson(this);

  @JsonKey(name: 'receiver')
  final String receiver;
  @JsonKey(name: 'receiverShard')
  final int receiverShard;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'senderShard')
  final int senderShard;
  @JsonKey(
    name: 'status',
    toJson: transactionStatusToJson,
    fromJson: transactionStatusFromJson,
  )
  final enums.TransactionStatus status;
  @JsonKey(name: 'txHash')
  final String txHash;
  static const fromJsonFactory = _$TransactionSendResultFromJson;
}

extension $TransactionSendResultExtension on TransactionSendResult {
  TransactionSendResult copyWith({
    String? receiver,
    int? receiverShard,
    String? sender,
    int? senderShard,
    enums.TransactionStatus? status,
    String? txHash,
  }) {
    return TransactionSendResult(
      receiver: receiver ?? this.receiver,
      receiverShard: receiverShard ?? this.receiverShard,
      sender: sender ?? this.sender,
      senderShard: senderShard ?? this.senderShard,
      status: status ?? this.status,
      txHash: txHash ?? this.txHash,
    );
  }

  TransactionSendResult copyWithWrapped({
    Wrapped<String>? receiver,
    Wrapped<int>? receiverShard,
    Wrapped<String>? sender,
    Wrapped<int>? senderShard,
    Wrapped<enums.TransactionStatus>? status,
    Wrapped<String>? txHash,
  }) {
    return TransactionSendResult(
      receiver: (receiver != null ? receiver.value : this.receiver),
      receiverShard: (receiverShard != null
          ? receiverShard.value
          : this.receiverShard),
      sender: (sender != null ? sender.value : this.sender),
      senderShard: (senderShard != null ? senderShard.value : this.senderShard),
      status: (status != null ? status.value : this.status),
      txHash: (txHash != null ? txHash.value : this.txHash),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageReplyDto {
  const ChatMessageReplyDto({
    required this.sender,
    required this.content,
    required this.timestamp,
    required this.id,
  });

  factory ChatMessageReplyDto.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageReplyDtoFromJson(json);

  static const toJsonFactory = _$ChatMessageReplyDtoToJson;
  Map<String, dynamic> toJson() => _$ChatMessageReplyDtoToJson(this);

  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'content')
  final ChatMessageReplyDto content;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'id')
  final String id;
  static const fromJsonFactory = _$ChatMessageReplyDtoFromJson;
}

extension $ChatMessageReplyDtoExtension on ChatMessageReplyDto {
  ChatMessageReplyDto copyWith({
    String? sender,
    ChatMessageReplyDto? content,
    int? timestamp,
    String? id,
  }) {
    return ChatMessageReplyDto(
      sender: sender ?? this.sender,
      content: content ?? this.content,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
    );
  }

  ChatMessageReplyDto copyWithWrapped({
    Wrapped<String>? sender,
    Wrapped<ChatMessageReplyDto>? content,
    Wrapped<int>? timestamp,
    Wrapped<String>? id,
  }) {
    return ChatMessageReplyDto(
      sender: (sender != null ? sender.value : this.sender),
      content: (content != null ? content.value : this.content),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageContentDto {
  const ChatMessageContentDto({
    required this.type,
    required this.$value,
    this.replyTo,
  });

  factory ChatMessageContentDto.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageContentDtoFromJson(json);

  static const toJsonFactory = _$ChatMessageContentDtoToJson;
  Map<String, dynamic> toJson() => _$ChatMessageContentDtoToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'replyTo')
  final ChatMessageReplyDto? replyTo;
  static const fromJsonFactory = _$ChatMessageContentDtoFromJson;
}

extension $ChatMessageContentDtoExtension on ChatMessageContentDto {
  ChatMessageContentDto copyWith({
    String? type,
    String? $value,
    ChatMessageReplyDto? replyTo,
  }) {
    return ChatMessageContentDto(
      type: type ?? this.type,
      $value: $value ?? this.$value,
      replyTo: replyTo ?? this.replyTo,
    );
  }

  ChatMessageContentDto copyWithWrapped({
    Wrapped<String>? type,
    Wrapped<String>? $value,
    Wrapped<ChatMessageReplyDto?>? replyTo,
  }) {
    return ChatMessageContentDto(
      type: (type != null ? type.value : this.type),
      $value: ($value != null ? $value.value : this.$value),
      replyTo: (replyTo != null ? replyTo.value : this.replyTo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SendChatMessageDto {
  const SendChatMessageDto({
    required this.sender,
    required this.content,
    required this.receiver,
  });

  factory SendChatMessageDto.fromJson(Map<String, dynamic> json) =>
      _$SendChatMessageDtoFromJson(json);

  static const toJsonFactory = _$SendChatMessageDtoToJson;
  Map<String, dynamic> toJson() => _$SendChatMessageDtoToJson(this);

  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'content')
  final ChatMessageContentDto content;
  @JsonKey(name: 'receiver')
  final String receiver;
  static const fromJsonFactory = _$SendChatMessageDtoFromJson;
}

extension $SendChatMessageDtoExtension on SendChatMessageDto {
  SendChatMessageDto copyWith({
    String? sender,
    ChatMessageContentDto? content,
    String? receiver,
  }) {
    return SendChatMessageDto(
      sender: sender ?? this.sender,
      content: content ?? this.content,
      receiver: receiver ?? this.receiver,
    );
  }

  SendChatMessageDto copyWithWrapped({
    Wrapped<String>? sender,
    Wrapped<ChatMessageContentDto>? content,
    Wrapped<String>? receiver,
  }) {
    return SendChatMessageDto(
      sender: (sender != null ? sender.value : this.sender),
      content: (content != null ? content.value : this.content),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MessageDto {
  const MessageDto({
    required this.content,
    required this.isRead,
    required this.timestamp,
    required this.sender,
    required this.isDeletedFor,
  });

  factory MessageDto.fromJson(Map<String, dynamic> json) =>
      _$MessageDtoFromJson(json);

  static const toJsonFactory = _$MessageDtoToJson;
  Map<String, dynamic> toJson() => _$MessageDtoToJson(this);

  @JsonKey(name: 'content')
  final ChatMessageContentDto content;
  @JsonKey(name: 'isRead')
  final bool isRead;
  @JsonKey(name: 'timestamp')
  final double timestamp;
  @JsonKey(name: 'sender')
  final String sender;
  @JsonKey(name: 'isDeletedFor', defaultValue: <String>[])
  final List<String> isDeletedFor;
  static const fromJsonFactory = _$MessageDtoFromJson;
}

extension $MessageDtoExtension on MessageDto {
  MessageDto copyWith({
    ChatMessageContentDto? content,
    bool? isRead,
    double? timestamp,
    String? sender,
    List<String>? isDeletedFor,
  }) {
    return MessageDto(
      content: content ?? this.content,
      isRead: isRead ?? this.isRead,
      timestamp: timestamp ?? this.timestamp,
      sender: sender ?? this.sender,
      isDeletedFor: isDeletedFor ?? this.isDeletedFor,
    );
  }

  MessageDto copyWithWrapped({
    Wrapped<ChatMessageContentDto>? content,
    Wrapped<bool>? isRead,
    Wrapped<double>? timestamp,
    Wrapped<String>? sender,
    Wrapped<List<String>>? isDeletedFor,
  }) {
    return MessageDto(
      content: (content != null ? content.value : this.content),
      isRead: (isRead != null ? isRead.value : this.isRead),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      sender: (sender != null ? sender.value : this.sender),
      isDeletedFor: (isDeletedFor != null
          ? isDeletedFor.value
          : this.isDeletedFor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessageDocHydrated {
  const ChatMessageDocHydrated({
    required this.dataType,
    required this.chatId,
    required this.isGroupChat,
    required this.message,
    required this.pk,
    required this.id,
    required this.ttl,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory ChatMessageDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageDocHydratedFromJson(json);

  static const toJsonFactory = _$ChatMessageDocHydratedToJson;
  Map<String, dynamic> toJson() => _$ChatMessageDocHydratedToJson(this);

  @JsonKey(name: 'dataType')
  final Object dataType;
  @JsonKey(name: 'chatId')
  final String chatId;
  @JsonKey(name: 'isGroupChat')
  final bool isGroupChat;
  @JsonKey(name: 'message')
  final MessageDto message;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'ttl')
  final double ttl;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$ChatMessageDocHydratedFromJson;
}

extension $ChatMessageDocHydratedExtension on ChatMessageDocHydrated {
  ChatMessageDocHydrated copyWith({
    Object? dataType,
    String? chatId,
    bool? isGroupChat,
    MessageDto? message,
    String? pk,
    String? id,
    double? ttl,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return ChatMessageDocHydrated(
      dataType: dataType ?? this.dataType,
      chatId: chatId ?? this.chatId,
      isGroupChat: isGroupChat ?? this.isGroupChat,
      message: message ?? this.message,
      pk: pk ?? this.pk,
      id: id ?? this.id,
      ttl: ttl ?? this.ttl,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  ChatMessageDocHydrated copyWithWrapped({
    Wrapped<Object>? dataType,
    Wrapped<String>? chatId,
    Wrapped<bool>? isGroupChat,
    Wrapped<MessageDto>? message,
    Wrapped<String>? pk,
    Wrapped<String>? id,
    Wrapped<double>? ttl,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return ChatMessageDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      chatId: (chatId != null ? chatId.value : this.chatId),
      isGroupChat: (isGroupChat != null ? isGroupChat.value : this.isGroupChat),
      message: (message != null ? message.value : this.message),
      pk: (pk != null ? pk.value : this.pk),
      id: (id != null ? id.value : this.id),
      ttl: (ttl != null ? ttl.value : this.ttl),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserConversationDocHydrated {
  const UserConversationDocHydrated({
    required this.dataType,
    this.chatName,
    required this.isGroupChat,
    required this.chatId,
    required this.message,
    this.deleteTimestamp,
    this.unreadCount,
    required this.id,
    required this.pk,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory UserConversationDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$UserConversationDocHydratedFromJson(json);

  static const toJsonFactory = _$UserConversationDocHydratedToJson;
  Map<String, dynamic> toJson() => _$UserConversationDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userConversationDocHydratedDataTypeToJson,
    fromJson: userConversationDocHydratedDataTypeDataTypeFromJson,
  )
  final enums.UserConversationDocHydratedDataType dataType;
  static enums.UserConversationDocHydratedDataType
  userConversationDocHydratedDataTypeDataTypeFromJson(Object? value) =>
      userConversationDocHydratedDataTypeFromJson(
        value,
        enums.UserConversationDocHydratedDataType.conversation,
      );

  @JsonKey(name: 'chatName')
  final Object? chatName;
  @JsonKey(name: 'isGroupChat')
  final bool isGroupChat;
  @JsonKey(name: 'chatId')
  final String chatId;
  @JsonKey(name: 'message')
  final MessageDto message;
  @JsonKey(name: 'deleteTimestamp')
  final Object? deleteTimestamp;
  @JsonKey(name: 'unreadCount')
  final Object? unreadCount;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$UserConversationDocHydratedFromJson;
}

extension $UserConversationDocHydratedExtension on UserConversationDocHydrated {
  UserConversationDocHydrated copyWith({
    enums.UserConversationDocHydratedDataType? dataType,
    Object? chatName,
    bool? isGroupChat,
    String? chatId,
    MessageDto? message,
    Object? deleteTimestamp,
    Object? unreadCount,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return UserConversationDocHydrated(
      dataType: dataType ?? this.dataType,
      chatName: chatName ?? this.chatName,
      isGroupChat: isGroupChat ?? this.isGroupChat,
      chatId: chatId ?? this.chatId,
      message: message ?? this.message,
      deleteTimestamp: deleteTimestamp ?? this.deleteTimestamp,
      unreadCount: unreadCount ?? this.unreadCount,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  UserConversationDocHydrated copyWithWrapped({
    Wrapped<enums.UserConversationDocHydratedDataType>? dataType,
    Wrapped<Object?>? chatName,
    Wrapped<bool>? isGroupChat,
    Wrapped<String>? chatId,
    Wrapped<MessageDto>? message,
    Wrapped<Object?>? deleteTimestamp,
    Wrapped<Object?>? unreadCount,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return UserConversationDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      chatName: (chatName != null ? chatName.value : this.chatName),
      isGroupChat: (isGroupChat != null ? isGroupChat.value : this.isGroupChat),
      chatId: (chatId != null ? chatId.value : this.chatId),
      message: (message != null ? message.value : this.message),
      deleteTimestamp: (deleteTimestamp != null
          ? deleteTimestamp.value
          : this.deleteTimestamp),
      unreadCount: (unreadCount != null ? unreadCount.value : this.unreadCount),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserConversationPaginated {
  const UserConversationPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory UserConversationPaginated.fromJson(Map<String, dynamic> json) =>
      _$UserConversationPaginatedFromJson(json);

  static const toJsonFactory = _$UserConversationPaginatedToJson;
  Map<String, dynamic> toJson() => _$UserConversationPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <UserConversationDocHydrated>[])
  final List<UserConversationDocHydrated> resources;
  static const fromJsonFactory = _$UserConversationPaginatedFromJson;
}

extension $UserConversationPaginatedExtension on UserConversationPaginated {
  UserConversationPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<UserConversationDocHydrated>? resources,
  }) {
    return UserConversationPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  UserConversationPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<UserConversationDocHydrated>>? resources,
  }) {
    return UserConversationPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ChatMessagePaginated {
  const ChatMessagePaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
    required this.receiver,
  });

  factory ChatMessagePaginated.fromJson(Map<String, dynamic> json) =>
      _$ChatMessagePaginatedFromJson(json);

  static const toJsonFactory = _$ChatMessagePaginatedToJson;
  Map<String, dynamic> toJson() => _$ChatMessagePaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <ChatMessageDocHydrated>[])
  final List<ChatMessageDocHydrated> resources;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$ChatMessagePaginatedFromJson;
}

extension $ChatMessagePaginatedExtension on ChatMessagePaginated {
  ChatMessagePaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<ChatMessageDocHydrated>? resources,
    OwnerDto? receiver,
  }) {
    return ChatMessagePaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
      receiver: receiver ?? this.receiver,
    );
  }

  ChatMessagePaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<ChatMessageDocHydrated>>? resources,
    Wrapped<OwnerDto>? receiver,
  }) {
    return ChatMessagePaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UnreadMessageCountByChatIdDto {
  const UnreadMessageCountByChatIdDto({
    required this.unreadCount,
    required this.chatId,
  });

  factory UnreadMessageCountByChatIdDto.fromJson(Map<String, dynamic> json) =>
      _$UnreadMessageCountByChatIdDtoFromJson(json);

  static const toJsonFactory = _$UnreadMessageCountByChatIdDtoToJson;
  Map<String, dynamic> toJson() => _$UnreadMessageCountByChatIdDtoToJson(this);

  @JsonKey(name: 'unreadCount')
  final double unreadCount;
  @JsonKey(name: 'chatId')
  final String chatId;
  static const fromJsonFactory = _$UnreadMessageCountByChatIdDtoFromJson;
}

extension $UnreadMessageCountByChatIdDtoExtension
    on UnreadMessageCountByChatIdDto {
  UnreadMessageCountByChatIdDto copyWith({
    double? unreadCount,
    String? chatId,
  }) {
    return UnreadMessageCountByChatIdDto(
      unreadCount: unreadCount ?? this.unreadCount,
      chatId: chatId ?? this.chatId,
    );
  }

  UnreadMessageCountByChatIdDto copyWithWrapped({
    Wrapped<double>? unreadCount,
    Wrapped<String>? chatId,
  }) {
    return UnreadMessageCountByChatIdDto(
      unreadCount: (unreadCount != null ? unreadCount.value : this.unreadCount),
      chatId: (chatId != null ? chatId.value : this.chatId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class GlobalConversationSummaryDto {
  const GlobalConversationSummaryDto({
    required this.totalUnreadChats,
    required this.totalUnreadMessages,
    required this.unreadMessageCountByChatId,
  });

  factory GlobalConversationSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$GlobalConversationSummaryDtoFromJson(json);

  static const toJsonFactory = _$GlobalConversationSummaryDtoToJson;
  Map<String, dynamic> toJson() => _$GlobalConversationSummaryDtoToJson(this);

  @JsonKey(name: 'totalUnreadChats')
  final double totalUnreadChats;
  @JsonKey(name: 'totalUnreadMessages')
  final double totalUnreadMessages;
  @JsonKey(
    name: 'unreadMessageCountByChatId',
    defaultValue: <UnreadMessageCountByChatIdDto>[],
  )
  final List<UnreadMessageCountByChatIdDto> unreadMessageCountByChatId;
  static const fromJsonFactory = _$GlobalConversationSummaryDtoFromJson;
}

extension $GlobalConversationSummaryDtoExtension
    on GlobalConversationSummaryDto {
  GlobalConversationSummaryDto copyWith({
    double? totalUnreadChats,
    double? totalUnreadMessages,
    List<UnreadMessageCountByChatIdDto>? unreadMessageCountByChatId,
  }) {
    return GlobalConversationSummaryDto(
      totalUnreadChats: totalUnreadChats ?? this.totalUnreadChats,
      totalUnreadMessages: totalUnreadMessages ?? this.totalUnreadMessages,
      unreadMessageCountByChatId:
          unreadMessageCountByChatId ?? this.unreadMessageCountByChatId,
    );
  }

  GlobalConversationSummaryDto copyWithWrapped({
    Wrapped<double>? totalUnreadChats,
    Wrapped<double>? totalUnreadMessages,
    Wrapped<List<UnreadMessageCountByChatIdDto>>? unreadMessageCountByChatId,
  }) {
    return GlobalConversationSummaryDto(
      totalUnreadChats: (totalUnreadChats != null
          ? totalUnreadChats.value
          : this.totalUnreadChats),
      totalUnreadMessages: (totalUnreadMessages != null
          ? totalUnreadMessages.value
          : this.totalUnreadMessages),
      unreadMessageCountByChatId: (unreadMessageCountByChatId != null
          ? unreadMessageCountByChatId.value
          : this.unreadMessageCountByChatId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBlockDocHydrated {
  const UserBlockDocHydrated({
    required this.dataType,
    required this.timestamp,
    required this.id,
    required this.pk,
    required this.ts,
    required this.sender,
    required this.receiver,
  });

  factory UserBlockDocHydrated.fromJson(Map<String, dynamic> json) =>
      _$UserBlockDocHydratedFromJson(json);

  static const toJsonFactory = _$UserBlockDocHydratedToJson;
  Map<String, dynamic> toJson() => _$UserBlockDocHydratedToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: userBlockDocHydratedDataTypeToJson,
    fromJson: userBlockDocHydratedDataTypeDataTypeFromJson,
  )
  final enums.UserBlockDocHydratedDataType dataType;
  static enums.UserBlockDocHydratedDataType
  userBlockDocHydratedDataTypeDataTypeFromJson(Object? value) =>
      userBlockDocHydratedDataTypeFromJson(
        value,
        enums.UserBlockDocHydratedDataType.blockeduser,
      );

  @JsonKey(name: 'timestamp')
  final Object timestamp;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: '_ts')
  final double ts;
  @JsonKey(name: 'sender')
  final OwnerDto sender;
  @JsonKey(name: 'receiver')
  final OwnerDto receiver;
  static const fromJsonFactory = _$UserBlockDocHydratedFromJson;
}

extension $UserBlockDocHydratedExtension on UserBlockDocHydrated {
  UserBlockDocHydrated copyWith({
    enums.UserBlockDocHydratedDataType? dataType,
    Object? timestamp,
    String? id,
    String? pk,
    double? ts,
    OwnerDto? sender,
    OwnerDto? receiver,
  }) {
    return UserBlockDocHydrated(
      dataType: dataType ?? this.dataType,
      timestamp: timestamp ?? this.timestamp,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      sender: sender ?? this.sender,
      receiver: receiver ?? this.receiver,
    );
  }

  UserBlockDocHydrated copyWithWrapped({
    Wrapped<enums.UserBlockDocHydratedDataType>? dataType,
    Wrapped<Object>? timestamp,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<double>? ts,
    Wrapped<OwnerDto>? sender,
    Wrapped<OwnerDto>? receiver,
  }) {
    return UserBlockDocHydrated(
      dataType: (dataType != null ? dataType.value : this.dataType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      sender: (sender != null ? sender.value : this.sender),
      receiver: (receiver != null ? receiver.value : this.receiver),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBlockPaginated {
  const UserBlockPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory UserBlockPaginated.fromJson(Map<String, dynamic> json) =>
      _$UserBlockPaginatedFromJson(json);

  static const toJsonFactory = _$UserBlockPaginatedToJson;
  Map<String, dynamic> toJson() => _$UserBlockPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <UserBlockDocHydrated>[])
  final List<UserBlockDocHydrated> resources;
  static const fromJsonFactory = _$UserBlockPaginatedFromJson;
}

extension $UserBlockPaginatedExtension on UserBlockPaginated {
  UserBlockPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<UserBlockDocHydrated>? resources,
  }) {
    return UserBlockPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  UserBlockPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<UserBlockDocHydrated>>? resources,
  }) {
    return UserBlockPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class WebSocketTokenDto {
  const WebSocketTokenDto({required this.token});

  factory WebSocketTokenDto.fromJson(Map<String, dynamic> json) =>
      _$WebSocketTokenDtoFromJson(json);

  static const toJsonFactory = _$WebSocketTokenDtoToJson;
  Map<String, dynamic> toJson() => _$WebSocketTokenDtoToJson(this);

  @JsonKey(name: 'token')
  final String token;
  static const fromJsonFactory = _$WebSocketTokenDtoFromJson;
}

extension $WebSocketTokenDtoExtension on WebSocketTokenDto {
  WebSocketTokenDto copyWith({String? token}) {
    return WebSocketTokenDto(token: token ?? this.token);
  }

  WebSocketTokenDto copyWithWrapped({Wrapped<String>? token}) {
    return WebSocketTokenDto(token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class UserInfo {
  const UserInfo({
    required this.collateral,
    required this.collateralShort,
    required this.collateralUsd,
    required this.borrow,
    required this.borrowShort,
    required this.borrowUsd,
    required this.health,
    required this.healthPercentage,
    required this.markets,
  });

  factory UserInfo.fromJson(Map<String, dynamic> json) =>
      _$UserInfoFromJson(json);

  static const toJsonFactory = _$UserInfoToJson;
  Map<String, dynamic> toJson() => _$UserInfoToJson(this);

  @JsonKey(name: 'collateral')
  final String collateral;
  @JsonKey(name: 'collateralShort')
  final double collateralShort;
  @JsonKey(name: 'collateralUsd')
  final double collateralUsd;
  @JsonKey(name: 'borrow')
  final String borrow;
  @JsonKey(name: 'borrowShort')
  final double borrowShort;
  @JsonKey(name: 'borrowUsd')
  final double borrowUsd;
  @JsonKey(name: 'health')
  final String health;
  @JsonKey(name: 'healthPercentage')
  final double healthPercentage;
  @JsonKey(name: 'markets', defaultValue: <String>[])
  final List<String> markets;
  static const fromJsonFactory = _$UserInfoFromJson;
}

extension $UserInfoExtension on UserInfo {
  UserInfo copyWith({
    String? collateral,
    double? collateralShort,
    double? collateralUsd,
    String? borrow,
    double? borrowShort,
    double? borrowUsd,
    String? health,
    double? healthPercentage,
    List<String>? markets,
  }) {
    return UserInfo(
      collateral: collateral ?? this.collateral,
      collateralShort: collateralShort ?? this.collateralShort,
      collateralUsd: collateralUsd ?? this.collateralUsd,
      borrow: borrow ?? this.borrow,
      borrowShort: borrowShort ?? this.borrowShort,
      borrowUsd: borrowUsd ?? this.borrowUsd,
      health: health ?? this.health,
      healthPercentage: healthPercentage ?? this.healthPercentage,
      markets: markets ?? this.markets,
    );
  }

  UserInfo copyWithWrapped({
    Wrapped<String>? collateral,
    Wrapped<double>? collateralShort,
    Wrapped<double>? collateralUsd,
    Wrapped<String>? borrow,
    Wrapped<double>? borrowShort,
    Wrapped<double>? borrowUsd,
    Wrapped<String>? health,
    Wrapped<double>? healthPercentage,
    Wrapped<List<String>>? markets,
  }) {
    return UserInfo(
      collateral: (collateral != null ? collateral.value : this.collateral),
      collateralShort: (collateralShort != null
          ? collateralShort.value
          : this.collateralShort),
      collateralUsd: (collateralUsd != null
          ? collateralUsd.value
          : this.collateralUsd),
      borrow: (borrow != null ? borrow.value : this.borrow),
      borrowShort: (borrowShort != null ? borrowShort.value : this.borrowShort),
      borrowUsd: (borrowUsd != null ? borrowUsd.value : this.borrowUsd),
      health: (health != null ? health.value : this.health),
      healthPercentage: (healthPercentage != null
          ? healthPercentage.value
          : this.healthPercentage),
      markets: (markets != null ? markets.value : this.markets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RegistrationDetailsCreateDto {
  const RegistrationDetailsCreateDto({
    required this.visibility,
    required this.maxLimit,
    required this.userLimit,
    required this.requireKYC,
    required this.requireName,
    required this.requireEmail,
    required this.requirePhoneNumber,
    required this.isPublished,
    required this.hasSideEvents,
    required this.hasWaitlist,
    required this.showGuestCount,
    required this.refundable,
    required this.nameWithNumber,
    required this.botProtection,
  });

  factory RegistrationDetailsCreateDto.fromJson(Map<String, dynamic> json) =>
      _$RegistrationDetailsCreateDtoFromJson(json);

  static const toJsonFactory = _$RegistrationDetailsCreateDtoToJson;
  Map<String, dynamic> toJson() => _$RegistrationDetailsCreateDtoToJson(this);

  @JsonKey(
    name: 'visibility',
    toJson: visibilityToJson,
    fromJson: visibilityFromJson,
  )
  final enums.Visibility visibility;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'requireKYC')
  final bool requireKYC;
  @JsonKey(name: 'requireName')
  final bool requireName;
  @JsonKey(name: 'requireEmail')
  final bool requireEmail;
  @JsonKey(name: 'requirePhoneNumber')
  final bool requirePhoneNumber;
  @JsonKey(name: 'isPublished')
  final bool isPublished;
  @JsonKey(name: 'hasSideEvents')
  final bool hasSideEvents;
  @JsonKey(name: 'hasWaitlist')
  final bool hasWaitlist;
  @JsonKey(name: 'showGuestCount')
  final bool showGuestCount;
  @JsonKey(name: 'refundable')
  final bool refundable;
  @JsonKey(name: 'nameWithNumber')
  final bool nameWithNumber;
  @JsonKey(name: 'botProtection')
  final bool botProtection;
  static const fromJsonFactory = _$RegistrationDetailsCreateDtoFromJson;
}

extension $RegistrationDetailsCreateDtoExtension
    on RegistrationDetailsCreateDto {
  RegistrationDetailsCreateDto copyWith({
    enums.Visibility? visibility,
    int? maxLimit,
    int? userLimit,
    bool? requireKYC,
    bool? requireName,
    bool? requireEmail,
    bool? requirePhoneNumber,
    bool? isPublished,
    bool? hasSideEvents,
    bool? hasWaitlist,
    bool? showGuestCount,
    bool? refundable,
    bool? nameWithNumber,
    bool? botProtection,
  }) {
    return RegistrationDetailsCreateDto(
      visibility: visibility ?? this.visibility,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      requireKYC: requireKYC ?? this.requireKYC,
      requireName: requireName ?? this.requireName,
      requireEmail: requireEmail ?? this.requireEmail,
      requirePhoneNumber: requirePhoneNumber ?? this.requirePhoneNumber,
      isPublished: isPublished ?? this.isPublished,
      hasSideEvents: hasSideEvents ?? this.hasSideEvents,
      hasWaitlist: hasWaitlist ?? this.hasWaitlist,
      showGuestCount: showGuestCount ?? this.showGuestCount,
      refundable: refundable ?? this.refundable,
      nameWithNumber: nameWithNumber ?? this.nameWithNumber,
      botProtection: botProtection ?? this.botProtection,
    );
  }

  RegistrationDetailsCreateDto copyWithWrapped({
    Wrapped<enums.Visibility>? visibility,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? requireKYC,
    Wrapped<bool>? requireName,
    Wrapped<bool>? requireEmail,
    Wrapped<bool>? requirePhoneNumber,
    Wrapped<bool>? isPublished,
    Wrapped<bool>? hasSideEvents,
    Wrapped<bool>? hasWaitlist,
    Wrapped<bool>? showGuestCount,
    Wrapped<bool>? refundable,
    Wrapped<bool>? nameWithNumber,
    Wrapped<bool>? botProtection,
  }) {
    return RegistrationDetailsCreateDto(
      visibility: (visibility != null ? visibility.value : this.visibility),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      requireKYC: (requireKYC != null ? requireKYC.value : this.requireKYC),
      requireName: (requireName != null ? requireName.value : this.requireName),
      requireEmail: (requireEmail != null
          ? requireEmail.value
          : this.requireEmail),
      requirePhoneNumber: (requirePhoneNumber != null
          ? requirePhoneNumber.value
          : this.requirePhoneNumber),
      isPublished: (isPublished != null ? isPublished.value : this.isPublished),
      hasSideEvents: (hasSideEvents != null
          ? hasSideEvents.value
          : this.hasSideEvents),
      hasWaitlist: (hasWaitlist != null ? hasWaitlist.value : this.hasWaitlist),
      showGuestCount: (showGuestCount != null
          ? showGuestCount.value
          : this.showGuestCount),
      refundable: (refundable != null ? refundable.value : this.refundable),
      nameWithNumber: (nameWithNumber != null
          ? nameWithNumber.value
          : this.nameWithNumber),
      botProtection: (botProtection != null
          ? botProtection.value
          : this.botProtection),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileCreateDto {
  const EventProfileCreateDto({
    required this.title,
    required this.startTime,
    required this.endTime,
    required this.location,
    required this.isVirtualEvent,
    this.slug,
    required this.category,
    this.subCategory,
    this.seo,
    required this.registration,
  });

  factory EventProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileCreateDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'location')
  final EventLocationDto location;
  @JsonKey(name: 'isVirtualEvent')
  final bool isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryToJson,
    fromJson: eventCategoryFromJson,
  )
  final enums.EventCategory category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'registration')
  final RegistrationDetailsCreateDto registration;
  static const fromJsonFactory = _$EventProfileCreateDtoFromJson;
}

extension $EventProfileCreateDtoExtension on EventProfileCreateDto {
  EventProfileCreateDto copyWith({
    String? title,
    int? startTime,
    int? endTime,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    EventSeoDto? seo,
    RegistrationDetailsCreateDto? registration,
  }) {
    return EventProfileCreateDto(
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      seo: seo ?? this.seo,
      registration: registration ?? this.registration,
    );
  }

  EventProfileCreateDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<EventLocationDto>? location,
    Wrapped<bool>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<enums.EventCategory>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<RegistrationDetailsCreateDto>? registration,
  }) {
    return EventProfileCreateDto(
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      seo: (seo != null ? seo.value : this.seo),
      registration: (registration != null
          ? registration.value
          : this.registration),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileFilterCriteriaDto {
  const EventProfileFilterCriteriaDto({
    this.searchText,
    this.area,
    this.latitude,
    this.longitude,
    this.rangeKm,
    this.range,
    this.category,
    this.subCategory,
  });

  factory EventProfileFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventProfileFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'area', defaultValue: <String>[])
  final List<String>? area;
  @JsonKey(name: 'latitude')
  final double? latitude;
  @JsonKey(name: 'longitude')
  final double? longitude;
  @JsonKey(name: 'rangeKm')
  final double? rangeKm;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'subCategory', defaultValue: <String>[])
  final List<String>? subCategory;
  static const fromJsonFactory = _$EventProfileFilterCriteriaDtoFromJson;
}

extension $EventProfileFilterCriteriaDtoExtension
    on EventProfileFilterCriteriaDto {
  EventProfileFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? area,
    double? latitude,
    double? longitude,
    double? rangeKm,
    List<RangeFilter>? range,
    List<String>? category,
    List<String>? subCategory,
  }) {
    return EventProfileFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      area: area ?? this.area,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      rangeKm: rangeKm ?? this.rangeKm,
      range: range ?? this.range,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
    );
  }

  EventProfileFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? area,
    Wrapped<double?>? latitude,
    Wrapped<double?>? longitude,
    Wrapped<double?>? rangeKm,
    Wrapped<List<RangeFilter>?>? range,
    Wrapped<List<String>?>? category,
    Wrapped<List<String>?>? subCategory,
  }) {
    return EventProfileFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      area: (area != null ? area.value : this.area),
      latitude: (latitude != null ? latitude.value : this.latitude),
      longitude: (longitude != null ? longitude.value : this.longitude),
      rangeKm: (rangeKm != null ? rangeKm.value : this.rangeKm),
      range: (range != null ? range.value : this.range),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventExtraProperties {
  const EventExtraProperties({
    this.creatorProfile,
    this.guestSummary,
    this.startsFrom,
  });

  factory EventExtraProperties.fromJson(Map<String, dynamic> json) =>
      _$EventExtraPropertiesFromJson(json);

  static const toJsonFactory = _$EventExtraPropertiesToJson;
  Map<String, dynamic> toJson() => _$EventExtraPropertiesToJson(this);

  @JsonKey(name: 'creatorProfile')
  final bool? creatorProfile;
  @JsonKey(name: 'guestSummary')
  final bool? guestSummary;
  @JsonKey(name: 'startsFrom')
  final bool? startsFrom;
  static const fromJsonFactory = _$EventExtraPropertiesFromJson;
}

extension $EventExtraPropertiesExtension on EventExtraProperties {
  EventExtraProperties copyWith({
    bool? creatorProfile,
    bool? guestSummary,
    bool? startsFrom,
  }) {
    return EventExtraProperties(
      creatorProfile: creatorProfile ?? this.creatorProfile,
      guestSummary: guestSummary ?? this.guestSummary,
      startsFrom: startsFrom ?? this.startsFrom,
    );
  }

  EventExtraProperties copyWithWrapped({
    Wrapped<bool?>? creatorProfile,
    Wrapped<bool?>? guestSummary,
    Wrapped<bool?>? startsFrom,
  }) {
    return EventExtraProperties(
      creatorProfile: (creatorProfile != null
          ? creatorProfile.value
          : this.creatorProfile),
      guestSummary: (guestSummary != null
          ? guestSummary.value
          : this.guestSummary),
      startsFrom: (startsFrom != null ? startsFrom.value : this.startsFrom),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileFilter {
  const EventProfileFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
    this.extraProperties,
  });

  factory EventProfileFilter.fromJson(Map<String, dynamic> json) =>
      _$EventProfileFilterFromJson(json);

  static const toJsonFactory = _$EventProfileFilterToJson;
  Map<String, dynamic> toJson() => _$EventProfileFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventProfileFilterCriteriaDto filters;
  @JsonKey(name: 'extraProperties')
  final EventExtraProperties? extraProperties;
  static const fromJsonFactory = _$EventProfileFilterFromJson;
}

extension $EventProfileFilterExtension on EventProfileFilter {
  EventProfileFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventProfileFilterCriteriaDto? filters,
    EventExtraProperties? extraProperties,
  }) {
    return EventProfileFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
      extraProperties: extraProperties ?? this.extraProperties,
    );
  }

  EventProfileFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventProfileFilterCriteriaDto>? filters,
    Wrapped<EventExtraProperties?>? extraProperties,
  }) {
    return EventProfileFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
      extraProperties: (extraProperties != null
          ? extraProperties.value
          : this.extraProperties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileQuery {
  const EventProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$EventProfileQueryFromJson(json);

  static const toJsonFactory = _$EventProfileQueryToJson;
  Map<String, dynamic> toJson() => _$EventProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventProfile>[])
  final List<EventProfile> resources;
  static const fromJsonFactory = _$EventProfileQueryFromJson;
}

extension $EventProfileQueryExtension on EventProfileQuery {
  EventProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventProfile>? resources,
  }) {
    return EventProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventProfile>>? resources,
  }) {
    return EventProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventProfileEditDto {
  const EventProfileEditDto({
    this.title,
    this.startTime,
    this.endTime,
    this.location,
    this.isVirtualEvent,
    this.slug,
    this.category,
    this.subCategory,
    this.seo,
    this.registration,
  });

  factory EventProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventProfileEditDtoToJson(this);

  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'startTime')
  final int? startTime;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'location')
  final EventLocationDto? location;
  @JsonKey(name: 'isVirtualEvent')
  final bool? isVirtualEvent;
  @JsonKey(name: 'slug')
  final String? slug;
  @JsonKey(
    name: 'category',
    toJson: eventCategoryNullableToJson,
    fromJson: eventCategoryNullableFromJson,
  )
  final enums.EventCategory? category;
  @JsonKey(
    name: 'subCategory',
    toJson: eventSubCategoryNullableToJson,
    fromJson: eventSubCategoryNullableFromJson,
  )
  final enums.EventSubCategory? subCategory;
  @JsonKey(name: 'seo')
  final EventSeoDto? seo;
  @JsonKey(name: 'registration')
  final RegistrationDetailsCreateDto? registration;
  static const fromJsonFactory = _$EventProfileEditDtoFromJson;
}

extension $EventProfileEditDtoExtension on EventProfileEditDto {
  EventProfileEditDto copyWith({
    String? title,
    int? startTime,
    int? endTime,
    EventLocationDto? location,
    bool? isVirtualEvent,
    String? slug,
    enums.EventCategory? category,
    enums.EventSubCategory? subCategory,
    EventSeoDto? seo,
    RegistrationDetailsCreateDto? registration,
  }) {
    return EventProfileEditDto(
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      location: location ?? this.location,
      isVirtualEvent: isVirtualEvent ?? this.isVirtualEvent,
      slug: slug ?? this.slug,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      seo: seo ?? this.seo,
      registration: registration ?? this.registration,
    );
  }

  EventProfileEditDto copyWithWrapped({
    Wrapped<String?>? title,
    Wrapped<int?>? startTime,
    Wrapped<int?>? endTime,
    Wrapped<EventLocationDto?>? location,
    Wrapped<bool?>? isVirtualEvent,
    Wrapped<String?>? slug,
    Wrapped<enums.EventCategory?>? category,
    Wrapped<enums.EventSubCategory?>? subCategory,
    Wrapped<EventSeoDto?>? seo,
    Wrapped<RegistrationDetailsCreateDto?>? registration,
  }) {
    return EventProfileEditDto(
      title: (title != null ? title.value : this.title),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      location: (location != null ? location.value : this.location),
      isVirtualEvent: (isVirtualEvent != null
          ? isVirtualEvent.value
          : this.isVirtualEvent),
      slug: (slug != null ? slug.value : this.slug),
      category: (category != null ? category.value : this.category),
      subCategory: (subCategory != null ? subCategory.value : this.subCategory),
      seo: (seo != null ? seo.value : this.seo),
      registration: (registration != null
          ? registration.value
          : this.registration),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketSelectionDto {
  const TicketSelectionDto({
    required this.ticketProfileId,
    required this.ticketStageId,
    required this.quantity,
    this.price,
    this.name,
    this.description,
    this.currency,
  });

  factory TicketSelectionDto.fromJson(Map<String, dynamic> json) =>
      _$TicketSelectionDtoFromJson(json);

  static const toJsonFactory = _$TicketSelectionDtoToJson;
  Map<String, dynamic> toJson() => _$TicketSelectionDtoToJson(this);

  @JsonKey(name: 'ticketProfileId')
  final String ticketProfileId;
  @JsonKey(name: 'ticketStageId')
  final String ticketStageId;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$TicketSelectionDtoFromJson;
}

extension $TicketSelectionDtoExtension on TicketSelectionDto {
  TicketSelectionDto copyWith({
    String? ticketProfileId,
    String? ticketStageId,
    int? quantity,
    double? price,
    String? name,
    String? description,
    String? currency,
  }) {
    return TicketSelectionDto(
      ticketProfileId: ticketProfileId ?? this.ticketProfileId,
      ticketStageId: ticketStageId ?? this.ticketStageId,
      quantity: quantity ?? this.quantity,
      price: price ?? this.price,
      name: name ?? this.name,
      description: description ?? this.description,
      currency: currency ?? this.currency,
    );
  }

  TicketSelectionDto copyWithWrapped({
    Wrapped<String>? ticketProfileId,
    Wrapped<String>? ticketStageId,
    Wrapped<int>? quantity,
    Wrapped<double?>? price,
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? currency,
  }) {
    return TicketSelectionDto(
      ticketProfileId: (ticketProfileId != null
          ? ticketProfileId.value
          : this.ticketProfileId),
      ticketStageId: (ticketStageId != null
          ? ticketStageId.value
          : this.ticketStageId),
      quantity: (quantity != null ? quantity.value : this.quantity),
      price: (price != null ? price.value : this.price),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      currency: (currency != null ? currency.value : this.currency),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionAnswerDto {
  const EventQuestionAnswerDto({
    required this.questionId,
    required this.answer,
  });

  factory EventQuestionAnswerDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionAnswerDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionAnswerDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionAnswerDtoToJson(this);

  @JsonKey(name: 'questionId')
  final String questionId;
  @JsonKey(name: 'answer')
  final Object answer;
  static const fromJsonFactory = _$EventQuestionAnswerDtoFromJson;
}

extension $EventQuestionAnswerDtoExtension on EventQuestionAnswerDto {
  EventQuestionAnswerDto copyWith({String? questionId, Object? answer}) {
    return EventQuestionAnswerDto(
      questionId: questionId ?? this.questionId,
      answer: answer ?? this.answer,
    );
  }

  EventQuestionAnswerDto copyWithWrapped({
    Wrapped<String>? questionId,
    Wrapped<Object>? answer,
  }) {
    return EventQuestionAnswerDto(
      questionId: (questionId != null ? questionId.value : this.questionId),
      answer: (answer != null ? answer.value : this.answer),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CallbackUrl {
  const CallbackUrl({
    required this.success,
    required this.error,
    required this.successClose,
    required this.errorClose,
  });

  factory CallbackUrl.fromJson(Map<String, dynamic> json) =>
      _$CallbackUrlFromJson(json);

  static const toJsonFactory = _$CallbackUrlToJson;
  Map<String, dynamic> toJson() => _$CallbackUrlToJson(this);

  @JsonKey(name: 'success')
  final String success;
  @JsonKey(name: 'error')
  final String error;
  @JsonKey(name: 'successClose')
  final String successClose;
  @JsonKey(name: 'errorClose')
  final String errorClose;
  static const fromJsonFactory = _$CallbackUrlFromJson;
}

extension $CallbackUrlExtension on CallbackUrl {
  CallbackUrl copyWith({
    String? success,
    String? error,
    String? successClose,
    String? errorClose,
  }) {
    return CallbackUrl(
      success: success ?? this.success,
      error: error ?? this.error,
      successClose: successClose ?? this.successClose,
      errorClose: errorClose ?? this.errorClose,
    );
  }

  CallbackUrl copyWithWrapped({
    Wrapped<String>? success,
    Wrapped<String>? error,
    Wrapped<String>? successClose,
    Wrapped<String>? errorClose,
  }) {
    return CallbackUrl(
      success: (success != null ? success.value : this.success),
      error: (error != null ? error.value : this.error),
      successClose: (successClose != null
          ? successClose.value
          : this.successClose),
      errorClose: (errorClose != null ? errorClose.value : this.errorClose),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DigitalWalletDto {
  const DigitalWalletDto({required this.walletType, this.data});

  factory DigitalWalletDto.fromJson(Map<String, dynamic> json) =>
      _$DigitalWalletDtoFromJson(json);

  static const toJsonFactory = _$DigitalWalletDtoToJson;
  Map<String, dynamic> toJson() => _$DigitalWalletDtoToJson(this);

  @JsonKey(
    name: 'walletType',
    toJson: digitalWalletDtoWalletTypeToJson,
    fromJson: digitalWalletDtoWalletTypeFromJson,
  )
  final enums.DigitalWalletDtoWalletType walletType;
  @JsonKey(name: 'data')
  final dynamic data;
  static const fromJsonFactory = _$DigitalWalletDtoFromJson;
}

extension $DigitalWalletDtoExtension on DigitalWalletDto {
  DigitalWalletDto copyWith({
    enums.DigitalWalletDtoWalletType? walletType,
    dynamic data,
  }) {
    return DigitalWalletDto(
      walletType: walletType ?? this.walletType,
      data: data ?? this.data,
    );
  }

  DigitalWalletDto copyWithWrapped({
    Wrapped<enums.DigitalWalletDtoWalletType>? walletType,
    Wrapped<dynamic>? data,
  }) {
    return DigitalWalletDto(
      walletType: (walletType != null ? walletType.value : this.walletType),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestRegistrationDto {
  const EventGuestRegistrationDto({
    this.email,
    this.name,
    this.phone,
    this.ticketSelections,
    this.code,
    this.payWithCrypto,
    this.currency,
    this.questionAnswers,
    this.callbackUrl,
    this.digitalWallet,
  });

  factory EventGuestRegistrationDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestRegistrationDtoFromJson(json);

  static const toJsonFactory = _$EventGuestRegistrationDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestRegistrationDtoToJson(this);

  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'ticketSelections', defaultValue: <TicketSelectionDto>[])
  final List<TicketSelectionDto>? ticketSelections;
  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(name: 'payWithCrypto', defaultValue: false)
  final bool? payWithCrypto;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'questionAnswers', defaultValue: <EventQuestionAnswerDto>[])
  final List<EventQuestionAnswerDto>? questionAnswers;
  @JsonKey(name: 'callbackUrl')
  final CallbackUrl? callbackUrl;
  @JsonKey(name: 'digitalWallet')
  final DigitalWalletDto? digitalWallet;
  static const fromJsonFactory = _$EventGuestRegistrationDtoFromJson;
}

extension $EventGuestRegistrationDtoExtension on EventGuestRegistrationDto {
  EventGuestRegistrationDto copyWith({
    String? email,
    String? name,
    String? phone,
    List<TicketSelectionDto>? ticketSelections,
    String? code,
    bool? payWithCrypto,
    String? currency,
    List<EventQuestionAnswerDto>? questionAnswers,
    CallbackUrl? callbackUrl,
    DigitalWalletDto? digitalWallet,
  }) {
    return EventGuestRegistrationDto(
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      ticketSelections: ticketSelections ?? this.ticketSelections,
      code: code ?? this.code,
      payWithCrypto: payWithCrypto ?? this.payWithCrypto,
      currency: currency ?? this.currency,
      questionAnswers: questionAnswers ?? this.questionAnswers,
      callbackUrl: callbackUrl ?? this.callbackUrl,
      digitalWallet: digitalWallet ?? this.digitalWallet,
    );
  }

  EventGuestRegistrationDto copyWithWrapped({
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
    Wrapped<List<TicketSelectionDto>?>? ticketSelections,
    Wrapped<String?>? code,
    Wrapped<bool?>? payWithCrypto,
    Wrapped<String?>? currency,
    Wrapped<List<EventQuestionAnswerDto>?>? questionAnswers,
    Wrapped<CallbackUrl?>? callbackUrl,
    Wrapped<DigitalWalletDto?>? digitalWallet,
  }) {
    return EventGuestRegistrationDto(
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      ticketSelections: (ticketSelections != null
          ? ticketSelections.value
          : this.ticketSelections),
      code: (code != null ? code.value : this.code),
      payWithCrypto: (payWithCrypto != null
          ? payWithCrypto.value
          : this.payWithCrypto),
      currency: (currency != null ? currency.value : this.currency),
      questionAnswers: (questionAnswers != null
          ? questionAnswers.value
          : this.questionAnswers),
      callbackUrl: (callbackUrl != null ? callbackUrl.value : this.callbackUrl),
      digitalWallet: (digitalWallet != null
          ? digitalWallet.value
          : this.digitalWallet),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwispayPaymentFormData {
  const TwispayPaymentFormData({
    required this.base64JsonRequest,
    required this.base64Checksum,
  });

  factory TwispayPaymentFormData.fromJson(Map<String, dynamic> json) =>
      _$TwispayPaymentFormDataFromJson(json);

  static const toJsonFactory = _$TwispayPaymentFormDataToJson;
  Map<String, dynamic> toJson() => _$TwispayPaymentFormDataToJson(this);

  @JsonKey(name: 'base64JsonRequest')
  final String base64JsonRequest;
  @JsonKey(name: 'base64Checksum')
  final String base64Checksum;
  static const fromJsonFactory = _$TwispayPaymentFormDataFromJson;
}

extension $TwispayPaymentFormDataExtension on TwispayPaymentFormData {
  TwispayPaymentFormData copyWith({
    String? base64JsonRequest,
    String? base64Checksum,
  }) {
    return TwispayPaymentFormData(
      base64JsonRequest: base64JsonRequest ?? this.base64JsonRequest,
      base64Checksum: base64Checksum ?? this.base64Checksum,
    );
  }

  TwispayPaymentFormData copyWithWrapped({
    Wrapped<String>? base64JsonRequest,
    Wrapped<String>? base64Checksum,
  }) {
    return TwispayPaymentFormData(
      base64JsonRequest: (base64JsonRequest != null
          ? base64JsonRequest.value
          : this.base64JsonRequest),
      base64Checksum: (base64Checksum != null
          ? base64Checksum.value
          : this.base64Checksum),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StripePaymentFormData {
  const StripePaymentFormData({
    required this.sessionId,
    required this.publicKey,
  });

  factory StripePaymentFormData.fromJson(Map<String, dynamic> json) =>
      _$StripePaymentFormDataFromJson(json);

  static const toJsonFactory = _$StripePaymentFormDataToJson;
  Map<String, dynamic> toJson() => _$StripePaymentFormDataToJson(this);

  @JsonKey(name: 'sessionId')
  final String sessionId;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  static const fromJsonFactory = _$StripePaymentFormDataFromJson;
}

extension $StripePaymentFormDataExtension on StripePaymentFormData {
  StripePaymentFormData copyWith({String? sessionId, String? publicKey}) {
    return StripePaymentFormData(
      sessionId: sessionId ?? this.sessionId,
      publicKey: publicKey ?? this.publicKey,
    );
  }

  StripePaymentFormData copyWithWrapped({
    Wrapped<String>? sessionId,
    Wrapped<String>? publicKey,
  }) {
    return StripePaymentFormData(
      sessionId: (sessionId != null ? sessionId.value : this.sessionId),
      publicKey: (publicKey != null ? publicKey.value : this.publicKey),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TwispayDigitalWalletPaymentData {
  const TwispayDigitalWalletPaymentData({
    required this.orderId,
    required this.externalOrderId,
    required this.transactionId,
    required this.is3d,
    required this.isRedirect,
    this.redirectUrl,
    this.redirectMethod,
    this.redirectParams,
  });

  factory TwispayDigitalWalletPaymentData.fromJson(Map<String, dynamic> json) =>
      _$TwispayDigitalWalletPaymentDataFromJson(json);

  static const toJsonFactory = _$TwispayDigitalWalletPaymentDataToJson;
  Map<String, dynamic> toJson() =>
      _$TwispayDigitalWalletPaymentDataToJson(this);

  @JsonKey(name: 'orderId')
  final double orderId;
  @JsonKey(name: 'externalOrderId')
  final String externalOrderId;
  @JsonKey(name: 'transactionId')
  final double transactionId;
  @JsonKey(name: 'is3d')
  final bool is3d;
  @JsonKey(name: 'isRedirect')
  final bool isRedirect;
  @JsonKey(name: 'redirectUrl')
  final String? redirectUrl;
  @JsonKey(name: 'redirectMethod')
  final String? redirectMethod;
  @JsonKey(name: 'redirectParams')
  final Object? redirectParams;
  static const fromJsonFactory = _$TwispayDigitalWalletPaymentDataFromJson;
}

extension $TwispayDigitalWalletPaymentDataExtension
    on TwispayDigitalWalletPaymentData {
  TwispayDigitalWalletPaymentData copyWith({
    double? orderId,
    String? externalOrderId,
    double? transactionId,
    bool? is3d,
    bool? isRedirect,
    String? redirectUrl,
    String? redirectMethod,
    Object? redirectParams,
  }) {
    return TwispayDigitalWalletPaymentData(
      orderId: orderId ?? this.orderId,
      externalOrderId: externalOrderId ?? this.externalOrderId,
      transactionId: transactionId ?? this.transactionId,
      is3d: is3d ?? this.is3d,
      isRedirect: isRedirect ?? this.isRedirect,
      redirectUrl: redirectUrl ?? this.redirectUrl,
      redirectMethod: redirectMethod ?? this.redirectMethod,
      redirectParams: redirectParams ?? this.redirectParams,
    );
  }

  TwispayDigitalWalletPaymentData copyWithWrapped({
    Wrapped<double>? orderId,
    Wrapped<String>? externalOrderId,
    Wrapped<double>? transactionId,
    Wrapped<bool>? is3d,
    Wrapped<bool>? isRedirect,
    Wrapped<String?>? redirectUrl,
    Wrapped<String?>? redirectMethod,
    Wrapped<Object?>? redirectParams,
  }) {
    return TwispayDigitalWalletPaymentData(
      orderId: (orderId != null ? orderId.value : this.orderId),
      externalOrderId: (externalOrderId != null
          ? externalOrderId.value
          : this.externalOrderId),
      transactionId: (transactionId != null
          ? transactionId.value
          : this.transactionId),
      is3d: (is3d != null ? is3d.value : this.is3d),
      isRedirect: (isRedirect != null ? isRedirect.value : this.isRedirect),
      redirectUrl: (redirectUrl != null ? redirectUrl.value : this.redirectUrl),
      redirectMethod: (redirectMethod != null
          ? redirectMethod.value
          : this.redirectMethod),
      redirectParams: (redirectParams != null
          ? redirectParams.value
          : this.redirectParams),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FiatPaymentForm {
  const FiatPaymentForm({required this.type, required this.data});

  factory FiatPaymentForm.fromJson(Map<String, dynamic> json) =>
      _$FiatPaymentFormFromJson(json);

  static const toJsonFactory = _$FiatPaymentFormToJson;
  Map<String, dynamic> toJson() => _$FiatPaymentFormToJson(this);

  @JsonKey(
    name: 'type',
    toJson: paymentProviderToJson,
    fromJson: paymentProviderFromJson,
  )
  final enums.PaymentProvider type;
  @JsonKey(name: 'data')
  final dynamic data;
  static const fromJsonFactory = _$FiatPaymentFormFromJson;
}

extension $FiatPaymentFormExtension on FiatPaymentForm {
  FiatPaymentForm copyWith({enums.PaymentProvider? type, dynamic data}) {
    return FiatPaymentForm(type: type ?? this.type, data: data ?? this.data);
  }

  FiatPaymentForm copyWithWrapped({
    Wrapped<enums.PaymentProvider>? type,
    Wrapped<dynamic>? data,
  }) {
    return FiatPaymentForm(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CryptoPaymentResult {
  const CryptoPaymentResult({required this.signature, required this.data});

  factory CryptoPaymentResult.fromJson(Map<String, dynamic> json) =>
      _$CryptoPaymentResultFromJson(json);

  static const toJsonFactory = _$CryptoPaymentResultToJson;
  Map<String, dynamic> toJson() => _$CryptoPaymentResultToJson(this);

  @JsonKey(name: 'signature')
  final String signature;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$CryptoPaymentResultFromJson;
}

extension $CryptoPaymentResultExtension on CryptoPaymentResult {
  CryptoPaymentResult copyWith({String? signature, String? data}) {
    return CryptoPaymentResult(
      signature: signature ?? this.signature,
      data: data ?? this.data,
    );
  }

  CryptoPaymentResult copyWithWrapped({
    Wrapped<String>? signature,
    Wrapped<String>? data,
  }) {
    return CryptoPaymentResult(
      signature: (signature != null ? signature.value : this.signature),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationResponseDto {
  const EventRegistrationResponseDto({
    required this.guestDoc,
    this.fiatPaymentForm,
    this.cryptoPayment,
  });

  factory EventRegistrationResponseDto.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationResponseDtoFromJson(json);

  static const toJsonFactory = _$EventRegistrationResponseDtoToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationResponseDtoToJson(this);

  @JsonKey(name: 'guestDoc')
  final EventGuestProfile guestDoc;
  @JsonKey(name: 'fiatPaymentForm')
  final FiatPaymentForm? fiatPaymentForm;
  @JsonKey(name: 'cryptoPayment')
  final CryptoPaymentResult? cryptoPayment;
  static const fromJsonFactory = _$EventRegistrationResponseDtoFromJson;
}

extension $EventRegistrationResponseDtoExtension
    on EventRegistrationResponseDto {
  EventRegistrationResponseDto copyWith({
    EventGuestProfile? guestDoc,
    FiatPaymentForm? fiatPaymentForm,
    CryptoPaymentResult? cryptoPayment,
  }) {
    return EventRegistrationResponseDto(
      guestDoc: guestDoc ?? this.guestDoc,
      fiatPaymentForm: fiatPaymentForm ?? this.fiatPaymentForm,
      cryptoPayment: cryptoPayment ?? this.cryptoPayment,
    );
  }

  EventRegistrationResponseDto copyWithWrapped({
    Wrapped<EventGuestProfile>? guestDoc,
    Wrapped<FiatPaymentForm?>? fiatPaymentForm,
    Wrapped<CryptoPaymentResult?>? cryptoPayment,
  }) {
    return EventRegistrationResponseDto(
      guestDoc: (guestDoc != null ? guestDoc.value : this.guestDoc),
      fiatPaymentForm: (fiatPaymentForm != null
          ? fiatPaymentForm.value
          : this.fiatPaymentForm),
      cryptoPayment: (cryptoPayment != null
          ? cryptoPayment.value
          : this.cryptoPayment),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileCreateDto {
  const EventTicketProfileCreateDto({
    this.name,
    this.description,
    this.royalties,
    this.badgeColor,
    this.maxLimit,
    required this.userLimit,
  });

  factory EventTicketProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventTicketProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileCreateDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  static const fromJsonFactory = _$EventTicketProfileCreateDtoFromJson;
}

extension $EventTicketProfileCreateDtoExtension on EventTicketProfileCreateDto {
  EventTicketProfileCreateDto copyWith({
    String? name,
    String? description,
    double? royalties,
    String? badgeColor,
    int? maxLimit,
    int? userLimit,
  }) {
    return EventTicketProfileCreateDto(
      name: name ?? this.name,
      description: description ?? this.description,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
    );
  }

  EventTicketProfileCreateDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<int?>? maxLimit,
    Wrapped<int>? userLimit,
  }) {
    return EventTicketProfileCreateDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileDoc {
  const EventTicketProfileDoc({
    required this.dataType,
    required this.eventId,
    this.name,
    this.description,
    this.profile,
    this.royalties,
    this.badgeColor,
    this.characteristics,
    this.maxLimit,
    required this.userLimit,
    required this.soldCount,
    required this.createdAt,
    required this.id,
    this.pk,
    this.ts,
  });

  factory EventTicketProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileDocFromJson(json);

  static const toJsonFactory = _$EventTicketProfileDocToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'soldCount')
  final int soldCount;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  static const fromJsonFactory = _$EventTicketProfileDocFromJson;
}

extension $EventTicketProfileDocExtension on EventTicketProfileDoc {
  EventTicketProfileDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? description,
    String? profile,
    double? royalties,
    String? badgeColor,
    Object? characteristics,
    int? maxLimit,
    int? userLimit,
    int? soldCount,
    int? createdAt,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventTicketProfileDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      description: description ?? this.description,
      profile: profile ?? this.profile,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      soldCount: soldCount ?? this.soldCount,
      createdAt: createdAt ?? this.createdAt,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventTicketProfileDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? profile,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<int?>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<int>? soldCount,
    Wrapped<int>? createdAt,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
  }) {
    return EventTicketProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      profile: (profile != null ? profile.value : this.profile),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventTicketProfileEditDto {
  const EventTicketProfileEditDto({
    this.name,
    this.description,
    this.royalties,
    this.badgeColor,
    this.maxLimit,
    this.userLimit,
  });

  factory EventTicketProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventTicketProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventTicketProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventTicketProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int? userLimit;
  static const fromJsonFactory = _$EventTicketProfileEditDtoFromJson;
}

extension $EventTicketProfileEditDtoExtension on EventTicketProfileEditDto {
  EventTicketProfileEditDto copyWith({
    String? name,
    String? description,
    double? royalties,
    String? badgeColor,
    int? maxLimit,
    int? userLimit,
  }) {
    return EventTicketProfileEditDto(
      name: name ?? this.name,
      description: description ?? this.description,
      royalties: royalties ?? this.royalties,
      badgeColor: badgeColor ?? this.badgeColor,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
    );
  }

  EventTicketProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<double?>? royalties,
    Wrapped<String?>? badgeColor,
    Wrapped<int?>? maxLimit,
    Wrapped<int?>? userLimit,
  }) {
    return EventTicketProfileEditDto(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      royalties: (royalties != null ? royalties.value : this.royalties),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileCreateDto {
  const EventStageProfileCreateDto({
    required this.ticketId,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.maxLimit,
    required this.userLimit,
    required this.isEnabled,
    required this.isWhitelist,
    required this.requiredApproval,
    required this.prices,
  });

  factory EventStageProfileCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileCreateDtoFromJson(json);

  static const toJsonFactory = _$EventStageProfileCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileCreateDtoToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'isEnabled')
  final bool isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  static const fromJsonFactory = _$EventStageProfileCreateDtoFromJson;
}

extension $EventStageProfileCreateDtoExtension on EventStageProfileCreateDto {
  EventStageProfileCreateDto copyWith({
    String? ticketId,
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
  }) {
    return EventStageProfileCreateDto(
      ticketId: ticketId ?? this.ticketId,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
    );
  }

  EventStageProfileCreateDto copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<String>? name,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? isEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<bool>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
  }) {
    return EventStageProfileCreateDto(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileDoc {
  const EventStageProfileDoc({
    required this.dataType,
    required this.eventId,
    required this.ticketId,
    required this.name,
    required this.startTime,
    required this.endTime,
    required this.maxLimit,
    required this.userLimit,
    required this.isEnabled,
    required this.isWhitelist,
    required this.requiredApproval,
    required this.prices,
    required this.soldCount,
    required this.id,
    this.pk,
    this.ts,
  });

  factory EventStageProfileDoc.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileDocFromJson(json);

  static const toJsonFactory = _$EventStageProfileDocToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventTicketStage,
  );

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'maxLimit')
  final int maxLimit;
  @JsonKey(name: 'userLimit')
  final int userLimit;
  @JsonKey(name: 'isEnabled')
  final bool isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment> prices;
  @JsonKey(name: 'soldCount')
  final int soldCount;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  static const fromJsonFactory = _$EventStageProfileDocFromJson;
}

extension $EventStageProfileDocExtension on EventStageProfileDoc {
  EventStageProfileDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? ticketId,
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
    int? soldCount,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventStageProfileDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      ticketId: ticketId ?? this.ticketId,
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
      soldCount: soldCount ?? this.soldCount,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventStageProfileDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String>? ticketId,
    Wrapped<String>? name,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? maxLimit,
    Wrapped<int>? userLimit,
    Wrapped<bool>? isEnabled,
    Wrapped<bool>? isWhitelist,
    Wrapped<bool>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>>? prices,
    Wrapped<int>? soldCount,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
  }) {
    return EventStageProfileDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
      soldCount: (soldCount != null ? soldCount.value : this.soldCount),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventStageProfileEditDto {
  const EventStageProfileEditDto({
    this.name,
    this.startTime,
    this.endTime,
    this.maxLimit,
    this.userLimit,
    this.isEnabled,
    this.isWhitelist,
    this.requiredApproval,
    this.prices,
  });

  factory EventStageProfileEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventStageProfileEditDtoFromJson(json);

  static const toJsonFactory = _$EventStageProfileEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventStageProfileEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'startTime')
  final int? startTime;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'maxLimit')
  final int? maxLimit;
  @JsonKey(name: 'userLimit')
  final int? userLimit;
  @JsonKey(name: 'isEnabled')
  final bool? isEnabled;
  @JsonKey(name: 'isWhitelist')
  final bool? isWhitelist;
  @JsonKey(name: 'requiredApproval')
  final bool? requiredApproval;
  @JsonKey(name: 'prices', defaultValue: <EgldOrEsdtTokenPayment>[])
  final List<EgldOrEsdtTokenPayment>? prices;
  static const fromJsonFactory = _$EventStageProfileEditDtoFromJson;
}

extension $EventStageProfileEditDtoExtension on EventStageProfileEditDto {
  EventStageProfileEditDto copyWith({
    String? name,
    int? startTime,
    int? endTime,
    int? maxLimit,
    int? userLimit,
    bool? isEnabled,
    bool? isWhitelist,
    bool? requiredApproval,
    List<EgldOrEsdtTokenPayment>? prices,
  }) {
    return EventStageProfileEditDto(
      name: name ?? this.name,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      maxLimit: maxLimit ?? this.maxLimit,
      userLimit: userLimit ?? this.userLimit,
      isEnabled: isEnabled ?? this.isEnabled,
      isWhitelist: isWhitelist ?? this.isWhitelist,
      requiredApproval: requiredApproval ?? this.requiredApproval,
      prices: prices ?? this.prices,
    );
  }

  EventStageProfileEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<int?>? startTime,
    Wrapped<int?>? endTime,
    Wrapped<int?>? maxLimit,
    Wrapped<int?>? userLimit,
    Wrapped<bool?>? isEnabled,
    Wrapped<bool?>? isWhitelist,
    Wrapped<bool?>? requiredApproval,
    Wrapped<List<EgldOrEsdtTokenPayment>?>? prices,
  }) {
    return EventStageProfileEditDto(
      name: (name != null ? name.value : this.name),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      maxLimit: (maxLimit != null ? maxLimit.value : this.maxLimit),
      userLimit: (userLimit != null ? userLimit.value : this.userLimit),
      isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
      isWhitelist: (isWhitelist != null ? isWhitelist.value : this.isWhitelist),
      requiredApproval: (requiredApproval != null
          ? requiredApproval.value
          : this.requiredApproval),
      prices: (prices != null ? prices.value : this.prices),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketCalculationRequestDto {
  const TicketCalculationRequestDto({
    this.code,
    required this.ticketSelections,
  });

  factory TicketCalculationRequestDto.fromJson(Map<String, dynamic> json) =>
      _$TicketCalculationRequestDtoFromJson(json);

  static const toJsonFactory = _$TicketCalculationRequestDtoToJson;
  Map<String, dynamic> toJson() => _$TicketCalculationRequestDtoToJson(this);

  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(name: 'ticketSelections', defaultValue: <TicketSelectionDto>[])
  final List<TicketSelectionDto> ticketSelections;
  static const fromJsonFactory = _$TicketCalculationRequestDtoFromJson;
}

extension $TicketCalculationRequestDtoExtension on TicketCalculationRequestDto {
  TicketCalculationRequestDto copyWith({
    String? code,
    List<TicketSelectionDto>? ticketSelections,
  }) {
    return TicketCalculationRequestDto(
      code: code ?? this.code,
      ticketSelections: ticketSelections ?? this.ticketSelections,
    );
  }

  TicketCalculationRequestDto copyWithWrapped({
    Wrapped<String?>? code,
    Wrapped<List<TicketSelectionDto>>? ticketSelections,
  }) {
    return TicketCalculationRequestDto(
      code: (code != null ? code.value : this.code),
      ticketSelections: (ticketSelections != null
          ? ticketSelections.value
          : this.ticketSelections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class StagePrice {
  const StagePrice({
    required this.stageId,
    required this.stageName,
    required this.ticketId,
    required this.ticketType,
    required this.currency,
    required this.normalPrice,
    required this.discountedPrice,
    required this.quantity,
  });

  factory StagePrice.fromJson(Map<String, dynamic> json) =>
      _$StagePriceFromJson(json);

  static const toJsonFactory = _$StagePriceToJson;
  Map<String, dynamic> toJson() => _$StagePriceToJson(this);

  @JsonKey(name: 'stageId')
  final String stageId;
  @JsonKey(name: 'stageName')
  final String stageName;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'ticketType')
  final String ticketType;
  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'normalPrice')
  final double normalPrice;
  @JsonKey(name: 'discountedPrice')
  final double discountedPrice;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory = _$StagePriceFromJson;
}

extension $StagePriceExtension on StagePrice {
  StagePrice copyWith({
    String? stageId,
    String? stageName,
    String? ticketId,
    String? ticketType,
    String? currency,
    double? normalPrice,
    double? discountedPrice,
    int? quantity,
  }) {
    return StagePrice(
      stageId: stageId ?? this.stageId,
      stageName: stageName ?? this.stageName,
      ticketId: ticketId ?? this.ticketId,
      ticketType: ticketType ?? this.ticketType,
      currency: currency ?? this.currency,
      normalPrice: normalPrice ?? this.normalPrice,
      discountedPrice: discountedPrice ?? this.discountedPrice,
      quantity: quantity ?? this.quantity,
    );
  }

  StagePrice copyWithWrapped({
    Wrapped<String>? stageId,
    Wrapped<String>? stageName,
    Wrapped<String>? ticketId,
    Wrapped<String>? ticketType,
    Wrapped<String>? currency,
    Wrapped<double>? normalPrice,
    Wrapped<double>? discountedPrice,
    Wrapped<int>? quantity,
  }) {
    return StagePrice(
      stageId: (stageId != null ? stageId.value : this.stageId),
      stageName: (stageName != null ? stageName.value : this.stageName),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      ticketType: (ticketType != null ? ticketType.value : this.ticketType),
      currency: (currency != null ? currency.value : this.currency),
      normalPrice: (normalPrice != null ? normalPrice.value : this.normalPrice),
      discountedPrice: (discountedPrice != null
          ? discountedPrice.value
          : this.discountedPrice),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketPricesResponse {
  const TicketPricesResponse({
    required this.currency,
    required this.stagePrices,
    this.vat,
  });

  factory TicketPricesResponse.fromJson(Map<String, dynamic> json) =>
      _$TicketPricesResponseFromJson(json);

  static const toJsonFactory = _$TicketPricesResponseToJson;
  Map<String, dynamic> toJson() => _$TicketPricesResponseToJson(this);

  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'stagePrices', defaultValue: <StagePrice>[])
  final List<StagePrice> stagePrices;
  @JsonKey(name: 'vat')
  final double? vat;
  static const fromJsonFactory = _$TicketPricesResponseFromJson;
}

extension $TicketPricesResponseExtension on TicketPricesResponse {
  TicketPricesResponse copyWith({
    String? currency,
    List<StagePrice>? stagePrices,
    double? vat,
  }) {
    return TicketPricesResponse(
      currency: currency ?? this.currency,
      stagePrices: stagePrices ?? this.stagePrices,
      vat: vat ?? this.vat,
    );
  }

  TicketPricesResponse copyWithWrapped({
    Wrapped<String>? currency,
    Wrapped<List<StagePrice>>? stagePrices,
    Wrapped<double?>? vat,
  }) {
    return TicketPricesResponse(
      currency: (currency != null ? currency.value : this.currency),
      stagePrices: (stagePrices != null ? stagePrices.value : this.stagePrices),
      vat: (vat != null ? vat.value : this.vat),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class DiscountCodeValidationResponse {
  const DiscountCodeValidationResponse({
    required this.isValid,
    required this.discountType,
    required this.discountAmount,
    this.discountMaxAmount,
  });

  factory DiscountCodeValidationResponse.fromJson(Map<String, dynamic> json) =>
      _$DiscountCodeValidationResponseFromJson(json);

  static const toJsonFactory = _$DiscountCodeValidationResponseToJson;
  Map<String, dynamic> toJson() => _$DiscountCodeValidationResponseToJson(this);

  @JsonKey(name: 'isValid')
  final bool isValid;
  @JsonKey(name: 'discountType')
  final String discountType;
  @JsonKey(name: 'discountAmount')
  final double discountAmount;
  @JsonKey(name: 'discountMaxAmount')
  final double? discountMaxAmount;
  static const fromJsonFactory = _$DiscountCodeValidationResponseFromJson;
}

extension $DiscountCodeValidationResponseExtension
    on DiscountCodeValidationResponse {
  DiscountCodeValidationResponse copyWith({
    bool? isValid,
    String? discountType,
    double? discountAmount,
    double? discountMaxAmount,
  }) {
    return DiscountCodeValidationResponse(
      isValid: isValid ?? this.isValid,
      discountType: discountType ?? this.discountType,
      discountAmount: discountAmount ?? this.discountAmount,
      discountMaxAmount: discountMaxAmount ?? this.discountMaxAmount,
    );
  }

  DiscountCodeValidationResponse copyWithWrapped({
    Wrapped<bool>? isValid,
    Wrapped<String>? discountType,
    Wrapped<double>? discountAmount,
    Wrapped<double?>? discountMaxAmount,
  }) {
    return DiscountCodeValidationResponse(
      isValid: (isValid != null ? isValid.value : this.isValid),
      discountType: (discountType != null
          ? discountType.value
          : this.discountType),
      discountAmount: (discountAmount != null
          ? discountAmount.value
          : this.discountAmount),
      discountMaxAmount: (discountMaxAmount != null
          ? discountMaxAmount.value
          : this.discountMaxAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketsType {
  const TicketsType({required this.ticketId, required this.quantity});

  factory TicketsType.fromJson(Map<String, dynamic> json) =>
      _$TicketsTypeFromJson(json);

  static const toJsonFactory = _$TicketsTypeToJson;
  Map<String, dynamic> toJson() => _$TicketsTypeToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory = _$TicketsTypeFromJson;
}

extension $TicketsTypeExtension on TicketsType {
  TicketsType copyWith({String? ticketId, int? quantity}) {
    return TicketsType(
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
    );
  }

  TicketsType copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<int>? quantity,
  }) {
    return TicketsType(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationCreateDto {
  const EventInvitationCreateDto({
    this.name,
    this.email,
    required this.startTime,
    required this.endTime,
    required this.tickets,
  });

  factory EventInvitationCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationCreateDtoFromJson(json);

  static const toJsonFactory = _$EventInvitationCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventInvitationCreateDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'tickets', defaultValue: <TicketsType>[])
  final List<TicketsType> tickets;
  static const fromJsonFactory = _$EventInvitationCreateDtoFromJson;
}

extension $EventInvitationCreateDtoExtension on EventInvitationCreateDto {
  EventInvitationCreateDto copyWith({
    String? name,
    String? email,
    int? startTime,
    int? endTime,
    List<TicketsType>? tickets,
  }) {
    return EventInvitationCreateDto(
      name: name ?? this.name,
      email: email ?? this.email,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      tickets: tickets ?? this.tickets,
    );
  }

  EventInvitationCreateDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<List<TicketsType>>? tickets,
  }) {
    return EventInvitationCreateDto(
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      tickets: (tickets != null ? tickets.value : this.tickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketProfileSummary {
  const TicketProfileSummary({
    this.name,
    this.description,
    this.profile,
    this.badgeColor,
    this.characteristics,
    this.ticketId,
    this.quantity,
  });

  factory TicketProfileSummary.fromJson(Map<String, dynamic> json) =>
      _$TicketProfileSummaryFromJson(json);

  static const toJsonFactory = _$TicketProfileSummaryToJson;
  Map<String, dynamic> toJson() => _$TicketProfileSummaryToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'badgeColor')
  final String? badgeColor;
  @JsonKey(name: 'characteristics')
  final Object? characteristics;
  @JsonKey(name: 'ticketId')
  final String? ticketId;
  @JsonKey(name: 'quantity')
  final int? quantity;
  static const fromJsonFactory = _$TicketProfileSummaryFromJson;
}

extension $TicketProfileSummaryExtension on TicketProfileSummary {
  TicketProfileSummary copyWith({
    String? name,
    String? description,
    String? profile,
    String? badgeColor,
    Object? characteristics,
    String? ticketId,
    int? quantity,
  }) {
    return TicketProfileSummary(
      name: name ?? this.name,
      description: description ?? this.description,
      profile: profile ?? this.profile,
      badgeColor: badgeColor ?? this.badgeColor,
      characteristics: characteristics ?? this.characteristics,
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
    );
  }

  TicketProfileSummary copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<String?>? description,
    Wrapped<String?>? profile,
    Wrapped<String?>? badgeColor,
    Wrapped<Object?>? characteristics,
    Wrapped<String?>? ticketId,
    Wrapped<int?>? quantity,
  }) {
    return TicketProfileSummary(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      profile: (profile != null ? profile.value : this.profile),
      badgeColor: (badgeColor != null ? badgeColor.value : this.badgeColor),
      characteristics: (characteristics != null
          ? characteristics.value
          : this.characteristics),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationDoc {
  const EventInvitationDoc({
    required this.dataType,
    required this.eventId,
    this.name,
    this.email,
    this.phone,
    required this.tickets,
    required this.startTime,
    required this.endTime,
    required this.createdAt,
    required this.isClaimed,
    required this.isUsed,
    required this.status,
    required this.claimedAt,
    this.claimedBy,
    this.txHash,
    required this.id,
    this.pk,
    this.ts,
  });

  factory EventInvitationDoc.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationDocFromJson(json);

  static const toJsonFactory = _$EventInvitationDocToJson;
  Map<String, dynamic> toJson() => _$EventInvitationDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) =>
      ticketingDataTypeFromJson(value, enums.TicketingDataType.eventInvitation);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'tickets', defaultValue: <TicketProfileSummary>[])
  final List<TicketProfileSummary> tickets;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isClaimed')
  final bool isClaimed;
  @JsonKey(name: 'isUsed')
  final bool isUsed;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusToJson,
    fromJson: eventInvitationStatusStatusFromJson,
  )
  final enums.EventInvitationStatus status;
  static enums.EventInvitationStatus eventInvitationStatusStatusFromJson(
    Object? value,
  ) =>
      eventInvitationStatusFromJson(value, enums.EventInvitationStatus.pending);

  @JsonKey(name: 'claimedAt')
  final int claimedAt;
  @JsonKey(name: 'claimedBy')
  final String? claimedBy;
  @JsonKey(name: 'txHash')
  final String? txHash;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  static const fromJsonFactory = _$EventInvitationDocFromJson;
}

extension $EventInvitationDocExtension on EventInvitationDoc {
  EventInvitationDoc copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? email,
    String? phone,
    List<TicketProfileSummary>? tickets,
    int? startTime,
    int? endTime,
    int? createdAt,
    bool? isClaimed,
    bool? isUsed,
    enums.EventInvitationStatus? status,
    int? claimedAt,
    String? claimedBy,
    String? txHash,
    String? id,
    String? pk,
    int? ts,
  }) {
    return EventInvitationDoc(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      tickets: tickets ?? this.tickets,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      createdAt: createdAt ?? this.createdAt,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      status: status ?? this.status,
      claimedAt: claimedAt ?? this.claimedAt,
      claimedBy: claimedBy ?? this.claimedBy,
      txHash: txHash ?? this.txHash,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
    );
  }

  EventInvitationDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<List<TicketProfileSummary>>? tickets,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isClaimed,
    Wrapped<bool>? isUsed,
    Wrapped<enums.EventInvitationStatus>? status,
    Wrapped<int>? claimedAt,
    Wrapped<String?>? claimedBy,
    Wrapped<String?>? txHash,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
  }) {
    return EventInvitationDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      tickets: (tickets != null ? tickets.value : this.tickets),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      status: (status != null ? status.value : this.status),
      claimedAt: (claimedAt != null ? claimedAt.value : this.claimedAt),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      txHash: (txHash != null ? txHash.value : this.txHash),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationFilterCriteriaDto {
  const EventInvitationFilterCriteriaDto({
    this.searchText,
    this.claimedBy,
    this.eventId,
    this.email,
    this.status,
    this.isClaimed,
    this.isUsed,
    this.range,
  });

  factory EventInvitationFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$EventInvitationFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventInvitationFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$EventInvitationFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'claimedBy', defaultValue: <String>[])
  final List<String>? claimedBy;
  @JsonKey(name: 'eventId', defaultValue: <String>[])
  final List<String>? eventId;
  @JsonKey(name: 'email', defaultValue: <String>[])
  final List<String>? email;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusListToJson,
    fromJson: eventInvitationStatusListFromJson,
  )
  final List<enums.EventInvitationStatus>? status;
  @JsonKey(name: 'isClaimed')
  final bool? isClaimed;
  @JsonKey(name: 'isUsed')
  final bool? isUsed;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventInvitationFilterCriteriaDtoFromJson;
}

extension $EventInvitationFilterCriteriaDtoExtension
    on EventInvitationFilterCriteriaDto {
  EventInvitationFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? claimedBy,
    List<String>? eventId,
    List<String>? email,
    List<enums.EventInvitationStatus>? status,
    bool? isClaimed,
    bool? isUsed,
    List<RangeFilter>? range,
  }) {
    return EventInvitationFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      claimedBy: claimedBy ?? this.claimedBy,
      eventId: eventId ?? this.eventId,
      email: email ?? this.email,
      status: status ?? this.status,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      range: range ?? this.range,
    );
  }

  EventInvitationFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? claimedBy,
    Wrapped<List<String>?>? eventId,
    Wrapped<List<String>?>? email,
    Wrapped<List<enums.EventInvitationStatus>?>? status,
    Wrapped<bool?>? isClaimed,
    Wrapped<bool?>? isUsed,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventInvitationFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      eventId: (eventId != null ? eventId.value : this.eventId),
      email: (email != null ? email.value : this.email),
      status: (status != null ? status.value : this.status),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationFilter {
  const EventInvitationFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventInvitationFilter.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationFilterFromJson(json);

  static const toJsonFactory = _$EventInvitationFilterToJson;
  Map<String, dynamic> toJson() => _$EventInvitationFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventInvitationFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventInvitationFilterFromJson;
}

extension $EventInvitationFilterExtension on EventInvitationFilter {
  EventInvitationFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventInvitationFilterCriteriaDto? filters,
  }) {
    return EventInvitationFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventInvitationFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventInvitationFilterCriteriaDto>? filters,
  }) {
    return EventInvitationFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitation {
  const EventInvitation({
    required this.dataType,
    required this.eventId,
    this.name,
    this.email,
    this.phone,
    required this.tickets,
    required this.startTime,
    required this.endTime,
    required this.createdAt,
    required this.isClaimed,
    required this.isUsed,
    required this.status,
    required this.claimedAt,
    this.claimedBy,
    this.txHash,
    required this.id,
    this.pk,
    this.ts,
    this.profile,
    this.herotag,
  });

  factory EventInvitation.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationFromJson(json);

  static const toJsonFactory = _$EventInvitationToJson;
  Map<String, dynamic> toJson() => _$EventInvitationToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) =>
      ticketingDataTypeFromJson(value, enums.TicketingDataType.eventInvitation);

  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'tickets', defaultValue: <TicketProfileSummary>[])
  final List<TicketProfileSummary> tickets;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'endTime')
  final int endTime;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isClaimed')
  final bool isClaimed;
  @JsonKey(name: 'isUsed')
  final bool isUsed;
  @JsonKey(
    name: 'status',
    toJson: eventInvitationStatusToJson,
    fromJson: eventInvitationStatusStatusFromJson,
  )
  final enums.EventInvitationStatus status;
  static enums.EventInvitationStatus eventInvitationStatusStatusFromJson(
    Object? value,
  ) =>
      eventInvitationStatusFromJson(value, enums.EventInvitationStatus.pending);

  @JsonKey(name: 'claimedAt')
  final int claimedAt;
  @JsonKey(name: 'claimedBy')
  final String? claimedBy;
  @JsonKey(name: 'txHash')
  final String? txHash;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'profile')
  final String? profile;
  @JsonKey(name: 'herotag')
  final String? herotag;
  static const fromJsonFactory = _$EventInvitationFromJson;
}

extension $EventInvitationExtension on EventInvitation {
  EventInvitation copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? name,
    String? email,
    String? phone,
    List<TicketProfileSummary>? tickets,
    int? startTime,
    int? endTime,
    int? createdAt,
    bool? isClaimed,
    bool? isUsed,
    enums.EventInvitationStatus? status,
    int? claimedAt,
    String? claimedBy,
    String? txHash,
    String? id,
    String? pk,
    int? ts,
    String? profile,
    String? herotag,
  }) {
    return EventInvitation(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      tickets: tickets ?? this.tickets,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      createdAt: createdAt ?? this.createdAt,
      isClaimed: isClaimed ?? this.isClaimed,
      isUsed: isUsed ?? this.isUsed,
      status: status ?? this.status,
      claimedAt: claimedAt ?? this.claimedAt,
      claimedBy: claimedBy ?? this.claimedBy,
      txHash: txHash ?? this.txHash,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventInvitation copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? eventId,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<String?>? phone,
    Wrapped<List<TicketProfileSummary>>? tickets,
    Wrapped<int>? startTime,
    Wrapped<int>? endTime,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isClaimed,
    Wrapped<bool>? isUsed,
    Wrapped<enums.EventInvitationStatus>? status,
    Wrapped<int>? claimedAt,
    Wrapped<String?>? claimedBy,
    Wrapped<String?>? txHash,
    Wrapped<String>? id,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<String?>? profile,
    Wrapped<String?>? herotag,
  }) {
    return EventInvitation(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      phone: (phone != null ? phone.value : this.phone),
      tickets: (tickets != null ? tickets.value : this.tickets),
      startTime: (startTime != null ? startTime.value : this.startTime),
      endTime: (endTime != null ? endTime.value : this.endTime),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isClaimed: (isClaimed != null ? isClaimed.value : this.isClaimed),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
      status: (status != null ? status.value : this.status),
      claimedAt: (claimedAt != null ? claimedAt.value : this.claimedAt),
      claimedBy: (claimedBy != null ? claimedBy.value : this.claimedBy),
      txHash: (txHash != null ? txHash.value : this.txHash),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventInvitationQuery {
  const EventInvitationQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventInvitationQuery.fromJson(Map<String, dynamic> json) =>
      _$EventInvitationQueryFromJson(json);

  static const toJsonFactory = _$EventInvitationQueryToJson;
  Map<String, dynamic> toJson() => _$EventInvitationQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventInvitation>[])
  final List<EventInvitation> resources;
  static const fromJsonFactory = _$EventInvitationQueryFromJson;
}

extension $EventInvitationQueryExtension on EventInvitationQuery {
  EventInvitationQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventInvitation>? resources,
  }) {
    return EventInvitationQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventInvitationQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventInvitation>>? resources,
  }) {
    return EventInvitationQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherFilterCriteriaDto {
  const EventVoucherFilterCriteriaDto({
    this.searchText,
    this.code,
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.isActive,
    this.ownerId,
    this.range,
  });

  factory EventVoucherFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'code', defaultValue: <String>[])
  final List<String>? code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeListToJson,
    fromJson: voucherTypeListFromJson,
  )
  final List<enums.VoucherType>? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int? maxUsesPerUser;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventVoucherFilterCriteriaDtoFromJson;
}

extension $EventVoucherFilterCriteriaDtoExtension
    on EventVoucherFilterCriteriaDto {
  EventVoucherFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? code,
    List<enums.VoucherType>? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    bool? isActive,
    String? ownerId,
    List<RangeFilter>? range,
  }) {
    return EventVoucherFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      range: range ?? this.range,
    );
  }

  EventVoucherFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? code,
    Wrapped<List<enums.VoucherType>?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int?>? maxUses,
    Wrapped<int?>? maxUsesPerUser,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventVoucherFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherFilter {
  const EventVoucherFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventVoucherFilter.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherFilterFromJson(json);

  static const toJsonFactory = _$EventVoucherFilterToJson;
  Map<String, dynamic> toJson() => _$EventVoucherFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventVoucherFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventVoucherFilterFromJson;
}

extension $EventVoucherFilterExtension on EventVoucherFilter {
  EventVoucherFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventVoucherFilterCriteriaDto? filters,
  }) {
    return EventVoucherFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventVoucherFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventVoucherFilterCriteriaDto>? filters,
  }) {
    return EventVoucherFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherDoc {
  const EventVoucherDoc({
    required this.dataType,
    required this.id,
    required this.code,
    required this.type,
    required this.amount,
    this.maxDiscountAmount,
    required this.maxUses,
    required this.maxUsesPerUser,
    required this.usedCount,
    required this.eventId,
    required this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    required this.startDate,
    required this.endDate,
    required this.isActive,
    this.ownerId,
    required this.createdAt,
    required this.createdBy,
    required this.pk,
  });

  factory EventVoucherDoc.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherDocFromJson(json);

  static const toJsonFactory = _$EventVoucherDocToJson;
  Map<String, dynamic> toJson() => _$EventVoucherDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventVoucher);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'code')
  final String code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeToJson,
    fromJson: voucherTypeFromJson,
  )
  final enums.VoucherType type;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int maxUsesPerUser;
  @JsonKey(name: 'usedCount')
  final int usedCount;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String> ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int startDate;
  @JsonKey(name: 'endDate')
  final int endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'createdBy')
  final String createdBy;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventVoucherDocFromJson;
}

extension $EventVoucherDocExtension on EventVoucherDoc {
  EventVoucherDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? code,
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    int? usedCount,
    String? eventId,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    int? createdAt,
    String? createdBy,
    String? pk,
  }) {
    return EventVoucherDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      usedCount: usedCount ?? this.usedCount,
      eventId: eventId ?? this.eventId,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      createdAt: createdAt ?? this.createdAt,
      createdBy: createdBy ?? this.createdBy,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? code,
    Wrapped<enums.VoucherType>? type,
    Wrapped<double>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int>? maxUses,
    Wrapped<int>? maxUsesPerUser,
    Wrapped<int>? usedCount,
    Wrapped<String>? eventId,
    Wrapped<List<String>>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int>? startDate,
    Wrapped<int>? endDate,
    Wrapped<bool>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<int>? createdAt,
    Wrapped<String>? createdBy,
    Wrapped<String>? pk,
  }) {
    return EventVoucherDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      usedCount: (usedCount != null ? usedCount.value : this.usedCount),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherQuery {
  const EventVoucherQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventVoucherQuery.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherQueryFromJson(json);

  static const toJsonFactory = _$EventVoucherQueryToJson;
  Map<String, dynamic> toJson() => _$EventVoucherQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventVoucherDoc>[])
  final List<EventVoucherDoc> resources;
  static const fromJsonFactory = _$EventVoucherQueryFromJson;
}

extension $EventVoucherQueryExtension on EventVoucherQuery {
  EventVoucherQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventVoucherDoc>? resources,
  }) {
    return EventVoucherQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventVoucherQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventVoucherDoc>>? resources,
  }) {
    return EventVoucherQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionDoc {
  const EventQuestionDoc({
    required this.dataType,
    required this.id,
    required this.eventId,
    required this.title,
    required this.required,
    required this.answerType,
    required this.requireTime,
    this.answers,
    required this.createdAt,
    required this.pk,
  });

  factory EventQuestionDoc.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionDocFromJson(json);

  static const toJsonFactory = _$EventQuestionDocToJson;
  Map<String, dynamic> toJson() => _$EventQuestionDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(value, enums.TicketingDataType.eventQuestion);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'required')
  final bool required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeToJson,
    fromJson: eventQuestionAnswerTypeFromJson,
  )
  final enums.EventQuestionAnswerType answerType;
  @JsonKey(name: 'requireTime')
  final bool requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventQuestionDocFromJson;
}

extension $EventQuestionDocExtension on EventQuestionDoc {
  EventQuestionDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? eventId,
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
    int? createdAt,
    String? pk,
  }) {
    return EventQuestionDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      eventId: eventId ?? this.eventId,
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
      createdAt: createdAt ?? this.createdAt,
      pk: pk ?? this.pk,
    );
  }

  EventQuestionDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? eventId,
    Wrapped<String>? title,
    Wrapped<bool>? required,
    Wrapped<enums.EventQuestionAnswerType>? answerType,
    Wrapped<bool>? requireTime,
    Wrapped<List<String>?>? answers,
    Wrapped<int>? createdAt,
    Wrapped<String>? pk,
  }) {
    return EventQuestionDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      eventId: (eventId != null ? eventId.value : this.eventId),
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionCreateDto {
  const EventQuestionCreateDto({
    required this.title,
    required this.required,
    required this.answerType,
    required this.requireTime,
    this.answers,
  });

  factory EventQuestionCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionCreateDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionCreateDtoToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'required')
  final bool required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeToJson,
    fromJson: eventQuestionAnswerTypeFromJson,
  )
  final enums.EventQuestionAnswerType answerType;
  @JsonKey(name: 'requireTime')
  final bool requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  static const fromJsonFactory = _$EventQuestionCreateDtoFromJson;
}

extension $EventQuestionCreateDtoExtension on EventQuestionCreateDto {
  EventQuestionCreateDto copyWith({
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
  }) {
    return EventQuestionCreateDto(
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
    );
  }

  EventQuestionCreateDto copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<bool>? required,
    Wrapped<enums.EventQuestionAnswerType>? answerType,
    Wrapped<bool>? requireTime,
    Wrapped<List<String>?>? answers,
  }) {
    return EventQuestionCreateDto(
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventQuestionEditDto {
  const EventQuestionEditDto({
    this.title,
    this.required,
    this.answerType,
    this.requireTime,
    this.answers,
  });

  factory EventQuestionEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventQuestionEditDtoFromJson(json);

  static const toJsonFactory = _$EventQuestionEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventQuestionEditDtoToJson(this);

  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'required')
  final bool? required;
  @JsonKey(
    name: 'answerType',
    toJson: eventQuestionAnswerTypeNullableToJson,
    fromJson: eventQuestionAnswerTypeNullableFromJson,
  )
  final enums.EventQuestionAnswerType? answerType;
  @JsonKey(name: 'requireTime')
  final bool? requireTime;
  @JsonKey(name: 'answers', defaultValue: <String>[])
  final List<String>? answers;
  static const fromJsonFactory = _$EventQuestionEditDtoFromJson;
}

extension $EventQuestionEditDtoExtension on EventQuestionEditDto {
  EventQuestionEditDto copyWith({
    String? title,
    bool? required,
    enums.EventQuestionAnswerType? answerType,
    bool? requireTime,
    List<String>? answers,
  }) {
    return EventQuestionEditDto(
      title: title ?? this.title,
      required: required ?? this.required,
      answerType: answerType ?? this.answerType,
      requireTime: requireTime ?? this.requireTime,
      answers: answers ?? this.answers,
    );
  }

  EventQuestionEditDto copyWithWrapped({
    Wrapped<String?>? title,
    Wrapped<bool?>? required,
    Wrapped<enums.EventQuestionAnswerType?>? answerType,
    Wrapped<bool?>? requireTime,
    Wrapped<List<String>?>? answers,
  }) {
    return EventQuestionEditDto(
      title: (title != null ? title.value : this.title),
      required: (required != null ? required.value : this.required),
      answerType: (answerType != null ? answerType.value : this.answerType),
      requireTime: (requireTime != null ? requireTime.value : this.requireTime),
      answers: (answers != null ? answers.value : this.answers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventClaimInvitationDto {
  const EventClaimInvitationDto({
    this.email,
    this.name,
    this.phone,
    this.questionAnswers,
  });

  factory EventClaimInvitationDto.fromJson(Map<String, dynamic> json) =>
      _$EventClaimInvitationDtoFromJson(json);

  static const toJsonFactory = _$EventClaimInvitationDtoToJson;
  Map<String, dynamic> toJson() => _$EventClaimInvitationDtoToJson(this);

  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'questionAnswers', defaultValue: <EventQuestionAnswerDto>[])
  final List<EventQuestionAnswerDto>? questionAnswers;
  static const fromJsonFactory = _$EventClaimInvitationDtoFromJson;
}

extension $EventClaimInvitationDtoExtension on EventClaimInvitationDto {
  EventClaimInvitationDto copyWith({
    String? email,
    String? name,
    String? phone,
    List<EventQuestionAnswerDto>? questionAnswers,
  }) {
    return EventClaimInvitationDto(
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      questionAnswers: questionAnswers ?? this.questionAnswers,
    );
  }

  EventClaimInvitationDto copyWithWrapped({
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
    Wrapped<List<EventQuestionAnswerDto>?>? questionAnswers,
  }) {
    return EventClaimInvitationDto(
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      questionAnswers: (questionAnswers != null
          ? questionAnswers.value
          : this.questionAnswers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventAcceptInvitation {
  const EventAcceptInvitation({required this.invitation, required this.guest});

  factory EventAcceptInvitation.fromJson(Map<String, dynamic> json) =>
      _$EventAcceptInvitationFromJson(json);

  static const toJsonFactory = _$EventAcceptInvitationToJson;
  Map<String, dynamic> toJson() => _$EventAcceptInvitationToJson(this);

  @JsonKey(name: 'invitation')
  final EventInvitation invitation;
  @JsonKey(name: 'guest')
  final EventGuestProfile guest;
  static const fromJsonFactory = _$EventAcceptInvitationFromJson;
}

extension $EventAcceptInvitationExtension on EventAcceptInvitation {
  EventAcceptInvitation copyWith({
    EventInvitation? invitation,
    EventGuestProfile? guest,
  }) {
    return EventAcceptInvitation(
      invitation: invitation ?? this.invitation,
      guest: guest ?? this.guest,
    );
  }

  EventAcceptInvitation copyWithWrapped({
    Wrapped<EventInvitation>? invitation,
    Wrapped<EventGuestProfile>? guest,
  }) {
    return EventAcceptInvitation(
      invitation: (invitation != null ? invitation.value : this.invitation),
      guest: (guest != null ? guest.value : this.guest),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestFilterCriteriaDto {
  const EventGuestFilterCriteriaDto({
    this.searchText,
    this.wallet,
    this.eventId,
    this.status,
    this.questionnaireFilled,
    this.range,
  });

  factory EventGuestFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventGuestFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'wallet', defaultValue: <String>[])
  final List<String>? wallet;
  @JsonKey(name: 'eventId', defaultValue: <String>[])
  final List<String>? eventId;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusListToJson,
    fromJson: eventGuestStatusListFromJson,
  )
  final List<enums.EventGuestStatus>? status;
  @JsonKey(name: 'questionnaireFilled')
  final bool? questionnaireFilled;
  @JsonKey(name: 'range', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? range;
  static const fromJsonFactory = _$EventGuestFilterCriteriaDtoFromJson;
}

extension $EventGuestFilterCriteriaDtoExtension on EventGuestFilterCriteriaDto {
  EventGuestFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? wallet,
    List<String>? eventId,
    List<enums.EventGuestStatus>? status,
    bool? questionnaireFilled,
    List<RangeFilter>? range,
  }) {
    return EventGuestFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      wallet: wallet ?? this.wallet,
      eventId: eventId ?? this.eventId,
      status: status ?? this.status,
      questionnaireFilled: questionnaireFilled ?? this.questionnaireFilled,
      range: range ?? this.range,
    );
  }

  EventGuestFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? wallet,
    Wrapped<List<String>?>? eventId,
    Wrapped<List<enums.EventGuestStatus>?>? status,
    Wrapped<bool?>? questionnaireFilled,
    Wrapped<List<RangeFilter>?>? range,
  }) {
    return EventGuestFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      wallet: (wallet != null ? wallet.value : this.wallet),
      eventId: (eventId != null ? eventId.value : this.eventId),
      status: (status != null ? status.value : this.status),
      questionnaireFilled: (questionnaireFilled != null
          ? questionnaireFilled.value
          : this.questionnaireFilled),
      range: (range != null ? range.value : this.range),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestFilter {
  const EventGuestFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventGuestFilter.fromJson(Map<String, dynamic> json) =>
      _$EventGuestFilterFromJson(json);

  static const toJsonFactory = _$EventGuestFilterToJson;
  Map<String, dynamic> toJson() => _$EventGuestFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect', defaultValue: false)
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventGuestFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventGuestFilterFromJson;
}

extension $EventGuestFilterExtension on EventGuestFilter {
  EventGuestFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventGuestFilterCriteriaDto? filters,
  }) {
    return EventGuestFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventGuestFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventGuestFilterCriteriaDto>? filters,
  }) {
    return EventGuestFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestProfileQuery {
  const EventGuestProfileQuery({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventGuestProfileQuery.fromJson(Map<String, dynamic> json) =>
      _$EventGuestProfileQueryFromJson(json);

  static const toJsonFactory = _$EventGuestProfileQueryToJson;
  Map<String, dynamic> toJson() => _$EventGuestProfileQueryToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventGuestProfile>[])
  final List<EventGuestProfile> resources;
  static const fromJsonFactory = _$EventGuestProfileQueryFromJson;
}

extension $EventGuestProfileQueryExtension on EventGuestProfileQuery {
  EventGuestProfileQuery copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventGuestProfile>? resources,
  }) {
    return EventGuestProfileQuery(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventGuestProfileQuery copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventGuestProfile>>? resources,
  }) {
    return EventGuestProfileQuery(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestExport {
  const EventGuestExport({
    required this.wallet,
    this.email,
    this.name,
    this.phone,
    required this.status,
  });

  factory EventGuestExport.fromJson(Map<String, dynamic> json) =>
      _$EventGuestExportFromJson(json);

  static const toJsonFactory = _$EventGuestExportToJson;
  Map<String, dynamic> toJson() => _$EventGuestExportToJson(this);

  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(
    name: 'status',
    toJson: eventGuestStatusToJson,
    fromJson: eventGuestStatusFromJson,
  )
  final enums.EventGuestStatus status;
  static const fromJsonFactory = _$EventGuestExportFromJson;
}

extension $EventGuestExportExtension on EventGuestExport {
  EventGuestExport copyWith({
    String? wallet,
    String? email,
    String? name,
    String? phone,
    enums.EventGuestStatus? status,
  }) {
    return EventGuestExport(
      wallet: wallet ?? this.wallet,
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      status: status ?? this.status,
    );
  }

  EventGuestExport copyWithWrapped({
    Wrapped<String>? wallet,
    Wrapped<String?>? email,
    Wrapped<String?>? name,
    Wrapped<String?>? phone,
    Wrapped<enums.EventGuestStatus>? status,
  }) {
    return EventGuestExport(
      wallet: (wallet != null ? wallet.value : this.wallet),
      email: (email != null ? email.value : this.email),
      name: (name != null ? name.value : this.name),
      phone: (phone != null ? phone.value : this.phone),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleCreateDto {
  const EventUserRoleCreateDto({
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.endTime,
  });

  factory EventUserRoleCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleCreateDtoFromJson(json);

  static const toJsonFactory = _$EventUserRoleCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleCreateDtoToJson(this);

  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'endTime')
  final int? endTime;
  static const fromJsonFactory = _$EventUserRoleCreateDtoFromJson;
}

extension $EventUserRoleCreateDtoExtension on EventUserRoleCreateDto {
  EventUserRoleCreateDto copyWith({
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? endTime,
  }) {
    return EventUserRoleCreateDto(
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      endTime: endTime ?? this.endTime,
    );
  }

  EventUserRoleCreateDto copyWithWrapped({
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? endTime,
  }) {
    return EventUserRoleCreateDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      endTime: (endTime != null ? endTime.value : this.endTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRole {
  const EventUserRole({
    required this.dataType,
    this.eventId,
    this.wallet,
    this.name,
    this.email,
    required this.role,
    required this.permissions,
    this.createdAt,
    this.endTime,
    this.id,
    this.status,
    this.pk,
    this.ts,
    required this.profile,
    required this.herotag,
  });

  factory EventUserRole.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleFromJson(json);

  static const toJsonFactory = _$EventUserRoleToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles> role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission> permissions;
  @JsonKey(name: 'createdAt')
  final int? createdAt;
  @JsonKey(name: 'endTime')
  final int? endTime;
  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
    name: 'status',
    toJson: roleStatusNullableToJson,
    fromJson: roleStatusNullableFromJson,
  )
  final enums.RoleStatus? status;
  @JsonKey(name: 'pk')
  final String? pk;
  @JsonKey(name: '_ts')
  final int? ts;
  @JsonKey(name: 'profile')
  final String profile;
  @JsonKey(name: 'herotag')
  final String herotag;
  static const fromJsonFactory = _$EventUserRoleFromJson;
}

extension $EventUserRoleExtension on EventUserRole {
  EventUserRole copyWith({
    enums.TicketingDataType? dataType,
    String? eventId,
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? createdAt,
    int? endTime,
    String? id,
    enums.RoleStatus? status,
    String? pk,
    int? ts,
    String? profile,
    String? herotag,
  }) {
    return EventUserRole(
      dataType: dataType ?? this.dataType,
      eventId: eventId ?? this.eventId,
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      createdAt: createdAt ?? this.createdAt,
      endTime: endTime ?? this.endTime,
      id: id ?? this.id,
      status: status ?? this.status,
      pk: pk ?? this.pk,
      ts: ts ?? this.ts,
      profile: profile ?? this.profile,
      herotag: herotag ?? this.herotag,
    );
  }

  EventUserRole copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String?>? eventId,
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>>? role,
    Wrapped<List<enums.EventUserRolePermission>>? permissions,
    Wrapped<int?>? createdAt,
    Wrapped<int?>? endTime,
    Wrapped<String?>? id,
    Wrapped<enums.RoleStatus?>? status,
    Wrapped<String?>? pk,
    Wrapped<int?>? ts,
    Wrapped<String>? profile,
    Wrapped<String>? herotag,
  }) {
    return EventUserRole(
      dataType: (dataType != null ? dataType.value : this.dataType),
      eventId: (eventId != null ? eventId.value : this.eventId),
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      endTime: (endTime != null ? endTime.value : this.endTime),
      id: (id != null ? id.value : this.id),
      status: (status != null ? status.value : this.status),
      pk: (pk != null ? pk.value : this.pk),
      ts: (ts != null ? ts.value : this.ts),
      profile: (profile != null ? profile.value : this.profile),
      herotag: (herotag != null ? herotag.value : this.herotag),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventUserRoleEditDto {
  const EventUserRoleEditDto({
    this.wallet,
    this.name,
    this.email,
    this.role,
    this.permissions,
    this.endTime,
  });

  factory EventUserRoleEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventUserRoleEditDtoFromJson(json);

  static const toJsonFactory = _$EventUserRoleEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventUserRoleEditDtoToJson(this);

  @JsonKey(name: 'wallet')
  final String? wallet;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(
    name: 'role',
    toJson: eventUserRolesListToJson,
    fromJson: eventUserRolesListFromJson,
  )
  final List<enums.EventUserRoles>? role;
  @JsonKey(
    name: 'permissions',
    toJson: eventUserRolePermissionListToJson,
    fromJson: eventUserRolePermissionListFromJson,
  )
  final List<enums.EventUserRolePermission>? permissions;
  @JsonKey(name: 'endTime')
  final int? endTime;
  static const fromJsonFactory = _$EventUserRoleEditDtoFromJson;
}

extension $EventUserRoleEditDtoExtension on EventUserRoleEditDto {
  EventUserRoleEditDto copyWith({
    String? wallet,
    String? name,
    String? email,
    List<enums.EventUserRoles>? role,
    List<enums.EventUserRolePermission>? permissions,
    int? endTime,
  }) {
    return EventUserRoleEditDto(
      wallet: wallet ?? this.wallet,
      name: name ?? this.name,
      email: email ?? this.email,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      endTime: endTime ?? this.endTime,
    );
  }

  EventUserRoleEditDto copyWithWrapped({
    Wrapped<String?>? wallet,
    Wrapped<String?>? name,
    Wrapped<String?>? email,
    Wrapped<List<enums.EventUserRoles>?>? role,
    Wrapped<List<enums.EventUserRolePermission>?>? permissions,
    Wrapped<int?>? endTime,
  }) {
    return EventUserRoleEditDto(
      wallet: (wallet != null ? wallet.value : this.wallet),
      name: (name != null ? name.value : this.name),
      email: (email != null ? email.value : this.email),
      role: (role != null ? role.value : this.role),
      permissions: (permissions != null ? permissions.value : this.permissions),
      endTime: (endTime != null ? endTime.value : this.endTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BageQRData {
  const BageQRData({required this.type, required this.data});

  factory BageQRData.fromJson(Map<String, dynamic> json) =>
      _$BageQRDataFromJson(json);

  static const toJsonFactory = _$BageQRDataToJson;
  Map<String, dynamic> toJson() => _$BageQRDataToJson(this);

  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$BageQRDataFromJson;
}

extension $BageQRDataExtension on BageQRData {
  BageQRData copyWith({enums.EventTicketQrType? type, String? data}) {
    return BageQRData(type: type ?? this.type, data: data ?? this.data);
  }

  BageQRData copyWithWrapped({
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<String>? data,
  }) {
    return BageQRData(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class QRBody {
  const QRBody({required this.type, required this.data});

  factory QRBody.fromJson(Map<String, dynamic> json) => _$QRBodyFromJson(json);

  static const toJsonFactory = _$QRBodyToJson;
  Map<String, dynamic> toJson() => _$QRBodyToJson(this);

  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(name: 'data')
  final String data;
  static const fromJsonFactory = _$QRBodyFromJson;
}

extension $QRBodyExtension on QRBody {
  QRBody copyWith({enums.EventTicketQrType? type, String? data}) {
    return QRBody(type: type ?? this.type, data: data ?? this.data);
  }

  QRBody copyWithWrapped({
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<String>? data,
  }) {
    return QRBody(
      type: (type != null ? type.value : this.type),
      data: (data != null ? data.value : this.data),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventCheckInQR {
  const EventCheckInQR({required this.qr, this.tickets});

  factory EventCheckInQR.fromJson(Map<String, dynamic> json) =>
      _$EventCheckInQRFromJson(json);

  static const toJsonFactory = _$EventCheckInQRToJson;
  Map<String, dynamic> toJson() => _$EventCheckInQRToJson(this);

  @JsonKey(name: 'qr')
  final QRBody qr;
  @JsonKey(name: 'tickets', defaultValue: <TicketsType>[])
  final List<TicketsType>? tickets;
  static const fromJsonFactory = _$EventCheckInQRFromJson;
}

extension $EventCheckInQRExtension on EventCheckInQR {
  EventCheckInQR copyWith({QRBody? qr, List<TicketsType>? tickets}) {
    return EventCheckInQR(qr: qr ?? this.qr, tickets: tickets ?? this.tickets);
  }

  EventCheckInQR copyWithWrapped({
    Wrapped<QRBody>? qr,
    Wrapped<List<TicketsType>?>? tickets,
  }) {
    return EventCheckInQR(
      qr: (qr != null ? qr.value : this.qr),
      tickets: (tickets != null ? tickets.value : this.tickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketSelection {
  const TicketSelection({
    required this.identifier,
    required this.ticketId,
    required this.quantity,
    this.ticketProfile,
  });

  factory TicketSelection.fromJson(Map<String, dynamic> json) =>
      _$TicketSelectionFromJson(json);

  static const toJsonFactory = _$TicketSelectionToJson;
  Map<String, dynamic> toJson() => _$TicketSelectionToJson(this);

  @JsonKey(name: 'identifier')
  final String identifier;
  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'ticketProfile')
  final TicketProfileSummary? ticketProfile;
  static const fromJsonFactory = _$TicketSelectionFromJson;
}

extension $TicketSelectionExtension on TicketSelection {
  TicketSelection copyWith({
    String? identifier,
    String? ticketId,
    int? quantity,
    TicketProfileSummary? ticketProfile,
  }) {
    return TicketSelection(
      identifier: identifier ?? this.identifier,
      ticketId: ticketId ?? this.ticketId,
      quantity: quantity ?? this.quantity,
      ticketProfile: ticketProfile ?? this.ticketProfile,
    );
  }

  TicketSelection copyWithWrapped({
    Wrapped<String>? identifier,
    Wrapped<String>? ticketId,
    Wrapped<int>? quantity,
    Wrapped<TicketProfileSummary?>? ticketProfile,
  }) {
    return TicketSelection(
      identifier: (identifier != null ? identifier.value : this.identifier),
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      quantity: (quantity != null ? quantity.value : this.quantity),
      ticketProfile: (ticketProfile != null
          ? ticketProfile.value
          : this.ticketProfile),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TicketValidationResult {
  const TicketValidationResult({
    required this.status,
    required this.type,
    required this.message,
    this.guest,
    this.invitation,
    this.nfts,
    this.availableTickets,
  });

  factory TicketValidationResult.fromJson(Map<String, dynamic> json) =>
      _$TicketValidationResultFromJson(json);

  static const toJsonFactory = _$TicketValidationResultToJson;
  Map<String, dynamic> toJson() => _$TicketValidationResultToJson(this);

  @JsonKey(
    name: 'status',
    toJson: eventScanStatusToJson,
    fromJson: eventScanStatusFromJson,
  )
  final enums.EventScanStatus status;
  @JsonKey(
    name: 'type',
    toJson: eventTicketQrTypeToJson,
    fromJson: eventTicketQrTypeFromJson,
  )
  final enums.EventTicketQrType type;
  @JsonKey(
    name: 'message',
    toJson: eventScanMessageToJson,
    fromJson: eventScanMessageFromJson,
  )
  final enums.EventScanMessage message;
  @JsonKey(name: 'guest')
  final EventGuestProfile? guest;
  @JsonKey(name: 'invitation')
  final EventInvitation? invitation;
  @JsonKey(name: 'nfts', defaultValue: <NftDocHydrated>[])
  final List<NftDocHydrated>? nfts;
  @JsonKey(name: 'availableTickets', defaultValue: <TicketSelection>[])
  final List<TicketSelection>? availableTickets;
  static const fromJsonFactory = _$TicketValidationResultFromJson;
}

extension $TicketValidationResultExtension on TicketValidationResult {
  TicketValidationResult copyWith({
    enums.EventScanStatus? status,
    enums.EventTicketQrType? type,
    enums.EventScanMessage? message,
    EventGuestProfile? guest,
    EventInvitation? invitation,
    List<NftDocHydrated>? nfts,
    List<TicketSelection>? availableTickets,
  }) {
    return TicketValidationResult(
      status: status ?? this.status,
      type: type ?? this.type,
      message: message ?? this.message,
      guest: guest ?? this.guest,
      invitation: invitation ?? this.invitation,
      nfts: nfts ?? this.nfts,
      availableTickets: availableTickets ?? this.availableTickets,
    );
  }

  TicketValidationResult copyWithWrapped({
    Wrapped<enums.EventScanStatus>? status,
    Wrapped<enums.EventTicketQrType>? type,
    Wrapped<enums.EventScanMessage>? message,
    Wrapped<EventGuestProfile?>? guest,
    Wrapped<EventInvitation?>? invitation,
    Wrapped<List<NftDocHydrated>?>? nfts,
    Wrapped<List<TicketSelection>?>? availableTickets,
  }) {
    return TicketValidationResult(
      status: (status != null ? status.value : this.status),
      type: (type != null ? type.value : this.type),
      message: (message != null ? message.value : this.message),
      guest: (guest != null ? guest.value : this.guest),
      invitation: (invitation != null ? invitation.value : this.invitation),
      nfts: (nfts != null ? nfts.value : this.nfts),
      availableTickets: (availableTickets != null
          ? availableTickets.value
          : this.availableTickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherCreateDto {
  const EventVoucherCreateDto({
    this.code,
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.eventId,
    this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    this.startDate,
    this.endDate,
    this.isActive,
    this.ownerId,
    this.pk,
  });

  factory EventVoucherCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherCreateDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherCreateDtoToJson(this);

  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(
    name: 'type',
    toJson: voucherTypeNullableToJson,
    fromJson: voucherTypeNullableFromJson,
  )
  final enums.VoucherType? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int? maxUsesPerUser;
  @JsonKey(name: 'eventId')
  final String? eventId;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String>? ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int? startDate;
  @JsonKey(name: 'endDate')
  final int? endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$EventVoucherCreateDtoFromJson;
}

extension $EventVoucherCreateDtoExtension on EventVoucherCreateDto {
  EventVoucherCreateDto copyWith({
    String? code,
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    String? eventId,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    String? pk,
  }) {
    return EventVoucherCreateDto(
      code: code ?? this.code,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      eventId: eventId ?? this.eventId,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherCreateDto copyWithWrapped({
    Wrapped<String?>? code,
    Wrapped<enums.VoucherType?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int?>? maxUses,
    Wrapped<int?>? maxUsesPerUser,
    Wrapped<String?>? eventId,
    Wrapped<List<String>?>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int?>? startDate,
    Wrapped<int?>? endDate,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? pk,
  }) {
    return EventVoucherCreateDto(
      code: (code != null ? code.value : this.code),
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      eventId: (eventId != null ? eventId.value : this.eventId),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventVoucherEditDto {
  const EventVoucherEditDto({
    this.type,
    this.amount,
    this.maxDiscountAmount,
    this.maxUses,
    this.maxUsesPerUser,
    this.ticketTypeIds,
    this.stageIds,
    this.minTicketCount,
    this.maxTicketCount,
    this.startDate,
    this.endDate,
    this.isActive,
    this.ownerId,
    this.pk,
  });

  factory EventVoucherEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventVoucherEditDtoFromJson(json);

  static const toJsonFactory = _$EventVoucherEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventVoucherEditDtoToJson(this);

  @JsonKey(
    name: 'type',
    toJson: voucherTypeNullableToJson,
    fromJson: voucherTypeNullableFromJson,
  )
  final enums.VoucherType? type;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  @JsonKey(name: 'maxUses')
  final int? maxUses;
  @JsonKey(name: 'maxUsesPerUser')
  final int? maxUsesPerUser;
  @JsonKey(name: 'ticketTypeIds', defaultValue: <String>[])
  final List<String>? ticketTypeIds;
  @JsonKey(name: 'stageIds', defaultValue: <String>[])
  final List<String>? stageIds;
  @JsonKey(name: 'minTicketCount')
  final int? minTicketCount;
  @JsonKey(name: 'maxTicketCount')
  final int? maxTicketCount;
  @JsonKey(name: 'startDate')
  final int? startDate;
  @JsonKey(name: 'endDate')
  final int? endDate;
  @JsonKey(name: 'isActive', defaultValue: true)
  final bool? isActive;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'pk')
  final String? pk;
  static const fromJsonFactory = _$EventVoucherEditDtoFromJson;
}

extension $EventVoucherEditDtoExtension on EventVoucherEditDto {
  EventVoucherEditDto copyWith({
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
    int? maxUses,
    int? maxUsesPerUser,
    List<String>? ticketTypeIds,
    List<String>? stageIds,
    int? minTicketCount,
    int? maxTicketCount,
    int? startDate,
    int? endDate,
    bool? isActive,
    String? ownerId,
    String? pk,
  }) {
    return EventVoucherEditDto(
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUses: maxUses ?? this.maxUses,
      maxUsesPerUser: maxUsesPerUser ?? this.maxUsesPerUser,
      ticketTypeIds: ticketTypeIds ?? this.ticketTypeIds,
      stageIds: stageIds ?? this.stageIds,
      minTicketCount: minTicketCount ?? this.minTicketCount,
      maxTicketCount: maxTicketCount ?? this.maxTicketCount,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      ownerId: ownerId ?? this.ownerId,
      pk: pk ?? this.pk,
    );
  }

  EventVoucherEditDto copyWithWrapped({
    Wrapped<enums.VoucherType?>? type,
    Wrapped<double?>? amount,
    Wrapped<double?>? maxDiscountAmount,
    Wrapped<int?>? maxUses,
    Wrapped<int?>? maxUsesPerUser,
    Wrapped<List<String>?>? ticketTypeIds,
    Wrapped<List<String>?>? stageIds,
    Wrapped<int?>? minTicketCount,
    Wrapped<int?>? maxTicketCount,
    Wrapped<int?>? startDate,
    Wrapped<int?>? endDate,
    Wrapped<bool?>? isActive,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? pk,
  }) {
    return EventVoucherEditDto(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
      maxUses: (maxUses != null ? maxUses.value : this.maxUses),
      maxUsesPerUser: (maxUsesPerUser != null
          ? maxUsesPerUser.value
          : this.maxUsesPerUser),
      ticketTypeIds: (ticketTypeIds != null
          ? ticketTypeIds.value
          : this.ticketTypeIds),
      stageIds: (stageIds != null ? stageIds.value : this.stageIds),
      minTicketCount: (minTicketCount != null
          ? minTicketCount.value
          : this.minTicketCount),
      maxTicketCount: (maxTicketCount != null
          ? maxTicketCount.value
          : this.maxTicketCount),
      startDate: (startDate != null ? startDate.value : this.startDate),
      endDate: (endDate != null ? endDate.value : this.endDate),
      isActive: (isActive != null ? isActive.value : this.isActive),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ManualCheckInDto {
  const ManualCheckInDto({
    required this.invitationIdOrAddress,
    this.selectedTickets,
  });

  factory ManualCheckInDto.fromJson(Map<String, dynamic> json) =>
      _$ManualCheckInDtoFromJson(json);

  static const toJsonFactory = _$ManualCheckInDtoToJson;
  Map<String, dynamic> toJson() => _$ManualCheckInDtoToJson(this);

  @JsonKey(name: 'invitationIdOrAddress')
  final String invitationIdOrAddress;
  @JsonKey(name: 'selectedTickets', defaultValue: <TicketsType>[])
  final List<TicketsType>? selectedTickets;
  static const fromJsonFactory = _$ManualCheckInDtoFromJson;
}

extension $ManualCheckInDtoExtension on ManualCheckInDto {
  ManualCheckInDto copyWith({
    String? invitationIdOrAddress,
    List<TicketsType>? selectedTickets,
  }) {
    return ManualCheckInDto(
      invitationIdOrAddress:
          invitationIdOrAddress ?? this.invitationIdOrAddress,
      selectedTickets: selectedTickets ?? this.selectedTickets,
    );
  }

  ManualCheckInDto copyWithWrapped({
    Wrapped<String>? invitationIdOrAddress,
    Wrapped<List<TicketsType>?>? selectedTickets,
  }) {
    return ManualCheckInDto(
      invitationIdOrAddress: (invitationIdOrAddress != null
          ? invitationIdOrAddress.value
          : this.invitationIdOrAddress),
      selectedTickets: (selectedTickets != null
          ? selectedTickets.value
          : this.selectedTickets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestAnswerDoc {
  const EventGuestAnswerDoc({
    required this.dataType,
    required this.id,
    required this.wallet,
    required this.questionId,
    required this.eventId,
    required this.answer,
    required this.createdAt,
    this.ttl,
  });

  factory EventGuestAnswerDoc.fromJson(Map<String, dynamic> json) =>
      _$EventGuestAnswerDocFromJson(json);

  static const toJsonFactory = _$EventGuestAnswerDocToJson;
  Map<String, dynamic> toJson() => _$EventGuestAnswerDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventQuestionAnswer,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'wallet')
  final String wallet;
  @JsonKey(name: 'questionId')
  final String questionId;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'answer')
  final Object answer;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'ttl')
  final int? ttl;
  static const fromJsonFactory = _$EventGuestAnswerDocFromJson;
}

extension $EventGuestAnswerDocExtension on EventGuestAnswerDoc {
  EventGuestAnswerDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? wallet,
    String? questionId,
    String? eventId,
    Object? answer,
    int? createdAt,
    int? ttl,
  }) {
    return EventGuestAnswerDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      wallet: wallet ?? this.wallet,
      questionId: questionId ?? this.questionId,
      eventId: eventId ?? this.eventId,
      answer: answer ?? this.answer,
      createdAt: createdAt ?? this.createdAt,
      ttl: ttl ?? this.ttl,
    );
  }

  EventGuestAnswerDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? wallet,
    Wrapped<String>? questionId,
    Wrapped<String>? eventId,
    Wrapped<Object>? answer,
    Wrapped<int>? createdAt,
    Wrapped<int?>? ttl,
  }) {
    return EventGuestAnswerDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      wallet: (wallet != null ? wallet.value : this.wallet),
      questionId: (questionId != null ? questionId.value : this.questionId),
      eventId: (eventId != null ? eventId.value : this.eventId),
      answer: (answer != null ? answer.value : this.answer),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      ttl: (ttl != null ? ttl.value : this.ttl),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AnsweredQuestionWithDetails {
  const AnsweredQuestionWithDetails({this.answer, this.question});

  factory AnsweredQuestionWithDetails.fromJson(Map<String, dynamic> json) =>
      _$AnsweredQuestionWithDetailsFromJson(json);

  static const toJsonFactory = _$AnsweredQuestionWithDetailsToJson;
  Map<String, dynamic> toJson() => _$AnsweredQuestionWithDetailsToJson(this);

  @JsonKey(name: 'answer')
  final EventGuestAnswerDoc? answer;
  @JsonKey(name: 'question')
  final EventQuestionDoc? question;
  static const fromJsonFactory = _$AnsweredQuestionWithDetailsFromJson;
}

extension $AnsweredQuestionWithDetailsExtension on AnsweredQuestionWithDetails {
  AnsweredQuestionWithDetails copyWith({
    EventGuestAnswerDoc? answer,
    EventQuestionDoc? question,
  }) {
    return AnsweredQuestionWithDetails(
      answer: answer ?? this.answer,
      question: question ?? this.question,
    );
  }

  AnsweredQuestionWithDetails copyWithWrapped({
    Wrapped<EventGuestAnswerDoc?>? answer,
    Wrapped<EventQuestionDoc?>? question,
  }) {
    return AnsweredQuestionWithDetails(
      answer: (answer != null ? answer.value : this.answer),
      question: (question != null ? question.value : this.question),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestApproveDto {
  const EventGuestApproveDto({this.address, required this.isApproved});

  factory EventGuestApproveDto.fromJson(Map<String, dynamic> json) =>
      _$EventGuestApproveDtoFromJson(json);

  static const toJsonFactory = _$EventGuestApproveDtoToJson;
  Map<String, dynamic> toJson() => _$EventGuestApproveDtoToJson(this);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'isApproved')
  final bool isApproved;
  static const fromJsonFactory = _$EventGuestApproveDtoFromJson;
}

extension $EventGuestApproveDtoExtension on EventGuestApproveDto {
  EventGuestApproveDto copyWith({String? address, bool? isApproved}) {
    return EventGuestApproveDto(
      address: address ?? this.address,
      isApproved: isApproved ?? this.isApproved,
    );
  }

  EventGuestApproveDto copyWithWrapped({
    Wrapped<String?>? address,
    Wrapped<bool>? isApproved,
  }) {
    return EventGuestApproveDto(
      address: (address != null ? address.value : this.address),
      isApproved: (isApproved != null ? isApproved.value : this.isApproved),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventLocationCities {
  const EventLocationCities({required this.city, required this.eventCount});

  factory EventLocationCities.fromJson(Map<String, dynamic> json) =>
      _$EventLocationCitiesFromJson(json);

  static const toJsonFactory = _$EventLocationCitiesToJson;
  Map<String, dynamic> toJson() => _$EventLocationCitiesToJson(this);

  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'eventCount')
  final int eventCount;
  static const fromJsonFactory = _$EventLocationCitiesFromJson;
}

extension $EventLocationCitiesExtension on EventLocationCities {
  EventLocationCities copyWith({String? city, int? eventCount}) {
    return EventLocationCities(
      city: city ?? this.city,
      eventCount: eventCount ?? this.eventCount,
    );
  }

  EventLocationCities copyWithWrapped({
    Wrapped<String>? city,
    Wrapped<int>? eventCount,
  }) {
    return EventLocationCities(
      city: (city != null ? city.value : this.city),
      eventCount: (eventCount != null ? eventCount.value : this.eventCount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventCountGroupedByCountry {
  const EventCountGroupedByCountry({
    required this.country,
    required this.eventCount,
    required this.cities,
  });

  factory EventCountGroupedByCountry.fromJson(Map<String, dynamic> json) =>
      _$EventCountGroupedByCountryFromJson(json);

  static const toJsonFactory = _$EventCountGroupedByCountryToJson;
  Map<String, dynamic> toJson() => _$EventCountGroupedByCountryToJson(this);

  @JsonKey(name: 'country')
  final String country;
  @JsonKey(name: 'eventCount')
  final int eventCount;
  @JsonKey(name: 'cities', defaultValue: <EventLocationCities>[])
  final List<EventLocationCities> cities;
  static const fromJsonFactory = _$EventCountGroupedByCountryFromJson;
}

extension $EventCountGroupedByCountryExtension on EventCountGroupedByCountry {
  EventCountGroupedByCountry copyWith({
    String? country,
    int? eventCount,
    List<EventLocationCities>? cities,
  }) {
    return EventCountGroupedByCountry(
      country: country ?? this.country,
      eventCount: eventCount ?? this.eventCount,
      cities: cities ?? this.cities,
    );
  }

  EventCountGroupedByCountry copyWithWrapped({
    Wrapped<String>? country,
    Wrapped<int>? eventCount,
    Wrapped<List<EventLocationCities>>? cities,
  }) {
    return EventCountGroupedByCountry(
      country: (country != null ? country.value : this.country),
      eventCount: (eventCount != null ? eventCount.value : this.eventCount),
      cities: (cities != null ? cities.value : this.cities),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ShortVoucherDoc {
  const ShortVoucherDoc({
    required this.type,
    required this.amount,
    this.maxDiscountAmount,
  });

  factory ShortVoucherDoc.fromJson(Map<String, dynamic> json) =>
      _$ShortVoucherDocFromJson(json);

  static const toJsonFactory = _$ShortVoucherDocToJson;
  Map<String, dynamic> toJson() => _$ShortVoucherDocToJson(this);

  @JsonKey(
    name: 'type',
    toJson: voucherTypeToJson,
    fromJson: voucherTypeFromJson,
  )
  final enums.VoucherType type;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'maxDiscountAmount')
  final double? maxDiscountAmount;
  static const fromJsonFactory = _$ShortVoucherDocFromJson;
}

extension $ShortVoucherDocExtension on ShortVoucherDoc {
  ShortVoucherDoc copyWith({
    enums.VoucherType? type,
    double? amount,
    double? maxDiscountAmount,
  }) {
    return ShortVoucherDoc(
      type: type ?? this.type,
      amount: amount ?? this.amount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
    );
  }

  ShortVoucherDoc copyWithWrapped({
    Wrapped<enums.VoucherType>? type,
    Wrapped<double>? amount,
    Wrapped<double?>? maxDiscountAmount,
  }) {
    return ShortVoucherDoc(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
      maxDiscountAmount: (maxDiscountAmount != null
          ? maxDiscountAmount.value
          : this.maxDiscountAmount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RewardDetails {
  const RewardDetails({
    required this.rewardType,
    required this.conditionType,
    required this.condition,
    this.currency,
    this.voucherInfo,
  });

  factory RewardDetails.fromJson(Map<String, dynamic> json) =>
      _$RewardDetailsFromJson(json);

  static const toJsonFactory = _$RewardDetailsToJson;
  Map<String, dynamic> toJson() => _$RewardDetailsToJson(this);

  @JsonKey(
    name: 'rewardType',
    toJson: eventReferralEnumToJson,
    fromJson: eventReferralEnumFromJson,
  )
  final enums.EventReferralEnum rewardType;
  @JsonKey(
    name: 'conditionType',
    toJson: referralConditionTypeToJson,
    fromJson: referralConditionTypeFromJson,
  )
  final enums.ReferralConditionType conditionType;
  @JsonKey(name: 'condition')
  final double condition;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'voucherInfo')
  final ShortVoucherDoc? voucherInfo;
  static const fromJsonFactory = _$RewardDetailsFromJson;
}

extension $RewardDetailsExtension on RewardDetails {
  RewardDetails copyWith({
    enums.EventReferralEnum? rewardType,
    enums.ReferralConditionType? conditionType,
    double? condition,
    String? currency,
    ShortVoucherDoc? voucherInfo,
  }) {
    return RewardDetails(
      rewardType: rewardType ?? this.rewardType,
      conditionType: conditionType ?? this.conditionType,
      condition: condition ?? this.condition,
      currency: currency ?? this.currency,
      voucherInfo: voucherInfo ?? this.voucherInfo,
    );
  }

  RewardDetails copyWithWrapped({
    Wrapped<enums.EventReferralEnum>? rewardType,
    Wrapped<enums.ReferralConditionType>? conditionType,
    Wrapped<double>? condition,
    Wrapped<String?>? currency,
    Wrapped<ShortVoucherDoc?>? voucherInfo,
  }) {
    return RewardDetails(
      rewardType: (rewardType != null ? rewardType.value : this.rewardType),
      conditionType: (conditionType != null
          ? conditionType.value
          : this.conditionType),
      condition: (condition != null ? condition.value : this.condition),
      currency: (currency != null ? currency.value : this.currency),
      voucherInfo: (voucherInfo != null ? voucherInfo.value : this.voucherInfo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigCreateDto {
  const EventReferralConfigCreateDto({
    required this.name,
    this.appliedVoucher,
    this.rewardDetails,
    required this.isSelfService,
    required this.isActive,
  });

  factory EventReferralConfigCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigCreateDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigCreateDtoToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isSelfService')
  final bool isSelfService;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$EventReferralConfigCreateDtoFromJson;
}

extension $EventReferralConfigCreateDtoExtension
    on EventReferralConfigCreateDto {
  EventReferralConfigCreateDto copyWith({
    String? name,
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isSelfService,
    bool? isActive,
  }) {
    return EventReferralConfigCreateDto(
      name: name ?? this.name,
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isSelfService: isSelfService ?? this.isSelfService,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralConfigCreateDto copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool>? isSelfService,
    Wrapped<bool>? isActive,
  }) {
    return EventReferralConfigCreateDto(
      name: (name != null ? name.value : this.name),
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigDoc {
  const EventReferralConfigDoc({
    required this.dataType,
    required this.id,
    required this.eventId,
    required this.name,
    this.appliedVoucher,
    this.rewardDetails,
    required this.isSelfService,
    required this.isActive,
    required this.createdAt,
    required this.createdBy,
    required this.pk,
  });

  factory EventReferralConfigDoc.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigDocFromJson(json);

  static const toJsonFactory = _$EventReferralConfigDocToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventReferralConfig,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isSelfService')
  final bool isSelfService;
  @JsonKey(name: 'isActive')
  final bool isActive;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'createdBy')
  final String createdBy;
  @JsonKey(name: 'pk')
  final String pk;
  static const fromJsonFactory = _$EventReferralConfigDocFromJson;
}

extension $EventReferralConfigDocExtension on EventReferralConfigDoc {
  EventReferralConfigDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? eventId,
    String? name,
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isSelfService,
    bool? isActive,
    int? createdAt,
    String? createdBy,
    String? pk,
  }) {
    return EventReferralConfigDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      eventId: eventId ?? this.eventId,
      name: name ?? this.name,
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isSelfService: isSelfService ?? this.isSelfService,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      createdBy: createdBy ?? this.createdBy,
      pk: pk ?? this.pk,
    );
  }

  EventReferralConfigDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? eventId,
    Wrapped<String>? name,
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool>? isSelfService,
    Wrapped<bool>? isActive,
    Wrapped<int>? createdAt,
    Wrapped<String>? createdBy,
    Wrapped<String>? pk,
  }) {
    return EventReferralConfigDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      eventId: (eventId != null ? eventId.value : this.eventId),
      name: (name != null ? name.value : this.name),
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      isActive: (isActive != null ? isActive.value : this.isActive),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      createdBy: (createdBy != null ? createdBy.value : this.createdBy),
      pk: (pk != null ? pk.value : this.pk),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigEditDto {
  const EventReferralConfigEditDto({
    this.name,
    this.appliedVoucher,
    this.rewardDetails,
    this.isActive,
  });

  factory EventReferralConfigEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigEditDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigEditDtoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'appliedVoucher')
  final ShortVoucherDoc? appliedVoucher;
  @JsonKey(name: 'rewardDetails')
  final RewardDetails? rewardDetails;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  static const fromJsonFactory = _$EventReferralConfigEditDtoFromJson;
}

extension $EventReferralConfigEditDtoExtension on EventReferralConfigEditDto {
  EventReferralConfigEditDto copyWith({
    String? name,
    ShortVoucherDoc? appliedVoucher,
    RewardDetails? rewardDetails,
    bool? isActive,
  }) {
    return EventReferralConfigEditDto(
      name: name ?? this.name,
      appliedVoucher: appliedVoucher ?? this.appliedVoucher,
      rewardDetails: rewardDetails ?? this.rewardDetails,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralConfigEditDto copyWithWrapped({
    Wrapped<String?>? name,
    Wrapped<ShortVoucherDoc?>? appliedVoucher,
    Wrapped<RewardDetails?>? rewardDetails,
    Wrapped<bool?>? isActive,
  }) {
    return EventReferralConfigEditDto(
      name: (name != null ? name.value : this.name),
      appliedVoucher: (appliedVoucher != null
          ? appliedVoucher.value
          : this.appliedVoucher),
      rewardDetails: (rewardDetails != null
          ? rewardDetails.value
          : this.rewardDetails),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigFilterCriteriaDto {
  const EventReferralConfigFilterCriteriaDto({
    this.searchText,
    this.ownerId,
    this.isActive,
    this.isSelfService,
    this.createdAt,
  });

  factory EventReferralConfigFilterCriteriaDto.fromJson(
    Map<String, dynamic> json,
  ) => _$EventReferralConfigFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventReferralConfigFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() =>
      _$EventReferralConfigFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'isSelfService')
  final bool? isSelfService;
  @JsonKey(name: 'createdAt', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? createdAt;
  static const fromJsonFactory = _$EventReferralConfigFilterCriteriaDtoFromJson;
}

extension $EventReferralConfigFilterCriteriaDtoExtension
    on EventReferralConfigFilterCriteriaDto {
  EventReferralConfigFilterCriteriaDto copyWith({
    String? searchText,
    String? ownerId,
    bool? isActive,
    bool? isSelfService,
    List<RangeFilter>? createdAt,
  }) {
    return EventReferralConfigFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      ownerId: ownerId ?? this.ownerId,
      isActive: isActive ?? this.isActive,
      isSelfService: isSelfService ?? this.isSelfService,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  EventReferralConfigFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<String?>? ownerId,
    Wrapped<bool?>? isActive,
    Wrapped<bool?>? isSelfService,
    Wrapped<List<RangeFilter>?>? createdAt,
  }) {
    return EventReferralConfigFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      isSelfService: (isSelfService != null
          ? isSelfService.value
          : this.isSelfService),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigFilter {
  const EventReferralConfigFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventReferralConfigFilter.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigFilterFromJson(json);

  static const toJsonFactory = _$EventReferralConfigFilterToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventReferralConfigFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventReferralConfigFilterFromJson;
}

extension $EventReferralConfigFilterExtension on EventReferralConfigFilter {
  EventReferralConfigFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventReferralConfigFilterCriteriaDto? filters,
  }) {
    return EventReferralConfigFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventReferralConfigFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventReferralConfigFilterCriteriaDto>? filters,
  }) {
    return EventReferralConfigFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralConfigPaginated {
  const EventReferralConfigPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventReferralConfigPaginated.fromJson(Map<String, dynamic> json) =>
      _$EventReferralConfigPaginatedFromJson(json);

  static const toJsonFactory = _$EventReferralConfigPaginatedToJson;
  Map<String, dynamic> toJson() => _$EventReferralConfigPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventReferralConfigDoc>[])
  final List<EventReferralConfigDoc> resources;
  static const fromJsonFactory = _$EventReferralConfigPaginatedFromJson;
}

extension $EventReferralConfigPaginatedExtension
    on EventReferralConfigPaginated {
  EventReferralConfigPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventReferralConfigDoc>? resources,
  }) {
    return EventReferralConfigPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventReferralConfigPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventReferralConfigDoc>>? resources,
  }) {
    return EventReferralConfigPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralCreateDto {
  const EventReferralCreateDto({
    required this.referralCode,
    required this.referralConfigId,
  });

  factory EventReferralCreateDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralCreateDtoFromJson(json);

  static const toJsonFactory = _$EventReferralCreateDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralCreateDtoToJson(this);

  @JsonKey(name: 'referralCode')
  final String referralCode;
  @JsonKey(name: 'referralConfigId')
  final String referralConfigId;
  static const fromJsonFactory = _$EventReferralCreateDtoFromJson;
}

extension $EventReferralCreateDtoExtension on EventReferralCreateDto {
  EventReferralCreateDto copyWith({
    String? referralCode,
    String? referralConfigId,
  }) {
    return EventReferralCreateDto(
      referralCode: referralCode ?? this.referralCode,
      referralConfigId: referralConfigId ?? this.referralConfigId,
    );
  }

  EventReferralCreateDto copyWithWrapped({
    Wrapped<String>? referralCode,
    Wrapped<String>? referralConfigId,
  }) {
    return EventReferralCreateDto(
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralDoc {
  const EventReferralDoc({
    required this.dataType,
    required this.id,
    required this.pk,
    required this.referralCode,
    this.ownerId,
    required this.eventId,
    required this.referralConfigId,
    required this.successfulReferrals,
    required this.createdAt,
    required this.isActive,
  });

  factory EventReferralDoc.fromJson(Map<String, dynamic> json) =>
      _$EventReferralDocFromJson(json);

  static const toJsonFactory = _$EventReferralDocToJson;
  Map<String, dynamic> toJson() => _$EventReferralDocToJson(this);

  @JsonKey(
    name: 'dataType',
    toJson: ticketingDataTypeToJson,
    fromJson: ticketingDataTypeDataTypeFromJson,
  )
  final enums.TicketingDataType dataType;
  static enums.TicketingDataType ticketingDataTypeDataTypeFromJson(
    Object? value,
  ) => ticketingDataTypeFromJson(
    value,
    enums.TicketingDataType.eventReferralCode,
  );

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'pk')
  final String pk;
  @JsonKey(name: 'referralCode')
  final String referralCode;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'eventId')
  final String eventId;
  @JsonKey(name: 'referralConfigId')
  final String referralConfigId;
  @JsonKey(name: 'successfulReferrals')
  final int successfulReferrals;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'isActive')
  final bool isActive;
  static const fromJsonFactory = _$EventReferralDocFromJson;
}

extension $EventReferralDocExtension on EventReferralDoc {
  EventReferralDoc copyWith({
    enums.TicketingDataType? dataType,
    String? id,
    String? pk,
    String? referralCode,
    String? ownerId,
    String? eventId,
    String? referralConfigId,
    int? successfulReferrals,
    int? createdAt,
    bool? isActive,
  }) {
    return EventReferralDoc(
      dataType: dataType ?? this.dataType,
      id: id ?? this.id,
      pk: pk ?? this.pk,
      referralCode: referralCode ?? this.referralCode,
      ownerId: ownerId ?? this.ownerId,
      eventId: eventId ?? this.eventId,
      referralConfigId: referralConfigId ?? this.referralConfigId,
      successfulReferrals: successfulReferrals ?? this.successfulReferrals,
      createdAt: createdAt ?? this.createdAt,
      isActive: isActive ?? this.isActive,
    );
  }

  EventReferralDoc copyWithWrapped({
    Wrapped<enums.TicketingDataType>? dataType,
    Wrapped<String>? id,
    Wrapped<String>? pk,
    Wrapped<String>? referralCode,
    Wrapped<String?>? ownerId,
    Wrapped<String>? eventId,
    Wrapped<String>? referralConfigId,
    Wrapped<int>? successfulReferrals,
    Wrapped<int>? createdAt,
    Wrapped<bool>? isActive,
  }) {
    return EventReferralDoc(
      dataType: (dataType != null ? dataType.value : this.dataType),
      id: (id != null ? id.value : this.id),
      pk: (pk != null ? pk.value : this.pk),
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      eventId: (eventId != null ? eventId.value : this.eventId),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
      successfulReferrals: (successfulReferrals != null
          ? successfulReferrals.value
          : this.successfulReferrals),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralEditDto {
  const EventReferralEditDto({this.isActive});

  factory EventReferralEditDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralEditDtoFromJson(json);

  static const toJsonFactory = _$EventReferralEditDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralEditDtoToJson(this);

  @JsonKey(name: 'isActive')
  final bool? isActive;
  static const fromJsonFactory = _$EventReferralEditDtoFromJson;
}

extension $EventReferralEditDtoExtension on EventReferralEditDto {
  EventReferralEditDto copyWith({bool? isActive}) {
    return EventReferralEditDto(isActive: isActive ?? this.isActive);
  }

  EventReferralEditDto copyWithWrapped({Wrapped<bool?>? isActive}) {
    return EventReferralEditDto(
      isActive: (isActive != null ? isActive.value : this.isActive),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralFilterCriteriaDto {
  const EventReferralFilterCriteriaDto({
    this.searchText,
    this.referralCode,
    this.ownerId,
    this.referralConfigId,
    this.isActive,
    this.minSuccessfulReferrals,
    this.maxSuccessfulReferrals,
    this.conditionType,
    this.createdAt,
  });

  factory EventReferralFilterCriteriaDto.fromJson(Map<String, dynamic> json) =>
      _$EventReferralFilterCriteriaDtoFromJson(json);

  static const toJsonFactory = _$EventReferralFilterCriteriaDtoToJson;
  Map<String, dynamic> toJson() => _$EventReferralFilterCriteriaDtoToJson(this);

  @JsonKey(name: 'searchText')
  final String? searchText;
  @JsonKey(name: 'referralCode', defaultValue: <String>[])
  final List<String>? referralCode;
  @JsonKey(name: 'ownerId')
  final String? ownerId;
  @JsonKey(name: 'referralConfigId')
  final String? referralConfigId;
  @JsonKey(name: 'isActive')
  final bool? isActive;
  @JsonKey(name: 'minSuccessfulReferrals')
  final int? minSuccessfulReferrals;
  @JsonKey(name: 'maxSuccessfulReferrals')
  final int? maxSuccessfulReferrals;
  @JsonKey(
    name: 'conditionType',
    toJson: referralConditionTypeListToJson,
    fromJson: referralConditionTypeListFromJson,
  )
  final List<enums.ReferralConditionType>? conditionType;
  @JsonKey(name: 'createdAt', defaultValue: <RangeFilter>[])
  final List<RangeFilter>? createdAt;
  static const fromJsonFactory = _$EventReferralFilterCriteriaDtoFromJson;
}

extension $EventReferralFilterCriteriaDtoExtension
    on EventReferralFilterCriteriaDto {
  EventReferralFilterCriteriaDto copyWith({
    String? searchText,
    List<String>? referralCode,
    String? ownerId,
    String? referralConfigId,
    bool? isActive,
    int? minSuccessfulReferrals,
    int? maxSuccessfulReferrals,
    List<enums.ReferralConditionType>? conditionType,
    List<RangeFilter>? createdAt,
  }) {
    return EventReferralFilterCriteriaDto(
      searchText: searchText ?? this.searchText,
      referralCode: referralCode ?? this.referralCode,
      ownerId: ownerId ?? this.ownerId,
      referralConfigId: referralConfigId ?? this.referralConfigId,
      isActive: isActive ?? this.isActive,
      minSuccessfulReferrals:
          minSuccessfulReferrals ?? this.minSuccessfulReferrals,
      maxSuccessfulReferrals:
          maxSuccessfulReferrals ?? this.maxSuccessfulReferrals,
      conditionType: conditionType ?? this.conditionType,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  EventReferralFilterCriteriaDto copyWithWrapped({
    Wrapped<String?>? searchText,
    Wrapped<List<String>?>? referralCode,
    Wrapped<String?>? ownerId,
    Wrapped<String?>? referralConfigId,
    Wrapped<bool?>? isActive,
    Wrapped<int?>? minSuccessfulReferrals,
    Wrapped<int?>? maxSuccessfulReferrals,
    Wrapped<List<enums.ReferralConditionType>?>? conditionType,
    Wrapped<List<RangeFilter>?>? createdAt,
  }) {
    return EventReferralFilterCriteriaDto(
      searchText: (searchText != null ? searchText.value : this.searchText),
      referralCode: (referralCode != null
          ? referralCode.value
          : this.referralCode),
      ownerId: (ownerId != null ? ownerId.value : this.ownerId),
      referralConfigId: (referralConfigId != null
          ? referralConfigId.value
          : this.referralConfigId),
      isActive: (isActive != null ? isActive.value : this.isActive),
      minSuccessfulReferrals: (minSuccessfulReferrals != null
          ? minSuccessfulReferrals.value
          : this.minSuccessfulReferrals),
      maxSuccessfulReferrals: (maxSuccessfulReferrals != null
          ? maxSuccessfulReferrals.value
          : this.maxSuccessfulReferrals),
      conditionType: (conditionType != null
          ? conditionType.value
          : this.conditionType),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralFilter {
  const EventReferralFilter({
    this.select,
    this.orderBy,
    this.includeCount,
    this.strictSelect,
    this.top,
    this.skip,
    required this.filters,
  });

  factory EventReferralFilter.fromJson(Map<String, dynamic> json) =>
      _$EventReferralFilterFromJson(json);

  static const toJsonFactory = _$EventReferralFilterToJson;
  Map<String, dynamic> toJson() => _$EventReferralFilterToJson(this);

  @JsonKey(name: 'select', defaultValue: <String>[])
  final List<String>? select;
  @JsonKey(name: 'orderBy', defaultValue: <String>[])
  final List<String>? orderBy;
  @JsonKey(name: 'includeCount', defaultValue: false)
  final bool? includeCount;
  @JsonKey(name: 'strictSelect')
  final bool? strictSelect;
  @JsonKey(name: 'top')
  final int? top;
  @JsonKey(name: 'skip')
  final int? skip;
  @JsonKey(name: 'filters')
  final EventReferralFilterCriteriaDto filters;
  static const fromJsonFactory = _$EventReferralFilterFromJson;
}

extension $EventReferralFilterExtension on EventReferralFilter {
  EventReferralFilter copyWith({
    List<String>? select,
    List<String>? orderBy,
    bool? includeCount,
    bool? strictSelect,
    int? top,
    int? skip,
    EventReferralFilterCriteriaDto? filters,
  }) {
    return EventReferralFilter(
      select: select ?? this.select,
      orderBy: orderBy ?? this.orderBy,
      includeCount: includeCount ?? this.includeCount,
      strictSelect: strictSelect ?? this.strictSelect,
      top: top ?? this.top,
      skip: skip ?? this.skip,
      filters: filters ?? this.filters,
    );
  }

  EventReferralFilter copyWithWrapped({
    Wrapped<List<String>?>? select,
    Wrapped<List<String>?>? orderBy,
    Wrapped<bool?>? includeCount,
    Wrapped<bool?>? strictSelect,
    Wrapped<int?>? top,
    Wrapped<int?>? skip,
    Wrapped<EventReferralFilterCriteriaDto>? filters,
  }) {
    return EventReferralFilter(
      select: (select != null ? select.value : this.select),
      orderBy: (orderBy != null ? orderBy.value : this.orderBy),
      includeCount: (includeCount != null
          ? includeCount.value
          : this.includeCount),
      strictSelect: (strictSelect != null
          ? strictSelect.value
          : this.strictSelect),
      top: (top != null ? top.value : this.top),
      skip: (skip != null ? skip.value : this.skip),
      filters: (filters != null ? filters.value : this.filters),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventReferralPaginated {
  const EventReferralPaginated({
    this.count,
    required this.hasMoreResults,
    required this.resources,
  });

  factory EventReferralPaginated.fromJson(Map<String, dynamic> json) =>
      _$EventReferralPaginatedFromJson(json);

  static const toJsonFactory = _$EventReferralPaginatedToJson;
  Map<String, dynamic> toJson() => _$EventReferralPaginatedToJson(this);

  @JsonKey(name: 'count')
  final Object? count;
  @JsonKey(name: 'hasMoreResults')
  final bool hasMoreResults;
  @JsonKey(name: 'resources', defaultValue: <EventReferralDoc>[])
  final List<EventReferralDoc> resources;
  static const fromJsonFactory = _$EventReferralPaginatedFromJson;
}

extension $EventReferralPaginatedExtension on EventReferralPaginated {
  EventReferralPaginated copyWith({
    Object? count,
    bool? hasMoreResults,
    List<EventReferralDoc>? resources,
  }) {
    return EventReferralPaginated(
      count: count ?? this.count,
      hasMoreResults: hasMoreResults ?? this.hasMoreResults,
      resources: resources ?? this.resources,
    );
  }

  EventReferralPaginated copyWithWrapped({
    Wrapped<Object?>? count,
    Wrapped<bool>? hasMoreResults,
    Wrapped<List<EventReferralDoc>>? resources,
  }) {
    return EventReferralPaginated(
      count: (count != null ? count.value : this.count),
      hasMoreResults: (hasMoreResults != null
          ? hasMoreResults.value
          : this.hasMoreResults),
      resources: (resources != null ? resources.value : this.resources),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftSaleInfo {
  const NftSaleInfo({
    required this.auctionId,
    required this.seller,
    required this.minBid,
    required this.maxBid,
    this.currentBid,
    required this.startTime,
    required this.deadline,
    required this.paymentToken,
    required this.paymentTokenNonce,
    required this.auctionType,
    required this.timestamp,
    required this.minBidShort,
    this.minBidUsdValue,
    required this.maxBidShort,
    this.maxBidUsdValue,
    this.currentBidShort,
    required this.quantity,
    required this.marketplace,
    this.royalties,
    this.currentWinner,
  });

  factory NftSaleInfo.fromJson(Map<String, dynamic> json) =>
      _$NftSaleInfoFromJson(json);

  static const toJsonFactory = _$NftSaleInfoToJson;
  Map<String, dynamic> toJson() => _$NftSaleInfoToJson(this);

  @JsonKey(name: 'auctionId')
  final double auctionId;
  @JsonKey(name: 'seller')
  final String seller;
  @JsonKey(name: 'minBid')
  final String minBid;
  @JsonKey(name: 'maxBid')
  final String maxBid;
  @JsonKey(name: 'currentBid')
  final String? currentBid;
  @JsonKey(name: 'startTime')
  final int startTime;
  @JsonKey(name: 'deadline')
  final int deadline;
  @JsonKey(name: 'paymentToken')
  final String paymentToken;
  @JsonKey(name: 'paymentTokenNonce')
  final int paymentTokenNonce;
  @JsonKey(
    name: 'auctionType',
    toJson: xoxnoAuctionTypeStringToJson,
    fromJson: xoxnoAuctionTypeStringFromJson,
  )
  final enums.XoxnoAuctionTypeString auctionType;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'minBidShort')
  final double minBidShort;
  @JsonKey(name: 'minBidUsdValue')
  final double? minBidUsdValue;
  @JsonKey(name: 'maxBidShort')
  final double maxBidShort;
  @JsonKey(name: 'maxBidUsdValue')
  final double? maxBidUsdValue;
  @JsonKey(name: 'currentBidShort')
  final double? currentBidShort;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(
    name: 'marketplace',
    toJson: marketplacesOnSaleNamesToJson,
    fromJson: marketplacesOnSaleNamesFromJson,
  )
  final enums.MarketplacesOnSaleNames marketplace;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'currentWinner')
  final String? currentWinner;
  static const fromJsonFactory = _$NftSaleInfoFromJson;
}

extension $NftSaleInfoExtension on NftSaleInfo {
  NftSaleInfo copyWith({
    double? auctionId,
    String? seller,
    String? minBid,
    String? maxBid,
    String? currentBid,
    int? startTime,
    int? deadline,
    String? paymentToken,
    int? paymentTokenNonce,
    enums.XoxnoAuctionTypeString? auctionType,
    int? timestamp,
    double? minBidShort,
    double? minBidUsdValue,
    double? maxBidShort,
    double? maxBidUsdValue,
    double? currentBidShort,
    double? quantity,
    enums.MarketplacesOnSaleNames? marketplace,
    double? royalties,
    String? currentWinner,
  }) {
    return NftSaleInfo(
      auctionId: auctionId ?? this.auctionId,
      seller: seller ?? this.seller,
      minBid: minBid ?? this.minBid,
      maxBid: maxBid ?? this.maxBid,
      currentBid: currentBid ?? this.currentBid,
      startTime: startTime ?? this.startTime,
      deadline: deadline ?? this.deadline,
      paymentToken: paymentToken ?? this.paymentToken,
      paymentTokenNonce: paymentTokenNonce ?? this.paymentTokenNonce,
      auctionType: auctionType ?? this.auctionType,
      timestamp: timestamp ?? this.timestamp,
      minBidShort: minBidShort ?? this.minBidShort,
      minBidUsdValue: minBidUsdValue ?? this.minBidUsdValue,
      maxBidShort: maxBidShort ?? this.maxBidShort,
      maxBidUsdValue: maxBidUsdValue ?? this.maxBidUsdValue,
      currentBidShort: currentBidShort ?? this.currentBidShort,
      quantity: quantity ?? this.quantity,
      marketplace: marketplace ?? this.marketplace,
      royalties: royalties ?? this.royalties,
      currentWinner: currentWinner ?? this.currentWinner,
    );
  }

  NftSaleInfo copyWithWrapped({
    Wrapped<double>? auctionId,
    Wrapped<String>? seller,
    Wrapped<String>? minBid,
    Wrapped<String>? maxBid,
    Wrapped<String?>? currentBid,
    Wrapped<int>? startTime,
    Wrapped<int>? deadline,
    Wrapped<String>? paymentToken,
    Wrapped<int>? paymentTokenNonce,
    Wrapped<enums.XoxnoAuctionTypeString>? auctionType,
    Wrapped<int>? timestamp,
    Wrapped<double>? minBidShort,
    Wrapped<double?>? minBidUsdValue,
    Wrapped<double>? maxBidShort,
    Wrapped<double?>? maxBidUsdValue,
    Wrapped<double?>? currentBidShort,
    Wrapped<double>? quantity,
    Wrapped<enums.MarketplacesOnSaleNames>? marketplace,
    Wrapped<double?>? royalties,
    Wrapped<String?>? currentWinner,
  }) {
    return NftSaleInfo(
      auctionId: (auctionId != null ? auctionId.value : this.auctionId),
      seller: (seller != null ? seller.value : this.seller),
      minBid: (minBid != null ? minBid.value : this.minBid),
      maxBid: (maxBid != null ? maxBid.value : this.maxBid),
      currentBid: (currentBid != null ? currentBid.value : this.currentBid),
      startTime: (startTime != null ? startTime.value : this.startTime),
      deadline: (deadline != null ? deadline.value : this.deadline),
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      paymentTokenNonce: (paymentTokenNonce != null
          ? paymentTokenNonce.value
          : this.paymentTokenNonce),
      auctionType: (auctionType != null ? auctionType.value : this.auctionType),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      minBidShort: (minBidShort != null ? minBidShort.value : this.minBidShort),
      minBidUsdValue: (minBidUsdValue != null
          ? minBidUsdValue.value
          : this.minBidUsdValue),
      maxBidShort: (maxBidShort != null ? maxBidShort.value : this.maxBidShort),
      maxBidUsdValue: (maxBidUsdValue != null
          ? maxBidUsdValue.value
          : this.maxBidUsdValue),
      currentBidShort: (currentBidShort != null
          ? currentBidShort.value
          : this.currentBidShort),
      quantity: (quantity != null ? quantity.value : this.quantity),
      marketplace: (marketplace != null ? marketplace.value : this.marketplace),
      royalties: (royalties != null ? royalties.value : this.royalties),
      currentWinner: (currentWinner != null
          ? currentWinner.value
          : this.currentWinner),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventGuestCheckIn {
  const EventGuestCheckIn({
    required this.ticketId,
    this.ticketProfile,
    required this.isCheckIn,
    required this.freeTicket,
    required this.receivedAt,
    this.invitationId,
    this.timestamp,
    this.quantity,
    this.transactionId,
  });

  factory EventGuestCheckIn.fromJson(Map<String, dynamic> json) =>
      _$EventGuestCheckInFromJson(json);

  static const toJsonFactory = _$EventGuestCheckInToJson;
  Map<String, dynamic> toJson() => _$EventGuestCheckInToJson(this);

  @JsonKey(name: 'ticketId')
  final String ticketId;
  @JsonKey(name: 'ticketProfile')
  final TicketProfileSummary? ticketProfile;
  @JsonKey(name: 'isCheckIn')
  final bool isCheckIn;
  @JsonKey(name: 'freeTicket', defaultValue: false)
  final bool freeTicket;
  @JsonKey(name: 'receivedAt')
  final int receivedAt;
  @JsonKey(name: 'invitationId')
  final String? invitationId;
  @JsonKey(name: 'timestamp')
  final int? timestamp;
  @JsonKey(name: 'quantity')
  final int? quantity;
  @JsonKey(name: 'transactionId')
  final String? transactionId;
  static const fromJsonFactory = _$EventGuestCheckInFromJson;
}

extension $EventGuestCheckInExtension on EventGuestCheckIn {
  EventGuestCheckIn copyWith({
    String? ticketId,
    TicketProfileSummary? ticketProfile,
    bool? isCheckIn,
    bool? freeTicket,
    int? receivedAt,
    String? invitationId,
    int? timestamp,
    int? quantity,
    String? transactionId,
  }) {
    return EventGuestCheckIn(
      ticketId: ticketId ?? this.ticketId,
      ticketProfile: ticketProfile ?? this.ticketProfile,
      isCheckIn: isCheckIn ?? this.isCheckIn,
      freeTicket: freeTicket ?? this.freeTicket,
      receivedAt: receivedAt ?? this.receivedAt,
      invitationId: invitationId ?? this.invitationId,
      timestamp: timestamp ?? this.timestamp,
      quantity: quantity ?? this.quantity,
      transactionId: transactionId ?? this.transactionId,
    );
  }

  EventGuestCheckIn copyWithWrapped({
    Wrapped<String>? ticketId,
    Wrapped<TicketProfileSummary?>? ticketProfile,
    Wrapped<bool>? isCheckIn,
    Wrapped<bool>? freeTicket,
    Wrapped<int>? receivedAt,
    Wrapped<String?>? invitationId,
    Wrapped<int?>? timestamp,
    Wrapped<int?>? quantity,
    Wrapped<String?>? transactionId,
  }) {
    return EventGuestCheckIn(
      ticketId: (ticketId != null ? ticketId.value : this.ticketId),
      ticketProfile: (ticketProfile != null
          ? ticketProfile.value
          : this.ticketProfile),
      isCheckIn: (isCheckIn != null ? isCheckIn.value : this.isCheckIn),
      freeTicket: (freeTicket != null ? freeTicket.value : this.freeTicket),
      receivedAt: (receivedAt != null ? receivedAt.value : this.receivedAt),
      invitationId: (invitationId != null
          ? invitationId.value
          : this.invitationId),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      quantity: (quantity != null ? quantity.value : this.quantity),
      transactionId: (transactionId != null
          ? transactionId.value
          : this.transactionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressUploadPicturePut$RequestBody {
  const UserAddressUploadPicturePut$RequestBody({required this.file});

  factory UserAddressUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$UserAddressUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressUploadPicturePut$RequestBodyFromJson;
}

extension $UserAddressUploadPicturePut$RequestBodyExtension
    on UserAddressUploadPicturePut$RequestBody {
  UserAddressUploadPicturePut$RequestBody copyWith({String? file}) {
    return UserAddressUploadPicturePut$RequestBody(file: file ?? this.file);
  }

  UserAddressUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressUploadBannerPut$RequestBody {
  const UserAddressUploadBannerPut$RequestBody({required this.file});

  factory UserAddressUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$UserAddressUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressUploadBannerPut$RequestBodyFromJson;
}

extension $UserAddressUploadBannerPut$RequestBodyExtension
    on UserAddressUploadBannerPut$RequestBody {
  UserAddressUploadBannerPut$RequestBody copyWith({String? file}) {
    return UserAddressUploadBannerPut$RequestBody(file: file ?? this.file);
  }

  UserAddressUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressCreatorUploadPicturePut$RequestBody {
  const UserAddressCreatorUploadPicturePut$RequestBody({required this.file});

  factory UserAddressCreatorUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressCreatorUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$UserAddressCreatorUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressCreatorUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressCreatorUploadPicturePut$RequestBodyFromJson;
}

extension $UserAddressCreatorUploadPicturePut$RequestBodyExtension
    on UserAddressCreatorUploadPicturePut$RequestBody {
  UserAddressCreatorUploadPicturePut$RequestBody copyWith({String? file}) {
    return UserAddressCreatorUploadPicturePut$RequestBody(
      file: file ?? this.file,
    );
  }

  UserAddressCreatorUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressCreatorUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddressCreatorUploadBannerPut$RequestBody {
  const UserAddressCreatorUploadBannerPut$RequestBody({required this.file});

  factory UserAddressCreatorUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$UserAddressCreatorUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$UserAddressCreatorUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$UserAddressCreatorUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$UserAddressCreatorUploadBannerPut$RequestBodyFromJson;
}

extension $UserAddressCreatorUploadBannerPut$RequestBodyExtension
    on UserAddressCreatorUploadBannerPut$RequestBody {
  UserAddressCreatorUploadBannerPut$RequestBody copyWith({String? file}) {
    return UserAddressCreatorUploadBannerPut$RequestBody(
      file: file ?? this.file,
    );
  }

  UserAddressCreatorUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return UserAddressCreatorUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionCollectionUploadPicturePut$RequestBody {
  const CollectionCollectionUploadPicturePut$RequestBody({required this.file});

  factory CollectionCollectionUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionCollectionUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$CollectionCollectionUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionCollectionUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$CollectionCollectionUploadPicturePut$RequestBodyFromJson;
}

extension $CollectionCollectionUploadPicturePut$RequestBodyExtension
    on CollectionCollectionUploadPicturePut$RequestBody {
  CollectionCollectionUploadPicturePut$RequestBody copyWith({String? file}) {
    return CollectionCollectionUploadPicturePut$RequestBody(
      file: file ?? this.file,
    );
  }

  CollectionCollectionUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return CollectionCollectionUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionCollectionUploadBannerPut$RequestBody {
  const CollectionCollectionUploadBannerPut$RequestBody({required this.file});

  factory CollectionCollectionUploadBannerPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$CollectionCollectionUploadBannerPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$CollectionCollectionUploadBannerPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$CollectionCollectionUploadBannerPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$CollectionCollectionUploadBannerPut$RequestBodyFromJson;
}

extension $CollectionCollectionUploadBannerPut$RequestBodyExtension
    on CollectionCollectionUploadBannerPut$RequestBody {
  CollectionCollectionUploadBannerPut$RequestBody copyWith({String? file}) {
    return CollectionCollectionUploadBannerPut$RequestBody(
      file: file ?? this.file,
    );
  }

  CollectionCollectionUploadBannerPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return CollectionCollectionUploadBannerPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PoolPoolIdUploadPicturePut$RequestBody {
  const PoolPoolIdUploadPicturePut$RequestBody({required this.file});

  factory PoolPoolIdUploadPicturePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$PoolPoolIdUploadPicturePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$PoolPoolIdUploadPicturePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$PoolPoolIdUploadPicturePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$PoolPoolIdUploadPicturePut$RequestBodyFromJson;
}

extension $PoolPoolIdUploadPicturePut$RequestBodyExtension
    on PoolPoolIdUploadPicturePut$RequestBody {
  PoolPoolIdUploadPicturePut$RequestBody copyWith({String? file}) {
    return PoolPoolIdUploadPicturePut$RequestBody(file: file ?? this.file);
  }

  PoolPoolIdUploadPicturePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return PoolPoolIdUploadPicturePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdProfilePut$RequestBody {
  const EventEventIdProfilePut$RequestBody({required this.file});

  factory EventEventIdProfilePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdProfilePut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdProfilePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdProfilePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory = _$EventEventIdProfilePut$RequestBodyFromJson;
}

extension $EventEventIdProfilePut$RequestBodyExtension
    on EventEventIdProfilePut$RequestBody {
  EventEventIdProfilePut$RequestBody copyWith({String? file}) {
    return EventEventIdProfilePut$RequestBody(file: file ?? this.file);
  }

  EventEventIdProfilePut$RequestBody copyWithWrapped({Wrapped<String>? file}) {
    return EventEventIdProfilePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdBackgroundPut$RequestBody {
  const EventEventIdBackgroundPut$RequestBody({required this.file});

  factory EventEventIdBackgroundPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdBackgroundPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdBackgroundPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdBackgroundPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdBackgroundPut$RequestBodyFromJson;
}

extension $EventEventIdBackgroundPut$RequestBodyExtension
    on EventEventIdBackgroundPut$RequestBody {
  EventEventIdBackgroundPut$RequestBody copyWith({String? file}) {
    return EventEventIdBackgroundPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdBackgroundPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdBackgroundPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdDescriptionPut$RequestBody {
  const EventEventIdDescriptionPut$RequestBody({required this.file});

  factory EventEventIdDescriptionPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdDescriptionPut$RequestBodyFromJson(json);

  static const toJsonFactory = _$EventEventIdDescriptionPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdDescriptionPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdDescriptionPut$RequestBodyFromJson;
}

extension $EventEventIdDescriptionPut$RequestBodyExtension
    on EventEventIdDescriptionPut$RequestBody {
  EventEventIdDescriptionPut$RequestBody copyWith({String? file}) {
    return EventEventIdDescriptionPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdDescriptionPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdDescriptionPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdDescriptionImagePut$RequestBody {
  const EventEventIdDescriptionImagePut$RequestBody({required this.file});

  factory EventEventIdDescriptionImagePut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdDescriptionImagePut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$EventEventIdDescriptionImagePut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdDescriptionImagePut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdDescriptionImagePut$RequestBodyFromJson;
}

extension $EventEventIdDescriptionImagePut$RequestBodyExtension
    on EventEventIdDescriptionImagePut$RequestBody {
  EventEventIdDescriptionImagePut$RequestBody copyWith({String? file}) {
    return EventEventIdDescriptionImagePut$RequestBody(file: file ?? this.file);
  }

  EventEventIdDescriptionImagePut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdDescriptionImagePut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class EventEventIdTicketTicketIdPut$RequestBody {
  const EventEventIdTicketTicketIdPut$RequestBody({required this.file});

  factory EventEventIdTicketTicketIdPut$RequestBody.fromJson(
    Map<String, dynamic> json,
  ) => _$EventEventIdTicketTicketIdPut$RequestBodyFromJson(json);

  static const toJsonFactory =
      _$EventEventIdTicketTicketIdPut$RequestBodyToJson;
  Map<String, dynamic> toJson() =>
      _$EventEventIdTicketTicketIdPut$RequestBodyToJson(this);

  @JsonKey(name: 'file')
  final String file;
  static const fromJsonFactory =
      _$EventEventIdTicketTicketIdPut$RequestBodyFromJson;
}

extension $EventEventIdTicketTicketIdPut$RequestBodyExtension
    on EventEventIdTicketTicketIdPut$RequestBody {
  EventEventIdTicketTicketIdPut$RequestBody copyWith({String? file}) {
    return EventEventIdTicketTicketIdPut$RequestBody(file: file ?? this.file);
  }

  EventEventIdTicketTicketIdPut$RequestBody copyWithWrapped({
    Wrapped<String>? file,
  }) {
    return EventEventIdTicketTicketIdPut$RequestBody(
      file: (file != null ? file.value : this.file),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class NftActivityDataHydrated$OriginalPayment {
  const NftActivityDataHydrated$OriginalPayment({
    this.paymentToken,
    this.price,
  });

  factory NftActivityDataHydrated$OriginalPayment.fromJson(
    Map<String, dynamic> json,
  ) => _$NftActivityDataHydrated$OriginalPaymentFromJson(json);

  static const toJsonFactory = _$NftActivityDataHydrated$OriginalPaymentToJson;
  Map<String, dynamic> toJson() =>
      _$NftActivityDataHydrated$OriginalPaymentToJson(this);

  @JsonKey(name: 'paymentToken')
  final String? paymentToken;
  @JsonKey(name: 'price')
  final double? price;
  static const fromJsonFactory =
      _$NftActivityDataHydrated$OriginalPaymentFromJson;
}

extension $NftActivityDataHydrated$OriginalPaymentExtension
    on NftActivityDataHydrated$OriginalPayment {
  NftActivityDataHydrated$OriginalPayment copyWith({
    String? paymentToken,
    double? price,
  }) {
    return NftActivityDataHydrated$OriginalPayment(
      paymentToken: paymentToken ?? this.paymentToken,
      price: price ?? this.price,
    );
  }

  NftActivityDataHydrated$OriginalPayment copyWithWrapped({
    Wrapped<String?>? paymentToken,
    Wrapped<double?>? price,
  }) {
    return NftActivityDataHydrated$OriginalPayment(
      paymentToken: (paymentToken != null
          ? paymentToken.value
          : this.paymentToken),
      price: (price != null ? price.value : this.price),
    );
  }
}

String? activityChainNullableToJson(enums.ActivityChain? activityChain) {
  return activityChain?.value;
}

String? activityChainToJson(enums.ActivityChain activityChain) {
  return activityChain.value;
}

enums.ActivityChain activityChainFromJson(
  Object? activityChain, [
  enums.ActivityChain? defaultValue,
]) {
  return enums.ActivityChain.values.firstWhereOrNull(
        (e) => e.value == activityChain,
      ) ??
      defaultValue ??
      enums.ActivityChain.swaggerGeneratedUnknown;
}

enums.ActivityChain? activityChainNullableFromJson(
  Object? activityChain, [
  enums.ActivityChain? defaultValue,
]) {
  if (activityChain == null) {
    return null;
  }
  return enums.ActivityChain.values.firstWhereOrNull(
        (e) => e.value == activityChain,
      ) ??
      defaultValue;
}

String activityChainExplodedListToJson(
  List<enums.ActivityChain>? activityChain,
) {
  return activityChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> activityChainListToJson(List<enums.ActivityChain>? activityChain) {
  if (activityChain == null) {
    return [];
  }

  return activityChain.map((e) => e.value!).toList();
}

List<enums.ActivityChain> activityChainListFromJson(
  List? activityChain, [
  List<enums.ActivityChain>? defaultValue,
]) {
  if (activityChain == null) {
    return defaultValue ?? [];
  }

  return activityChain.map((e) => activityChainFromJson(e.toString())).toList();
}

List<enums.ActivityChain>? activityChainNullableListFromJson(
  List? activityChain, [
  List<enums.ActivityChain>? defaultValue,
]) {
  if (activityChain == null) {
    return defaultValue;
  }

  return activityChain.map((e) => activityChainFromJson(e.toString())).toList();
}

String? userProfileDocDataTypeNullableToJson(
  enums.UserProfileDocDataType? userProfileDocDataType,
) {
  return userProfileDocDataType?.value;
}

String? userProfileDocDataTypeToJson(
  enums.UserProfileDocDataType userProfileDocDataType,
) {
  return userProfileDocDataType.value;
}

enums.UserProfileDocDataType userProfileDocDataTypeFromJson(
  Object? userProfileDocDataType, [
  enums.UserProfileDocDataType? defaultValue,
]) {
  return enums.UserProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDocDataType,
      ) ??
      defaultValue ??
      enums.UserProfileDocDataType.swaggerGeneratedUnknown;
}

enums.UserProfileDocDataType? userProfileDocDataTypeNullableFromJson(
  Object? userProfileDocDataType, [
  enums.UserProfileDocDataType? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return null;
  }
  return enums.UserProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDocDataType,
      ) ??
      defaultValue;
}

String userProfileDocDataTypeExplodedListToJson(
  List<enums.UserProfileDocDataType>? userProfileDocDataType,
) {
  return userProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDocDataTypeListToJson(
  List<enums.UserProfileDocDataType>? userProfileDocDataType,
) {
  if (userProfileDocDataType == null) {
    return [];
  }

  return userProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.UserProfileDocDataType> userProfileDocDataTypeListFromJson(
  List? userProfileDocDataType, [
  List<enums.UserProfileDocDataType>? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return userProfileDocDataType
      .map((e) => userProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDocDataType>? userProfileDocDataTypeNullableListFromJson(
  List? userProfileDocDataType, [
  List<enums.UserProfileDocDataType>? defaultValue,
]) {
  if (userProfileDocDataType == null) {
    return defaultValue;
  }

  return userProfileDocDataType
      .map((e) => userProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? userProfileDocChainNullableToJson(
  enums.UserProfileDocChain? userProfileDocChain,
) {
  return userProfileDocChain?.value;
}

String? userProfileDocChainToJson(
  enums.UserProfileDocChain userProfileDocChain,
) {
  return userProfileDocChain.value;
}

enums.UserProfileDocChain userProfileDocChainFromJson(
  Object? userProfileDocChain, [
  enums.UserProfileDocChain? defaultValue,
]) {
  return enums.UserProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDocChain,
      ) ??
      defaultValue ??
      enums.UserProfileDocChain.swaggerGeneratedUnknown;
}

enums.UserProfileDocChain? userProfileDocChainNullableFromJson(
  Object? userProfileDocChain, [
  enums.UserProfileDocChain? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return null;
  }
  return enums.UserProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDocChain,
      ) ??
      defaultValue;
}

String userProfileDocChainExplodedListToJson(
  List<enums.UserProfileDocChain>? userProfileDocChain,
) {
  return userProfileDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDocChainListToJson(
  List<enums.UserProfileDocChain>? userProfileDocChain,
) {
  if (userProfileDocChain == null) {
    return [];
  }

  return userProfileDocChain.map((e) => e.value!).toList();
}

List<enums.UserProfileDocChain> userProfileDocChainListFromJson(
  List? userProfileDocChain, [
  List<enums.UserProfileDocChain>? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return defaultValue ?? [];
  }

  return userProfileDocChain
      .map((e) => userProfileDocChainFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDocChain>? userProfileDocChainNullableListFromJson(
  List? userProfileDocChain, [
  List<enums.UserProfileDocChain>? defaultValue,
]) {
  if (userProfileDocChain == null) {
    return defaultValue;
  }

  return userProfileDocChain
      .map((e) => userProfileDocChainFromJson(e.toString()))
      .toList();
}

String? userProfileDtoDataTypeNullableToJson(
  enums.UserProfileDtoDataType? userProfileDtoDataType,
) {
  return userProfileDtoDataType?.value;
}

String? userProfileDtoDataTypeToJson(
  enums.UserProfileDtoDataType userProfileDtoDataType,
) {
  return userProfileDtoDataType.value;
}

enums.UserProfileDtoDataType userProfileDtoDataTypeFromJson(
  Object? userProfileDtoDataType, [
  enums.UserProfileDtoDataType? defaultValue,
]) {
  return enums.UserProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoDataType,
      ) ??
      defaultValue ??
      enums.UserProfileDtoDataType.swaggerGeneratedUnknown;
}

enums.UserProfileDtoDataType? userProfileDtoDataTypeNullableFromJson(
  Object? userProfileDtoDataType, [
  enums.UserProfileDtoDataType? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return null;
  }
  return enums.UserProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoDataType,
      ) ??
      defaultValue;
}

String userProfileDtoDataTypeExplodedListToJson(
  List<enums.UserProfileDtoDataType>? userProfileDtoDataType,
) {
  return userProfileDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDtoDataTypeListToJson(
  List<enums.UserProfileDtoDataType>? userProfileDtoDataType,
) {
  if (userProfileDtoDataType == null) {
    return [];
  }

  return userProfileDtoDataType.map((e) => e.value!).toList();
}

List<enums.UserProfileDtoDataType> userProfileDtoDataTypeListFromJson(
  List? userProfileDtoDataType, [
  List<enums.UserProfileDtoDataType>? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return defaultValue ?? [];
  }

  return userProfileDtoDataType
      .map((e) => userProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDtoDataType>? userProfileDtoDataTypeNullableListFromJson(
  List? userProfileDtoDataType, [
  List<enums.UserProfileDtoDataType>? defaultValue,
]) {
  if (userProfileDtoDataType == null) {
    return defaultValue;
  }

  return userProfileDtoDataType
      .map((e) => userProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? userProfileDtoChainNullableToJson(
  enums.UserProfileDtoChain? userProfileDtoChain,
) {
  return userProfileDtoChain?.value;
}

String? userProfileDtoChainToJson(
  enums.UserProfileDtoChain userProfileDtoChain,
) {
  return userProfileDtoChain.value;
}

enums.UserProfileDtoChain userProfileDtoChainFromJson(
  Object? userProfileDtoChain, [
  enums.UserProfileDtoChain? defaultValue,
]) {
  return enums.UserProfileDtoChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoChain,
      ) ??
      defaultValue ??
      enums.UserProfileDtoChain.swaggerGeneratedUnknown;
}

enums.UserProfileDtoChain? userProfileDtoChainNullableFromJson(
  Object? userProfileDtoChain, [
  enums.UserProfileDtoChain? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return null;
  }
  return enums.UserProfileDtoChain.values.firstWhereOrNull(
        (e) => e.value == userProfileDtoChain,
      ) ??
      defaultValue;
}

String userProfileDtoChainExplodedListToJson(
  List<enums.UserProfileDtoChain>? userProfileDtoChain,
) {
  return userProfileDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userProfileDtoChainListToJson(
  List<enums.UserProfileDtoChain>? userProfileDtoChain,
) {
  if (userProfileDtoChain == null) {
    return [];
  }

  return userProfileDtoChain.map((e) => e.value!).toList();
}

List<enums.UserProfileDtoChain> userProfileDtoChainListFromJson(
  List? userProfileDtoChain, [
  List<enums.UserProfileDtoChain>? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return defaultValue ?? [];
  }

  return userProfileDtoChain
      .map((e) => userProfileDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.UserProfileDtoChain>? userProfileDtoChainNullableListFromJson(
  List? userProfileDtoChain, [
  List<enums.UserProfileDtoChain>? defaultValue,
]) {
  if (userProfileDtoChain == null) {
    return defaultValue;
  }

  return userProfileDtoChain
      .map((e) => userProfileDtoChainFromJson(e.toString()))
      .toList();
}

String? creatorProfileDtoDataTypeNullableToJson(
  enums.CreatorProfileDtoDataType? creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType?.value;
}

String? creatorProfileDtoDataTypeToJson(
  enums.CreatorProfileDtoDataType creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType.value;
}

enums.CreatorProfileDtoDataType creatorProfileDtoDataTypeFromJson(
  Object? creatorProfileDtoDataType, [
  enums.CreatorProfileDtoDataType? defaultValue,
]) {
  return enums.CreatorProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDtoDataType,
      ) ??
      defaultValue ??
      enums.CreatorProfileDtoDataType.swaggerGeneratedUnknown;
}

enums.CreatorProfileDtoDataType? creatorProfileDtoDataTypeNullableFromJson(
  Object? creatorProfileDtoDataType, [
  enums.CreatorProfileDtoDataType? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return null;
  }
  return enums.CreatorProfileDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDtoDataType,
      ) ??
      defaultValue;
}

String creatorProfileDtoDataTypeExplodedListToJson(
  List<enums.CreatorProfileDtoDataType>? creatorProfileDtoDataType,
) {
  return creatorProfileDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorProfileDtoDataTypeListToJson(
  List<enums.CreatorProfileDtoDataType>? creatorProfileDtoDataType,
) {
  if (creatorProfileDtoDataType == null) {
    return [];
  }

  return creatorProfileDtoDataType.map((e) => e.value!).toList();
}

List<enums.CreatorProfileDtoDataType> creatorProfileDtoDataTypeListFromJson(
  List? creatorProfileDtoDataType, [
  List<enums.CreatorProfileDtoDataType>? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return defaultValue ?? [];
  }

  return creatorProfileDtoDataType
      .map((e) => creatorProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorProfileDtoDataType>?
creatorProfileDtoDataTypeNullableListFromJson(
  List? creatorProfileDtoDataType, [
  List<enums.CreatorProfileDtoDataType>? defaultValue,
]) {
  if (creatorProfileDtoDataType == null) {
    return defaultValue;
  }

  return creatorProfileDtoDataType
      .map((e) => creatorProfileDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? creatorProfileDocDataTypeNullableToJson(
  enums.CreatorProfileDocDataType? creatorProfileDocDataType,
) {
  return creatorProfileDocDataType?.value;
}

String? creatorProfileDocDataTypeToJson(
  enums.CreatorProfileDocDataType creatorProfileDocDataType,
) {
  return creatorProfileDocDataType.value;
}

enums.CreatorProfileDocDataType creatorProfileDocDataTypeFromJson(
  Object? creatorProfileDocDataType, [
  enums.CreatorProfileDocDataType? defaultValue,
]) {
  return enums.CreatorProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDocDataType,
      ) ??
      defaultValue ??
      enums.CreatorProfileDocDataType.swaggerGeneratedUnknown;
}

enums.CreatorProfileDocDataType? creatorProfileDocDataTypeNullableFromJson(
  Object? creatorProfileDocDataType, [
  enums.CreatorProfileDocDataType? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return null;
  }
  return enums.CreatorProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == creatorProfileDocDataType,
      ) ??
      defaultValue;
}

String creatorProfileDocDataTypeExplodedListToJson(
  List<enums.CreatorProfileDocDataType>? creatorProfileDocDataType,
) {
  return creatorProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorProfileDocDataTypeListToJson(
  List<enums.CreatorProfileDocDataType>? creatorProfileDocDataType,
) {
  if (creatorProfileDocDataType == null) {
    return [];
  }

  return creatorProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.CreatorProfileDocDataType> creatorProfileDocDataTypeListFromJson(
  List? creatorProfileDocDataType, [
  List<enums.CreatorProfileDocDataType>? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return creatorProfileDocDataType
      .map((e) => creatorProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorProfileDocDataType>?
creatorProfileDocDataTypeNullableListFromJson(
  List? creatorProfileDocDataType, [
  List<enums.CreatorProfileDocDataType>? defaultValue,
]) {
  if (creatorProfileDocDataType == null) {
    return defaultValue;
  }

  return creatorProfileDocDataType
      .map((e) => creatorProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? collectionDataTypeNullableToJson(
  enums.CollectionDataType? collectionDataType,
) {
  return collectionDataType?.value;
}

String? collectionDataTypeToJson(enums.CollectionDataType collectionDataType) {
  return collectionDataType.value;
}

enums.CollectionDataType collectionDataTypeFromJson(
  Object? collectionDataType, [
  enums.CollectionDataType? defaultValue,
]) {
  return enums.CollectionDataType.values.firstWhereOrNull(
        (e) => e.value == collectionDataType,
      ) ??
      defaultValue ??
      enums.CollectionDataType.swaggerGeneratedUnknown;
}

enums.CollectionDataType? collectionDataTypeNullableFromJson(
  Object? collectionDataType, [
  enums.CollectionDataType? defaultValue,
]) {
  if (collectionDataType == null) {
    return null;
  }
  return enums.CollectionDataType.values.firstWhereOrNull(
        (e) => e.value == collectionDataType,
      ) ??
      defaultValue;
}

String collectionDataTypeExplodedListToJson(
  List<enums.CollectionDataType>? collectionDataType,
) {
  return collectionDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionDataTypeListToJson(
  List<enums.CollectionDataType>? collectionDataType,
) {
  if (collectionDataType == null) {
    return [];
  }

  return collectionDataType.map((e) => e.value!).toList();
}

List<enums.CollectionDataType> collectionDataTypeListFromJson(
  List? collectionDataType, [
  List<enums.CollectionDataType>? defaultValue,
]) {
  if (collectionDataType == null) {
    return defaultValue ?? [];
  }

  return collectionDataType
      .map((e) => collectionDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionDataType>? collectionDataTypeNullableListFromJson(
  List? collectionDataType, [
  List<enums.CollectionDataType>? defaultValue,
]) {
  if (collectionDataType == null) {
    return defaultValue;
  }

  return collectionDataType
      .map((e) => collectionDataTypeFromJson(e.toString()))
      .toList();
}

String? shortCollectionInfoDocChainNullableToJson(
  enums.ShortCollectionInfoDocChain? shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain?.value;
}

String? shortCollectionInfoDocChainToJson(
  enums.ShortCollectionInfoDocChain shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain.value;
}

enums.ShortCollectionInfoDocChain shortCollectionInfoDocChainFromJson(
  Object? shortCollectionInfoDocChain, [
  enums.ShortCollectionInfoDocChain? defaultValue,
]) {
  return enums.ShortCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionInfoDocChain,
      ) ??
      defaultValue ??
      enums.ShortCollectionInfoDocChain.swaggerGeneratedUnknown;
}

enums.ShortCollectionInfoDocChain? shortCollectionInfoDocChainNullableFromJson(
  Object? shortCollectionInfoDocChain, [
  enums.ShortCollectionInfoDocChain? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return null;
  }
  return enums.ShortCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionInfoDocChain,
      ) ??
      defaultValue;
}

String shortCollectionInfoDocChainExplodedListToJson(
  List<enums.ShortCollectionInfoDocChain>? shortCollectionInfoDocChain,
) {
  return shortCollectionInfoDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortCollectionInfoDocChainListToJson(
  List<enums.ShortCollectionInfoDocChain>? shortCollectionInfoDocChain,
) {
  if (shortCollectionInfoDocChain == null) {
    return [];
  }

  return shortCollectionInfoDocChain.map((e) => e.value!).toList();
}

List<enums.ShortCollectionInfoDocChain> shortCollectionInfoDocChainListFromJson(
  List? shortCollectionInfoDocChain, [
  List<enums.ShortCollectionInfoDocChain>? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return defaultValue ?? [];
  }

  return shortCollectionInfoDocChain
      .map((e) => shortCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortCollectionInfoDocChain>?
shortCollectionInfoDocChainNullableListFromJson(
  List? shortCollectionInfoDocChain, [
  List<enums.ShortCollectionInfoDocChain>? defaultValue,
]) {
  if (shortCollectionInfoDocChain == null) {
    return defaultValue;
  }

  return shortCollectionInfoDocChain
      .map((e) => shortCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

String? collectionStatsDocHydratedChainNullableToJson(
  enums.CollectionStatsDocHydratedChain? collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain?.value;
}

String? collectionStatsDocHydratedChainToJson(
  enums.CollectionStatsDocHydratedChain collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain.value;
}

enums.CollectionStatsDocHydratedChain collectionStatsDocHydratedChainFromJson(
  Object? collectionStatsDocHydratedChain, [
  enums.CollectionStatsDocHydratedChain? defaultValue,
]) {
  return enums.CollectionStatsDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == collectionStatsDocHydratedChain,
      ) ??
      defaultValue ??
      enums.CollectionStatsDocHydratedChain.swaggerGeneratedUnknown;
}

enums.CollectionStatsDocHydratedChain?
collectionStatsDocHydratedChainNullableFromJson(
  Object? collectionStatsDocHydratedChain, [
  enums.CollectionStatsDocHydratedChain? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return null;
  }
  return enums.CollectionStatsDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == collectionStatsDocHydratedChain,
      ) ??
      defaultValue;
}

String collectionStatsDocHydratedChainExplodedListToJson(
  List<enums.CollectionStatsDocHydratedChain>? collectionStatsDocHydratedChain,
) {
  return collectionStatsDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionStatsDocHydratedChainListToJson(
  List<enums.CollectionStatsDocHydratedChain>? collectionStatsDocHydratedChain,
) {
  if (collectionStatsDocHydratedChain == null) {
    return [];
  }

  return collectionStatsDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.CollectionStatsDocHydratedChain>
collectionStatsDocHydratedChainListFromJson(
  List? collectionStatsDocHydratedChain, [
  List<enums.CollectionStatsDocHydratedChain>? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return collectionStatsDocHydratedChain
      .map((e) => collectionStatsDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionStatsDocHydratedChain>?
collectionStatsDocHydratedChainNullableListFromJson(
  List? collectionStatsDocHydratedChain, [
  List<enums.CollectionStatsDocHydratedChain>? defaultValue,
]) {
  if (collectionStatsDocHydratedChain == null) {
    return defaultValue;
  }

  return collectionStatsDocHydratedChain
      .map((e) => collectionStatsDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? tokenCategoryNullableToJson(enums.TokenCategory? tokenCategory) {
  return tokenCategory?.value;
}

String? tokenCategoryToJson(enums.TokenCategory tokenCategory) {
  return tokenCategory.value;
}

enums.TokenCategory tokenCategoryFromJson(
  Object? tokenCategory, [
  enums.TokenCategory? defaultValue,
]) {
  return enums.TokenCategory.values.firstWhereOrNull(
        (e) => e.value == tokenCategory,
      ) ??
      defaultValue ??
      enums.TokenCategory.swaggerGeneratedUnknown;
}

enums.TokenCategory? tokenCategoryNullableFromJson(
  Object? tokenCategory, [
  enums.TokenCategory? defaultValue,
]) {
  if (tokenCategory == null) {
    return null;
  }
  return enums.TokenCategory.values.firstWhereOrNull(
        (e) => e.value == tokenCategory,
      ) ??
      defaultValue;
}

String tokenCategoryExplodedListToJson(
  List<enums.TokenCategory>? tokenCategory,
) {
  return tokenCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> tokenCategoryListToJson(List<enums.TokenCategory>? tokenCategory) {
  if (tokenCategory == null) {
    return [];
  }

  return tokenCategory.map((e) => e.value!).toList();
}

List<enums.TokenCategory> tokenCategoryListFromJson(
  List? tokenCategory, [
  List<enums.TokenCategory>? defaultValue,
]) {
  if (tokenCategory == null) {
    return defaultValue ?? [];
  }

  return tokenCategory.map((e) => tokenCategoryFromJson(e.toString())).toList();
}

List<enums.TokenCategory>? tokenCategoryNullableListFromJson(
  List? tokenCategory, [
  List<enums.TokenCategory>? defaultValue,
]) {
  if (tokenCategory == null) {
    return defaultValue;
  }

  return tokenCategory.map((e) => tokenCategoryFromJson(e.toString())).toList();
}

String? tokenDataTypeNullableToJson(enums.TokenDataType? tokenDataType) {
  return tokenDataType?.value;
}

String? tokenDataTypeToJson(enums.TokenDataType tokenDataType) {
  return tokenDataType.value;
}

enums.TokenDataType tokenDataTypeFromJson(
  Object? tokenDataType, [
  enums.TokenDataType? defaultValue,
]) {
  return enums.TokenDataType.values.firstWhereOrNull(
        (e) => e.value == tokenDataType,
      ) ??
      defaultValue ??
      enums.TokenDataType.swaggerGeneratedUnknown;
}

enums.TokenDataType? tokenDataTypeNullableFromJson(
  Object? tokenDataType, [
  enums.TokenDataType? defaultValue,
]) {
  if (tokenDataType == null) {
    return null;
  }
  return enums.TokenDataType.values.firstWhereOrNull(
        (e) => e.value == tokenDataType,
      ) ??
      defaultValue;
}

String tokenDataTypeExplodedListToJson(
  List<enums.TokenDataType>? tokenDataType,
) {
  return tokenDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> tokenDataTypeListToJson(List<enums.TokenDataType>? tokenDataType) {
  if (tokenDataType == null) {
    return [];
  }

  return tokenDataType.map((e) => e.value!).toList();
}

List<enums.TokenDataType> tokenDataTypeListFromJson(
  List? tokenDataType, [
  List<enums.TokenDataType>? defaultValue,
]) {
  if (tokenDataType == null) {
    return defaultValue ?? [];
  }

  return tokenDataType.map((e) => tokenDataTypeFromJson(e.toString())).toList();
}

List<enums.TokenDataType>? tokenDataTypeNullableListFromJson(
  List? tokenDataType, [
  List<enums.TokenDataType>? defaultValue,
]) {
  if (tokenDataType == null) {
    return defaultValue;
  }

  return tokenDataType.map((e) => tokenDataTypeFromJson(e.toString())).toList();
}

String? lendingDataTypeNullableToJson(enums.LendingDataType? lendingDataType) {
  return lendingDataType?.value;
}

String? lendingDataTypeToJson(enums.LendingDataType lendingDataType) {
  return lendingDataType.value;
}

enums.LendingDataType lendingDataTypeFromJson(
  Object? lendingDataType, [
  enums.LendingDataType? defaultValue,
]) {
  return enums.LendingDataType.values.firstWhereOrNull(
        (e) => e.value == lendingDataType,
      ) ??
      defaultValue ??
      enums.LendingDataType.swaggerGeneratedUnknown;
}

enums.LendingDataType? lendingDataTypeNullableFromJson(
  Object? lendingDataType, [
  enums.LendingDataType? defaultValue,
]) {
  if (lendingDataType == null) {
    return null;
  }
  return enums.LendingDataType.values.firstWhereOrNull(
        (e) => e.value == lendingDataType,
      ) ??
      defaultValue;
}

String lendingDataTypeExplodedListToJson(
  List<enums.LendingDataType>? lendingDataType,
) {
  return lendingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> lendingDataTypeListToJson(
  List<enums.LendingDataType>? lendingDataType,
) {
  if (lendingDataType == null) {
    return [];
  }

  return lendingDataType.map((e) => e.value!).toList();
}

List<enums.LendingDataType> lendingDataTypeListFromJson(
  List? lendingDataType, [
  List<enums.LendingDataType>? defaultValue,
]) {
  if (lendingDataType == null) {
    return defaultValue ?? [];
  }

  return lendingDataType
      .map((e) => lendingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.LendingDataType>? lendingDataTypeNullableListFromJson(
  List? lendingDataType, [
  List<enums.LendingDataType>? defaultValue,
]) {
  if (lendingDataType == null) {
    return defaultValue;
  }

  return lendingDataType
      .map((e) => lendingDataTypeFromJson(e.toString()))
      .toList();
}

String? pricingMethodNullableToJson(enums.PricingMethod? pricingMethod) {
  return pricingMethod?.value;
}

String? pricingMethodToJson(enums.PricingMethod pricingMethod) {
  return pricingMethod.value;
}

enums.PricingMethod pricingMethodFromJson(
  Object? pricingMethod, [
  enums.PricingMethod? defaultValue,
]) {
  return enums.PricingMethod.values.firstWhereOrNull(
        (e) => e.value == pricingMethod,
      ) ??
      defaultValue ??
      enums.PricingMethod.swaggerGeneratedUnknown;
}

enums.PricingMethod? pricingMethodNullableFromJson(
  Object? pricingMethod, [
  enums.PricingMethod? defaultValue,
]) {
  if (pricingMethod == null) {
    return null;
  }
  return enums.PricingMethod.values.firstWhereOrNull(
        (e) => e.value == pricingMethod,
      ) ??
      defaultValue;
}

String pricingMethodExplodedListToJson(
  List<enums.PricingMethod>? pricingMethod,
) {
  return pricingMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> pricingMethodListToJson(List<enums.PricingMethod>? pricingMethod) {
  if (pricingMethod == null) {
    return [];
  }

  return pricingMethod.map((e) => e.value!).toList();
}

List<enums.PricingMethod> pricingMethodListFromJson(
  List? pricingMethod, [
  List<enums.PricingMethod>? defaultValue,
]) {
  if (pricingMethod == null) {
    return defaultValue ?? [];
  }

  return pricingMethod.map((e) => pricingMethodFromJson(e.toString())).toList();
}

List<enums.PricingMethod>? pricingMethodNullableListFromJson(
  List? pricingMethod, [
  List<enums.PricingMethod>? defaultValue,
]) {
  if (pricingMethod == null) {
    return defaultValue;
  }

  return pricingMethod.map((e) => pricingMethodFromJson(e.toString())).toList();
}

String? oracleTypeNullableToJson(enums.OracleType? oracleType) {
  return oracleType?.value;
}

String? oracleTypeToJson(enums.OracleType oracleType) {
  return oracleType.value;
}

enums.OracleType oracleTypeFromJson(
  Object? oracleType, [
  enums.OracleType? defaultValue,
]) {
  return enums.OracleType.values.firstWhereOrNull(
        (e) => e.value == oracleType,
      ) ??
      defaultValue ??
      enums.OracleType.swaggerGeneratedUnknown;
}

enums.OracleType? oracleTypeNullableFromJson(
  Object? oracleType, [
  enums.OracleType? defaultValue,
]) {
  if (oracleType == null) {
    return null;
  }
  return enums.OracleType.values.firstWhereOrNull(
        (e) => e.value == oracleType,
      ) ??
      defaultValue;
}

String oracleTypeExplodedListToJson(List<enums.OracleType>? oracleType) {
  return oracleType?.map((e) => e.value!).join(',') ?? '';
}

List<String> oracleTypeListToJson(List<enums.OracleType>? oracleType) {
  if (oracleType == null) {
    return [];
  }

  return oracleType.map((e) => e.value!).toList();
}

List<enums.OracleType> oracleTypeListFromJson(
  List? oracleType, [
  List<enums.OracleType>? defaultValue,
]) {
  if (oracleType == null) {
    return defaultValue ?? [];
  }

  return oracleType.map((e) => oracleTypeFromJson(e.toString())).toList();
}

List<enums.OracleType>? oracleTypeNullableListFromJson(
  List? oracleType, [
  List<enums.OracleType>? defaultValue,
]) {
  if (oracleType == null) {
    return defaultValue;
  }

  return oracleType.map((e) => oracleTypeFromJson(e.toString())).toList();
}

String? exchangeSourceNullableToJson(enums.ExchangeSource? exchangeSource) {
  return exchangeSource?.value;
}

String? exchangeSourceToJson(enums.ExchangeSource exchangeSource) {
  return exchangeSource.value;
}

enums.ExchangeSource exchangeSourceFromJson(
  Object? exchangeSource, [
  enums.ExchangeSource? defaultValue,
]) {
  return enums.ExchangeSource.values.firstWhereOrNull(
        (e) => e.value == exchangeSource,
      ) ??
      defaultValue ??
      enums.ExchangeSource.swaggerGeneratedUnknown;
}

enums.ExchangeSource? exchangeSourceNullableFromJson(
  Object? exchangeSource, [
  enums.ExchangeSource? defaultValue,
]) {
  if (exchangeSource == null) {
    return null;
  }
  return enums.ExchangeSource.values.firstWhereOrNull(
        (e) => e.value == exchangeSource,
      ) ??
      defaultValue;
}

String exchangeSourceExplodedListToJson(
  List<enums.ExchangeSource>? exchangeSource,
) {
  return exchangeSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> exchangeSourceListToJson(
  List<enums.ExchangeSource>? exchangeSource,
) {
  if (exchangeSource == null) {
    return [];
  }

  return exchangeSource.map((e) => e.value!).toList();
}

List<enums.ExchangeSource> exchangeSourceListFromJson(
  List? exchangeSource, [
  List<enums.ExchangeSource>? defaultValue,
]) {
  if (exchangeSource == null) {
    return defaultValue ?? [];
  }

  return exchangeSource
      .map((e) => exchangeSourceFromJson(e.toString()))
      .toList();
}

List<enums.ExchangeSource>? exchangeSourceNullableListFromJson(
  List? exchangeSource, [
  List<enums.ExchangeSource>? defaultValue,
]) {
  if (exchangeSource == null) {
    return defaultValue;
  }

  return exchangeSource
      .map((e) => exchangeSourceFromJson(e.toString()))
      .toList();
}

String? positionModeNullableToJson(enums.PositionMode? positionMode) {
  return positionMode?.value;
}

String? positionModeToJson(enums.PositionMode positionMode) {
  return positionMode.value;
}

enums.PositionMode positionModeFromJson(
  Object? positionMode, [
  enums.PositionMode? defaultValue,
]) {
  return enums.PositionMode.values.firstWhereOrNull(
        (e) => e.value == positionMode,
      ) ??
      defaultValue ??
      enums.PositionMode.swaggerGeneratedUnknown;
}

enums.PositionMode? positionModeNullableFromJson(
  Object? positionMode, [
  enums.PositionMode? defaultValue,
]) {
  if (positionMode == null) {
    return null;
  }
  return enums.PositionMode.values.firstWhereOrNull(
        (e) => e.value == positionMode,
      ) ??
      defaultValue;
}

String positionModeExplodedListToJson(List<enums.PositionMode>? positionMode) {
  return positionMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> positionModeListToJson(List<enums.PositionMode>? positionMode) {
  if (positionMode == null) {
    return [];
  }

  return positionMode.map((e) => e.value!).toList();
}

List<enums.PositionMode> positionModeListFromJson(
  List? positionMode, [
  List<enums.PositionMode>? defaultValue,
]) {
  if (positionMode == null) {
    return defaultValue ?? [];
  }

  return positionMode.map((e) => positionModeFromJson(e.toString())).toList();
}

List<enums.PositionMode>? positionModeNullableListFromJson(
  List? positionMode, [
  List<enums.PositionMode>? defaultValue,
]) {
  if (positionMode == null) {
    return defaultValue;
  }

  return positionMode.map((e) => positionModeFromJson(e.toString())).toList();
}

String? lendingPositionOrderByColumnNullableToJson(
  enums.LendingPositionOrderByColumn? lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn?.value;
}

String? lendingPositionOrderByColumnToJson(
  enums.LendingPositionOrderByColumn lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn.value;
}

enums.LendingPositionOrderByColumn lendingPositionOrderByColumnFromJson(
  Object? lendingPositionOrderByColumn, [
  enums.LendingPositionOrderByColumn? defaultValue,
]) {
  return enums.LendingPositionOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == lendingPositionOrderByColumn,
      ) ??
      defaultValue ??
      enums.LendingPositionOrderByColumn.swaggerGeneratedUnknown;
}

enums.LendingPositionOrderByColumn?
lendingPositionOrderByColumnNullableFromJson(
  Object? lendingPositionOrderByColumn, [
  enums.LendingPositionOrderByColumn? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return null;
  }
  return enums.LendingPositionOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == lendingPositionOrderByColumn,
      ) ??
      defaultValue;
}

String lendingPositionOrderByColumnExplodedListToJson(
  List<enums.LendingPositionOrderByColumn>? lendingPositionOrderByColumn,
) {
  return lendingPositionOrderByColumn?.map((e) => e.value!).join(',') ?? '';
}

List<String> lendingPositionOrderByColumnListToJson(
  List<enums.LendingPositionOrderByColumn>? lendingPositionOrderByColumn,
) {
  if (lendingPositionOrderByColumn == null) {
    return [];
  }

  return lendingPositionOrderByColumn.map((e) => e.value!).toList();
}

List<enums.LendingPositionOrderByColumn>
lendingPositionOrderByColumnListFromJson(
  List? lendingPositionOrderByColumn, [
  List<enums.LendingPositionOrderByColumn>? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return defaultValue ?? [];
  }

  return lendingPositionOrderByColumn
      .map((e) => lendingPositionOrderByColumnFromJson(e.toString()))
      .toList();
}

List<enums.LendingPositionOrderByColumn>?
lendingPositionOrderByColumnNullableListFromJson(
  List? lendingPositionOrderByColumn, [
  List<enums.LendingPositionOrderByColumn>? defaultValue,
]) {
  if (lendingPositionOrderByColumn == null) {
    return defaultValue;
  }

  return lendingPositionOrderByColumn
      .map((e) => lendingPositionOrderByColumnFromJson(e.toString()))
      .toList();
}

String? kustoOrderDirectionNullableToJson(
  enums.KustoOrderDirection? kustoOrderDirection,
) {
  return kustoOrderDirection?.value;
}

String? kustoOrderDirectionToJson(
  enums.KustoOrderDirection kustoOrderDirection,
) {
  return kustoOrderDirection.value;
}

enums.KustoOrderDirection kustoOrderDirectionFromJson(
  Object? kustoOrderDirection, [
  enums.KustoOrderDirection? defaultValue,
]) {
  return enums.KustoOrderDirection.values.firstWhereOrNull(
        (e) => e.value == kustoOrderDirection,
      ) ??
      defaultValue ??
      enums.KustoOrderDirection.swaggerGeneratedUnknown;
}

enums.KustoOrderDirection? kustoOrderDirectionNullableFromJson(
  Object? kustoOrderDirection, [
  enums.KustoOrderDirection? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return null;
  }
  return enums.KustoOrderDirection.values.firstWhereOrNull(
        (e) => e.value == kustoOrderDirection,
      ) ??
      defaultValue;
}

String kustoOrderDirectionExplodedListToJson(
  List<enums.KustoOrderDirection>? kustoOrderDirection,
) {
  return kustoOrderDirection?.map((e) => e.value!).join(',') ?? '';
}

List<String> kustoOrderDirectionListToJson(
  List<enums.KustoOrderDirection>? kustoOrderDirection,
) {
  if (kustoOrderDirection == null) {
    return [];
  }

  return kustoOrderDirection.map((e) => e.value!).toList();
}

List<enums.KustoOrderDirection> kustoOrderDirectionListFromJson(
  List? kustoOrderDirection, [
  List<enums.KustoOrderDirection>? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return defaultValue ?? [];
  }

  return kustoOrderDirection
      .map((e) => kustoOrderDirectionFromJson(e.toString()))
      .toList();
}

List<enums.KustoOrderDirection>? kustoOrderDirectionNullableListFromJson(
  List? kustoOrderDirection, [
  List<enums.KustoOrderDirection>? defaultValue,
]) {
  if (kustoOrderDirection == null) {
    return defaultValue;
  }

  return kustoOrderDirection
      .map((e) => kustoOrderDirectionFromJson(e.toString()))
      .toList();
}

String? lendingPositionStatusPositionModeNullableToJson(
  enums.LendingPositionStatusPositionMode? lendingPositionStatusPositionMode,
) {
  return lendingPositionStatusPositionMode?.value;
}

String? lendingPositionStatusPositionModeToJson(
  enums.LendingPositionStatusPositionMode lendingPositionStatusPositionMode,
) {
  return lendingPositionStatusPositionMode.value;
}

enums.LendingPositionStatusPositionMode
lendingPositionStatusPositionModeFromJson(
  Object? lendingPositionStatusPositionMode, [
  enums.LendingPositionStatusPositionMode? defaultValue,
]) {
  return enums.LendingPositionStatusPositionMode.values.firstWhereOrNull(
        (e) => e.value == lendingPositionStatusPositionMode,
      ) ??
      defaultValue ??
      enums.LendingPositionStatusPositionMode.swaggerGeneratedUnknown;
}

enums.LendingPositionStatusPositionMode?
lendingPositionStatusPositionModeNullableFromJson(
  Object? lendingPositionStatusPositionMode, [
  enums.LendingPositionStatusPositionMode? defaultValue,
]) {
  if (lendingPositionStatusPositionMode == null) {
    return null;
  }
  return enums.LendingPositionStatusPositionMode.values.firstWhereOrNull(
        (e) => e.value == lendingPositionStatusPositionMode,
      ) ??
      defaultValue;
}

String lendingPositionStatusPositionModeExplodedListToJson(
  List<enums.LendingPositionStatusPositionMode>?
  lendingPositionStatusPositionMode,
) {
  return lendingPositionStatusPositionMode?.map((e) => e.value!).join(',') ??
      '';
}

List<String> lendingPositionStatusPositionModeListToJson(
  List<enums.LendingPositionStatusPositionMode>?
  lendingPositionStatusPositionMode,
) {
  if (lendingPositionStatusPositionMode == null) {
    return [];
  }

  return lendingPositionStatusPositionMode.map((e) => e.value!).toList();
}

List<enums.LendingPositionStatusPositionMode>
lendingPositionStatusPositionModeListFromJson(
  List? lendingPositionStatusPositionMode, [
  List<enums.LendingPositionStatusPositionMode>? defaultValue,
]) {
  if (lendingPositionStatusPositionMode == null) {
    return defaultValue ?? [];
  }

  return lendingPositionStatusPositionMode
      .map((e) => lendingPositionStatusPositionModeFromJson(e.toString()))
      .toList();
}

List<enums.LendingPositionStatusPositionMode>?
lendingPositionStatusPositionModeNullableListFromJson(
  List? lendingPositionStatusPositionMode, [
  List<enums.LendingPositionStatusPositionMode>? defaultValue,
]) {
  if (lendingPositionStatusPositionMode == null) {
    return defaultValue;
  }

  return lendingPositionStatusPositionMode
      .map((e) => lendingPositionStatusPositionModeFromJson(e.toString()))
      .toList();
}

String? esdtTokenTypeNullableToJson(enums.EsdtTokenType? esdtTokenType) {
  return esdtTokenType?.value;
}

String? esdtTokenTypeToJson(enums.EsdtTokenType esdtTokenType) {
  return esdtTokenType.value;
}

enums.EsdtTokenType esdtTokenTypeFromJson(
  Object? esdtTokenType, [
  enums.EsdtTokenType? defaultValue,
]) {
  return enums.EsdtTokenType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenType,
      ) ??
      defaultValue ??
      enums.EsdtTokenType.swaggerGeneratedUnknown;
}

enums.EsdtTokenType? esdtTokenTypeNullableFromJson(
  Object? esdtTokenType, [
  enums.EsdtTokenType? defaultValue,
]) {
  if (esdtTokenType == null) {
    return null;
  }
  return enums.EsdtTokenType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenType,
      ) ??
      defaultValue;
}

String esdtTokenTypeExplodedListToJson(
  List<enums.EsdtTokenType>? esdtTokenType,
) {
  return esdtTokenType?.map((e) => e.value!).join(',') ?? '';
}

List<String> esdtTokenTypeListToJson(List<enums.EsdtTokenType>? esdtTokenType) {
  if (esdtTokenType == null) {
    return [];
  }

  return esdtTokenType.map((e) => e.value!).toList();
}

List<enums.EsdtTokenType> esdtTokenTypeListFromJson(
  List? esdtTokenType, [
  List<enums.EsdtTokenType>? defaultValue,
]) {
  if (esdtTokenType == null) {
    return defaultValue ?? [];
  }

  return esdtTokenType.map((e) => esdtTokenTypeFromJson(e.toString())).toList();
}

List<enums.EsdtTokenType>? esdtTokenTypeNullableListFromJson(
  List? esdtTokenType, [
  List<enums.EsdtTokenType>? defaultValue,
]) {
  if (esdtTokenType == null) {
    return defaultValue;
  }

  return esdtTokenType.map((e) => esdtTokenTypeFromJson(e.toString())).toList();
}

String? esdtTokenSubTypeNullableToJson(
  enums.EsdtTokenSubType? esdtTokenSubType,
) {
  return esdtTokenSubType?.value;
}

String? esdtTokenSubTypeToJson(enums.EsdtTokenSubType esdtTokenSubType) {
  return esdtTokenSubType.value;
}

enums.EsdtTokenSubType esdtTokenSubTypeFromJson(
  Object? esdtTokenSubType, [
  enums.EsdtTokenSubType? defaultValue,
]) {
  return enums.EsdtTokenSubType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenSubType,
      ) ??
      defaultValue ??
      enums.EsdtTokenSubType.swaggerGeneratedUnknown;
}

enums.EsdtTokenSubType? esdtTokenSubTypeNullableFromJson(
  Object? esdtTokenSubType, [
  enums.EsdtTokenSubType? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return null;
  }
  return enums.EsdtTokenSubType.values.firstWhereOrNull(
        (e) => e.value == esdtTokenSubType,
      ) ??
      defaultValue;
}

String esdtTokenSubTypeExplodedListToJson(
  List<enums.EsdtTokenSubType>? esdtTokenSubType,
) {
  return esdtTokenSubType?.map((e) => e.value!).join(',') ?? '';
}

List<String> esdtTokenSubTypeListToJson(
  List<enums.EsdtTokenSubType>? esdtTokenSubType,
) {
  if (esdtTokenSubType == null) {
    return [];
  }

  return esdtTokenSubType.map((e) => e.value!).toList();
}

List<enums.EsdtTokenSubType> esdtTokenSubTypeListFromJson(
  List? esdtTokenSubType, [
  List<enums.EsdtTokenSubType>? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return defaultValue ?? [];
  }

  return esdtTokenSubType
      .map((e) => esdtTokenSubTypeFromJson(e.toString()))
      .toList();
}

List<enums.EsdtTokenSubType>? esdtTokenSubTypeNullableListFromJson(
  List? esdtTokenSubType, [
  List<enums.EsdtTokenSubType>? defaultValue,
]) {
  if (esdtTokenSubType == null) {
    return defaultValue;
  }

  return esdtTokenSubType
      .map((e) => esdtTokenSubTypeFromJson(e.toString()))
      .toList();
}

String? xoxnoAuctionTypeStringNullableToJson(
  enums.XoxnoAuctionTypeString? xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString?.value;
}

String? xoxnoAuctionTypeStringToJson(
  enums.XoxnoAuctionTypeString xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString.value;
}

enums.XoxnoAuctionTypeString xoxnoAuctionTypeStringFromJson(
  Object? xoxnoAuctionTypeString, [
  enums.XoxnoAuctionTypeString? defaultValue,
]) {
  return enums.XoxnoAuctionTypeString.values.firstWhereOrNull(
        (e) => e.value == xoxnoAuctionTypeString,
      ) ??
      defaultValue ??
      enums.XoxnoAuctionTypeString.swaggerGeneratedUnknown;
}

enums.XoxnoAuctionTypeString? xoxnoAuctionTypeStringNullableFromJson(
  Object? xoxnoAuctionTypeString, [
  enums.XoxnoAuctionTypeString? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return null;
  }
  return enums.XoxnoAuctionTypeString.values.firstWhereOrNull(
        (e) => e.value == xoxnoAuctionTypeString,
      ) ??
      defaultValue;
}

String xoxnoAuctionTypeStringExplodedListToJson(
  List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeString,
) {
  return xoxnoAuctionTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> xoxnoAuctionTypeStringListToJson(
  List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeString,
) {
  if (xoxnoAuctionTypeString == null) {
    return [];
  }

  return xoxnoAuctionTypeString.map((e) => e.value!).toList();
}

List<enums.XoxnoAuctionTypeString> xoxnoAuctionTypeStringListFromJson(
  List? xoxnoAuctionTypeString, [
  List<enums.XoxnoAuctionTypeString>? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return defaultValue ?? [];
  }

  return xoxnoAuctionTypeString
      .map((e) => xoxnoAuctionTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.XoxnoAuctionTypeString>? xoxnoAuctionTypeStringNullableListFromJson(
  List? xoxnoAuctionTypeString, [
  List<enums.XoxnoAuctionTypeString>? defaultValue,
]) {
  if (xoxnoAuctionTypeString == null) {
    return defaultValue;
  }

  return xoxnoAuctionTypeString
      .map((e) => xoxnoAuctionTypeStringFromJson(e.toString()))
      .toList();
}

String? marketplacesOnSaleNamesNullableToJson(
  enums.MarketplacesOnSaleNames? marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames?.value;
}

String? marketplacesOnSaleNamesToJson(
  enums.MarketplacesOnSaleNames marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames.value;
}

enums.MarketplacesOnSaleNames marketplacesOnSaleNamesFromJson(
  Object? marketplacesOnSaleNames, [
  enums.MarketplacesOnSaleNames? defaultValue,
]) {
  return enums.MarketplacesOnSaleNames.values.firstWhereOrNull(
        (e) => e.value == marketplacesOnSaleNames,
      ) ??
      defaultValue ??
      enums.MarketplacesOnSaleNames.swaggerGeneratedUnknown;
}

enums.MarketplacesOnSaleNames? marketplacesOnSaleNamesNullableFromJson(
  Object? marketplacesOnSaleNames, [
  enums.MarketplacesOnSaleNames? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return null;
  }
  return enums.MarketplacesOnSaleNames.values.firstWhereOrNull(
        (e) => e.value == marketplacesOnSaleNames,
      ) ??
      defaultValue;
}

String marketplacesOnSaleNamesExplodedListToJson(
  List<enums.MarketplacesOnSaleNames>? marketplacesOnSaleNames,
) {
  return marketplacesOnSaleNames?.map((e) => e.value!).join(',') ?? '';
}

List<String> marketplacesOnSaleNamesListToJson(
  List<enums.MarketplacesOnSaleNames>? marketplacesOnSaleNames,
) {
  if (marketplacesOnSaleNames == null) {
    return [];
  }

  return marketplacesOnSaleNames.map((e) => e.value!).toList();
}

List<enums.MarketplacesOnSaleNames> marketplacesOnSaleNamesListFromJson(
  List? marketplacesOnSaleNames, [
  List<enums.MarketplacesOnSaleNames>? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return defaultValue ?? [];
  }

  return marketplacesOnSaleNames
      .map((e) => marketplacesOnSaleNamesFromJson(e.toString()))
      .toList();
}

List<enums.MarketplacesOnSaleNames>?
marketplacesOnSaleNamesNullableListFromJson(
  List? marketplacesOnSaleNames, [
  List<enums.MarketplacesOnSaleNames>? defaultValue,
]) {
  if (marketplacesOnSaleNames == null) {
    return defaultValue;
  }

  return marketplacesOnSaleNames
      .map((e) => marketplacesOnSaleNamesFromJson(e.toString()))
      .toList();
}

String? shortNftCollectionInfoDocChainNullableToJson(
  enums.ShortNftCollectionInfoDocChain? shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain?.value;
}

String? shortNftCollectionInfoDocChainToJson(
  enums.ShortNftCollectionInfoDocChain shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain.value;
}

enums.ShortNftCollectionInfoDocChain shortNftCollectionInfoDocChainFromJson(
  Object? shortNftCollectionInfoDocChain, [
  enums.ShortNftCollectionInfoDocChain? defaultValue,
]) {
  return enums.ShortNftCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortNftCollectionInfoDocChain,
      ) ??
      defaultValue ??
      enums.ShortNftCollectionInfoDocChain.swaggerGeneratedUnknown;
}

enums.ShortNftCollectionInfoDocChain?
shortNftCollectionInfoDocChainNullableFromJson(
  Object? shortNftCollectionInfoDocChain, [
  enums.ShortNftCollectionInfoDocChain? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return null;
  }
  return enums.ShortNftCollectionInfoDocChain.values.firstWhereOrNull(
        (e) => e.value == shortNftCollectionInfoDocChain,
      ) ??
      defaultValue;
}

String shortNftCollectionInfoDocChainExplodedListToJson(
  List<enums.ShortNftCollectionInfoDocChain>? shortNftCollectionInfoDocChain,
) {
  return shortNftCollectionInfoDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortNftCollectionInfoDocChainListToJson(
  List<enums.ShortNftCollectionInfoDocChain>? shortNftCollectionInfoDocChain,
) {
  if (shortNftCollectionInfoDocChain == null) {
    return [];
  }

  return shortNftCollectionInfoDocChain.map((e) => e.value!).toList();
}

List<enums.ShortNftCollectionInfoDocChain>
shortNftCollectionInfoDocChainListFromJson(
  List? shortNftCollectionInfoDocChain, [
  List<enums.ShortNftCollectionInfoDocChain>? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return defaultValue ?? [];
  }

  return shortNftCollectionInfoDocChain
      .map((e) => shortNftCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortNftCollectionInfoDocChain>?
shortNftCollectionInfoDocChainNullableListFromJson(
  List? shortNftCollectionInfoDocChain, [
  List<enums.ShortNftCollectionInfoDocChain>? defaultValue,
]) {
  if (shortNftCollectionInfoDocChain == null) {
    return defaultValue;
  }

  return shortNftCollectionInfoDocChain
      .map((e) => shortNftCollectionInfoDocChainFromJson(e.toString()))
      .toList();
}

String? inventorySummaryDtoHydratedChainNullableToJson(
  enums.InventorySummaryDtoHydratedChain? inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain?.value;
}

String? inventorySummaryDtoHydratedChainToJson(
  enums.InventorySummaryDtoHydratedChain inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain.value;
}

enums.InventorySummaryDtoHydratedChain inventorySummaryDtoHydratedChainFromJson(
  Object? inventorySummaryDtoHydratedChain, [
  enums.InventorySummaryDtoHydratedChain? defaultValue,
]) {
  return enums.InventorySummaryDtoHydratedChain.values.firstWhereOrNull(
        (e) => e.value == inventorySummaryDtoHydratedChain,
      ) ??
      defaultValue ??
      enums.InventorySummaryDtoHydratedChain.swaggerGeneratedUnknown;
}

enums.InventorySummaryDtoHydratedChain?
inventorySummaryDtoHydratedChainNullableFromJson(
  Object? inventorySummaryDtoHydratedChain, [
  enums.InventorySummaryDtoHydratedChain? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return null;
  }
  return enums.InventorySummaryDtoHydratedChain.values.firstWhereOrNull(
        (e) => e.value == inventorySummaryDtoHydratedChain,
      ) ??
      defaultValue;
}

String inventorySummaryDtoHydratedChainExplodedListToJson(
  List<enums.InventorySummaryDtoHydratedChain>?
  inventorySummaryDtoHydratedChain,
) {
  return inventorySummaryDtoHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> inventorySummaryDtoHydratedChainListToJson(
  List<enums.InventorySummaryDtoHydratedChain>?
  inventorySummaryDtoHydratedChain,
) {
  if (inventorySummaryDtoHydratedChain == null) {
    return [];
  }

  return inventorySummaryDtoHydratedChain.map((e) => e.value!).toList();
}

List<enums.InventorySummaryDtoHydratedChain>
inventorySummaryDtoHydratedChainListFromJson(
  List? inventorySummaryDtoHydratedChain, [
  List<enums.InventorySummaryDtoHydratedChain>? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return defaultValue ?? [];
  }

  return inventorySummaryDtoHydratedChain
      .map((e) => inventorySummaryDtoHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.InventorySummaryDtoHydratedChain>?
inventorySummaryDtoHydratedChainNullableListFromJson(
  List? inventorySummaryDtoHydratedChain, [
  List<enums.InventorySummaryDtoHydratedChain>? defaultValue,
]) {
  if (inventorySummaryDtoHydratedChain == null) {
    return defaultValue;
  }

  return inventorySummaryDtoHydratedChain
      .map((e) => inventorySummaryDtoHydratedChainFromJson(e.toString()))
      .toList();
}

String? offerTypeNullableToJson(enums.OfferType? offerType) {
  return offerType?.value;
}

String? offerTypeToJson(enums.OfferType offerType) {
  return offerType.value;
}

enums.OfferType offerTypeFromJson(
  Object? offerType, [
  enums.OfferType? defaultValue,
]) {
  return enums.OfferType.values.firstWhereOrNull((e) => e.value == offerType) ??
      defaultValue ??
      enums.OfferType.swaggerGeneratedUnknown;
}

enums.OfferType? offerTypeNullableFromJson(
  Object? offerType, [
  enums.OfferType? defaultValue,
]) {
  if (offerType == null) {
    return null;
  }
  return enums.OfferType.values.firstWhereOrNull((e) => e.value == offerType) ??
      defaultValue;
}

String offerTypeExplodedListToJson(List<enums.OfferType>? offerType) {
  return offerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> offerTypeListToJson(List<enums.OfferType>? offerType) {
  if (offerType == null) {
    return [];
  }

  return offerType.map((e) => e.value!).toList();
}

List<enums.OfferType> offerTypeListFromJson(
  List? offerType, [
  List<enums.OfferType>? defaultValue,
]) {
  if (offerType == null) {
    return defaultValue ?? [];
  }

  return offerType.map((e) => offerTypeFromJson(e.toString())).toList();
}

List<enums.OfferType>? offerTypeNullableListFromJson(
  List? offerType, [
  List<enums.OfferType>? defaultValue,
]) {
  if (offerType == null) {
    return defaultValue;
  }

  return offerType.map((e) => offerTypeFromJson(e.toString())).toList();
}

String? nftOfferDocHydratedDataTypeNullableToJson(
  enums.NftOfferDocHydratedDataType? nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType?.value;
}

String? nftOfferDocHydratedDataTypeToJson(
  enums.NftOfferDocHydratedDataType nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType.value;
}

enums.NftOfferDocHydratedDataType nftOfferDocHydratedDataTypeFromJson(
  Object? nftOfferDocHydratedDataType, [
  enums.NftOfferDocHydratedDataType? defaultValue,
]) {
  return enums.NftOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.NftOfferDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.NftOfferDocHydratedDataType? nftOfferDocHydratedDataTypeNullableFromJson(
  Object? nftOfferDocHydratedDataType, [
  enums.NftOfferDocHydratedDataType? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return null;
  }
  return enums.NftOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedDataType,
      ) ??
      defaultValue;
}

String nftOfferDocHydratedDataTypeExplodedListToJson(
  List<enums.NftOfferDocHydratedDataType>? nftOfferDocHydratedDataType,
) {
  return nftOfferDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftOfferDocHydratedDataTypeListToJson(
  List<enums.NftOfferDocHydratedDataType>? nftOfferDocHydratedDataType,
) {
  if (nftOfferDocHydratedDataType == null) {
    return [];
  }

  return nftOfferDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.NftOfferDocHydratedDataType> nftOfferDocHydratedDataTypeListFromJson(
  List? nftOfferDocHydratedDataType, [
  List<enums.NftOfferDocHydratedDataType>? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return nftOfferDocHydratedDataType
      .map((e) => nftOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftOfferDocHydratedDataType>?
nftOfferDocHydratedDataTypeNullableListFromJson(
  List? nftOfferDocHydratedDataType, [
  List<enums.NftOfferDocHydratedDataType>? defaultValue,
]) {
  if (nftOfferDocHydratedDataType == null) {
    return defaultValue;
  }

  return nftOfferDocHydratedDataType
      .map((e) => nftOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? nftOfferDocHydratedChainNullableToJson(
  enums.NftOfferDocHydratedChain? nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain?.value;
}

String? nftOfferDocHydratedChainToJson(
  enums.NftOfferDocHydratedChain nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain.value;
}

enums.NftOfferDocHydratedChain nftOfferDocHydratedChainFromJson(
  Object? nftOfferDocHydratedChain, [
  enums.NftOfferDocHydratedChain? defaultValue,
]) {
  return enums.NftOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedChain,
      ) ??
      defaultValue ??
      enums.NftOfferDocHydratedChain.swaggerGeneratedUnknown;
}

enums.NftOfferDocHydratedChain? nftOfferDocHydratedChainNullableFromJson(
  Object? nftOfferDocHydratedChain, [
  enums.NftOfferDocHydratedChain? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return null;
  }
  return enums.NftOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftOfferDocHydratedChain,
      ) ??
      defaultValue;
}

String nftOfferDocHydratedChainExplodedListToJson(
  List<enums.NftOfferDocHydratedChain>? nftOfferDocHydratedChain,
) {
  return nftOfferDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftOfferDocHydratedChainListToJson(
  List<enums.NftOfferDocHydratedChain>? nftOfferDocHydratedChain,
) {
  if (nftOfferDocHydratedChain == null) {
    return [];
  }

  return nftOfferDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.NftOfferDocHydratedChain> nftOfferDocHydratedChainListFromJson(
  List? nftOfferDocHydratedChain, [
  List<enums.NftOfferDocHydratedChain>? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return nftOfferDocHydratedChain
      .map((e) => nftOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.NftOfferDocHydratedChain>?
nftOfferDocHydratedChainNullableListFromJson(
  List? nftOfferDocHydratedChain, [
  List<enums.NftOfferDocHydratedChain>? defaultValue,
]) {
  if (nftOfferDocHydratedChain == null) {
    return defaultValue;
  }

  return nftOfferDocHydratedChain
      .map((e) => nftOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? shortCollectionDocChainNullableToJson(
  enums.ShortCollectionDocChain? shortCollectionDocChain,
) {
  return shortCollectionDocChain?.value;
}

String? shortCollectionDocChainToJson(
  enums.ShortCollectionDocChain shortCollectionDocChain,
) {
  return shortCollectionDocChain.value;
}

enums.ShortCollectionDocChain shortCollectionDocChainFromJson(
  Object? shortCollectionDocChain, [
  enums.ShortCollectionDocChain? defaultValue,
]) {
  return enums.ShortCollectionDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionDocChain,
      ) ??
      defaultValue ??
      enums.ShortCollectionDocChain.swaggerGeneratedUnknown;
}

enums.ShortCollectionDocChain? shortCollectionDocChainNullableFromJson(
  Object? shortCollectionDocChain, [
  enums.ShortCollectionDocChain? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return null;
  }
  return enums.ShortCollectionDocChain.values.firstWhereOrNull(
        (e) => e.value == shortCollectionDocChain,
      ) ??
      defaultValue;
}

String shortCollectionDocChainExplodedListToJson(
  List<enums.ShortCollectionDocChain>? shortCollectionDocChain,
) {
  return shortCollectionDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> shortCollectionDocChainListToJson(
  List<enums.ShortCollectionDocChain>? shortCollectionDocChain,
) {
  if (shortCollectionDocChain == null) {
    return [];
  }

  return shortCollectionDocChain.map((e) => e.value!).toList();
}

List<enums.ShortCollectionDocChain> shortCollectionDocChainListFromJson(
  List? shortCollectionDocChain, [
  List<enums.ShortCollectionDocChain>? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return defaultValue ?? [];
  }

  return shortCollectionDocChain
      .map((e) => shortCollectionDocChainFromJson(e.toString()))
      .toList();
}

List<enums.ShortCollectionDocChain>?
shortCollectionDocChainNullableListFromJson(
  List? shortCollectionDocChain, [
  List<enums.ShortCollectionDocChain>? defaultValue,
]) {
  if (shortCollectionDocChain == null) {
    return defaultValue;
  }

  return shortCollectionDocChain
      .map((e) => shortCollectionDocChainFromJson(e.toString()))
      .toList();
}

String? globalOfferDocHydratedDataTypeNullableToJson(
  enums.GlobalOfferDocHydratedDataType? globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType?.value;
}

String? globalOfferDocHydratedDataTypeToJson(
  enums.GlobalOfferDocHydratedDataType globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType.value;
}

enums.GlobalOfferDocHydratedDataType globalOfferDocHydratedDataTypeFromJson(
  Object? globalOfferDocHydratedDataType, [
  enums.GlobalOfferDocHydratedDataType? defaultValue,
]) {
  return enums.GlobalOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.GlobalOfferDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.GlobalOfferDocHydratedDataType?
globalOfferDocHydratedDataTypeNullableFromJson(
  Object? globalOfferDocHydratedDataType, [
  enums.GlobalOfferDocHydratedDataType? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return null;
  }
  return enums.GlobalOfferDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedDataType,
      ) ??
      defaultValue;
}

String globalOfferDocHydratedDataTypeExplodedListToJson(
  List<enums.GlobalOfferDocHydratedDataType>? globalOfferDocHydratedDataType,
) {
  return globalOfferDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> globalOfferDocHydratedDataTypeListToJson(
  List<enums.GlobalOfferDocHydratedDataType>? globalOfferDocHydratedDataType,
) {
  if (globalOfferDocHydratedDataType == null) {
    return [];
  }

  return globalOfferDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.GlobalOfferDocHydratedDataType>
globalOfferDocHydratedDataTypeListFromJson(
  List? globalOfferDocHydratedDataType, [
  List<enums.GlobalOfferDocHydratedDataType>? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return globalOfferDocHydratedDataType
      .map((e) => globalOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.GlobalOfferDocHydratedDataType>?
globalOfferDocHydratedDataTypeNullableListFromJson(
  List? globalOfferDocHydratedDataType, [
  List<enums.GlobalOfferDocHydratedDataType>? defaultValue,
]) {
  if (globalOfferDocHydratedDataType == null) {
    return defaultValue;
  }

  return globalOfferDocHydratedDataType
      .map((e) => globalOfferDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? globalOfferDocHydratedChainNullableToJson(
  enums.GlobalOfferDocHydratedChain? globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain?.value;
}

String? globalOfferDocHydratedChainToJson(
  enums.GlobalOfferDocHydratedChain globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain.value;
}

enums.GlobalOfferDocHydratedChain globalOfferDocHydratedChainFromJson(
  Object? globalOfferDocHydratedChain, [
  enums.GlobalOfferDocHydratedChain? defaultValue,
]) {
  return enums.GlobalOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedChain,
      ) ??
      defaultValue ??
      enums.GlobalOfferDocHydratedChain.swaggerGeneratedUnknown;
}

enums.GlobalOfferDocHydratedChain? globalOfferDocHydratedChainNullableFromJson(
  Object? globalOfferDocHydratedChain, [
  enums.GlobalOfferDocHydratedChain? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return null;
  }
  return enums.GlobalOfferDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == globalOfferDocHydratedChain,
      ) ??
      defaultValue;
}

String globalOfferDocHydratedChainExplodedListToJson(
  List<enums.GlobalOfferDocHydratedChain>? globalOfferDocHydratedChain,
) {
  return globalOfferDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> globalOfferDocHydratedChainListToJson(
  List<enums.GlobalOfferDocHydratedChain>? globalOfferDocHydratedChain,
) {
  if (globalOfferDocHydratedChain == null) {
    return [];
  }

  return globalOfferDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.GlobalOfferDocHydratedChain> globalOfferDocHydratedChainListFromJson(
  List? globalOfferDocHydratedChain, [
  List<enums.GlobalOfferDocHydratedChain>? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return globalOfferDocHydratedChain
      .map((e) => globalOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.GlobalOfferDocHydratedChain>?
globalOfferDocHydratedChainNullableListFromJson(
  List? globalOfferDocHydratedChain, [
  List<enums.GlobalOfferDocHydratedChain>? defaultValue,
]) {
  if (globalOfferDocHydratedChain == null) {
    return defaultValue;
  }

  return globalOfferDocHydratedChain
      .map((e) => globalOfferDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocDataTypeNullableToJson(
  enums.CollectionProfileDocDataType? collectionProfileDocDataType,
) {
  return collectionProfileDocDataType?.value;
}

String? collectionProfileDocDataTypeToJson(
  enums.CollectionProfileDocDataType collectionProfileDocDataType,
) {
  return collectionProfileDocDataType.value;
}

enums.CollectionProfileDocDataType collectionProfileDocDataTypeFromJson(
  Object? collectionProfileDocDataType, [
  enums.CollectionProfileDocDataType? defaultValue,
]) {
  return enums.CollectionProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocDataType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocDataType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocDataType?
collectionProfileDocDataTypeNullableFromJson(
  Object? collectionProfileDocDataType, [
  enums.CollectionProfileDocDataType? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return null;
  }
  return enums.CollectionProfileDocDataType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocDataType,
      ) ??
      defaultValue;
}

String collectionProfileDocDataTypeExplodedListToJson(
  List<enums.CollectionProfileDocDataType>? collectionProfileDocDataType,
) {
  return collectionProfileDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocDataTypeListToJson(
  List<enums.CollectionProfileDocDataType>? collectionProfileDocDataType,
) {
  if (collectionProfileDocDataType == null) {
    return [];
  }

  return collectionProfileDocDataType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocDataType>
collectionProfileDocDataTypeListFromJson(
  List? collectionProfileDocDataType, [
  List<enums.CollectionProfileDocDataType>? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocDataType
      .map((e) => collectionProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocDataType>?
collectionProfileDocDataTypeNullableListFromJson(
  List? collectionProfileDocDataType, [
  List<enums.CollectionProfileDocDataType>? defaultValue,
]) {
  if (collectionProfileDocDataType == null) {
    return defaultValue;
  }

  return collectionProfileDocDataType
      .map((e) => collectionProfileDocDataTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocTypeNullableToJson(
  enums.CollectionProfileDocType? collectionProfileDocType,
) {
  return collectionProfileDocType?.value;
}

String? collectionProfileDocTypeToJson(
  enums.CollectionProfileDocType collectionProfileDocType,
) {
  return collectionProfileDocType.value;
}

enums.CollectionProfileDocType collectionProfileDocTypeFromJson(
  Object? collectionProfileDocType, [
  enums.CollectionProfileDocType? defaultValue,
]) {
  return enums.CollectionProfileDocType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocType? collectionProfileDocTypeNullableFromJson(
  Object? collectionProfileDocType, [
  enums.CollectionProfileDocType? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return null;
  }
  return enums.CollectionProfileDocType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocType,
      ) ??
      defaultValue;
}

String collectionProfileDocTypeExplodedListToJson(
  List<enums.CollectionProfileDocType>? collectionProfileDocType,
) {
  return collectionProfileDocType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocTypeListToJson(
  List<enums.CollectionProfileDocType>? collectionProfileDocType,
) {
  if (collectionProfileDocType == null) {
    return [];
  }

  return collectionProfileDocType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocType> collectionProfileDocTypeListFromJson(
  List? collectionProfileDocType, [
  List<enums.CollectionProfileDocType>? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocType
      .map((e) => collectionProfileDocTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocType>?
collectionProfileDocTypeNullableListFromJson(
  List? collectionProfileDocType, [
  List<enums.CollectionProfileDocType>? defaultValue,
]) {
  if (collectionProfileDocType == null) {
    return defaultValue;
  }

  return collectionProfileDocType
      .map((e) => collectionProfileDocTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocSubTypeNullableToJson(
  enums.CollectionProfileDocSubType? collectionProfileDocSubType,
) {
  return collectionProfileDocSubType?.value;
}

String? collectionProfileDocSubTypeToJson(
  enums.CollectionProfileDocSubType collectionProfileDocSubType,
) {
  return collectionProfileDocSubType.value;
}

enums.CollectionProfileDocSubType collectionProfileDocSubTypeFromJson(
  Object? collectionProfileDocSubType, [
  enums.CollectionProfileDocSubType? defaultValue,
]) {
  return enums.CollectionProfileDocSubType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocSubType,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocSubType.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocSubType? collectionProfileDocSubTypeNullableFromJson(
  Object? collectionProfileDocSubType, [
  enums.CollectionProfileDocSubType? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return null;
  }
  return enums.CollectionProfileDocSubType.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocSubType,
      ) ??
      defaultValue;
}

String collectionProfileDocSubTypeExplodedListToJson(
  List<enums.CollectionProfileDocSubType>? collectionProfileDocSubType,
) {
  return collectionProfileDocSubType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocSubTypeListToJson(
  List<enums.CollectionProfileDocSubType>? collectionProfileDocSubType,
) {
  if (collectionProfileDocSubType == null) {
    return [];
  }

  return collectionProfileDocSubType.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocSubType> collectionProfileDocSubTypeListFromJson(
  List? collectionProfileDocSubType, [
  List<enums.CollectionProfileDocSubType>? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocSubType
      .map((e) => collectionProfileDocSubTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocSubType>?
collectionProfileDocSubTypeNullableListFromJson(
  List? collectionProfileDocSubType, [
  List<enums.CollectionProfileDocSubType>? defaultValue,
]) {
  if (collectionProfileDocSubType == null) {
    return defaultValue;
  }

  return collectionProfileDocSubType
      .map((e) => collectionProfileDocSubTypeFromJson(e.toString()))
      .toList();
}

String? collectionProfileDocChainNullableToJson(
  enums.CollectionProfileDocChain? collectionProfileDocChain,
) {
  return collectionProfileDocChain?.value;
}

String? collectionProfileDocChainToJson(
  enums.CollectionProfileDocChain collectionProfileDocChain,
) {
  return collectionProfileDocChain.value;
}

enums.CollectionProfileDocChain collectionProfileDocChainFromJson(
  Object? collectionProfileDocChain, [
  enums.CollectionProfileDocChain? defaultValue,
]) {
  return enums.CollectionProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocChain,
      ) ??
      defaultValue ??
      enums.CollectionProfileDocChain.swaggerGeneratedUnknown;
}

enums.CollectionProfileDocChain? collectionProfileDocChainNullableFromJson(
  Object? collectionProfileDocChain, [
  enums.CollectionProfileDocChain? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return null;
  }
  return enums.CollectionProfileDocChain.values.firstWhereOrNull(
        (e) => e.value == collectionProfileDocChain,
      ) ??
      defaultValue;
}

String collectionProfileDocChainExplodedListToJson(
  List<enums.CollectionProfileDocChain>? collectionProfileDocChain,
) {
  return collectionProfileDocChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionProfileDocChainListToJson(
  List<enums.CollectionProfileDocChain>? collectionProfileDocChain,
) {
  if (collectionProfileDocChain == null) {
    return [];
  }

  return collectionProfileDocChain.map((e) => e.value!).toList();
}

List<enums.CollectionProfileDocChain> collectionProfileDocChainListFromJson(
  List? collectionProfileDocChain, [
  List<enums.CollectionProfileDocChain>? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return defaultValue ?? [];
  }

  return collectionProfileDocChain
      .map((e) => collectionProfileDocChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionProfileDocChain>?
collectionProfileDocChainNullableListFromJson(
  List? collectionProfileDocChain, [
  List<enums.CollectionProfileDocChain>? defaultValue,
]) {
  if (collectionProfileDocChain == null) {
    return defaultValue;
  }

  return collectionProfileDocChain
      .map((e) => collectionProfileDocChainFromJson(e.toString()))
      .toList();
}

String? pinnedCollectionDtoChainNullableToJson(
  enums.PinnedCollectionDtoChain? pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain?.value;
}

String? pinnedCollectionDtoChainToJson(
  enums.PinnedCollectionDtoChain pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain.value;
}

enums.PinnedCollectionDtoChain pinnedCollectionDtoChainFromJson(
  Object? pinnedCollectionDtoChain, [
  enums.PinnedCollectionDtoChain? defaultValue,
]) {
  return enums.PinnedCollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == pinnedCollectionDtoChain,
      ) ??
      defaultValue ??
      enums.PinnedCollectionDtoChain.swaggerGeneratedUnknown;
}

enums.PinnedCollectionDtoChain? pinnedCollectionDtoChainNullableFromJson(
  Object? pinnedCollectionDtoChain, [
  enums.PinnedCollectionDtoChain? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return null;
  }
  return enums.PinnedCollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == pinnedCollectionDtoChain,
      ) ??
      defaultValue;
}

String pinnedCollectionDtoChainExplodedListToJson(
  List<enums.PinnedCollectionDtoChain>? pinnedCollectionDtoChain,
) {
  return pinnedCollectionDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> pinnedCollectionDtoChainListToJson(
  List<enums.PinnedCollectionDtoChain>? pinnedCollectionDtoChain,
) {
  if (pinnedCollectionDtoChain == null) {
    return [];
  }

  return pinnedCollectionDtoChain.map((e) => e.value!).toList();
}

List<enums.PinnedCollectionDtoChain> pinnedCollectionDtoChainListFromJson(
  List? pinnedCollectionDtoChain, [
  List<enums.PinnedCollectionDtoChain>? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return defaultValue ?? [];
  }

  return pinnedCollectionDtoChain
      .map((e) => pinnedCollectionDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.PinnedCollectionDtoChain>?
pinnedCollectionDtoChainNullableListFromJson(
  List? pinnedCollectionDtoChain, [
  List<enums.PinnedCollectionDtoChain>? defaultValue,
]) {
  if (pinnedCollectionDtoChain == null) {
    return defaultValue;
  }

  return pinnedCollectionDtoChain
      .map((e) => pinnedCollectionDtoChainFromJson(e.toString()))
      .toList();
}

String? collectionMintProfileDocHydratedDataTypeNullableToJson(
  enums.CollectionMintProfileDocHydratedDataType?
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType?.value;
}

String? collectionMintProfileDocHydratedDataTypeToJson(
  enums.CollectionMintProfileDocHydratedDataType
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType.value;
}

enums.CollectionMintProfileDocHydratedDataType
collectionMintProfileDocHydratedDataTypeFromJson(
  Object? collectionMintProfileDocHydratedDataType, [
  enums.CollectionMintProfileDocHydratedDataType? defaultValue,
]) {
  return enums.CollectionMintProfileDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == collectionMintProfileDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.CollectionMintProfileDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.CollectionMintProfileDocHydratedDataType?
collectionMintProfileDocHydratedDataTypeNullableFromJson(
  Object? collectionMintProfileDocHydratedDataType, [
  enums.CollectionMintProfileDocHydratedDataType? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return null;
  }
  return enums.CollectionMintProfileDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == collectionMintProfileDocHydratedDataType,
      ) ??
      defaultValue;
}

String collectionMintProfileDocHydratedDataTypeExplodedListToJson(
  List<enums.CollectionMintProfileDocHydratedDataType>?
  collectionMintProfileDocHydratedDataType,
) {
  return collectionMintProfileDocHydratedDataType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> collectionMintProfileDocHydratedDataTypeListToJson(
  List<enums.CollectionMintProfileDocHydratedDataType>?
  collectionMintProfileDocHydratedDataType,
) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return [];
  }

  return collectionMintProfileDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.CollectionMintProfileDocHydratedDataType>
collectionMintProfileDocHydratedDataTypeListFromJson(
  List? collectionMintProfileDocHydratedDataType, [
  List<enums.CollectionMintProfileDocHydratedDataType>? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return collectionMintProfileDocHydratedDataType
      .map(
        (e) => collectionMintProfileDocHydratedDataTypeFromJson(e.toString()),
      )
      .toList();
}

List<enums.CollectionMintProfileDocHydratedDataType>?
collectionMintProfileDocHydratedDataTypeNullableListFromJson(
  List? collectionMintProfileDocHydratedDataType, [
  List<enums.CollectionMintProfileDocHydratedDataType>? defaultValue,
]) {
  if (collectionMintProfileDocHydratedDataType == null) {
    return defaultValue;
  }

  return collectionMintProfileDocHydratedDataType
      .map(
        (e) => collectionMintProfileDocHydratedDataTypeFromJson(e.toString()),
      )
      .toList();
}

String? mintingListingDtoDataTypeNullableToJson(
  enums.MintingListingDtoDataType? mintingListingDtoDataType,
) {
  return mintingListingDtoDataType?.value;
}

String? mintingListingDtoDataTypeToJson(
  enums.MintingListingDtoDataType mintingListingDtoDataType,
) {
  return mintingListingDtoDataType.value;
}

enums.MintingListingDtoDataType mintingListingDtoDataTypeFromJson(
  Object? mintingListingDtoDataType, [
  enums.MintingListingDtoDataType? defaultValue,
]) {
  return enums.MintingListingDtoDataType.values.firstWhereOrNull(
        (e) => e.value == mintingListingDtoDataType,
      ) ??
      defaultValue ??
      enums.MintingListingDtoDataType.swaggerGeneratedUnknown;
}

enums.MintingListingDtoDataType? mintingListingDtoDataTypeNullableFromJson(
  Object? mintingListingDtoDataType, [
  enums.MintingListingDtoDataType? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return null;
  }
  return enums.MintingListingDtoDataType.values.firstWhereOrNull(
        (e) => e.value == mintingListingDtoDataType,
      ) ??
      defaultValue;
}

String mintingListingDtoDataTypeExplodedListToJson(
  List<enums.MintingListingDtoDataType>? mintingListingDtoDataType,
) {
  return mintingListingDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mintingListingDtoDataTypeListToJson(
  List<enums.MintingListingDtoDataType>? mintingListingDtoDataType,
) {
  if (mintingListingDtoDataType == null) {
    return [];
  }

  return mintingListingDtoDataType.map((e) => e.value!).toList();
}

List<enums.MintingListingDtoDataType> mintingListingDtoDataTypeListFromJson(
  List? mintingListingDtoDataType, [
  List<enums.MintingListingDtoDataType>? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return defaultValue ?? [];
  }

  return mintingListingDtoDataType
      .map((e) => mintingListingDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.MintingListingDtoDataType>?
mintingListingDtoDataTypeNullableListFromJson(
  List? mintingListingDtoDataType, [
  List<enums.MintingListingDtoDataType>? defaultValue,
]) {
  if (mintingListingDtoDataType == null) {
    return defaultValue;
  }

  return mintingListingDtoDataType
      .map((e) => mintingListingDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? ticketingDataTypeNullableToJson(
  enums.TicketingDataType? ticketingDataType,
) {
  return ticketingDataType?.value;
}

String? ticketingDataTypeToJson(enums.TicketingDataType ticketingDataType) {
  return ticketingDataType.value;
}

enums.TicketingDataType ticketingDataTypeFromJson(
  Object? ticketingDataType, [
  enums.TicketingDataType? defaultValue,
]) {
  return enums.TicketingDataType.values.firstWhereOrNull(
        (e) => e.value == ticketingDataType,
      ) ??
      defaultValue ??
      enums.TicketingDataType.swaggerGeneratedUnknown;
}

enums.TicketingDataType? ticketingDataTypeNullableFromJson(
  Object? ticketingDataType, [
  enums.TicketingDataType? defaultValue,
]) {
  if (ticketingDataType == null) {
    return null;
  }
  return enums.TicketingDataType.values.firstWhereOrNull(
        (e) => e.value == ticketingDataType,
      ) ??
      defaultValue;
}

String ticketingDataTypeExplodedListToJson(
  List<enums.TicketingDataType>? ticketingDataType,
) {
  return ticketingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> ticketingDataTypeListToJson(
  List<enums.TicketingDataType>? ticketingDataType,
) {
  if (ticketingDataType == null) {
    return [];
  }

  return ticketingDataType.map((e) => e.value!).toList();
}

List<enums.TicketingDataType> ticketingDataTypeListFromJson(
  List? ticketingDataType, [
  List<enums.TicketingDataType>? defaultValue,
]) {
  if (ticketingDataType == null) {
    return defaultValue ?? [];
  }

  return ticketingDataType
      .map((e) => ticketingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.TicketingDataType>? ticketingDataTypeNullableListFromJson(
  List? ticketingDataType, [
  List<enums.TicketingDataType>? defaultValue,
]) {
  if (ticketingDataType == null) {
    return defaultValue;
  }

  return ticketingDataType
      .map((e) => ticketingDataTypeFromJson(e.toString()))
      .toList();
}

String? eventCategoryNullableToJson(enums.EventCategory? eventCategory) {
  return eventCategory?.value;
}

String? eventCategoryToJson(enums.EventCategory eventCategory) {
  return eventCategory.value;
}

enums.EventCategory eventCategoryFromJson(
  Object? eventCategory, [
  enums.EventCategory? defaultValue,
]) {
  return enums.EventCategory.values.firstWhereOrNull(
        (e) => e.value == eventCategory,
      ) ??
      defaultValue ??
      enums.EventCategory.swaggerGeneratedUnknown;
}

enums.EventCategory? eventCategoryNullableFromJson(
  Object? eventCategory, [
  enums.EventCategory? defaultValue,
]) {
  if (eventCategory == null) {
    return null;
  }
  return enums.EventCategory.values.firstWhereOrNull(
        (e) => e.value == eventCategory,
      ) ??
      defaultValue;
}

String eventCategoryExplodedListToJson(
  List<enums.EventCategory>? eventCategory,
) {
  return eventCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventCategoryListToJson(List<enums.EventCategory>? eventCategory) {
  if (eventCategory == null) {
    return [];
  }

  return eventCategory.map((e) => e.value!).toList();
}

List<enums.EventCategory> eventCategoryListFromJson(
  List? eventCategory, [
  List<enums.EventCategory>? defaultValue,
]) {
  if (eventCategory == null) {
    return defaultValue ?? [];
  }

  return eventCategory.map((e) => eventCategoryFromJson(e.toString())).toList();
}

List<enums.EventCategory>? eventCategoryNullableListFromJson(
  List? eventCategory, [
  List<enums.EventCategory>? defaultValue,
]) {
  if (eventCategory == null) {
    return defaultValue;
  }

  return eventCategory.map((e) => eventCategoryFromJson(e.toString())).toList();
}

String? eventSubCategoryNullableToJson(
  enums.EventSubCategory? eventSubCategory,
) {
  return eventSubCategory?.value;
}

String? eventSubCategoryToJson(enums.EventSubCategory eventSubCategory) {
  return eventSubCategory.value;
}

enums.EventSubCategory eventSubCategoryFromJson(
  Object? eventSubCategory, [
  enums.EventSubCategory? defaultValue,
]) {
  return enums.EventSubCategory.values.firstWhereOrNull(
        (e) => e.value == eventSubCategory,
      ) ??
      defaultValue ??
      enums.EventSubCategory.swaggerGeneratedUnknown;
}

enums.EventSubCategory? eventSubCategoryNullableFromJson(
  Object? eventSubCategory, [
  enums.EventSubCategory? defaultValue,
]) {
  if (eventSubCategory == null) {
    return null;
  }
  return enums.EventSubCategory.values.firstWhereOrNull(
        (e) => e.value == eventSubCategory,
      ) ??
      defaultValue;
}

String eventSubCategoryExplodedListToJson(
  List<enums.EventSubCategory>? eventSubCategory,
) {
  return eventSubCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventSubCategoryListToJson(
  List<enums.EventSubCategory>? eventSubCategory,
) {
  if (eventSubCategory == null) {
    return [];
  }

  return eventSubCategory.map((e) => e.value!).toList();
}

List<enums.EventSubCategory> eventSubCategoryListFromJson(
  List? eventSubCategory, [
  List<enums.EventSubCategory>? defaultValue,
]) {
  if (eventSubCategory == null) {
    return defaultValue ?? [];
  }

  return eventSubCategory
      .map((e) => eventSubCategoryFromJson(e.toString()))
      .toList();
}

List<enums.EventSubCategory>? eventSubCategoryNullableListFromJson(
  List? eventSubCategory, [
  List<enums.EventSubCategory>? defaultValue,
]) {
  if (eventSubCategory == null) {
    return defaultValue;
  }

  return eventSubCategory
      .map((e) => eventSubCategoryFromJson(e.toString()))
      .toList();
}

String? visibilityNullableToJson(enums.Visibility? visibility) {
  return visibility?.value;
}

String? visibilityToJson(enums.Visibility visibility) {
  return visibility.value;
}

enums.Visibility visibilityFromJson(
  Object? visibility, [
  enums.Visibility? defaultValue,
]) {
  return enums.Visibility.values.firstWhereOrNull(
        (e) => e.value == visibility,
      ) ??
      defaultValue ??
      enums.Visibility.swaggerGeneratedUnknown;
}

enums.Visibility? visibilityNullableFromJson(
  Object? visibility, [
  enums.Visibility? defaultValue,
]) {
  if (visibility == null) {
    return null;
  }
  return enums.Visibility.values.firstWhereOrNull(
        (e) => e.value == visibility,
      ) ??
      defaultValue;
}

String visibilityExplodedListToJson(List<enums.Visibility>? visibility) {
  return visibility?.map((e) => e.value!).join(',') ?? '';
}

List<String> visibilityListToJson(List<enums.Visibility>? visibility) {
  if (visibility == null) {
    return [];
  }

  return visibility.map((e) => e.value!).toList();
}

List<enums.Visibility> visibilityListFromJson(
  List? visibility, [
  List<enums.Visibility>? defaultValue,
]) {
  if (visibility == null) {
    return defaultValue ?? [];
  }

  return visibility.map((e) => visibilityFromJson(e.toString())).toList();
}

List<enums.Visibility>? visibilityNullableListFromJson(
  List? visibility, [
  List<enums.Visibility>? defaultValue,
]) {
  if (visibility == null) {
    return defaultValue;
  }

  return visibility.map((e) => visibilityFromJson(e.toString())).toList();
}

String? eventUserRolesNullableToJson(enums.EventUserRoles? eventUserRoles) {
  return eventUserRoles?.value;
}

String? eventUserRolesToJson(enums.EventUserRoles eventUserRoles) {
  return eventUserRoles.value;
}

enums.EventUserRoles eventUserRolesFromJson(
  Object? eventUserRoles, [
  enums.EventUserRoles? defaultValue,
]) {
  return enums.EventUserRoles.values.firstWhereOrNull(
        (e) => e.value == eventUserRoles,
      ) ??
      defaultValue ??
      enums.EventUserRoles.swaggerGeneratedUnknown;
}

enums.EventUserRoles? eventUserRolesNullableFromJson(
  Object? eventUserRoles, [
  enums.EventUserRoles? defaultValue,
]) {
  if (eventUserRoles == null) {
    return null;
  }
  return enums.EventUserRoles.values.firstWhereOrNull(
        (e) => e.value == eventUserRoles,
      ) ??
      defaultValue;
}

String eventUserRolesExplodedListToJson(
  List<enums.EventUserRoles>? eventUserRoles,
) {
  return eventUserRoles?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventUserRolesListToJson(
  List<enums.EventUserRoles>? eventUserRoles,
) {
  if (eventUserRoles == null) {
    return [];
  }

  return eventUserRoles.map((e) => e.value!).toList();
}

List<enums.EventUserRoles> eventUserRolesListFromJson(
  List? eventUserRoles, [
  List<enums.EventUserRoles>? defaultValue,
]) {
  if (eventUserRoles == null) {
    return defaultValue ?? [];
  }

  return eventUserRoles
      .map((e) => eventUserRolesFromJson(e.toString()))
      .toList();
}

List<enums.EventUserRoles>? eventUserRolesNullableListFromJson(
  List? eventUserRoles, [
  List<enums.EventUserRoles>? defaultValue,
]) {
  if (eventUserRoles == null) {
    return defaultValue;
  }

  return eventUserRoles
      .map((e) => eventUserRolesFromJson(e.toString()))
      .toList();
}

String? eventUserRolePermissionNullableToJson(
  enums.EventUserRolePermission? eventUserRolePermission,
) {
  return eventUserRolePermission?.value;
}

String? eventUserRolePermissionToJson(
  enums.EventUserRolePermission eventUserRolePermission,
) {
  return eventUserRolePermission.value;
}

enums.EventUserRolePermission eventUserRolePermissionFromJson(
  Object? eventUserRolePermission, [
  enums.EventUserRolePermission? defaultValue,
]) {
  return enums.EventUserRolePermission.values.firstWhereOrNull(
        (e) => e.value == eventUserRolePermission,
      ) ??
      defaultValue ??
      enums.EventUserRolePermission.swaggerGeneratedUnknown;
}

enums.EventUserRolePermission? eventUserRolePermissionNullableFromJson(
  Object? eventUserRolePermission, [
  enums.EventUserRolePermission? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return null;
  }
  return enums.EventUserRolePermission.values.firstWhereOrNull(
        (e) => e.value == eventUserRolePermission,
      ) ??
      defaultValue;
}

String eventUserRolePermissionExplodedListToJson(
  List<enums.EventUserRolePermission>? eventUserRolePermission,
) {
  return eventUserRolePermission?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventUserRolePermissionListToJson(
  List<enums.EventUserRolePermission>? eventUserRolePermission,
) {
  if (eventUserRolePermission == null) {
    return [];
  }

  return eventUserRolePermission.map((e) => e.value!).toList();
}

List<enums.EventUserRolePermission> eventUserRolePermissionListFromJson(
  List? eventUserRolePermission, [
  List<enums.EventUserRolePermission>? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return defaultValue ?? [];
  }

  return eventUserRolePermission
      .map((e) => eventUserRolePermissionFromJson(e.toString()))
      .toList();
}

List<enums.EventUserRolePermission>?
eventUserRolePermissionNullableListFromJson(
  List? eventUserRolePermission, [
  List<enums.EventUserRolePermission>? defaultValue,
]) {
  if (eventUserRolePermission == null) {
    return defaultValue;
  }

  return eventUserRolePermission
      .map((e) => eventUserRolePermissionFromJson(e.toString()))
      .toList();
}

String? roleStatusNullableToJson(enums.RoleStatus? roleStatus) {
  return roleStatus?.value;
}

String? roleStatusToJson(enums.RoleStatus roleStatus) {
  return roleStatus.value;
}

enums.RoleStatus roleStatusFromJson(
  Object? roleStatus, [
  enums.RoleStatus? defaultValue,
]) {
  return enums.RoleStatus.values.firstWhereOrNull(
        (e) => e.value == roleStatus,
      ) ??
      defaultValue ??
      enums.RoleStatus.swaggerGeneratedUnknown;
}

enums.RoleStatus? roleStatusNullableFromJson(
  Object? roleStatus, [
  enums.RoleStatus? defaultValue,
]) {
  if (roleStatus == null) {
    return null;
  }
  return enums.RoleStatus.values.firstWhereOrNull(
        (e) => e.value == roleStatus,
      ) ??
      defaultValue;
}

String roleStatusExplodedListToJson(List<enums.RoleStatus>? roleStatus) {
  return roleStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> roleStatusListToJson(List<enums.RoleStatus>? roleStatus) {
  if (roleStatus == null) {
    return [];
  }

  return roleStatus.map((e) => e.value!).toList();
}

List<enums.RoleStatus> roleStatusListFromJson(
  List? roleStatus, [
  List<enums.RoleStatus>? defaultValue,
]) {
  if (roleStatus == null) {
    return defaultValue ?? [];
  }

  return roleStatus.map((e) => roleStatusFromJson(e.toString())).toList();
}

List<enums.RoleStatus>? roleStatusNullableListFromJson(
  List? roleStatus, [
  List<enums.RoleStatus>? defaultValue,
]) {
  if (roleStatus == null) {
    return defaultValue;
  }

  return roleStatus.map((e) => roleStatusFromJson(e.toString())).toList();
}

String? eventGuestStatusNullableToJson(
  enums.EventGuestStatus? eventGuestStatus,
) {
  return eventGuestStatus?.value;
}

String? eventGuestStatusToJson(enums.EventGuestStatus eventGuestStatus) {
  return eventGuestStatus.value;
}

enums.EventGuestStatus eventGuestStatusFromJson(
  Object? eventGuestStatus, [
  enums.EventGuestStatus? defaultValue,
]) {
  return enums.EventGuestStatus.values.firstWhereOrNull(
        (e) => e.value == eventGuestStatus,
      ) ??
      defaultValue ??
      enums.EventGuestStatus.swaggerGeneratedUnknown;
}

enums.EventGuestStatus? eventGuestStatusNullableFromJson(
  Object? eventGuestStatus, [
  enums.EventGuestStatus? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return null;
  }
  return enums.EventGuestStatus.values.firstWhereOrNull(
        (e) => e.value == eventGuestStatus,
      ) ??
      defaultValue;
}

String eventGuestStatusExplodedListToJson(
  List<enums.EventGuestStatus>? eventGuestStatus,
) {
  return eventGuestStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventGuestStatusListToJson(
  List<enums.EventGuestStatus>? eventGuestStatus,
) {
  if (eventGuestStatus == null) {
    return [];
  }

  return eventGuestStatus.map((e) => e.value!).toList();
}

List<enums.EventGuestStatus> eventGuestStatusListFromJson(
  List? eventGuestStatus, [
  List<enums.EventGuestStatus>? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return defaultValue ?? [];
  }

  return eventGuestStatus
      .map((e) => eventGuestStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventGuestStatus>? eventGuestStatusNullableListFromJson(
  List? eventGuestStatus, [
  List<enums.EventGuestStatus>? defaultValue,
]) {
  if (eventGuestStatus == null) {
    return defaultValue;
  }

  return eventGuestStatus
      .map((e) => eventGuestStatusFromJson(e.toString()))
      .toList();
}

String? creatorDetailsDtoDataTypeNullableToJson(
  enums.CreatorDetailsDtoDataType? creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType?.value;
}

String? creatorDetailsDtoDataTypeToJson(
  enums.CreatorDetailsDtoDataType creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType.value;
}

enums.CreatorDetailsDtoDataType creatorDetailsDtoDataTypeFromJson(
  Object? creatorDetailsDtoDataType, [
  enums.CreatorDetailsDtoDataType? defaultValue,
]) {
  return enums.CreatorDetailsDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorDetailsDtoDataType,
      ) ??
      defaultValue ??
      enums.CreatorDetailsDtoDataType.swaggerGeneratedUnknown;
}

enums.CreatorDetailsDtoDataType? creatorDetailsDtoDataTypeNullableFromJson(
  Object? creatorDetailsDtoDataType, [
  enums.CreatorDetailsDtoDataType? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return null;
  }
  return enums.CreatorDetailsDtoDataType.values.firstWhereOrNull(
        (e) => e.value == creatorDetailsDtoDataType,
      ) ??
      defaultValue;
}

String creatorDetailsDtoDataTypeExplodedListToJson(
  List<enums.CreatorDetailsDtoDataType>? creatorDetailsDtoDataType,
) {
  return creatorDetailsDtoDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorDetailsDtoDataTypeListToJson(
  List<enums.CreatorDetailsDtoDataType>? creatorDetailsDtoDataType,
) {
  if (creatorDetailsDtoDataType == null) {
    return [];
  }

  return creatorDetailsDtoDataType.map((e) => e.value!).toList();
}

List<enums.CreatorDetailsDtoDataType> creatorDetailsDtoDataTypeListFromJson(
  List? creatorDetailsDtoDataType, [
  List<enums.CreatorDetailsDtoDataType>? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return defaultValue ?? [];
  }

  return creatorDetailsDtoDataType
      .map((e) => creatorDetailsDtoDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatorDetailsDtoDataType>?
creatorDetailsDtoDataTypeNullableListFromJson(
  List? creatorDetailsDtoDataType, [
  List<enums.CreatorDetailsDtoDataType>? defaultValue,
]) {
  if (creatorDetailsDtoDataType == null) {
    return defaultValue;
  }

  return creatorDetailsDtoDataType
      .map((e) => creatorDetailsDtoDataTypeFromJson(e.toString()))
      .toList();
}

String? linkedAccountTypeNullableToJson(
  enums.LinkedAccountType? linkedAccountType,
) {
  return linkedAccountType?.value;
}

String? linkedAccountTypeToJson(enums.LinkedAccountType linkedAccountType) {
  return linkedAccountType.value;
}

enums.LinkedAccountType linkedAccountTypeFromJson(
  Object? linkedAccountType, [
  enums.LinkedAccountType? defaultValue,
]) {
  return enums.LinkedAccountType.values.firstWhereOrNull(
        (e) => e.value == linkedAccountType,
      ) ??
      defaultValue ??
      enums.LinkedAccountType.swaggerGeneratedUnknown;
}

enums.LinkedAccountType? linkedAccountTypeNullableFromJson(
  Object? linkedAccountType, [
  enums.LinkedAccountType? defaultValue,
]) {
  if (linkedAccountType == null) {
    return null;
  }
  return enums.LinkedAccountType.values.firstWhereOrNull(
        (e) => e.value == linkedAccountType,
      ) ??
      defaultValue;
}

String linkedAccountTypeExplodedListToJson(
  List<enums.LinkedAccountType>? linkedAccountType,
) {
  return linkedAccountType?.map((e) => e.value!).join(',') ?? '';
}

List<String> linkedAccountTypeListToJson(
  List<enums.LinkedAccountType>? linkedAccountType,
) {
  if (linkedAccountType == null) {
    return [];
  }

  return linkedAccountType.map((e) => e.value!).toList();
}

List<enums.LinkedAccountType> linkedAccountTypeListFromJson(
  List? linkedAccountType, [
  List<enums.LinkedAccountType>? defaultValue,
]) {
  if (linkedAccountType == null) {
    return defaultValue ?? [];
  }

  return linkedAccountType
      .map((e) => linkedAccountTypeFromJson(e.toString()))
      .toList();
}

List<enums.LinkedAccountType>? linkedAccountTypeNullableListFromJson(
  List? linkedAccountType, [
  List<enums.LinkedAccountType>? defaultValue,
]) {
  if (linkedAccountType == null) {
    return defaultValue;
  }

  return linkedAccountType
      .map((e) => linkedAccountTypeFromJson(e.toString()))
      .toList();
}

String? walletClientTypeNullableToJson(
  enums.WalletClientType? walletClientType,
) {
  return walletClientType?.value;
}

String? walletClientTypeToJson(enums.WalletClientType walletClientType) {
  return walletClientType.value;
}

enums.WalletClientType walletClientTypeFromJson(
  Object? walletClientType, [
  enums.WalletClientType? defaultValue,
]) {
  return enums.WalletClientType.values.firstWhereOrNull(
        (e) => e.value == walletClientType,
      ) ??
      defaultValue ??
      enums.WalletClientType.swaggerGeneratedUnknown;
}

enums.WalletClientType? walletClientTypeNullableFromJson(
  Object? walletClientType, [
  enums.WalletClientType? defaultValue,
]) {
  if (walletClientType == null) {
    return null;
  }
  return enums.WalletClientType.values.firstWhereOrNull(
        (e) => e.value == walletClientType,
      ) ??
      defaultValue;
}

String walletClientTypeExplodedListToJson(
  List<enums.WalletClientType>? walletClientType,
) {
  return walletClientType?.map((e) => e.value!).join(',') ?? '';
}

List<String> walletClientTypeListToJson(
  List<enums.WalletClientType>? walletClientType,
) {
  if (walletClientType == null) {
    return [];
  }

  return walletClientType.map((e) => e.value!).toList();
}

List<enums.WalletClientType> walletClientTypeListFromJson(
  List? walletClientType, [
  List<enums.WalletClientType>? defaultValue,
]) {
  if (walletClientType == null) {
    return defaultValue ?? [];
  }

  return walletClientType
      .map((e) => walletClientTypeFromJson(e.toString()))
      .toList();
}

List<enums.WalletClientType>? walletClientTypeNullableListFromJson(
  List? walletClientType, [
  List<enums.WalletClientType>? defaultValue,
]) {
  if (walletClientType == null) {
    return defaultValue;
  }

  return walletClientType
      .map((e) => walletClientTypeFromJson(e.toString()))
      .toList();
}

String? stakingDataTypeNullableToJson(enums.StakingDataType? stakingDataType) {
  return stakingDataType?.value;
}

String? stakingDataTypeToJson(enums.StakingDataType stakingDataType) {
  return stakingDataType.value;
}

enums.StakingDataType stakingDataTypeFromJson(
  Object? stakingDataType, [
  enums.StakingDataType? defaultValue,
]) {
  return enums.StakingDataType.values.firstWhereOrNull(
        (e) => e.value == stakingDataType,
      ) ??
      defaultValue ??
      enums.StakingDataType.swaggerGeneratedUnknown;
}

enums.StakingDataType? stakingDataTypeNullableFromJson(
  Object? stakingDataType, [
  enums.StakingDataType? defaultValue,
]) {
  if (stakingDataType == null) {
    return null;
  }
  return enums.StakingDataType.values.firstWhereOrNull(
        (e) => e.value == stakingDataType,
      ) ??
      defaultValue;
}

String stakingDataTypeExplodedListToJson(
  List<enums.StakingDataType>? stakingDataType,
) {
  return stakingDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingDataTypeListToJson(
  List<enums.StakingDataType>? stakingDataType,
) {
  if (stakingDataType == null) {
    return [];
  }

  return stakingDataType.map((e) => e.value!).toList();
}

List<enums.StakingDataType> stakingDataTypeListFromJson(
  List? stakingDataType, [
  List<enums.StakingDataType>? defaultValue,
]) {
  if (stakingDataType == null) {
    return defaultValue ?? [];
  }

  return stakingDataType
      .map((e) => stakingDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.StakingDataType>? stakingDataTypeNullableListFromJson(
  List? stakingDataType, [
  List<enums.StakingDataType>? defaultValue,
]) {
  if (stakingDataType == null) {
    return defaultValue;
  }

  return stakingDataType
      .map((e) => stakingDataTypeFromJson(e.toString()))
      .toList();
}

String? stakingPoolTypeStringNullableToJson(
  enums.StakingPoolTypeString? stakingPoolTypeString,
) {
  return stakingPoolTypeString?.value;
}

String? stakingPoolTypeStringToJson(
  enums.StakingPoolTypeString stakingPoolTypeString,
) {
  return stakingPoolTypeString.value;
}

enums.StakingPoolTypeString stakingPoolTypeStringFromJson(
  Object? stakingPoolTypeString, [
  enums.StakingPoolTypeString? defaultValue,
]) {
  return enums.StakingPoolTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingPoolTypeString,
      ) ??
      defaultValue ??
      enums.StakingPoolTypeString.swaggerGeneratedUnknown;
}

enums.StakingPoolTypeString? stakingPoolTypeStringNullableFromJson(
  Object? stakingPoolTypeString, [
  enums.StakingPoolTypeString? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return null;
  }
  return enums.StakingPoolTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingPoolTypeString,
      ) ??
      defaultValue;
}

String stakingPoolTypeStringExplodedListToJson(
  List<enums.StakingPoolTypeString>? stakingPoolTypeString,
) {
  return stakingPoolTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingPoolTypeStringListToJson(
  List<enums.StakingPoolTypeString>? stakingPoolTypeString,
) {
  if (stakingPoolTypeString == null) {
    return [];
  }

  return stakingPoolTypeString.map((e) => e.value!).toList();
}

List<enums.StakingPoolTypeString> stakingPoolTypeStringListFromJson(
  List? stakingPoolTypeString, [
  List<enums.StakingPoolTypeString>? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return defaultValue ?? [];
  }

  return stakingPoolTypeString
      .map((e) => stakingPoolTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.StakingPoolTypeString>? stakingPoolTypeStringNullableListFromJson(
  List? stakingPoolTypeString, [
  List<enums.StakingPoolTypeString>? defaultValue,
]) {
  if (stakingPoolTypeString == null) {
    return defaultValue;
  }

  return stakingPoolTypeString
      .map((e) => stakingPoolTypeStringFromJson(e.toString()))
      .toList();
}

String? stakingIssuingTypeStringNullableToJson(
  enums.StakingIssuingTypeString? stakingIssuingTypeString,
) {
  return stakingIssuingTypeString?.value;
}

String? stakingIssuingTypeStringToJson(
  enums.StakingIssuingTypeString stakingIssuingTypeString,
) {
  return stakingIssuingTypeString.value;
}

enums.StakingIssuingTypeString stakingIssuingTypeStringFromJson(
  Object? stakingIssuingTypeString, [
  enums.StakingIssuingTypeString? defaultValue,
]) {
  return enums.StakingIssuingTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingIssuingTypeString,
      ) ??
      defaultValue ??
      enums.StakingIssuingTypeString.swaggerGeneratedUnknown;
}

enums.StakingIssuingTypeString? stakingIssuingTypeStringNullableFromJson(
  Object? stakingIssuingTypeString, [
  enums.StakingIssuingTypeString? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return null;
  }
  return enums.StakingIssuingTypeString.values.firstWhereOrNull(
        (e) => e.value == stakingIssuingTypeString,
      ) ??
      defaultValue;
}

String stakingIssuingTypeStringExplodedListToJson(
  List<enums.StakingIssuingTypeString>? stakingIssuingTypeString,
) {
  return stakingIssuingTypeString?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingIssuingTypeStringListToJson(
  List<enums.StakingIssuingTypeString>? stakingIssuingTypeString,
) {
  if (stakingIssuingTypeString == null) {
    return [];
  }

  return stakingIssuingTypeString.map((e) => e.value!).toList();
}

List<enums.StakingIssuingTypeString> stakingIssuingTypeStringListFromJson(
  List? stakingIssuingTypeString, [
  List<enums.StakingIssuingTypeString>? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return defaultValue ?? [];
  }

  return stakingIssuingTypeString
      .map((e) => stakingIssuingTypeStringFromJson(e.toString()))
      .toList();
}

List<enums.StakingIssuingTypeString>?
stakingIssuingTypeStringNullableListFromJson(
  List? stakingIssuingTypeString, [
  List<enums.StakingIssuingTypeString>? defaultValue,
]) {
  if (stakingIssuingTypeString == null) {
    return defaultValue;
  }

  return stakingIssuingTypeString
      .map((e) => stakingIssuingTypeStringFromJson(e.toString()))
      .toList();
}

String? stakingStatusNullableToJson(enums.StakingStatus? stakingStatus) {
  return stakingStatus?.value;
}

String? stakingStatusToJson(enums.StakingStatus stakingStatus) {
  return stakingStatus.value;
}

enums.StakingStatus stakingStatusFromJson(
  Object? stakingStatus, [
  enums.StakingStatus? defaultValue,
]) {
  return enums.StakingStatus.values.firstWhereOrNull(
        (e) => e.value == stakingStatus,
      ) ??
      defaultValue ??
      enums.StakingStatus.swaggerGeneratedUnknown;
}

enums.StakingStatus? stakingStatusNullableFromJson(
  Object? stakingStatus, [
  enums.StakingStatus? defaultValue,
]) {
  if (stakingStatus == null) {
    return null;
  }
  return enums.StakingStatus.values.firstWhereOrNull(
        (e) => e.value == stakingStatus,
      ) ??
      defaultValue;
}

String stakingStatusExplodedListToJson(
  List<enums.StakingStatus>? stakingStatus,
) {
  return stakingStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> stakingStatusListToJson(List<enums.StakingStatus>? stakingStatus) {
  if (stakingStatus == null) {
    return [];
  }

  return stakingStatus.map((e) => e.value!).toList();
}

List<enums.StakingStatus> stakingStatusListFromJson(
  List? stakingStatus, [
  List<enums.StakingStatus>? defaultValue,
]) {
  if (stakingStatus == null) {
    return defaultValue ?? [];
  }

  return stakingStatus.map((e) => stakingStatusFromJson(e.toString())).toList();
}

List<enums.StakingStatus>? stakingStatusNullableListFromJson(
  List? stakingStatus, [
  List<enums.StakingStatus>? defaultValue,
]) {
  if (stakingStatus == null) {
    return defaultValue;
  }

  return stakingStatus.map((e) => stakingStatusFromJson(e.toString())).toList();
}

String? collectionDtoChainNullableToJson(
  enums.CollectionDtoChain? collectionDtoChain,
) {
  return collectionDtoChain?.value;
}

String? collectionDtoChainToJson(enums.CollectionDtoChain collectionDtoChain) {
  return collectionDtoChain.value;
}

enums.CollectionDtoChain collectionDtoChainFromJson(
  Object? collectionDtoChain, [
  enums.CollectionDtoChain? defaultValue,
]) {
  return enums.CollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == collectionDtoChain,
      ) ??
      defaultValue ??
      enums.CollectionDtoChain.swaggerGeneratedUnknown;
}

enums.CollectionDtoChain? collectionDtoChainNullableFromJson(
  Object? collectionDtoChain, [
  enums.CollectionDtoChain? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return null;
  }
  return enums.CollectionDtoChain.values.firstWhereOrNull(
        (e) => e.value == collectionDtoChain,
      ) ??
      defaultValue;
}

String collectionDtoChainExplodedListToJson(
  List<enums.CollectionDtoChain>? collectionDtoChain,
) {
  return collectionDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionDtoChainListToJson(
  List<enums.CollectionDtoChain>? collectionDtoChain,
) {
  if (collectionDtoChain == null) {
    return [];
  }

  return collectionDtoChain.map((e) => e.value!).toList();
}

List<enums.CollectionDtoChain> collectionDtoChainListFromJson(
  List? collectionDtoChain, [
  List<enums.CollectionDtoChain>? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return defaultValue ?? [];
  }

  return collectionDtoChain
      .map((e) => collectionDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.CollectionDtoChain>? collectionDtoChainNullableListFromJson(
  List? collectionDtoChain, [
  List<enums.CollectionDtoChain>? defaultValue,
]) {
  if (collectionDtoChain == null) {
    return defaultValue;
  }

  return collectionDtoChain
      .map((e) => collectionDtoChainFromJson(e.toString()))
      .toList();
}

String? userDtoChainNullableToJson(enums.UserDtoChain? userDtoChain) {
  return userDtoChain?.value;
}

String? userDtoChainToJson(enums.UserDtoChain userDtoChain) {
  return userDtoChain.value;
}

enums.UserDtoChain userDtoChainFromJson(
  Object? userDtoChain, [
  enums.UserDtoChain? defaultValue,
]) {
  return enums.UserDtoChain.values.firstWhereOrNull(
        (e) => e.value == userDtoChain,
      ) ??
      defaultValue ??
      enums.UserDtoChain.swaggerGeneratedUnknown;
}

enums.UserDtoChain? userDtoChainNullableFromJson(
  Object? userDtoChain, [
  enums.UserDtoChain? defaultValue,
]) {
  if (userDtoChain == null) {
    return null;
  }
  return enums.UserDtoChain.values.firstWhereOrNull(
        (e) => e.value == userDtoChain,
      ) ??
      defaultValue;
}

String userDtoChainExplodedListToJson(List<enums.UserDtoChain>? userDtoChain) {
  return userDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> userDtoChainListToJson(List<enums.UserDtoChain>? userDtoChain) {
  if (userDtoChain == null) {
    return [];
  }

  return userDtoChain.map((e) => e.value!).toList();
}

List<enums.UserDtoChain> userDtoChainListFromJson(
  List? userDtoChain, [
  List<enums.UserDtoChain>? defaultValue,
]) {
  if (userDtoChain == null) {
    return defaultValue ?? [];
  }

  return userDtoChain.map((e) => userDtoChainFromJson(e.toString())).toList();
}

List<enums.UserDtoChain>? userDtoChainNullableListFromJson(
  List? userDtoChain, [
  List<enums.UserDtoChain>? defaultValue,
]) {
  if (userDtoChain == null) {
    return defaultValue;
  }

  return userDtoChain.map((e) => userDtoChainFromJson(e.toString())).toList();
}

String? creatorDtoChainNullableToJson(enums.CreatorDtoChain? creatorDtoChain) {
  return creatorDtoChain?.value;
}

String? creatorDtoChainToJson(enums.CreatorDtoChain creatorDtoChain) {
  return creatorDtoChain.value;
}

enums.CreatorDtoChain creatorDtoChainFromJson(
  Object? creatorDtoChain, [
  enums.CreatorDtoChain? defaultValue,
]) {
  return enums.CreatorDtoChain.values.firstWhereOrNull(
        (e) => e.value == creatorDtoChain,
      ) ??
      defaultValue ??
      enums.CreatorDtoChain.swaggerGeneratedUnknown;
}

enums.CreatorDtoChain? creatorDtoChainNullableFromJson(
  Object? creatorDtoChain, [
  enums.CreatorDtoChain? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return null;
  }
  return enums.CreatorDtoChain.values.firstWhereOrNull(
        (e) => e.value == creatorDtoChain,
      ) ??
      defaultValue;
}

String creatorDtoChainExplodedListToJson(
  List<enums.CreatorDtoChain>? creatorDtoChain,
) {
  return creatorDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> creatorDtoChainListToJson(
  List<enums.CreatorDtoChain>? creatorDtoChain,
) {
  if (creatorDtoChain == null) {
    return [];
  }

  return creatorDtoChain.map((e) => e.value!).toList();
}

List<enums.CreatorDtoChain> creatorDtoChainListFromJson(
  List? creatorDtoChain, [
  List<enums.CreatorDtoChain>? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return defaultValue ?? [];
  }

  return creatorDtoChain
      .map((e) => creatorDtoChainFromJson(e.toString()))
      .toList();
}

List<enums.CreatorDtoChain>? creatorDtoChainNullableListFromJson(
  List? creatorDtoChain, [
  List<enums.CreatorDtoChain>? defaultValue,
]) {
  if (creatorDtoChain == null) {
    return defaultValue;
  }

  return creatorDtoChain
      .map((e) => creatorDtoChainFromJson(e.toString()))
      .toList();
}

String? nftDtoChainNullableToJson(enums.NftDtoChain? nftDtoChain) {
  return nftDtoChain?.value;
}

String? nftDtoChainToJson(enums.NftDtoChain nftDtoChain) {
  return nftDtoChain.value;
}

enums.NftDtoChain nftDtoChainFromJson(
  Object? nftDtoChain, [
  enums.NftDtoChain? defaultValue,
]) {
  return enums.NftDtoChain.values.firstWhereOrNull(
        (e) => e.value == nftDtoChain,
      ) ??
      defaultValue ??
      enums.NftDtoChain.swaggerGeneratedUnknown;
}

enums.NftDtoChain? nftDtoChainNullableFromJson(
  Object? nftDtoChain, [
  enums.NftDtoChain? defaultValue,
]) {
  if (nftDtoChain == null) {
    return null;
  }
  return enums.NftDtoChain.values.firstWhereOrNull(
        (e) => e.value == nftDtoChain,
      ) ??
      defaultValue;
}

String nftDtoChainExplodedListToJson(List<enums.NftDtoChain>? nftDtoChain) {
  return nftDtoChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftDtoChainListToJson(List<enums.NftDtoChain>? nftDtoChain) {
  if (nftDtoChain == null) {
    return [];
  }

  return nftDtoChain.map((e) => e.value!).toList();
}

List<enums.NftDtoChain> nftDtoChainListFromJson(
  List? nftDtoChain, [
  List<enums.NftDtoChain>? defaultValue,
]) {
  if (nftDtoChain == null) {
    return defaultValue ?? [];
  }

  return nftDtoChain.map((e) => nftDtoChainFromJson(e.toString())).toList();
}

List<enums.NftDtoChain>? nftDtoChainNullableListFromJson(
  List? nftDtoChain, [
  List<enums.NftDtoChain>? defaultValue,
]) {
  if (nftDtoChain == null) {
    return defaultValue;
  }

  return nftDtoChain.map((e) => nftDtoChainFromJson(e.toString())).toList();
}

String? notificationDocDataTypeNullableToJson(
  enums.NotificationDocDataType? notificationDocDataType,
) {
  return notificationDocDataType?.value;
}

String? notificationDocDataTypeToJson(
  enums.NotificationDocDataType notificationDocDataType,
) {
  return notificationDocDataType.value;
}

enums.NotificationDocDataType notificationDocDataTypeFromJson(
  Object? notificationDocDataType, [
  enums.NotificationDocDataType? defaultValue,
]) {
  return enums.NotificationDocDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDocDataType,
      ) ??
      defaultValue ??
      enums.NotificationDocDataType.swaggerGeneratedUnknown;
}

enums.NotificationDocDataType? notificationDocDataTypeNullableFromJson(
  Object? notificationDocDataType, [
  enums.NotificationDocDataType? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return null;
  }
  return enums.NotificationDocDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDocDataType,
      ) ??
      defaultValue;
}

String notificationDocDataTypeExplodedListToJson(
  List<enums.NotificationDocDataType>? notificationDocDataType,
) {
  return notificationDocDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDocDataTypeListToJson(
  List<enums.NotificationDocDataType>? notificationDocDataType,
) {
  if (notificationDocDataType == null) {
    return [];
  }

  return notificationDocDataType.map((e) => e.value!).toList();
}

List<enums.NotificationDocDataType> notificationDocDataTypeListFromJson(
  List? notificationDocDataType, [
  List<enums.NotificationDocDataType>? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return defaultValue ?? [];
  }

  return notificationDocDataType
      .map((e) => notificationDocDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDocDataType>?
notificationDocDataTypeNullableListFromJson(
  List? notificationDocDataType, [
  List<enums.NotificationDocDataType>? defaultValue,
]) {
  if (notificationDocDataType == null) {
    return defaultValue;
  }

  return notificationDocDataType
      .map((e) => notificationDocDataTypeFromJson(e.toString()))
      .toList();
}

String? notificationDocActivityTypeNullableToJson(
  enums.NotificationDocActivityType? notificationDocActivityType,
) {
  return notificationDocActivityType?.value;
}

String? notificationDocActivityTypeToJson(
  enums.NotificationDocActivityType notificationDocActivityType,
) {
  return notificationDocActivityType.value;
}

enums.NotificationDocActivityType notificationDocActivityTypeFromJson(
  Object? notificationDocActivityType, [
  enums.NotificationDocActivityType? defaultValue,
]) {
  return enums.NotificationDocActivityType.values.firstWhereOrNull(
        (e) => e.value == notificationDocActivityType,
      ) ??
      defaultValue ??
      enums.NotificationDocActivityType.swaggerGeneratedUnknown;
}

enums.NotificationDocActivityType? notificationDocActivityTypeNullableFromJson(
  Object? notificationDocActivityType, [
  enums.NotificationDocActivityType? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return null;
  }
  return enums.NotificationDocActivityType.values.firstWhereOrNull(
        (e) => e.value == notificationDocActivityType,
      ) ??
      defaultValue;
}

String notificationDocActivityTypeExplodedListToJson(
  List<enums.NotificationDocActivityType>? notificationDocActivityType,
) {
  return notificationDocActivityType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDocActivityTypeListToJson(
  List<enums.NotificationDocActivityType>? notificationDocActivityType,
) {
  if (notificationDocActivityType == null) {
    return [];
  }

  return notificationDocActivityType.map((e) => e.value!).toList();
}

List<enums.NotificationDocActivityType> notificationDocActivityTypeListFromJson(
  List? notificationDocActivityType, [
  List<enums.NotificationDocActivityType>? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return defaultValue ?? [];
  }

  return notificationDocActivityType
      .map((e) => notificationDocActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDocActivityType>?
notificationDocActivityTypeNullableListFromJson(
  List? notificationDocActivityType, [
  List<enums.NotificationDocActivityType>? defaultValue,
]) {
  if (notificationDocActivityType == null) {
    return defaultValue;
  }

  return notificationDocActivityType
      .map((e) => notificationDocActivityTypeFromJson(e.toString()))
      .toList();
}

String? devicePlatformNullableToJson(enums.DevicePlatform? devicePlatform) {
  return devicePlatform?.value;
}

String? devicePlatformToJson(enums.DevicePlatform devicePlatform) {
  return devicePlatform.value;
}

enums.DevicePlatform devicePlatformFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  return enums.DevicePlatform.values.firstWhereOrNull(
        (e) => e.value == devicePlatform,
      ) ??
      defaultValue ??
      enums.DevicePlatform.swaggerGeneratedUnknown;
}

enums.DevicePlatform? devicePlatformNullableFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  if (devicePlatform == null) {
    return null;
  }
  return enums.DevicePlatform.values.firstWhereOrNull(
        (e) => e.value == devicePlatform,
      ) ??
      defaultValue;
}

String devicePlatformExplodedListToJson(
  List<enums.DevicePlatform>? devicePlatform,
) {
  return devicePlatform?.map((e) => e.value!).join(',') ?? '';
}

List<String> devicePlatformListToJson(
  List<enums.DevicePlatform>? devicePlatform,
) {
  if (devicePlatform == null) {
    return [];
  }

  return devicePlatform.map((e) => e.value!).toList();
}

List<enums.DevicePlatform> devicePlatformListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue ?? [];
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

List<enums.DevicePlatform>? devicePlatformNullableListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue;
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

String? notificationDataTypeNullableToJson(
  enums.NotificationDataType? notificationDataType,
) {
  return notificationDataType?.value;
}

String? notificationDataTypeToJson(
  enums.NotificationDataType notificationDataType,
) {
  return notificationDataType.value;
}

enums.NotificationDataType notificationDataTypeFromJson(
  Object? notificationDataType, [
  enums.NotificationDataType? defaultValue,
]) {
  return enums.NotificationDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDataType,
      ) ??
      defaultValue ??
      enums.NotificationDataType.swaggerGeneratedUnknown;
}

enums.NotificationDataType? notificationDataTypeNullableFromJson(
  Object? notificationDataType, [
  enums.NotificationDataType? defaultValue,
]) {
  if (notificationDataType == null) {
    return null;
  }
  return enums.NotificationDataType.values.firstWhereOrNull(
        (e) => e.value == notificationDataType,
      ) ??
      defaultValue;
}

String notificationDataTypeExplodedListToJson(
  List<enums.NotificationDataType>? notificationDataType,
) {
  return notificationDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> notificationDataTypeListToJson(
  List<enums.NotificationDataType>? notificationDataType,
) {
  if (notificationDataType == null) {
    return [];
  }

  return notificationDataType.map((e) => e.value!).toList();
}

List<enums.NotificationDataType> notificationDataTypeListFromJson(
  List? notificationDataType, [
  List<enums.NotificationDataType>? defaultValue,
]) {
  if (notificationDataType == null) {
    return defaultValue ?? [];
  }

  return notificationDataType
      .map((e) => notificationDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.NotificationDataType>? notificationDataTypeNullableListFromJson(
  List? notificationDataType, [
  List<enums.NotificationDataType>? defaultValue,
]) {
  if (notificationDataType == null) {
    return defaultValue;
  }

  return notificationDataType
      .map((e) => notificationDataTypeFromJson(e.toString()))
      .toList();
}

String? pushNotificationTypeNullableToJson(
  enums.PushNotificationType? pushNotificationType,
) {
  return pushNotificationType?.value;
}

String? pushNotificationTypeToJson(
  enums.PushNotificationType pushNotificationType,
) {
  return pushNotificationType.value;
}

enums.PushNotificationType pushNotificationTypeFromJson(
  Object? pushNotificationType, [
  enums.PushNotificationType? defaultValue,
]) {
  return enums.PushNotificationType.values.firstWhereOrNull(
        (e) => e.value == pushNotificationType,
      ) ??
      defaultValue ??
      enums.PushNotificationType.swaggerGeneratedUnknown;
}

enums.PushNotificationType? pushNotificationTypeNullableFromJson(
  Object? pushNotificationType, [
  enums.PushNotificationType? defaultValue,
]) {
  if (pushNotificationType == null) {
    return null;
  }
  return enums.PushNotificationType.values.firstWhereOrNull(
        (e) => e.value == pushNotificationType,
      ) ??
      defaultValue;
}

String pushNotificationTypeExplodedListToJson(
  List<enums.PushNotificationType>? pushNotificationType,
) {
  return pushNotificationType?.map((e) => e.value!).join(',') ?? '';
}

List<String> pushNotificationTypeListToJson(
  List<enums.PushNotificationType>? pushNotificationType,
) {
  if (pushNotificationType == null) {
    return [];
  }

  return pushNotificationType.map((e) => e.value!).toList();
}

List<enums.PushNotificationType> pushNotificationTypeListFromJson(
  List? pushNotificationType, [
  List<enums.PushNotificationType>? defaultValue,
]) {
  if (pushNotificationType == null) {
    return defaultValue ?? [];
  }

  return pushNotificationType
      .map((e) => pushNotificationTypeFromJson(e.toString()))
      .toList();
}

List<enums.PushNotificationType>? pushNotificationTypeNullableListFromJson(
  List? pushNotificationType, [
  List<enums.PushNotificationType>? defaultValue,
]) {
  if (pushNotificationType == null) {
    return defaultValue;
  }

  return pushNotificationType
      .map((e) => pushNotificationTypeFromJson(e.toString()))
      .toList();
}

String? pushNotificationStatusNullableToJson(
  enums.PushNotificationStatus? pushNotificationStatus,
) {
  return pushNotificationStatus?.value;
}

String? pushNotificationStatusToJson(
  enums.PushNotificationStatus pushNotificationStatus,
) {
  return pushNotificationStatus.value;
}

enums.PushNotificationStatus pushNotificationStatusFromJson(
  Object? pushNotificationStatus, [
  enums.PushNotificationStatus? defaultValue,
]) {
  return enums.PushNotificationStatus.values.firstWhereOrNull(
        (e) => e.value == pushNotificationStatus,
      ) ??
      defaultValue ??
      enums.PushNotificationStatus.swaggerGeneratedUnknown;
}

enums.PushNotificationStatus? pushNotificationStatusNullableFromJson(
  Object? pushNotificationStatus, [
  enums.PushNotificationStatus? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return null;
  }
  return enums.PushNotificationStatus.values.firstWhereOrNull(
        (e) => e.value == pushNotificationStatus,
      ) ??
      defaultValue;
}

String pushNotificationStatusExplodedListToJson(
  List<enums.PushNotificationStatus>? pushNotificationStatus,
) {
  return pushNotificationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> pushNotificationStatusListToJson(
  List<enums.PushNotificationStatus>? pushNotificationStatus,
) {
  if (pushNotificationStatus == null) {
    return [];
  }

  return pushNotificationStatus.map((e) => e.value!).toList();
}

List<enums.PushNotificationStatus> pushNotificationStatusListFromJson(
  List? pushNotificationStatus, [
  List<enums.PushNotificationStatus>? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return defaultValue ?? [];
  }

  return pushNotificationStatus
      .map((e) => pushNotificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.PushNotificationStatus>? pushNotificationStatusNullableListFromJson(
  List? pushNotificationStatus, [
  List<enums.PushNotificationStatus>? defaultValue,
]) {
  if (pushNotificationStatus == null) {
    return defaultValue;
  }

  return pushNotificationStatus
      .map((e) => pushNotificationStatusFromJson(e.toString()))
      .toList();
}

String? symbolInfoDtoDataStatusNullableToJson(
  enums.SymbolInfoDtoDataStatus? symbolInfoDtoDataStatus,
) {
  return symbolInfoDtoDataStatus?.value;
}

String? symbolInfoDtoDataStatusToJson(
  enums.SymbolInfoDtoDataStatus symbolInfoDtoDataStatus,
) {
  return symbolInfoDtoDataStatus.value;
}

enums.SymbolInfoDtoDataStatus symbolInfoDtoDataStatusFromJson(
  Object? symbolInfoDtoDataStatus, [
  enums.SymbolInfoDtoDataStatus? defaultValue,
]) {
  return enums.SymbolInfoDtoDataStatus.values.firstWhereOrNull(
        (e) => e.value == symbolInfoDtoDataStatus,
      ) ??
      defaultValue ??
      enums.SymbolInfoDtoDataStatus.swaggerGeneratedUnknown;
}

enums.SymbolInfoDtoDataStatus? symbolInfoDtoDataStatusNullableFromJson(
  Object? symbolInfoDtoDataStatus, [
  enums.SymbolInfoDtoDataStatus? defaultValue,
]) {
  if (symbolInfoDtoDataStatus == null) {
    return null;
  }
  return enums.SymbolInfoDtoDataStatus.values.firstWhereOrNull(
        (e) => e.value == symbolInfoDtoDataStatus,
      ) ??
      defaultValue;
}

String symbolInfoDtoDataStatusExplodedListToJson(
  List<enums.SymbolInfoDtoDataStatus>? symbolInfoDtoDataStatus,
) {
  return symbolInfoDtoDataStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> symbolInfoDtoDataStatusListToJson(
  List<enums.SymbolInfoDtoDataStatus>? symbolInfoDtoDataStatus,
) {
  if (symbolInfoDtoDataStatus == null) {
    return [];
  }

  return symbolInfoDtoDataStatus.map((e) => e.value!).toList();
}

List<enums.SymbolInfoDtoDataStatus> symbolInfoDtoDataStatusListFromJson(
  List? symbolInfoDtoDataStatus, [
  List<enums.SymbolInfoDtoDataStatus>? defaultValue,
]) {
  if (symbolInfoDtoDataStatus == null) {
    return defaultValue ?? [];
  }

  return symbolInfoDtoDataStatus
      .map((e) => symbolInfoDtoDataStatusFromJson(e.toString()))
      .toList();
}

List<enums.SymbolInfoDtoDataStatus>?
symbolInfoDtoDataStatusNullableListFromJson(
  List? symbolInfoDtoDataStatus, [
  List<enums.SymbolInfoDtoDataStatus>? defaultValue,
]) {
  if (symbolInfoDtoDataStatus == null) {
    return defaultValue;
  }

  return symbolInfoDtoDataStatus
      .map((e) => symbolInfoDtoDataStatusFromJson(e.toString()))
      .toList();
}

String? nftActivityTypeNullableToJson(enums.NftActivityType? nftActivityType) {
  return nftActivityType?.value;
}

String? nftActivityTypeToJson(enums.NftActivityType nftActivityType) {
  return nftActivityType.value;
}

enums.NftActivityType nftActivityTypeFromJson(
  Object? nftActivityType, [
  enums.NftActivityType? defaultValue,
]) {
  return enums.NftActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityType,
      ) ??
      defaultValue ??
      enums.NftActivityType.swaggerGeneratedUnknown;
}

enums.NftActivityType? nftActivityTypeNullableFromJson(
  Object? nftActivityType, [
  enums.NftActivityType? defaultValue,
]) {
  if (nftActivityType == null) {
    return null;
  }
  return enums.NftActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityType,
      ) ??
      defaultValue;
}

String nftActivityTypeExplodedListToJson(
  List<enums.NftActivityType>? nftActivityType,
) {
  return nftActivityType?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityTypeListToJson(
  List<enums.NftActivityType>? nftActivityType,
) {
  if (nftActivityType == null) {
    return [];
  }

  return nftActivityType.map((e) => e.value!).toList();
}

List<enums.NftActivityType> nftActivityTypeListFromJson(
  List? nftActivityType, [
  List<enums.NftActivityType>? defaultValue,
]) {
  if (nftActivityType == null) {
    return defaultValue ?? [];
  }

  return nftActivityType
      .map((e) => nftActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityType>? nftActivityTypeNullableListFromJson(
  List? nftActivityType, [
  List<enums.NftActivityType>? defaultValue,
]) {
  if (nftActivityType == null) {
    return defaultValue;
  }

  return nftActivityType
      .map((e) => nftActivityTypeFromJson(e.toString()))
      .toList();
}

String? nftActivityEventSourceNullableToJson(
  enums.NftActivityEventSource? nftActivityEventSource,
) {
  return nftActivityEventSource?.value;
}

String? nftActivityEventSourceToJson(
  enums.NftActivityEventSource nftActivityEventSource,
) {
  return nftActivityEventSource.value;
}

enums.NftActivityEventSource nftActivityEventSourceFromJson(
  Object? nftActivityEventSource, [
  enums.NftActivityEventSource? defaultValue,
]) {
  return enums.NftActivityEventSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityEventSource,
      ) ??
      defaultValue ??
      enums.NftActivityEventSource.swaggerGeneratedUnknown;
}

enums.NftActivityEventSource? nftActivityEventSourceNullableFromJson(
  Object? nftActivityEventSource, [
  enums.NftActivityEventSource? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return null;
  }
  return enums.NftActivityEventSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityEventSource,
      ) ??
      defaultValue;
}

String nftActivityEventSourceExplodedListToJson(
  List<enums.NftActivityEventSource>? nftActivityEventSource,
) {
  return nftActivityEventSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityEventSourceListToJson(
  List<enums.NftActivityEventSource>? nftActivityEventSource,
) {
  if (nftActivityEventSource == null) {
    return [];
  }

  return nftActivityEventSource.map((e) => e.value!).toList();
}

List<enums.NftActivityEventSource> nftActivityEventSourceListFromJson(
  List? nftActivityEventSource, [
  List<enums.NftActivityEventSource>? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return defaultValue ?? [];
  }

  return nftActivityEventSource
      .map((e) => nftActivityEventSourceFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityEventSource>? nftActivityEventSourceNullableListFromJson(
  List? nftActivityEventSource, [
  List<enums.NftActivityEventSource>? defaultValue,
]) {
  if (nftActivityEventSource == null) {
    return defaultValue;
  }

  return nftActivityEventSource
      .map((e) => nftActivityEventSourceFromJson(e.toString()))
      .toList();
}

String? nftActivityDataHydratedAuctionTypeNullableToJson(
  enums.NftActivityDataHydratedAuctionType? nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType?.value;
}

String? nftActivityDataHydratedAuctionTypeToJson(
  enums.NftActivityDataHydratedAuctionType nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType.value;
}

enums.NftActivityDataHydratedAuctionType
nftActivityDataHydratedAuctionTypeFromJson(
  Object? nftActivityDataHydratedAuctionType, [
  enums.NftActivityDataHydratedAuctionType? defaultValue,
]) {
  return enums.NftActivityDataHydratedAuctionType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDataHydratedAuctionType,
      ) ??
      defaultValue ??
      enums.NftActivityDataHydratedAuctionType.swaggerGeneratedUnknown;
}

enums.NftActivityDataHydratedAuctionType?
nftActivityDataHydratedAuctionTypeNullableFromJson(
  Object? nftActivityDataHydratedAuctionType, [
  enums.NftActivityDataHydratedAuctionType? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return null;
  }
  return enums.NftActivityDataHydratedAuctionType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDataHydratedAuctionType,
      ) ??
      defaultValue;
}

String nftActivityDataHydratedAuctionTypeExplodedListToJson(
  List<enums.NftActivityDataHydratedAuctionType>?
  nftActivityDataHydratedAuctionType,
) {
  return nftActivityDataHydratedAuctionType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> nftActivityDataHydratedAuctionTypeListToJson(
  List<enums.NftActivityDataHydratedAuctionType>?
  nftActivityDataHydratedAuctionType,
) {
  if (nftActivityDataHydratedAuctionType == null) {
    return [];
  }

  return nftActivityDataHydratedAuctionType.map((e) => e.value!).toList();
}

List<enums.NftActivityDataHydratedAuctionType>
nftActivityDataHydratedAuctionTypeListFromJson(
  List? nftActivityDataHydratedAuctionType, [
  List<enums.NftActivityDataHydratedAuctionType>? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return defaultValue ?? [];
  }

  return nftActivityDataHydratedAuctionType
      .map((e) => nftActivityDataHydratedAuctionTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDataHydratedAuctionType>?
nftActivityDataHydratedAuctionTypeNullableListFromJson(
  List? nftActivityDataHydratedAuctionType, [
  List<enums.NftActivityDataHydratedAuctionType>? defaultValue,
]) {
  if (nftActivityDataHydratedAuctionType == null) {
    return defaultValue;
  }

  return nftActivityDataHydratedAuctionType
      .map((e) => nftActivityDataHydratedAuctionTypeFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedChainNullableToJson(
  enums.NftActivityDocHydratedChain? nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain?.value;
}

String? nftActivityDocHydratedChainToJson(
  enums.NftActivityDocHydratedChain nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain.value;
}

enums.NftActivityDocHydratedChain nftActivityDocHydratedChainFromJson(
  Object? nftActivityDocHydratedChain, [
  enums.NftActivityDocHydratedChain? defaultValue,
]) {
  return enums.NftActivityDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedChain,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedChain.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedChain? nftActivityDocHydratedChainNullableFromJson(
  Object? nftActivityDocHydratedChain, [
  enums.NftActivityDocHydratedChain? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return null;
  }
  return enums.NftActivityDocHydratedChain.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedChain,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedChainExplodedListToJson(
  List<enums.NftActivityDocHydratedChain>? nftActivityDocHydratedChain,
) {
  return nftActivityDocHydratedChain?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityDocHydratedChainListToJson(
  List<enums.NftActivityDocHydratedChain>? nftActivityDocHydratedChain,
) {
  if (nftActivityDocHydratedChain == null) {
    return [];
  }

  return nftActivityDocHydratedChain.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedChain> nftActivityDocHydratedChainListFromJson(
  List? nftActivityDocHydratedChain, [
  List<enums.NftActivityDocHydratedChain>? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedChain
      .map((e) => nftActivityDocHydratedChainFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedChain>?
nftActivityDocHydratedChainNullableListFromJson(
  List? nftActivityDocHydratedChain, [
  List<enums.NftActivityDocHydratedChain>? defaultValue,
]) {
  if (nftActivityDocHydratedChain == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedChain
      .map((e) => nftActivityDocHydratedChainFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedSourceNullableToJson(
  enums.NftActivityDocHydratedSource? nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource?.value;
}

String? nftActivityDocHydratedSourceToJson(
  enums.NftActivityDocHydratedSource nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource.value;
}

enums.NftActivityDocHydratedSource nftActivityDocHydratedSourceFromJson(
  Object? nftActivityDocHydratedSource, [
  enums.NftActivityDocHydratedSource? defaultValue,
]) {
  return enums.NftActivityDocHydratedSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedSource,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedSource.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedSource?
nftActivityDocHydratedSourceNullableFromJson(
  Object? nftActivityDocHydratedSource, [
  enums.NftActivityDocHydratedSource? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return null;
  }
  return enums.NftActivityDocHydratedSource.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedSource,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedSourceExplodedListToJson(
  List<enums.NftActivityDocHydratedSource>? nftActivityDocHydratedSource,
) {
  return nftActivityDocHydratedSource?.map((e) => e.value!).join(',') ?? '';
}

List<String> nftActivityDocHydratedSourceListToJson(
  List<enums.NftActivityDocHydratedSource>? nftActivityDocHydratedSource,
) {
  if (nftActivityDocHydratedSource == null) {
    return [];
  }

  return nftActivityDocHydratedSource.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedSource>
nftActivityDocHydratedSourceListFromJson(
  List? nftActivityDocHydratedSource, [
  List<enums.NftActivityDocHydratedSource>? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedSource
      .map((e) => nftActivityDocHydratedSourceFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedSource>?
nftActivityDocHydratedSourceNullableListFromJson(
  List? nftActivityDocHydratedSource, [
  List<enums.NftActivityDocHydratedSource>? defaultValue,
]) {
  if (nftActivityDocHydratedSource == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedSource
      .map((e) => nftActivityDocHydratedSourceFromJson(e.toString()))
      .toList();
}

String? nftActivityDocHydratedActivityTypeNullableToJson(
  enums.NftActivityDocHydratedActivityType? nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType?.value;
}

String? nftActivityDocHydratedActivityTypeToJson(
  enums.NftActivityDocHydratedActivityType nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType.value;
}

enums.NftActivityDocHydratedActivityType
nftActivityDocHydratedActivityTypeFromJson(
  Object? nftActivityDocHydratedActivityType, [
  enums.NftActivityDocHydratedActivityType? defaultValue,
]) {
  return enums.NftActivityDocHydratedActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedActivityType,
      ) ??
      defaultValue ??
      enums.NftActivityDocHydratedActivityType.swaggerGeneratedUnknown;
}

enums.NftActivityDocHydratedActivityType?
nftActivityDocHydratedActivityTypeNullableFromJson(
  Object? nftActivityDocHydratedActivityType, [
  enums.NftActivityDocHydratedActivityType? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return null;
  }
  return enums.NftActivityDocHydratedActivityType.values.firstWhereOrNull(
        (e) => e.value == nftActivityDocHydratedActivityType,
      ) ??
      defaultValue;
}

String nftActivityDocHydratedActivityTypeExplodedListToJson(
  List<enums.NftActivityDocHydratedActivityType>?
  nftActivityDocHydratedActivityType,
) {
  return nftActivityDocHydratedActivityType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> nftActivityDocHydratedActivityTypeListToJson(
  List<enums.NftActivityDocHydratedActivityType>?
  nftActivityDocHydratedActivityType,
) {
  if (nftActivityDocHydratedActivityType == null) {
    return [];
  }

  return nftActivityDocHydratedActivityType.map((e) => e.value!).toList();
}

List<enums.NftActivityDocHydratedActivityType>
nftActivityDocHydratedActivityTypeListFromJson(
  List? nftActivityDocHydratedActivityType, [
  List<enums.NftActivityDocHydratedActivityType>? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return defaultValue ?? [];
  }

  return nftActivityDocHydratedActivityType
      .map((e) => nftActivityDocHydratedActivityTypeFromJson(e.toString()))
      .toList();
}

List<enums.NftActivityDocHydratedActivityType>?
nftActivityDocHydratedActivityTypeNullableListFromJson(
  List? nftActivityDocHydratedActivityType, [
  List<enums.NftActivityDocHydratedActivityType>? defaultValue,
]) {
  if (nftActivityDocHydratedActivityType == null) {
    return defaultValue;
  }

  return nftActivityDocHydratedActivityType
      .map((e) => nftActivityDocHydratedActivityTypeFromJson(e.toString()))
      .toList();
}

String? userStatsOrderByColumnNullableToJson(
  enums.UserStatsOrderByColumn? userStatsOrderByColumn,
) {
  return userStatsOrderByColumn?.value;
}

String? userStatsOrderByColumnToJson(
  enums.UserStatsOrderByColumn userStatsOrderByColumn,
) {
  return userStatsOrderByColumn.value;
}

enums.UserStatsOrderByColumn userStatsOrderByColumnFromJson(
  Object? userStatsOrderByColumn, [
  enums.UserStatsOrderByColumn? defaultValue,
]) {
  return enums.UserStatsOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == userStatsOrderByColumn,
      ) ??
      defaultValue ??
      enums.UserStatsOrderByColumn.swaggerGeneratedUnknown;
}

enums.UserStatsOrderByColumn? userStatsOrderByColumnNullableFromJson(
  Object? userStatsOrderByColumn, [
  enums.UserStatsOrderByColumn? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return null;
  }
  return enums.UserStatsOrderByColumn.values.firstWhereOrNull(
        (e) => e.value == userStatsOrderByColumn,
      ) ??
      defaultValue;
}

String userStatsOrderByColumnExplodedListToJson(
  List<enums.UserStatsOrderByColumn>? userStatsOrderByColumn,
) {
  return userStatsOrderByColumn?.map((e) => e.value!).join(',') ?? '';
}

List<String> userStatsOrderByColumnListToJson(
  List<enums.UserStatsOrderByColumn>? userStatsOrderByColumn,
) {
  if (userStatsOrderByColumn == null) {
    return [];
  }

  return userStatsOrderByColumn.map((e) => e.value!).toList();
}

List<enums.UserStatsOrderByColumn> userStatsOrderByColumnListFromJson(
  List? userStatsOrderByColumn, [
  List<enums.UserStatsOrderByColumn>? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return defaultValue ?? [];
  }

  return userStatsOrderByColumn
      .map((e) => userStatsOrderByColumnFromJson(e.toString()))
      .toList();
}

List<enums.UserStatsOrderByColumn>? userStatsOrderByColumnNullableListFromJson(
  List? userStatsOrderByColumn, [
  List<enums.UserStatsOrderByColumn>? defaultValue,
]) {
  if (userStatsOrderByColumn == null) {
    return defaultValue;
  }

  return userStatsOrderByColumn
      .map((e) => userStatsOrderByColumnFromJson(e.toString()))
      .toList();
}

String? loginRequestDtoServiceNullableToJson(
  enums.LoginRequestDtoService? loginRequestDtoService,
) {
  return loginRequestDtoService?.value;
}

String? loginRequestDtoServiceToJson(
  enums.LoginRequestDtoService loginRequestDtoService,
) {
  return loginRequestDtoService.value;
}

enums.LoginRequestDtoService loginRequestDtoServiceFromJson(
  Object? loginRequestDtoService, [
  enums.LoginRequestDtoService? defaultValue,
]) {
  return enums.LoginRequestDtoService.values.firstWhereOrNull(
        (e) => e.value == loginRequestDtoService,
      ) ??
      defaultValue ??
      enums.LoginRequestDtoService.swaggerGeneratedUnknown;
}

enums.LoginRequestDtoService? loginRequestDtoServiceNullableFromJson(
  Object? loginRequestDtoService, [
  enums.LoginRequestDtoService? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return null;
  }
  return enums.LoginRequestDtoService.values.firstWhereOrNull(
        (e) => e.value == loginRequestDtoService,
      ) ??
      defaultValue;
}

String loginRequestDtoServiceExplodedListToJson(
  List<enums.LoginRequestDtoService>? loginRequestDtoService,
) {
  return loginRequestDtoService?.map((e) => e.value!).join(',') ?? '';
}

List<String> loginRequestDtoServiceListToJson(
  List<enums.LoginRequestDtoService>? loginRequestDtoService,
) {
  if (loginRequestDtoService == null) {
    return [];
  }

  return loginRequestDtoService.map((e) => e.value!).toList();
}

List<enums.LoginRequestDtoService> loginRequestDtoServiceListFromJson(
  List? loginRequestDtoService, [
  List<enums.LoginRequestDtoService>? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return defaultValue ?? [];
  }

  return loginRequestDtoService
      .map((e) => loginRequestDtoServiceFromJson(e.toString()))
      .toList();
}

List<enums.LoginRequestDtoService>? loginRequestDtoServiceNullableListFromJson(
  List? loginRequestDtoService, [
  List<enums.LoginRequestDtoService>? defaultValue,
]) {
  if (loginRequestDtoService == null) {
    return defaultValue;
  }

  return loginRequestDtoService
      .map((e) => loginRequestDtoServiceFromJson(e.toString()))
      .toList();
}

String? transactionTypeNullableToJson(enums.TransactionType? transactionType) {
  return transactionType?.value;
}

String? transactionTypeToJson(enums.TransactionType transactionType) {
  return transactionType.value;
}

enums.TransactionType transactionTypeFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  return enums.TransactionType.values.firstWhereOrNull(
        (e) => e.value == transactionType,
      ) ??
      defaultValue ??
      enums.TransactionType.swaggerGeneratedUnknown;
}

enums.TransactionType? transactionTypeNullableFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  if (transactionType == null) {
    return null;
  }
  return enums.TransactionType.values.firstWhereOrNull(
        (e) => e.value == transactionType,
      ) ??
      defaultValue;
}

String transactionTypeExplodedListToJson(
  List<enums.TransactionType>? transactionType,
) {
  return transactionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> transactionTypeListToJson(
  List<enums.TransactionType>? transactionType,
) {
  if (transactionType == null) {
    return [];
  }

  return transactionType.map((e) => e.value!).toList();
}

List<enums.TransactionType> transactionTypeListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue ?? [];
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionType>? transactionTypeNullableListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue;
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

String? transactionStatusNullableToJson(
  enums.TransactionStatus? transactionStatus,
) {
  return transactionStatus?.value;
}

String? transactionStatusToJson(enums.TransactionStatus transactionStatus) {
  return transactionStatus.value;
}

enums.TransactionStatus transactionStatusFromJson(
  Object? transactionStatus, [
  enums.TransactionStatus? defaultValue,
]) {
  return enums.TransactionStatus.values.firstWhereOrNull(
        (e) => e.value == transactionStatus,
      ) ??
      defaultValue ??
      enums.TransactionStatus.swaggerGeneratedUnknown;
}

enums.TransactionStatus? transactionStatusNullableFromJson(
  Object? transactionStatus, [
  enums.TransactionStatus? defaultValue,
]) {
  if (transactionStatus == null) {
    return null;
  }
  return enums.TransactionStatus.values.firstWhereOrNull(
        (e) => e.value == transactionStatus,
      ) ??
      defaultValue;
}

String transactionStatusExplodedListToJson(
  List<enums.TransactionStatus>? transactionStatus,
) {
  return transactionStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> transactionStatusListToJson(
  List<enums.TransactionStatus>? transactionStatus,
) {
  if (transactionStatus == null) {
    return [];
  }

  return transactionStatus.map((e) => e.value!).toList();
}

List<enums.TransactionStatus> transactionStatusListFromJson(
  List? transactionStatus, [
  List<enums.TransactionStatus>? defaultValue,
]) {
  if (transactionStatus == null) {
    return defaultValue ?? [];
  }

  return transactionStatus
      .map((e) => transactionStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransactionStatus>? transactionStatusNullableListFromJson(
  List? transactionStatus, [
  List<enums.TransactionStatus>? defaultValue,
]) {
  if (transactionStatus == null) {
    return defaultValue;
  }

  return transactionStatus
      .map((e) => transactionStatusFromJson(e.toString()))
      .toList();
}

String? userConversationDocHydratedDataTypeNullableToJson(
  enums.UserConversationDocHydratedDataType?
  userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType?.value;
}

String? userConversationDocHydratedDataTypeToJson(
  enums.UserConversationDocHydratedDataType userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType.value;
}

enums.UserConversationDocHydratedDataType
userConversationDocHydratedDataTypeFromJson(
  Object? userConversationDocHydratedDataType, [
  enums.UserConversationDocHydratedDataType? defaultValue,
]) {
  return enums.UserConversationDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userConversationDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.UserConversationDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.UserConversationDocHydratedDataType?
userConversationDocHydratedDataTypeNullableFromJson(
  Object? userConversationDocHydratedDataType, [
  enums.UserConversationDocHydratedDataType? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return null;
  }
  return enums.UserConversationDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userConversationDocHydratedDataType,
      ) ??
      defaultValue;
}

String userConversationDocHydratedDataTypeExplodedListToJson(
  List<enums.UserConversationDocHydratedDataType>?
  userConversationDocHydratedDataType,
) {
  return userConversationDocHydratedDataType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> userConversationDocHydratedDataTypeListToJson(
  List<enums.UserConversationDocHydratedDataType>?
  userConversationDocHydratedDataType,
) {
  if (userConversationDocHydratedDataType == null) {
    return [];
  }

  return userConversationDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.UserConversationDocHydratedDataType>
userConversationDocHydratedDataTypeListFromJson(
  List? userConversationDocHydratedDataType, [
  List<enums.UserConversationDocHydratedDataType>? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return userConversationDocHydratedDataType
      .map((e) => userConversationDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserConversationDocHydratedDataType>?
userConversationDocHydratedDataTypeNullableListFromJson(
  List? userConversationDocHydratedDataType, [
  List<enums.UserConversationDocHydratedDataType>? defaultValue,
]) {
  if (userConversationDocHydratedDataType == null) {
    return defaultValue;
  }

  return userConversationDocHydratedDataType
      .map((e) => userConversationDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? userBlockDocHydratedDataTypeNullableToJson(
  enums.UserBlockDocHydratedDataType? userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType?.value;
}

String? userBlockDocHydratedDataTypeToJson(
  enums.UserBlockDocHydratedDataType userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType.value;
}

enums.UserBlockDocHydratedDataType userBlockDocHydratedDataTypeFromJson(
  Object? userBlockDocHydratedDataType, [
  enums.UserBlockDocHydratedDataType? defaultValue,
]) {
  return enums.UserBlockDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userBlockDocHydratedDataType,
      ) ??
      defaultValue ??
      enums.UserBlockDocHydratedDataType.swaggerGeneratedUnknown;
}

enums.UserBlockDocHydratedDataType?
userBlockDocHydratedDataTypeNullableFromJson(
  Object? userBlockDocHydratedDataType, [
  enums.UserBlockDocHydratedDataType? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return null;
  }
  return enums.UserBlockDocHydratedDataType.values.firstWhereOrNull(
        (e) => e.value == userBlockDocHydratedDataType,
      ) ??
      defaultValue;
}

String userBlockDocHydratedDataTypeExplodedListToJson(
  List<enums.UserBlockDocHydratedDataType>? userBlockDocHydratedDataType,
) {
  return userBlockDocHydratedDataType?.map((e) => e.value!).join(',') ?? '';
}

List<String> userBlockDocHydratedDataTypeListToJson(
  List<enums.UserBlockDocHydratedDataType>? userBlockDocHydratedDataType,
) {
  if (userBlockDocHydratedDataType == null) {
    return [];
  }

  return userBlockDocHydratedDataType.map((e) => e.value!).toList();
}

List<enums.UserBlockDocHydratedDataType>
userBlockDocHydratedDataTypeListFromJson(
  List? userBlockDocHydratedDataType, [
  List<enums.UserBlockDocHydratedDataType>? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return defaultValue ?? [];
  }

  return userBlockDocHydratedDataType
      .map((e) => userBlockDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserBlockDocHydratedDataType>?
userBlockDocHydratedDataTypeNullableListFromJson(
  List? userBlockDocHydratedDataType, [
  List<enums.UserBlockDocHydratedDataType>? defaultValue,
]) {
  if (userBlockDocHydratedDataType == null) {
    return defaultValue;
  }

  return userBlockDocHydratedDataType
      .map((e) => userBlockDocHydratedDataTypeFromJson(e.toString()))
      .toList();
}

String? digitalWalletDtoWalletTypeNullableToJson(
  enums.DigitalWalletDtoWalletType? digitalWalletDtoWalletType,
) {
  return digitalWalletDtoWalletType?.value;
}

String? digitalWalletDtoWalletTypeToJson(
  enums.DigitalWalletDtoWalletType digitalWalletDtoWalletType,
) {
  return digitalWalletDtoWalletType.value;
}

enums.DigitalWalletDtoWalletType digitalWalletDtoWalletTypeFromJson(
  Object? digitalWalletDtoWalletType, [
  enums.DigitalWalletDtoWalletType? defaultValue,
]) {
  return enums.DigitalWalletDtoWalletType.values.firstWhereOrNull(
        (e) => e.value == digitalWalletDtoWalletType,
      ) ??
      defaultValue ??
      enums.DigitalWalletDtoWalletType.swaggerGeneratedUnknown;
}

enums.DigitalWalletDtoWalletType? digitalWalletDtoWalletTypeNullableFromJson(
  Object? digitalWalletDtoWalletType, [
  enums.DigitalWalletDtoWalletType? defaultValue,
]) {
  if (digitalWalletDtoWalletType == null) {
    return null;
  }
  return enums.DigitalWalletDtoWalletType.values.firstWhereOrNull(
        (e) => e.value == digitalWalletDtoWalletType,
      ) ??
      defaultValue;
}

String digitalWalletDtoWalletTypeExplodedListToJson(
  List<enums.DigitalWalletDtoWalletType>? digitalWalletDtoWalletType,
) {
  return digitalWalletDtoWalletType?.map((e) => e.value!).join(',') ?? '';
}

List<String> digitalWalletDtoWalletTypeListToJson(
  List<enums.DigitalWalletDtoWalletType>? digitalWalletDtoWalletType,
) {
  if (digitalWalletDtoWalletType == null) {
    return [];
  }

  return digitalWalletDtoWalletType.map((e) => e.value!).toList();
}

List<enums.DigitalWalletDtoWalletType> digitalWalletDtoWalletTypeListFromJson(
  List? digitalWalletDtoWalletType, [
  List<enums.DigitalWalletDtoWalletType>? defaultValue,
]) {
  if (digitalWalletDtoWalletType == null) {
    return defaultValue ?? [];
  }

  return digitalWalletDtoWalletType
      .map((e) => digitalWalletDtoWalletTypeFromJson(e.toString()))
      .toList();
}

List<enums.DigitalWalletDtoWalletType>?
digitalWalletDtoWalletTypeNullableListFromJson(
  List? digitalWalletDtoWalletType, [
  List<enums.DigitalWalletDtoWalletType>? defaultValue,
]) {
  if (digitalWalletDtoWalletType == null) {
    return defaultValue;
  }

  return digitalWalletDtoWalletType
      .map((e) => digitalWalletDtoWalletTypeFromJson(e.toString()))
      .toList();
}

String? paymentProviderNullableToJson(enums.PaymentProvider? paymentProvider) {
  return paymentProvider?.value;
}

String? paymentProviderToJson(enums.PaymentProvider paymentProvider) {
  return paymentProvider.value;
}

enums.PaymentProvider paymentProviderFromJson(
  Object? paymentProvider, [
  enums.PaymentProvider? defaultValue,
]) {
  return enums.PaymentProvider.values.firstWhereOrNull(
        (e) => e.value == paymentProvider,
      ) ??
      defaultValue ??
      enums.PaymentProvider.swaggerGeneratedUnknown;
}

enums.PaymentProvider? paymentProviderNullableFromJson(
  Object? paymentProvider, [
  enums.PaymentProvider? defaultValue,
]) {
  if (paymentProvider == null) {
    return null;
  }
  return enums.PaymentProvider.values.firstWhereOrNull(
        (e) => e.value == paymentProvider,
      ) ??
      defaultValue;
}

String paymentProviderExplodedListToJson(
  List<enums.PaymentProvider>? paymentProvider,
) {
  return paymentProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> paymentProviderListToJson(
  List<enums.PaymentProvider>? paymentProvider,
) {
  if (paymentProvider == null) {
    return [];
  }

  return paymentProvider.map((e) => e.value!).toList();
}

List<enums.PaymentProvider> paymentProviderListFromJson(
  List? paymentProvider, [
  List<enums.PaymentProvider>? defaultValue,
]) {
  if (paymentProvider == null) {
    return defaultValue ?? [];
  }

  return paymentProvider
      .map((e) => paymentProviderFromJson(e.toString()))
      .toList();
}

List<enums.PaymentProvider>? paymentProviderNullableListFromJson(
  List? paymentProvider, [
  List<enums.PaymentProvider>? defaultValue,
]) {
  if (paymentProvider == null) {
    return defaultValue;
  }

  return paymentProvider
      .map((e) => paymentProviderFromJson(e.toString()))
      .toList();
}

String? eventInvitationStatusNullableToJson(
  enums.EventInvitationStatus? eventInvitationStatus,
) {
  return eventInvitationStatus?.value;
}

String? eventInvitationStatusToJson(
  enums.EventInvitationStatus eventInvitationStatus,
) {
  return eventInvitationStatus.value;
}

enums.EventInvitationStatus eventInvitationStatusFromJson(
  Object? eventInvitationStatus, [
  enums.EventInvitationStatus? defaultValue,
]) {
  return enums.EventInvitationStatus.values.firstWhereOrNull(
        (e) => e.value == eventInvitationStatus,
      ) ??
      defaultValue ??
      enums.EventInvitationStatus.swaggerGeneratedUnknown;
}

enums.EventInvitationStatus? eventInvitationStatusNullableFromJson(
  Object? eventInvitationStatus, [
  enums.EventInvitationStatus? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return null;
  }
  return enums.EventInvitationStatus.values.firstWhereOrNull(
        (e) => e.value == eventInvitationStatus,
      ) ??
      defaultValue;
}

String eventInvitationStatusExplodedListToJson(
  List<enums.EventInvitationStatus>? eventInvitationStatus,
) {
  return eventInvitationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventInvitationStatusListToJson(
  List<enums.EventInvitationStatus>? eventInvitationStatus,
) {
  if (eventInvitationStatus == null) {
    return [];
  }

  return eventInvitationStatus.map((e) => e.value!).toList();
}

List<enums.EventInvitationStatus> eventInvitationStatusListFromJson(
  List? eventInvitationStatus, [
  List<enums.EventInvitationStatus>? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return defaultValue ?? [];
  }

  return eventInvitationStatus
      .map((e) => eventInvitationStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventInvitationStatus>? eventInvitationStatusNullableListFromJson(
  List? eventInvitationStatus, [
  List<enums.EventInvitationStatus>? defaultValue,
]) {
  if (eventInvitationStatus == null) {
    return defaultValue;
  }

  return eventInvitationStatus
      .map((e) => eventInvitationStatusFromJson(e.toString()))
      .toList();
}

String? voucherTypeNullableToJson(enums.VoucherType? voucherType) {
  return voucherType?.value;
}

String? voucherTypeToJson(enums.VoucherType voucherType) {
  return voucherType.value;
}

enums.VoucherType voucherTypeFromJson(
  Object? voucherType, [
  enums.VoucherType? defaultValue,
]) {
  return enums.VoucherType.values.firstWhereOrNull(
        (e) => e.value == voucherType,
      ) ??
      defaultValue ??
      enums.VoucherType.swaggerGeneratedUnknown;
}

enums.VoucherType? voucherTypeNullableFromJson(
  Object? voucherType, [
  enums.VoucherType? defaultValue,
]) {
  if (voucherType == null) {
    return null;
  }
  return enums.VoucherType.values.firstWhereOrNull(
        (e) => e.value == voucherType,
      ) ??
      defaultValue;
}

String voucherTypeExplodedListToJson(List<enums.VoucherType>? voucherType) {
  return voucherType?.map((e) => e.value!).join(',') ?? '';
}

List<String> voucherTypeListToJson(List<enums.VoucherType>? voucherType) {
  if (voucherType == null) {
    return [];
  }

  return voucherType.map((e) => e.value!).toList();
}

List<enums.VoucherType> voucherTypeListFromJson(
  List? voucherType, [
  List<enums.VoucherType>? defaultValue,
]) {
  if (voucherType == null) {
    return defaultValue ?? [];
  }

  return voucherType.map((e) => voucherTypeFromJson(e.toString())).toList();
}

List<enums.VoucherType>? voucherTypeNullableListFromJson(
  List? voucherType, [
  List<enums.VoucherType>? defaultValue,
]) {
  if (voucherType == null) {
    return defaultValue;
  }

  return voucherType.map((e) => voucherTypeFromJson(e.toString())).toList();
}

String? eventQuestionAnswerTypeNullableToJson(
  enums.EventQuestionAnswerType? eventQuestionAnswerType,
) {
  return eventQuestionAnswerType?.value;
}

String? eventQuestionAnswerTypeToJson(
  enums.EventQuestionAnswerType eventQuestionAnswerType,
) {
  return eventQuestionAnswerType.value;
}

enums.EventQuestionAnswerType eventQuestionAnswerTypeFromJson(
  Object? eventQuestionAnswerType, [
  enums.EventQuestionAnswerType? defaultValue,
]) {
  return enums.EventQuestionAnswerType.values.firstWhereOrNull(
        (e) => e.value == eventQuestionAnswerType,
      ) ??
      defaultValue ??
      enums.EventQuestionAnswerType.swaggerGeneratedUnknown;
}

enums.EventQuestionAnswerType? eventQuestionAnswerTypeNullableFromJson(
  Object? eventQuestionAnswerType, [
  enums.EventQuestionAnswerType? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return null;
  }
  return enums.EventQuestionAnswerType.values.firstWhereOrNull(
        (e) => e.value == eventQuestionAnswerType,
      ) ??
      defaultValue;
}

String eventQuestionAnswerTypeExplodedListToJson(
  List<enums.EventQuestionAnswerType>? eventQuestionAnswerType,
) {
  return eventQuestionAnswerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventQuestionAnswerTypeListToJson(
  List<enums.EventQuestionAnswerType>? eventQuestionAnswerType,
) {
  if (eventQuestionAnswerType == null) {
    return [];
  }

  return eventQuestionAnswerType.map((e) => e.value!).toList();
}

List<enums.EventQuestionAnswerType> eventQuestionAnswerTypeListFromJson(
  List? eventQuestionAnswerType, [
  List<enums.EventQuestionAnswerType>? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return defaultValue ?? [];
  }

  return eventQuestionAnswerType
      .map((e) => eventQuestionAnswerTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventQuestionAnswerType>?
eventQuestionAnswerTypeNullableListFromJson(
  List? eventQuestionAnswerType, [
  List<enums.EventQuestionAnswerType>? defaultValue,
]) {
  if (eventQuestionAnswerType == null) {
    return defaultValue;
  }

  return eventQuestionAnswerType
      .map((e) => eventQuestionAnswerTypeFromJson(e.toString()))
      .toList();
}

String? eventTicketQrTypeNullableToJson(
  enums.EventTicketQrType? eventTicketQrType,
) {
  return eventTicketQrType?.value;
}

String? eventTicketQrTypeToJson(enums.EventTicketQrType eventTicketQrType) {
  return eventTicketQrType.value;
}

enums.EventTicketQrType eventTicketQrTypeFromJson(
  Object? eventTicketQrType, [
  enums.EventTicketQrType? defaultValue,
]) {
  return enums.EventTicketQrType.values.firstWhereOrNull(
        (e) => e.value == eventTicketQrType,
      ) ??
      defaultValue ??
      enums.EventTicketQrType.swaggerGeneratedUnknown;
}

enums.EventTicketQrType? eventTicketQrTypeNullableFromJson(
  Object? eventTicketQrType, [
  enums.EventTicketQrType? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return null;
  }
  return enums.EventTicketQrType.values.firstWhereOrNull(
        (e) => e.value == eventTicketQrType,
      ) ??
      defaultValue;
}

String eventTicketQrTypeExplodedListToJson(
  List<enums.EventTicketQrType>? eventTicketQrType,
) {
  return eventTicketQrType?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventTicketQrTypeListToJson(
  List<enums.EventTicketQrType>? eventTicketQrType,
) {
  if (eventTicketQrType == null) {
    return [];
  }

  return eventTicketQrType.map((e) => e.value!).toList();
}

List<enums.EventTicketQrType> eventTicketQrTypeListFromJson(
  List? eventTicketQrType, [
  List<enums.EventTicketQrType>? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return defaultValue ?? [];
  }

  return eventTicketQrType
      .map((e) => eventTicketQrTypeFromJson(e.toString()))
      .toList();
}

List<enums.EventTicketQrType>? eventTicketQrTypeNullableListFromJson(
  List? eventTicketQrType, [
  List<enums.EventTicketQrType>? defaultValue,
]) {
  if (eventTicketQrType == null) {
    return defaultValue;
  }

  return eventTicketQrType
      .map((e) => eventTicketQrTypeFromJson(e.toString()))
      .toList();
}

String? eventScanStatusNullableToJson(enums.EventScanStatus? eventScanStatus) {
  return eventScanStatus?.value;
}

String? eventScanStatusToJson(enums.EventScanStatus eventScanStatus) {
  return eventScanStatus.value;
}

enums.EventScanStatus eventScanStatusFromJson(
  Object? eventScanStatus, [
  enums.EventScanStatus? defaultValue,
]) {
  return enums.EventScanStatus.values.firstWhereOrNull(
        (e) => e.value == eventScanStatus,
      ) ??
      defaultValue ??
      enums.EventScanStatus.swaggerGeneratedUnknown;
}

enums.EventScanStatus? eventScanStatusNullableFromJson(
  Object? eventScanStatus, [
  enums.EventScanStatus? defaultValue,
]) {
  if (eventScanStatus == null) {
    return null;
  }
  return enums.EventScanStatus.values.firstWhereOrNull(
        (e) => e.value == eventScanStatus,
      ) ??
      defaultValue;
}

String eventScanStatusExplodedListToJson(
  List<enums.EventScanStatus>? eventScanStatus,
) {
  return eventScanStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventScanStatusListToJson(
  List<enums.EventScanStatus>? eventScanStatus,
) {
  if (eventScanStatus == null) {
    return [];
  }

  return eventScanStatus.map((e) => e.value!).toList();
}

List<enums.EventScanStatus> eventScanStatusListFromJson(
  List? eventScanStatus, [
  List<enums.EventScanStatus>? defaultValue,
]) {
  if (eventScanStatus == null) {
    return defaultValue ?? [];
  }

  return eventScanStatus
      .map((e) => eventScanStatusFromJson(e.toString()))
      .toList();
}

List<enums.EventScanStatus>? eventScanStatusNullableListFromJson(
  List? eventScanStatus, [
  List<enums.EventScanStatus>? defaultValue,
]) {
  if (eventScanStatus == null) {
    return defaultValue;
  }

  return eventScanStatus
      .map((e) => eventScanStatusFromJson(e.toString()))
      .toList();
}

String? eventScanMessageNullableToJson(
  enums.EventScanMessage? eventScanMessage,
) {
  return eventScanMessage?.value;
}

String? eventScanMessageToJson(enums.EventScanMessage eventScanMessage) {
  return eventScanMessage.value;
}

enums.EventScanMessage eventScanMessageFromJson(
  Object? eventScanMessage, [
  enums.EventScanMessage? defaultValue,
]) {
  return enums.EventScanMessage.values.firstWhereOrNull(
        (e) => e.value == eventScanMessage,
      ) ??
      defaultValue ??
      enums.EventScanMessage.swaggerGeneratedUnknown;
}

enums.EventScanMessage? eventScanMessageNullableFromJson(
  Object? eventScanMessage, [
  enums.EventScanMessage? defaultValue,
]) {
  if (eventScanMessage == null) {
    return null;
  }
  return enums.EventScanMessage.values.firstWhereOrNull(
        (e) => e.value == eventScanMessage,
      ) ??
      defaultValue;
}

String eventScanMessageExplodedListToJson(
  List<enums.EventScanMessage>? eventScanMessage,
) {
  return eventScanMessage?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventScanMessageListToJson(
  List<enums.EventScanMessage>? eventScanMessage,
) {
  if (eventScanMessage == null) {
    return [];
  }

  return eventScanMessage.map((e) => e.value!).toList();
}

List<enums.EventScanMessage> eventScanMessageListFromJson(
  List? eventScanMessage, [
  List<enums.EventScanMessage>? defaultValue,
]) {
  if (eventScanMessage == null) {
    return defaultValue ?? [];
  }

  return eventScanMessage
      .map((e) => eventScanMessageFromJson(e.toString()))
      .toList();
}

List<enums.EventScanMessage>? eventScanMessageNullableListFromJson(
  List? eventScanMessage, [
  List<enums.EventScanMessage>? defaultValue,
]) {
  if (eventScanMessage == null) {
    return defaultValue;
  }

  return eventScanMessage
      .map((e) => eventScanMessageFromJson(e.toString()))
      .toList();
}

String? eventReferralEnumNullableToJson(
  enums.EventReferralEnum? eventReferralEnum,
) {
  return eventReferralEnum?.value;
}

String? eventReferralEnumToJson(enums.EventReferralEnum eventReferralEnum) {
  return eventReferralEnum.value;
}

enums.EventReferralEnum eventReferralEnumFromJson(
  Object? eventReferralEnum, [
  enums.EventReferralEnum? defaultValue,
]) {
  return enums.EventReferralEnum.values.firstWhereOrNull(
        (e) => e.value == eventReferralEnum,
      ) ??
      defaultValue ??
      enums.EventReferralEnum.swaggerGeneratedUnknown;
}

enums.EventReferralEnum? eventReferralEnumNullableFromJson(
  Object? eventReferralEnum, [
  enums.EventReferralEnum? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return null;
  }
  return enums.EventReferralEnum.values.firstWhereOrNull(
        (e) => e.value == eventReferralEnum,
      ) ??
      defaultValue;
}

String eventReferralEnumExplodedListToJson(
  List<enums.EventReferralEnum>? eventReferralEnum,
) {
  return eventReferralEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> eventReferralEnumListToJson(
  List<enums.EventReferralEnum>? eventReferralEnum,
) {
  if (eventReferralEnum == null) {
    return [];
  }

  return eventReferralEnum.map((e) => e.value!).toList();
}

List<enums.EventReferralEnum> eventReferralEnumListFromJson(
  List? eventReferralEnum, [
  List<enums.EventReferralEnum>? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return defaultValue ?? [];
  }

  return eventReferralEnum
      .map((e) => eventReferralEnumFromJson(e.toString()))
      .toList();
}

List<enums.EventReferralEnum>? eventReferralEnumNullableListFromJson(
  List? eventReferralEnum, [
  List<enums.EventReferralEnum>? defaultValue,
]) {
  if (eventReferralEnum == null) {
    return defaultValue;
  }

  return eventReferralEnum
      .map((e) => eventReferralEnumFromJson(e.toString()))
      .toList();
}

String? referralConditionTypeNullableToJson(
  enums.ReferralConditionType? referralConditionType,
) {
  return referralConditionType?.value;
}

String? referralConditionTypeToJson(
  enums.ReferralConditionType referralConditionType,
) {
  return referralConditionType.value;
}

enums.ReferralConditionType referralConditionTypeFromJson(
  Object? referralConditionType, [
  enums.ReferralConditionType? defaultValue,
]) {
  return enums.ReferralConditionType.values.firstWhereOrNull(
        (e) => e.value == referralConditionType,
      ) ??
      defaultValue ??
      enums.ReferralConditionType.swaggerGeneratedUnknown;
}

enums.ReferralConditionType? referralConditionTypeNullableFromJson(
  Object? referralConditionType, [
  enums.ReferralConditionType? defaultValue,
]) {
  if (referralConditionType == null) {
    return null;
  }
  return enums.ReferralConditionType.values.firstWhereOrNull(
        (e) => e.value == referralConditionType,
      ) ??
      defaultValue;
}

String referralConditionTypeExplodedListToJson(
  List<enums.ReferralConditionType>? referralConditionType,
) {
  return referralConditionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> referralConditionTypeListToJson(
  List<enums.ReferralConditionType>? referralConditionType,
) {
  if (referralConditionType == null) {
    return [];
  }

  return referralConditionType.map((e) => e.value!).toList();
}

List<enums.ReferralConditionType> referralConditionTypeListFromJson(
  List? referralConditionType, [
  List<enums.ReferralConditionType>? defaultValue,
]) {
  if (referralConditionType == null) {
    return defaultValue ?? [];
  }

  return referralConditionType
      .map((e) => referralConditionTypeFromJson(e.toString()))
      .toList();
}

List<enums.ReferralConditionType>? referralConditionTypeNullableListFromJson(
  List? referralConditionType, [
  List<enums.ReferralConditionType>? defaultValue,
]) {
  if (referralConditionType == null) {
    return defaultValue;
  }

  return referralConditionType
      .map((e) => referralConditionTypeFromJson(e.toString()))
      .toList();
}

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
